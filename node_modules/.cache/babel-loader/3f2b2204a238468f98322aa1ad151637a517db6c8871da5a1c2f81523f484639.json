{"ast":null,"code":"import _taggedTemplateLiteral from \"/Users/jenn/Desktop/info340/project-jsorror/node_modules/@babel/runtime/helpers/esm/taggedTemplateLiteral.js\";\nvar _templateObject, _templateObject2, _templateObject3, _templateObject4, _templateObject5, _templateObject6, _templateObject7, _templateObject8, _templateObject9, _templateObject10, _templateObject11, _templateObject12, _templateObject13, _templateObject14;\n(function () {\n  \"use strict\";\n\n  try {\n    if (typeof document != \"undefined\") {\n      var elementStyle = document.createElement(\"style\");\n      elementStyle.appendChild(document.createTextNode(\"._handle_bk7m7_1 {\\n  fill: var(--color-handle-fill);\\n  stroke: var(--color-handle-stroke);\\n}\\n\\n._dragging_bk7m7_6 {\\n  fill: var(--color-handle-drag-fill);\\n}\\n\\n._dot_bk7m7_10 {\\n  fill: var(--color-handle-dots);\\n}\\n\\n._line_bk7m7_14 {\\n  stroke: var(--color-handle-line);\\n}\\n._slice_1knu8_1 {\\n  fill: var(--color-primary);\\n}\\n\\n._unsliced_1knu8_5 {\\n  fill: var(--color-background);\\n  opacity: 0.5;\\n  pointer-events: none;\\n}\\n._container_1u3dt_1 {\\n  /** Old mappings - to be removed in next major */\\n  --color-background: rgb(51, 51, 51);\\n  --color-on-background: #fff;\\n\\n  --color-tooltip: rgba(0, 5, 11, 0.9);\\n  --color-on-tooltip: #fff;\\n\\n  --color-handle-fill: #2c343a;\\n  --color-handle-stroke: #67c2e4;\\n  --color-handle-drag-fill: transparent;\\n  --color-handle-dots: #67c2e4;\\n  --color-handle-line: #67c2e4;\\n\\n  /** New mappings */\\n  --tooltip-background: var(--color-tooltip);\\n  --tooltip-color: var(--color-on-tooltip);\\n  --tooltip-border-radius: 5px;\\n  --tooltip-spacing: 5px;\\n\\n  --chart-background: var(--color-background);\\n  --chart-color: var(--color-on-background);\\n\\n  --chart-handle-fill: var(--color-handle-fill);\\n  --chart-handle-stroke: var(--color-handle-stroke);\\n  --chart-handle-drag-fill: var(--color-handle-drag-fill);\\n  --chart-handle-dots: var(--color-handle-dots);\\n  --chart-handle-line: var(--color-handle-line);\\n}\\n\\n  ._container_1u3dt_1 ._svg_1u3dt_30:focus {\\n      outline: none;\\n    }\\n\\n  ._container_1u3dt_1 ._svg_1u3dt_30:focus-visible {\\n      outline: auto;\\n    }\\n._container_19vag_1 {\\n  display: flex;\\n  overflow: auto;\\n}\\n\\n  ._container_19vag_1._horizontal_19vag_5 {\\n    align-items: center;\\n    flex-direction: row;\\n  }\\n\\n  ._container_19vag_1._vertical_19vag_10 {\\n    flex-direction: column;\\n  }\\n._symbol_f5unn_1 {\\n  width: 15px;\\n  height: 3px;\\n}\\n._entry_1493o_1 {\\n  display: flex;\\n  color: var(--color-on-primary);\\n  padding: 8px;\\n  will-change: transparency;\\n  transition: opacity 150ms ease-in;\\n}\\n\\n  ._entry_1493o_1._vertical_1493o_8 {\\n    flex-direction: row;\\n    align-items: center;\\n  }\\n\\n  ._entry_1493o_1._vertical_1493o_8:first-child {\\n      padding-top: 0;\\n    }\\n\\n  ._entry_1493o_1._vertical_1493o_8:last-child {\\n      padding-bottom: 0;\\n    }\\n\\n  ._entry_1493o_1._vertical_1493o_8 ._label_1493o_20 {\\n      margin-left: 8px;\\n    }\\n\\n  ._entry_1493o_1._vertical_1493o_8 svg {\\n      display: block;\\n      margin: 0 auto;\\n    }\\n\\n  ._entry_1493o_1._horizontal_1493o_30 {\\n    align-items: center;\\n    flex-direction: row;\\n  }\\n\\n  ._entry_1493o_1._horizontal_1493o_30:first-child {\\n      padding-left: 0;\\n    }\\n\\n  ._entry_1493o_1._horizontal_1493o_30:last-child {\\n      padding-right: 0;\\n    }\\n\\n  ._entry_1493o_1._horizontal_1493o_30 ._label_1493o_20 {\\n      margin-left: 8px;\\n    }\\n\\n  ._entry_1493o_1 ._label_1493o_20 {\\n    font-size: 12px;\\n  }\\n\\n  ._entry_1493o_1 svg {\\n    width: 15px;\\n    height: 15px;\\n  }\\n._container_1gnp9_1 {\\n  display: flex;\\n  height: 100%;\\n}\\n\\n  ._container_1gnp9_1._vertical_1gnp9_5 {\\n    flex-direction: column;\\n    max-width: 55px;\\n  }\\n\\n  ._container_1gnp9_1._vertical_1gnp9_5 ._start_1gnp9_9,\\n    ._container_1gnp9_1._vertical_1gnp9_5 ._end_1gnp9_10 {\\n      text-align: center;\\n      padding: 5px 0;\\n      width: 100%;\\n    }\\n\\n  ._container_1gnp9_1._vertical_1gnp9_5 ._gradient_1gnp9_16 {\\n      width: 25px;\\n      margin: 0 auto;\\n    }\\n\\n  ._container_1gnp9_1._horizontal_1gnp9_22 {\\n    flex-direction: row-reverse;\\n  }\\n\\n  ._container_1gnp9_1._horizontal_1gnp9_22 ._start_1gnp9_9,\\n    ._container_1gnp9_1._horizontal_1gnp9_22 ._end_1gnp9_10 {\\n      max-width: 20%;\\n    }\\n\\n  ._container_1gnp9_1._horizontal_1gnp9_22 ._start_1gnp9_9 {\\n      text-align: right;\\n      padding-left: 5px;\\n    }\\n\\n  ._container_1gnp9_1._horizontal_1gnp9_22 ._end_1gnp9_10 {\\n      text-align: left;\\n      padding-right: 5px;\\n    }\\n\\n  ._container_1gnp9_1 ._gradient_1gnp9_16 {\\n    flex: 1;\\n    width: 100%;\\n    border-radius: 2px;\\n  }\\n\\n  ._container_1gnp9_1 ._start_1gnp9_9,\\n  ._container_1gnp9_1 ._end_1gnp9_10 {\\n    color: var(--color-on-primary);\\n    font-size: 12px;\\n    white-space: nowrap;\\n    overflow: hidden;\\n    text-overflow: ellipsis;\\n  }\\n._gridLine_5yx3q_1 {\\n  shape-rendering: crispEdges;\\n  pointer-events: none;\\n}\\n._gridStripe_xcrvl_1 {\\n  pointer-events: none;\\n}\\n._markLine_1sfls_1 {\\n  pointer-events: none;\\n  stroke-dasharray: 4, 4;\\n  stroke-linecap: round;\\n}\\n._label_uiu20_1 {\\n  font-size: 16px;\\n  margin-bottom: 3px;\\n  color: var(--color-on-tooltip);\\n}\\n\\n._value_uiu20_7 {\\n  font-size: 13px;\\n  color: var(--color-on-tooltip);\\n  opacity: 0.7;\\n}\\n\\n._subValue_uiu20_13 {\\n  display: block;\\n  text-align: left;\\n  padding: 3px 5px;\\n}\\n\\n._subValue_uiu20_13 ._subValueColor_uiu20_18 {\\n    width: 5px;\\n    height: 15px;\\n    margin-right: 8px;\\n    display: inline-block;\\n  }\\n\\n._subValue_uiu20_13 ._subValueName_uiu20_25 {\\n    margin-right: 5px;\\n  }\\n._base_b22et_1 {\\n  white-space: nowrap;\\n  text-align: center;\\n  will-change: transform, opacity;\\n  background-color: var(--tooltip-background);\\n  color: var(--tooltip-color);\\n  padding: var(--tooltip-spacing);\\n  border-radius: var(--tooltip-border-radius);\\n}\\n\\n  ._base_b22et_1 ._disablePointer_b22et_10 {\\n    cursor: not-allowed;\\n  }\\n._inactive_jp2yc_1 {\\n  opacity: 0.2;\\n}\\n\\n._hidden_jp2yc_5 {\\n  opacity: 0;\\n}\\n._scatterPlot_gc5eo_1 {\\n  overflow: visible;\\n}\\n._point_u68jv_1 {\\n  stroke: rgba(255, 255, 255, 0.5);\\n  stroke-width: 1px;\\n}\\n._areaChart_yyojn_1 {\\n  overflow: visible;\\n}\\n._barChart_sfjii_1 {\\n  overflow: visible;\\n}\\n\\n  ._barChart_sfjii_1._stackedNormalized_sfjii_4 .bar, ._barChart_sfjii_1._stacked_sfjii_4 .bar, ._barChart_sfjii_1._marimekko_sfjii_6 .bar {\\n      stroke: var(--color-background);\\n      stroke-width: 0.2;\\n    }\\n._marker_agib4_1 {\\n  fill: var(--color-primary);\\n  cursor: pointer;\\n}\\n._label_qd893_1 {\\n  font-size: 12px;\\n  -webkit-user-select: none;\\n     -moz-user-select: none;\\n          user-select: none;\\n  pointer-events: none;\\n}\\n._link_1oi50_1 {\\n  fill: none;\\n  transition: stroke-opacity 100ms ease-in-out, stroke 100ms ease-in-out;\\n  mix-blend-mode: initial;\\n}\\n\\n._tooltip_1oi50_7 {\\n  text-align: center;\\n  pointer-events: none;\\n}\\n\\n._tooltip_1oi50_7 ._tooltipLabel_1oi50_11 {\\n    font-size: 16px;\\n    margin-bottom: 3px;\\n    color: rgba(255, 255, 255, 1);\\n    text-align: center;\\n  }\\n\\n._tooltip_1oi50_7 ._tooltipValue_1oi50_18 {\\n    font-size: 13px;\\n    color: rgba(255, 255, 255, 0.7);\\n    text-align: center;\\n  }\\n._node_oqk6h_1 {\\n  transition: opacity 100ms ease-in-out, fill-opacity 100ms ease-in-out;\\n}\\n\\n._tooltip_oqk6h_5 {\\n  text-align: center;\\n  padding: 0 8px;\\n  pointer-events: none;\\n}\\n\\n._tooltip_oqk6h_5 ._tooltipLabel_oqk6h_10 {\\n    font-size: 16px;\\n    margin-bottom: 3px;\\n    color: rgba(255, 255, 255, 1);\\n    text-align: center;\\n  }\\n\\n._tooltip_oqk6h_5 ._tooltipValue_oqk6h_17 {\\n    font-size: 13px;\\n    color: rgba(255, 255, 255, 0.7);\\n    text-align: center;\\n  }\\n._inactive_kwc4n_1 {\\n  opacity: 0.4;\\n  transition: opacity 200ms ease-in-out;\\n}\\n\\n._hidden_kwc4n_6 {\\n  opacity: 0;\\n}\\n._valueLabel_1eyd5_1 {\\n  font-size: 14px;\\n  font-weight: 400;\\n  fill: var(--color-on-background);\\n  opacity: 0.6;\\n}\\n._valueLabel_1h164_1 {\\n  font-size: 18px;\\n  font-weight: 400;\\n  fill: var(--color-on-background);\\n}\\n._stackedValueLabel_1w6zx_1 {\\n  font-size: 18px;\\n  font-weight: 400;\\n  fill: var(--color-on-background);\\n}\\n._stackedDescriptionLabel_1h95t_1 {\\n  font-size: 12px;\\n  font-weight: 400;\\n  fill: var(--color-on-background);\\n}\\n._cell_r3f8c_1 {\\n  transition: stroke 150ms ease-in-out;\\n}\\n._item_18e6r_1 {\\n  margin-bottom: 5px;\\n  align-items: center;\\n  display: grid;\\n  grid-column-gap: 5px;\\n  grid-row-gap: 3px;\\n}\\n\\n  ._item_18e6r_1._labelStart_18e6r_8._valueEnd_18e6r_9 {\\n      grid-template-columns: 2fr 2fr 1fr;\\n      grid-template-areas: 'label bar value-label';\\n    }\\n\\n  ._item_18e6r_1._labelBottom_18e6r_15._valueEnd_18e6r_9 {\\n      grid-template-columns: 1fr 50px;\\n      grid-template-areas:\\n        'bar value-label'\\n        'label label';\\n    }\\n\\n  ._item_18e6r_1._labelNone_18e6r_24 ._label_18e6r_8 {\\n      display: none;\\n    }\\n\\n  ._item_18e6r_1._labelNone_18e6r_24._valueEnd_18e6r_9 {\\n      grid-template-columns: 1fr 50px;\\n      grid-template-areas: 'bar value-label';\\n    }\\n\\n  ._item_18e6r_1._labelEnd_18e6r_35._valueStart_18e6r_36 {\\n      grid-template-columns: 50px 1fr 1fr;\\n      grid-template-areas: 'value-label bar label';\\n    }\\n\\n  ._item_18e6r_1._labelTop_18e6r_42._valueStart_18e6r_36 {\\n      grid-template-columns: 50px 1fr;\\n      grid-template-areas:\\n        'label label'\\n        'value-label bar';\\n    }\\n\\n  ._item_18e6r_1._labelTop_18e6r_42._valueEnd_18e6r_9 {\\n      grid-template-columns: 1fr 50px;\\n      grid-template-areas:\\n        'label label'\\n        'bar value-label';\\n    }\\n\\n  ._item_18e6r_1._labelTop_18e6r_42._valueBottom_18e6r_57 {\\n      grid-template-columns: 1fr;\\n      grid-template-areas:\\n        'label'\\n        'bar'\\n        'value-label';\\n    }\\n\\n  ._item_18e6r_1._labelTop_18e6r_42._valueNone_18e6r_65 {\\n      grid-template-columns: 1fr;\\n      grid-template-areas:\\n        'label'\\n        'bar';\\n    }\\n\\n  ._item_18e6r_1._labelTop_18e6r_42._valueNone_18e6r_65 ._valueLabel_18e6r_71 {\\n        display: none;\\n      }\\n\\n  ._item_18e6r_1._clickable_18e6r_77 {\\n    cursor: pointer;\\n  }\\n\\n  ._item_18e6r_1 ._label_18e6r_8,\\n  ._item_18e6r_1 ._valueLabel_18e6r_71 {\\n    cursor: inherit;\\n  }\\n\\n  ._item_18e6r_1 ._label_18e6r_8 {\\n    grid-area: label;\\n  }\\n\\n  ._item_18e6r_1 ._valueLabel_18e6r_71 {\\n    grid-area: value-label;\\n    line-height: 10px;\\n    text-overflow: ellipsis;\\n    overflow-x: hidden;\\n  }\\n\\n  ._item_18e6r_1 ._outerBar_18e6r_97 {\\n    grid-area: bar;\\n    width: 100%;\\n    height: 10px;\\n    display: flex;\\n    align-items: center;\\n  }\\n\\n  ._item_18e6r_1 ._bar_18e6r_105 {\\n    height: 5px;\\n  }\\n._container_13giw_1 {\\n  display: flex;\\n  flex-direction: row;\\n  justify-content: space-between;\\n  align-items: center;\\n}\\n\\n  ._container_13giw_1 > div {\\n    flex: 1;\\n  }\"));\n      document.head.appendChild(elementStyle);\n    }\n  } catch (e) {\n    console.error(\"vite-plugin-css-injected-by-js\", e);\n  }\n})();\nimport { jsxs, jsx, Fragment as Fragment$1 } from \"react/jsx-runtime\";\nimport { useId, CloneElement, Tooltip } from \"reablocks\";\nimport { Fragment, createRef, useState, useCallback, useEffect, useMemo, useRef, Children, cloneElement, createContext, useContext, Component, forwardRef, useImperativeHandle, createElement, isValidElement } from \"react\";\nimport ellipsize from \"ellipsize\";\nimport { max, min, bisector, range, median, histogram, extent as extent$1, maxIndex } from \"d3-array\";\nimport { arc, line as line$1, curveMonotoneX, curveStep, curveLinear, stack, stackOffsetExpand, stackOffsetDiverging, area, pie, radialArea, curveCardinalClosed, curveCardinal, curveLinearClosed, radialLine } from \"d3-shape\";\nimport { scaleLinear, scaleTime, scaleBand, scaleOrdinal, scaleQuantile, scalePoint } from \"d3-scale\";\nimport humanFormat from \"human-format\";\nimport { applyToPoint, inverse, applyToPoints, smoothMatrix, transform, translate, scale, identity, fromDefinition, fromObject } from \"transformation-matrix\";\nimport classNames from \"classnames\";\nimport bind from \"memoize-bind\";\nimport useDimensions from \"react-cool-dimensions\";\nimport bigInt from \"big-integer\";\nimport chroma from \"chroma-js\";\nimport isEqual from \"react-fast-compare\";\nimport { useMotionValue, useSpring, motion, animate } from \"framer-motion\";\nimport { interpolate as interpolate$1 } from \"d3-interpolate\";\nimport { identifier } from \"safe-identifier\";\nimport { geoNaturalEarth1, geoMercator, geoPath } from \"d3-geo\";\nimport { sankey, sankeyJustify, sankeyCenter, sankeyLeft, sankeyRight, sankeyLinkHorizontal } from \"d3-sankey\";\nimport { layout } from \"@upsetjs/venn.js\";\nimport invert from \"invert-color\";\nimport { pack, hierarchy, treemap, treemapSquarify } from \"d3-hierarchy\";\nconst LinearAxisLine = _ref => {\n  let {\n    strokeColor,\n    strokeWidth,\n    strokeGradient,\n    scale: scale2,\n    orientation,\n    className\n  } = _ref;\n  const id = useId();\n  const [range0, range1] = scale2.range();\n  return /* @__PURE__ */jsxs(Fragment, {\n    children: [/* @__PURE__ */jsx(\"line\", {\n      className,\n      x1: orientation === \"vertical\" ? 0 : range0,\n      x2: orientation === \"vertical\" ? 1e-5 : range1,\n      y1: orientation === \"vertical\" ? range0 : 0,\n      y2: orientation === \"vertical\" ? range1 : 1e-5,\n      strokeWidth,\n      stroke: strokeGradient ? \"url(#axis-gradient-\".concat(id, \")\") : strokeColor\n    }), strokeGradient && /* @__PURE__ */jsx(CloneElement, {\n      element: strokeGradient,\n      id: \"axis-gradient-\".concat(id)\n    })]\n  });\n};\nLinearAxisLine.defaultProps = {\n  strokeColor: \"#8F979F\",\n  strokeWidth: 1\n};\nconst LinearAxis = props => {\n  const {\n    position,\n    tickSeries,\n    axisLine,\n    height,\n    width,\n    scale: scale2,\n    orientation,\n    visibility = \"visible\",\n    onDimensionsChange\n  } = props;\n  const containerRef = createRef();\n  const [dimensions, setDimensions] = useState({\n    height,\n    width\n  });\n  const updateDimensions = useCallback(() => {\n    const shouldOffset = position !== \"center\";\n    let height2;\n    let width2;\n    if (shouldOffset) {\n      const dims = containerRef.current.getBoundingClientRect();\n      width2 = Math.floor(dims.width);\n      height2 = Math.floor(dims.height);\n    }\n    if (orientation === \"vertical\") {\n      if (dimensions.width !== width2) {\n        setDimensions({\n          ...dimensions,\n          width: width2\n        });\n        onDimensionsChange({\n          width: width2\n        });\n      }\n    } else {\n      if (dimensions.height !== height2) {\n        setDimensions({\n          ...dimensions,\n          height: height2\n        });\n        onDimensionsChange({\n          height: height2\n        });\n      }\n    }\n  }, [containerRef, dimensions, onDimensionsChange, orientation, position]);\n  useEffect(() => {\n    updateDimensions();\n  }, [updateDimensions, height, width, scale2]);\n  function getPosition() {\n    let translateY2 = 0;\n    let translateX2 = 0;\n    if (position === \"end\" && orientation === \"horizontal\") {\n      translateY2 = height;\n    } else if (position === \"center\" && orientation === \"horizontal\") {\n      translateY2 = height / 2;\n    } else if (position === \"end\" && orientation === \"vertical\") {\n      translateX2 = width;\n    } else if (position === \"center\" && orientation === \"vertical\") {\n      translateX2 = width / 2;\n    }\n    return {\n      translateX: translateX2,\n      translateY: translateY2\n    };\n  }\n  const {\n    translateX,\n    translateY\n  } = getPosition();\n  return /* @__PURE__ */jsxs(\"g\", {\n    transform: \"translate(\".concat(translateX, \", \").concat(translateY, \")\"),\n    ref: containerRef,\n    visibility,\n    children: [axisLine && /* @__PURE__ */jsx(CloneElement, {\n      element: axisLine,\n      height,\n      width,\n      scale: scale2,\n      orientation\n    }), (tickSeries.props.line || tickSeries.props.label) && /* @__PURE__ */jsx(CloneElement, {\n      element: tickSeries,\n      height,\n      width,\n      scale: scale2,\n      orientation,\n      axis: props\n    })]\n  });\n};\nLinearAxis.defaultProps = {\n  scaled: false,\n  roundDomains: false,\n  axisLine: /* @__PURE__ */jsx(LinearAxisLine, {}),\n  onDimensionsChange: () => void 0\n};\nconst LinearAxisTickLabel = _ref2 => {\n  let {\n    text,\n    fullText,\n    angle,\n    orientation,\n    half,\n    line: line2,\n    textAnchor,\n    position,\n    className,\n    fill,\n    fontSize,\n    fontFamily,\n    rotation,\n    padding,\n    formatTooltip,\n    align\n  } = _ref2;\n  function getAlign() {\n    if ((align === \"inside\" || align === \"outside\") && half === \"center\") {\n      return \"center\";\n    }\n    if (align === \"inside\") {\n      return half === \"start\" ? \"end\" : \"start\";\n    }\n    if (align === \"outside\") {\n      return half === \"start\" ? \"start\" : \"end\";\n    }\n    return align;\n  }\n  function getTickLineSpacing() {\n    var _line2$props$size, _line2$props$position;\n    if (!line2) {\n      return [0, 0];\n    }\n    const size = (_line2$props$size = line2.props.size) !== null && _line2$props$size !== void 0 ? _line2$props$size : 3;\n    const position2 = (_line2$props$position = line2.props.position) !== null && _line2$props$position !== void 0 ? _line2$props$position : \"center\";\n    if (position2 === \"start\") {\n      return [size * -1, 0];\n    } else if (position2 === \"end\") {\n      return [0, size];\n    } else {\n      return [size * -0.5, size * 0.5];\n    }\n  }\n  function getOffset() {\n    const adjustedPadding = typeof padding === \"number\" ? {\n      fromAxis: padding,\n      alongAxis: padding\n    } : padding;\n    const spacing = getTickLineSpacing();\n    const offset1 = position === \"start\" ? spacing[0] - adjustedPadding.fromAxis : position === \"end\" ? spacing[1] + adjustedPadding.fromAxis : 0;\n    const align2 = getAlign();\n    let offset2 = 0;\n    offset2 += align2 === \"center\" ? 0 : align2 === \"start\" ? -adjustedPadding.alongAxis : adjustedPadding.alongAxis;\n    const horz = orientation === \"horizontal\";\n    return {\n      [horz ? \"x\" : \"y\"]: offset2,\n      [horz ? \"y\" : \"x\"]: offset1\n    };\n  }\n  function getTextPosition() {\n    let transform2 = \"\";\n    let newtextAnchor = \"\";\n    let alignmentBaseline = \"middle\";\n    if (angle !== 0) {\n      transform2 = \"rotate(\".concat(angle, \")\");\n      newtextAnchor = \"end\";\n    } else {\n      const align2 = getAlign();\n      if (orientation === \"horizontal\") {\n        newtextAnchor = align2 === \"center\" ? \"middle\" : align2 === \"start\" ? \"end\" : \"start\";\n        if (position === \"start\") {\n          alignmentBaseline = \"baseline\";\n        } else if (position === \"end\") {\n          alignmentBaseline = \"hanging\";\n        }\n      } else {\n        alignmentBaseline = align2 === \"center\" ? \"middle\" : align2 === \"start\" ? \"baseline\" : \"hanging\";\n        if (position === \"start\") {\n          newtextAnchor = \"end\";\n        } else if (position === \"end\") {\n          newtextAnchor = \"start\";\n        } else {\n          newtextAnchor = \"middle\";\n        }\n      }\n    }\n    return {\n      transform: transform2,\n      textAnchor: textAnchor || newtextAnchor,\n      alignmentBaseline\n    };\n  }\n  const {\n    x,\n    y\n  } = getOffset();\n  const textPosition = getTextPosition();\n  const titleHover = typeof formatTooltip === \"function\" ? formatTooltip(fullText) : fullText;\n  return /* @__PURE__ */jsxs(\"g\", {\n    transform: \"translate(\".concat(x, \", \").concat(y, \")\"),\n    fontSize,\n    fontFamily,\n    children: [/* @__PURE__ */jsx(\"title\", {\n      children: titleHover\n    }), /* @__PURE__ */jsx(\"text\", {\n      ...textPosition,\n      fill,\n      className,\n      children: text\n    })]\n  });\n};\nLinearAxisTickLabel.defaultProps = {\n  fill: \"#8F979F\",\n  fontSize: 11,\n  fontFamily: \"sans-serif\",\n  rotation: true,\n  padding: 5,\n  align: \"center\"\n};\nconst LinearAxisTickLine = _ref3 => {\n  let {\n    size,\n    position,\n    orientation,\n    strokeColor,\n    strokeWidth,\n    className\n  } = _ref3;\n  const path2 = useMemo(() => {\n    const isVertical = orientation === \"vertical\";\n    const tickSize = size || 0;\n    const start2 = position === \"start\" ? tickSize * -1 : position === \"center\" ? tickSize * -0.5 : 0;\n    const end2 = start2 + tickSize;\n    return {\n      x1: isVertical ? end2 : 0,\n      x2: isVertical ? start2 : 0,\n      y1: isVertical ? 0 : start2,\n      y2: isVertical ? 0 : end2\n    };\n  }, [orientation, position, size]);\n  return /* @__PURE__ */jsx(\"line\", {\n    className,\n    strokeWidth,\n    stroke: strokeColor,\n    ...path2\n  });\n};\nLinearAxisTickLine.defaultProps = {\n  strokeColor: \"#8F979F\",\n  strokeWidth: 1,\n  size: 5\n};\nconst getNavigatorLanguage = () => {\n  if (typeof window === \"undefined\") {\n    return \"en\";\n  }\n  if (navigator.languages && navigator.languages.length) {\n    return navigator.languages[0];\n  }\n  if (navigator.userLanguage || navigator.language || navigator.browserLanguage) {\n    return \"en\";\n  }\n};\nconst locale = getNavigatorLanguage();\nconst options = {\n  year: \"numeric\",\n  month: \"numeric\",\n  day: \"numeric\",\n  hour12: true,\n  formatMatcher: \"best fit\"\n};\nfunction formatValue(value2) {\n  if (value2 !== void 0) {\n    if (value2 instanceof Date) {\n      return value2.toLocaleDateString(locale, options);\n    } else if (typeof value2 === \"number\") {\n      return value2.toLocaleString();\n    }\n    return value2;\n  }\n  return \"No value\";\n}\nfunction getAriaLabel(datapoint) {\n  const isArray = Array.isArray(datapoint);\n  if (isArray) {\n    return datapoint == null ? void 0 : datapoint.map(row => getAriaLabel(row)).join(\", \");\n  } else {\n    const key = (datapoint == null ? void 0 : datapoint.key) || (datapoint == null ? void 0 : datapoint.x);\n    const value2 = (datapoint == null ? void 0 : datapoint.data) || (datapoint == null ? void 0 : datapoint.y);\n    return \"\".concat(key, \": \").concat(formatValue(value2));\n  }\n}\nconst ONE_DAY = 60 * 60 * 24;\nconst DURATION_TICK_STEPS = [1e-3,\n// 1 ms\n5e-3,\n// 5 ms\n0.01,\n// 10 ms\n0.05,\n// 50 ms\n0.1,\n// 100 ms\n0.5,\n// 500 ms\n1,\n// 1 s\n5,\n// 5 s\n10,\n// 10 s\n15,\n// 15 s\n60,\n// 1 m\n60 * 15,\n// 15 m\n60 * 30,\n// 30 m\n60 * 60,\n// 1 h\n60 * 60 * 2,\n// 2 h\n60 * 60 * 4,\n// 4 h\n60 * 60 * 6,\n// 6 h\n60 * 60 * 8,\n// 8 h\n60 * 60 * 12,\n// 12 h\nONE_DAY\n// 24 h\n];\nfunction reduceTicks(ticks, maxTicks) {\n  if (ticks.length > maxTicks) {\n    const reduced = [];\n    const modulus = Math.floor(ticks.length / maxTicks);\n    for (let i = 0; i < ticks.length; i++) {\n      if (i % modulus === 0) {\n        reduced.push(ticks[i]);\n      }\n    }\n    ticks = reduced;\n  }\n  return ticks;\n}\nfunction getMaxTicks(size, dimension) {\n  const tickWidth = Math.max(size, 0);\n  return Math.floor(dimension / tickWidth);\n}\nfunction getDurationTicks(domain, maxTicks) {\n  const domainWidth = domain[1] - domain[0];\n  let tickStep = null;\n  for (const s of DURATION_TICK_STEPS) {\n    if (domainWidth / s < maxTicks) {\n      tickStep = s;\n      break;\n    }\n  }\n  if (tickStep === null) {\n    const numDayTicks = domainWidth / ONE_DAY;\n    const dayStep = Math.ceil(numDayTicks / maxTicks);\n    tickStep = ONE_DAY * dayStep;\n  }\n  const ticks = [domain[0]];\n  while (ticks[ticks.length - 1] + tickStep <= domain[1]) {\n    ticks.push(ticks[ticks.length - 1] + tickStep);\n  }\n  return ticks;\n}\nfunction getTicks(scale2, tickValues, type) {\n  let maxTicks = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 100;\n  let interval = arguments.length > 4 ? arguments[4] : undefined;\n  let result;\n  if (tickValues) {\n    result = tickValues;\n  } else {\n    if (scale2.ticks) {\n      if (type === \"duration\") {\n        result = getDurationTicks(scale2.domain(), maxTicks);\n      } else if (interval) {\n        result = scale2.ticks(interval);\n      } else {\n        if (type === \"time\") {\n          result = scale2.ticks();\n          result = reduceTicks(result, maxTicks);\n        } else {\n          result = scale2.ticks(maxTicks);\n        }\n      }\n    } else {\n      tickValues = scale2.domain();\n      result = reduceTicks(tickValues, maxTicks);\n    }\n  }\n  return result;\n}\nconst cache = {};\nconst calculateDimensions = (text, fontFamily, fontSize) => {\n  const key = \"\".concat(text, \"_\").concat(fontFamily, \"_\").concat(fontSize);\n  if (cache[key]) {\n    return cache[key];\n  }\n  if (typeof window === \"undefined\" || typeof document === \"undefined\") {\n    const height = parseInt(typeof fontSize === \"string\" ? fontSize : fontSize.toString(), 10);\n    const dimensions2 = {\n      height,\n      // 8 is an approximation of the width of a character\n      width: text.length * 8\n    };\n    cache[key] = dimensions2;\n    return dimensions2;\n  }\n  const element = document.createElement(\"div\");\n  element.style.fontFamily = fontFamily;\n  element.style.fontSize = typeof fontSize === \"string\" ? fontSize : \"\".concat(fontSize, \"px\");\n  element.style.position = \"absolute\";\n  element.style.left = \"-9999px\";\n  element.style.whiteSpace = \"nowrap\";\n  element.style.height = \"auto\";\n  element.style.fontWeight = \"normal\";\n  element.style.lineHeight = \"normal\";\n  element.style.width = \"auto\";\n  element.style.wordBreak = \"normal\";\n  element.textContent = text;\n  document.body.appendChild(element);\n  const dimensions = {\n    height: element.offsetHeight,\n    width: element.offsetWidth\n  };\n  document.body.removeChild(element);\n  cache[key] = dimensions;\n  return dimensions;\n};\nconst LinearAxisTickSeries = _ref4 => {\n  let {\n    scale: scale2,\n    orientation,\n    height,\n    width,\n    label: label2,\n    tickSize,\n    tickValues,\n    interval,\n    line: line2,\n    axis\n  } = _ref4;\n  const getAdjustedScale = useCallback(() => {\n    if (scale2.bandwidth) {\n      let offset = scale2.bandwidth() / 2;\n      if (scale2.round()) {\n        offset = Math.round(offset);\n      }\n      return d => +scale2(d) + offset;\n    } else {\n      return d => +scale2(d);\n    }\n  }, [scale2]);\n  const getPosition = useCallback(scaledTick => {\n    if (orientation === \"horizontal\") {\n      return {\n        x: scaledTick,\n        y: 0\n      };\n    } else {\n      return {\n        x: 0,\n        y: scaledTick\n      };\n    }\n  }, [orientation]);\n  const getDimension2 = useCallback(() => {\n    return orientation === \"vertical\" ? height : width;\n  }, [height, orientation, width]);\n  const labelFormatFn = useMemo(() => {\n    if (label2 && label2.props.format) {\n      return label2.props.format;\n    } else if (scale2.tickFormat) {\n      return scale2.tickFormat.apply(scale2, [5]);\n    } else {\n      return v => formatValue(v);\n    }\n  }, [label2, scale2]);\n  const ticks = useMemo(() => {\n    const dimension = getDimension2();\n    const maxTicks = getMaxTicks(tickSize, dimension);\n    const ticks2 = getTicks(scale2, tickValues, axis.type, maxTicks, interval);\n    const adjustedScale = getAdjustedScale();\n    const format = labelFormatFn;\n    const midpoint = dimension / 2;\n    return ticks2.map(tick => {\n      const fullText = format(tick);\n      const scaledTick = adjustedScale(tick);\n      const position = getPosition(scaledTick);\n      const text = ellipsize(fullText, 18);\n      const size = label2 ? calculateDimensions(text, label2.props.fontFamily, label2.props.fontSize.toString()) : {};\n      return {\n        ...position,\n        ...size,\n        text,\n        fullText,\n        half: scaledTick === midpoint ? \"center\" : scaledTick < midpoint ? \"start\" : \"end\"\n      };\n    });\n  }, [axis.type, getAdjustedScale, getDimension2, getPosition, interval, label2, labelFormatFn, scale2, tickSize, tickValues]);\n  const angle = useMemo(() => {\n    if (!label2) {\n      return 0;\n    }\n    const labelProps = label2.props;\n    const dimension = getDimension2();\n    const maxTicksLength = max(ticks, tick => tick.width);\n    let angle2 = 0;\n    if (labelProps.rotation) {\n      if (labelProps.rotation === true) {\n        let baseWidth = maxTicksLength;\n        const maxBaseWidth = Math.floor(dimension / ticks.length);\n        while (baseWidth > maxBaseWidth && angle2 > -90) {\n          angle2 -= 30;\n          baseWidth = Math.cos(angle2 * (Math.PI / 180)) * maxTicksLength;\n        }\n      } else {\n        angle2 = labelProps.rotation;\n      }\n    }\n    return angle2;\n  }, [getDimension2, label2, ticks]);\n  return /* @__PURE__ */jsx(Fragment, {\n    children: ticks.map((tick, i) => /* @__PURE__ */jsxs(\"g\", {\n      transform: \"translate(\".concat(tick.x, \", \").concat(tick.y, \")\"),\n      children: [line2 && /* @__PURE__ */jsx(CloneElement, {\n        element: line2,\n        height,\n        width,\n        orientation\n      }), label2 && /* @__PURE__ */jsx(CloneElement, {\n        element: label2,\n        text: tick.text,\n        fullText: tick.fullText,\n        half: tick.half,\n        angle,\n        orientation,\n        line: line2\n      })]\n    }, i))\n  });\n};\nLinearAxisTickSeries.defaultProps = {\n  line: /* @__PURE__ */jsx(LinearAxisTickLine, {\n    height: 10,\n    width: 10,\n    orientation: \"horizontal\",\n    position: \"center\"\n  }),\n  label: /* @__PURE__ */jsx(LinearAxisTickLabel, {\n    line: /* @__PURE__ */jsx(LinearAxisTickLine, {\n      orientation: \"horizontal\",\n      position: \"center\",\n      height: 5,\n      width: 5\n    }),\n    text: \"\",\n    fullText: \"\",\n    angle: 0,\n    orientation: \"horizontal\",\n    half: \"start\",\n    position: \"center\"\n  }),\n  tickSize: 30\n};\nconst LinearXAxisTickLabel = props => /* @__PURE__ */jsx(LinearAxisTickLabel, {\n  ...props\n});\nLinearXAxisTickLabel.defaultProps = {\n  ...LinearAxisTickLabel.defaultProps,\n  rotation: true,\n  position: \"end\",\n  align: \"center\"\n};\nconst LinearXAxisTickLine = props => /* @__PURE__ */jsx(LinearAxisTickLine, {\n  ...props\n});\nLinearXAxisTickLine.defaultProps = {\n  ...LinearAxisTickLine.defaultProps,\n  position: \"end\"\n};\nconst LinearXAxisTickSeries = props => /* @__PURE__ */jsx(LinearAxisTickSeries, {\n  ...props\n});\nLinearXAxisTickSeries.defaultProps = {\n  ...LinearAxisTickSeries.defaultProps,\n  tickSize: 75,\n  line: /* @__PURE__ */jsx(LinearXAxisTickLine, {}),\n  label: /* @__PURE__ */jsx(LinearXAxisTickLabel, {})\n};\nconst LinearXAxis = props => /* @__PURE__ */jsx(LinearAxis, {\n  ...props\n});\nLinearXAxis.defaultProps = {\n  ...LinearAxis.defaultProps,\n  position: \"end\",\n  roundDomains: false,\n  scaled: false,\n  type: \"value\",\n  orientation: \"horizontal\",\n  tickSeries: /* @__PURE__ */jsx(LinearXAxisTickSeries, {})\n};\nconst LinearYAxisTickLabel = props => /* @__PURE__ */jsx(LinearAxisTickLabel, {\n  ...props\n});\nLinearYAxisTickLabel.defaultProps = {\n  ...LinearAxisTickLabel.defaultProps,\n  rotation: false,\n  position: \"start\",\n  align: \"center\"\n};\nconst LinearYAxisTickLine = props => /* @__PURE__ */jsx(LinearAxisTickLine, {\n  ...props\n});\nLinearYAxisTickLine.defaultProps = {\n  ...LinearAxisTickLine.defaultProps,\n  position: \"start\"\n};\nconst LinearYAxisTickSeries = props => /* @__PURE__ */jsx(LinearAxisTickSeries, {\n  ...props\n});\nLinearYAxisTickSeries.defaultProps = {\n  ...LinearAxisTickSeries.defaultProps,\n  tickSize: 30,\n  line: /* @__PURE__ */jsx(LinearYAxisTickLine, {}),\n  label: /* @__PURE__ */jsx(LinearYAxisTickLabel, {})\n};\nconst LinearYAxis = props => /* @__PURE__ */jsx(LinearAxis, {\n  ...props\n});\nLinearYAxis.defaultProps = {\n  ...LinearAxis.defaultProps,\n  orientation: \"vertical\",\n  scaled: false,\n  roundDomains: false,\n  type: \"value\",\n  position: \"start\",\n  tickSeries: /* @__PURE__ */jsx(LinearYAxisTickSeries, {})\n};\nconst isAxisVisible = axis => !!axis.tickSeries.props.label || !!axis.tickSeries.props.line;\nconst RadialAxisTickLine = _ref5 => {\n  let {\n    stroke,\n    size,\n    position,\n    innerRadius,\n    outerRadius\n  } = _ref5;\n  const x1 = position === \"outside\" ? size : -(outerRadius - innerRadius);\n  return /* @__PURE__ */jsx(\"line\", {\n    x1,\n    x2: 0,\n    stroke,\n    style: {\n      pointerEvents: \"none\"\n    }\n  });\n};\nRadialAxisTickLine.defaultProps = {\n  stroke: \"rgba(113, 128, 141, .5)\",\n  size: 10,\n  position: \"inside\"\n};\nconst rad2deg = angle => angle * 180 / Math.PI;\nconst RadialAxisTickLabel = _ref6 => {\n  let {\n    point: point2,\n    autoRotate,\n    rotation,\n    padding,\n    data,\n    fill,\n    fontFamily,\n    fontSize,\n    format,\n    lineSize,\n    index,\n    formatTooltip,\n    ...rest\n  } = _ref6;\n  const {\n    transform: transform2,\n    textAnchor\n  } = useMemo(() => {\n    let textAnchor2;\n    let transform22;\n    if (autoRotate) {\n      if (rotation >= 85 && rotation <= 95 || rotation <= -85 && rotation >= -95 || rotation >= 265 && rotation <= 275 || rotation <= -265 && rotation >= -275) {\n        textAnchor2 = \"middle\";\n      } else if (rotation < -85 && rotation > -265 || rotation > 95 && rotation < 265) {\n        textAnchor2 = \"end\";\n      } else {\n        textAnchor2 = \"start\";\n      }\n      transform22 = \"rotate(\".concat(90 - rad2deg(point2), \", \").concat(padding, \", 0)\");\n    } else {\n      const shouldRotate = rotation && (rotation > 100 || rotation < -100);\n      const rotate = shouldRotate ? 180 : 0;\n      const translate2 = shouldRotate ? -30 : 0;\n      textAnchor2 = shouldRotate ? \"end\" : \"start\";\n      transform22 = \"rotate(\".concat(rotate, \") translate(\").concat(translate2, \")\");\n    }\n    return {\n      transform: transform22,\n      textAnchor: textAnchor2\n    };\n  }, [autoRotate, padding, point2, rotation]);\n  const text = format ? format(data, index) : formatValue(data);\n  const titleHover = typeof formatTooltip === \"function\" ? formatTooltip(data, index) : text;\n  return /* @__PURE__ */jsxs(\"g\", {\n    transform: transform2,\n    children: [/* @__PURE__ */jsx(\"title\", {\n      children: titleHover\n    }), /* @__PURE__ */jsx(\"text\", {\n      dy: \"0.35em\",\n      x: lineSize + 5,\n      textAnchor,\n      fill,\n      fontFamily,\n      fontSize,\n      ...rest,\n      children: text\n    })]\n  });\n};\nRadialAxisTickLabel.defaultProps = {\n  fill: \"#71808d\",\n  fontSize: 11,\n  padding: 15,\n  fontFamily: \"sans-serif\",\n  autoRotate: true,\n  startAngle: 0,\n  endAngle: 2 * Math.PI\n};\nconst RadialAxisTick = _ref7 => {\n  let {\n    line: line2,\n    label: label2,\n    scale: scale2,\n    outerRadius,\n    data,\n    index,\n    padding,\n    innerRadius,\n    startAngle,\n    endAngle\n  } = _ref7;\n  const point2 = scale2(data);\n  const rotation = point2 * 180 / Math.PI - 90;\n  const transform2 = \"rotate(\".concat(rotation, \") translate(\").concat(outerRadius + padding, \",0)\");\n  const lineSize = line2 ? line2.props.size : 0;\n  return /* @__PURE__ */jsxs(\"g\", {\n    transform: transform2,\n    children: [line2 && /* @__PURE__ */jsx(CloneElement, {\n      element: line2,\n      innerRadius,\n      outerRadius\n    }), label2 && /* @__PURE__ */jsx(CloneElement, {\n      element: label2,\n      index,\n      point: point2,\n      rotation,\n      lineSize,\n      data,\n      startAngle,\n      endAngle\n    })]\n  });\n};\nRadialAxisTick.defaultProps = {\n  outerRadius: 0,\n  padding: 0,\n  line: /* @__PURE__ */jsx(RadialAxisTickLine, {}),\n  label: /* @__PURE__ */jsx(RadialAxisTickLabel, {}),\n  startAngle: 0,\n  endAngle: 2 * Math.PI\n};\nconst RadialAxisTickSeries = _ref8 => {\n  let {\n    scale: scale2,\n    count,\n    outerRadius,\n    tick,\n    tickValues,\n    innerRadius,\n    interval,\n    type,\n    startAngle,\n    endAngle\n  } = _ref8;\n  const ticks = getTicks(scale2, tickValues, type, count, interval || count);\n  return /* @__PURE__ */jsx(Fragment, {\n    children: ticks.map((data, i) => {\n      const tickElement = typeof tick === \"function\" ? tick({\n        index: i\n      }) : tick;\n      return /* @__PURE__ */jsx(CloneElement, {\n        element: tickElement,\n        index: i,\n        scale: scale2,\n        data,\n        innerRadius,\n        outerRadius,\n        startAngle,\n        endAngle\n      }, i);\n    })\n  });\n};\nRadialAxisTickSeries.defaultProps = {\n  count: 12,\n  type: \"time\",\n  tick: /* @__PURE__ */jsx(RadialAxisTick, {}),\n  startAngle: 0,\n  endAngle: 2 * Math.PI\n};\nconst RadialAxisArc = _ref9 => {\n  let {\n    index,\n    stroke,\n    strokeDasharray,\n    scale: scale2,\n    startAngle,\n    endAngle\n  } = _ref9;\n  var _a, _b, _c, _d;\n  const r = scale2(index);\n  const strokeColor = typeof stroke === \"string\" ? stroke : stroke(index);\n  const strokeDash = typeof strokeDasharray === \"string\" ? strokeDasharray : strokeDasharray(index);\n  const isFullCircle = Math.abs(endAngle - startAngle) >= 2 * Math.PI;\n  const x = arc()({\n    innerRadius: r,\n    outerRadius: r,\n    startAngle,\n    endAngle\n  });\n  const REGEX = /(-?\\d+\\.?\\d*,-?\\d+\\.?\\d*A-?\\d+\\.?\\d*,-?\\d+\\.?\\d*)/gm;\n  const matches = x.match(REGEX);\n  const start2 = (_b = (_a = matches == null ? void 0 : matches[0]) == null ? void 0 : _a.split(\"A\", 2)) == null ? void 0 : _b[0];\n  const end2 = (_d = (_c = matches == null ? void 0 : matches[1]) == null ? void 0 : _c.split(\"A\", 2)) == null ? void 0 : _d[0];\n  const d = x + \" M \".concat(start2, \" L 0,0 M \").concat(end2, \" L 0,0\");\n  return /* @__PURE__ */jsx(Fragment$1, {\n    children: isFullCircle ? /* @__PURE__ */jsx(\"circle\", {\n      fill: \"none\",\n      strokeDasharray: strokeDash,\n      stroke: strokeColor,\n      style: {\n        pointerEvents: \"none\"\n      },\n      cx: \"0\",\n      cy: \"0\",\n      r\n    }) : /* @__PURE__ */jsx(\"path\", {\n      d,\n      fill: \"none\",\n      strokeDasharray: strokeDash,\n      stroke: strokeColor,\n      style: {\n        pointerEvents: \"none\"\n      }\n    })\n  });\n};\nRadialAxisArc.defaultProps = {\n  stroke: \"#71808d\",\n  strokeDasharray: \"1,4\",\n  startAngle: 0,\n  endAngle: 2 * Math.PI\n};\nconst getPointsForLevels = _ref10 => {\n  let {\n    count,\n    outerRadius,\n    ticks,\n    arcs\n  } = _ref10;\n  const levels = [];\n  const polyangle = Math.PI * 2 / ticks;\n  for (const level of arcs) {\n    const hyp = level / count * outerRadius;\n    const points = [];\n    for (let vertex = 0; vertex < ticks; vertex++) {\n      const theta = vertex * polyangle;\n      points.push({\n        x: hyp * Math.sin(Math.PI - theta),\n        y: hyp * Math.cos(Math.PI - theta)\n      });\n    }\n    levels.push([...points, points[0]]);\n  }\n  return levels;\n};\nconst RadialAxisArcSeries = _ref11 => {\n  let {\n    count,\n    innerRadius,\n    outerRadius,\n    line: line2,\n    arc: arc2,\n    tickValues,\n    startAngle,\n    endAngle\n  } = _ref11;\n  const scale2 = scaleLinear().domain([0, count]).range([innerRadius, outerRadius]);\n  const arcs = scale2.ticks(count);\n  const points = getPointsForLevels({\n    count,\n    outerRadius,\n    ticks: tickValues.length,\n    arcs\n  });\n  return /* @__PURE__ */jsxs(Fragment$1, {\n    children: [line2 && /* @__PURE__ */jsx(Fragment$1, {\n      children: points.map((d, i) => /* @__PURE__ */jsx(CloneElement, {\n        element: line2,\n        data: d,\n        index: i\n      }, i))\n    }), arc2 && /* @__PURE__ */jsx(Fragment$1, {\n      children: arcs.map(d => /* @__PURE__ */jsx(CloneElement, {\n        element: arc2,\n        index: d,\n        scale: scale2,\n        startAngle,\n        endAngle\n      }, d))\n    })]\n  });\n};\nRadialAxisArcSeries.defaultProps = {\n  type: \"arc\",\n  count: 12,\n  arc: /* @__PURE__ */jsx(RadialAxisArc, {}),\n  startAngle: 0,\n  endAngle: 2 * Math.PI\n};\nconst RadialAxisArcLine = _ref12 => {\n  let {\n    data,\n    stroke,\n    index\n  } = _ref12;\n  const lineGenerator = line$1().x(d2 => d2.x).y(d2 => d2.y);\n  const d = lineGenerator(data);\n  const strokeColor = typeof stroke === \"string\" ? stroke : stroke(index);\n  return /* @__PURE__ */jsx(\"path\", {\n    d,\n    stroke: strokeColor,\n    fill: \"none\",\n    style: {\n      pointerEvents: \"none\"\n    }\n  });\n};\nRadialAxisArcLine.defaultProps = {\n  stroke: \"#71808d\"\n};\nconst humanFormatScale = new humanFormat.Scale({\n  k: 1e3,\n  M: 1e6,\n  B: 1e9\n});\nconst humanFormatMillionScale = new humanFormat.Scale({\n  M: 1,\n  B: 1e3,\n  T: 1e6\n});\nconst ONE_MILLION = 1e6;\nconst ONE_BILLION = 1e9;\nconst humanFormatBigInteger = bigInteger => {\n  if (bigInteger.greater(ONE_BILLION)) {\n    return humanFormat(bigInteger.divide(ONE_MILLION).toJSNumber(), {\n      scale: humanFormatMillionScale\n    });\n  }\n  return humanFormat(bigInteger.toJSNumber(), {\n    scale: humanFormatScale\n  });\n};\nconst bigIntegerToLocaleString = bigInteger => {\n  let i = 0;\n  let formattedString = \"\";\n  for (const c of bigInteger.toString().split(\"\").reverse()) {\n    if (i > 0 && i % 3 === 0) {\n      formattedString = \",\" + formattedString;\n    }\n    formattedString = c + formattedString;\n    i++;\n  }\n  return formattedString;\n};\nfunction parseMargins(margins) {\n  let top = 0;\n  let right = 0;\n  let bottom = 0;\n  let left = 0;\n  if (Array.isArray(margins)) {\n    if (margins.length === 2) {\n      top = margins[0];\n      bottom = margins[0];\n      left = margins[1];\n      right = margins[1];\n    } else if (margins.length === 4) {\n      top = margins[0];\n      right = margins[1];\n      bottom = margins[2];\n      left = margins[3];\n    }\n  } else if (margins !== void 0) {\n    top = margins;\n    right = margins;\n    bottom = margins;\n    left = margins;\n  }\n  return {\n    top,\n    right,\n    bottom,\n    left\n  };\n}\nfunction calculateMarginOffsets(height, width, margins) {\n  const {\n    left,\n    right,\n    bottom,\n    top\n  } = margins;\n  const newHeight = height - top - bottom;\n  const newWidth = width - left - right;\n  return {\n    height: newHeight,\n    width: newWidth\n  };\n}\nfunction getDimension(_ref13) {\n  let {\n    xOffset,\n    yOffset,\n    height,\n    width,\n    margins\n  } = _ref13;\n  const parsedMargins = parseMargins(margins);\n  const marginDims = calculateMarginOffsets(height, width, parsedMargins);\n  const chartWidth = marginDims.width - xOffset;\n  const chartHeight = marginDims.height - yOffset;\n  return {\n    xOffset,\n    yOffset,\n    height,\n    width,\n    chartWidth,\n    chartHeight,\n    xMargin: xOffset + parsedMargins.left,\n    yMargin: parsedMargins.top\n  };\n}\nfunction extent(data, attr) {\n  const accessor = (val, fn) => {\n    if (Array.isArray(val.data)) {\n      return fn(val.data, vv => vv[attr]);\n    }\n    return val[attr];\n  };\n  const minVal = min(data, d => accessor(d, min));\n  const maxVal = max(data, d => accessor(d, max));\n  return [minVal, maxVal];\n}\nfunction getYDomain(_ref14) {\n  let {\n    data,\n    scaled = false,\n    isDiverging = false\n  } = _ref14;\n  const [startY, endY] = extent(data, \"y\");\n  const [startY1, endY1] = extent(data, \"y1\");\n  if (startY < 0 || isDiverging) {\n    const posStart = -startY;\n    const maxNum = Math.max(posStart, endY);\n    return [-maxNum, maxNum];\n  }\n  if (scaled) {\n    return [startY1, endY1];\n  }\n  return [0, endY1];\n}\nfunction getXDomain(_ref15) {\n  let {\n    data,\n    scaled = false,\n    isDiverging = false\n  } = _ref15;\n  const startX0 = extent(data, \"x0\")[0];\n  const endX1 = extent(data, \"x1\")[1];\n  if (typeof startX0 === \"number\" && typeof endX1 === \"number\") {\n    if (startX0 < 0 || isDiverging) {\n      const posStart = -startX0;\n      const maxNum = Math.max(posStart, endX1);\n      return [-maxNum, maxNum];\n    }\n    if (!scaled) {\n      return [0, endX1];\n    }\n  }\n  return [startX0, endX1];\n}\nfunction interpolate(type) {\n  if (type === \"smooth\") {\n    return curveMonotoneX;\n  } else if (type === \"step\") {\n    return curveStep;\n  } else {\n    return curveLinear;\n  }\n}\nconst scaleBandInvert = function (scale2) {\n  let round = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  const domain = scale2.domain();\n  const paddingOuter = scale2(domain[0]);\n  const eachBand = scale2.step();\n  const [, end2] = scale2.range();\n  return offset => {\n    let band = Math.min((offset - paddingOuter) / eachBand, domain.length - 0.01);\n    if (band < 0 && Math.abs(band) > domain.length - 1) {\n      band = Math.floor(Math.abs(band)) * -1;\n    }\n    let index = round ? Math.round(band) % domain.length : Math.floor(band) % domain.length;\n    if (end2 === 0) {\n      index = index * -1;\n    }\n    return domain[Math.max(0, Math.min(index, domain.length - 1))];\n  };\n};\nconst getClosestContinousScalePoint = _ref16 => {\n  let {\n    pos,\n    scale: scale2,\n    data,\n    attr = \"x\",\n    roundDown = false\n  } = _ref16;\n  const domain = scale2.invert(pos);\n  const bisect = bisector(d => {\n    return attr === \"i\" ? d[attr] + 1 : d[attr];\n  }).right;\n  const index = bisect(data, domain);\n  const minIndex = Math.max(0, index - 1);\n  const before = data[minIndex];\n  if (roundDown) {\n    return before;\n  }\n  const maxIndex2 = Math.min(data.length - 1, index);\n  const after = data[maxIndex2];\n  let beforeVal = before[attr];\n  let afterVal = after[attr];\n  beforeVal = domain - beforeVal;\n  afterVal = afterVal - domain;\n  return beforeVal < afterVal ? before : after;\n};\nconst getClosestBandScalePoint = _ref17 => {\n  let {\n    pos,\n    scale: scale2,\n    data,\n    roundClosest = false\n  } = _ref17;\n  const domain = scale2.domain();\n  let prop;\n  if (scale2.mariemkoInvert) {\n    prop = scale2.mariemkoInvert(pos);\n  } else {\n    prop = scaleBandInvert(scale2, roundClosest)(pos);\n  }\n  const idx = domain.indexOf(prop);\n  return data[idx];\n};\nconst getParentSVG = event => {\n  let node2 = event.target.ownerSVGElement;\n  if (node2) {\n    while (node2.ownerSVGElement) {\n      node2 = node2.ownerSVGElement;\n    }\n  }\n  return node2;\n};\nconst getPositionForTarget = _ref18 => {\n  let {\n    target,\n    clientX,\n    clientY\n  } = _ref18;\n  const rect = target.getBoundingClientRect();\n  return {\n    x: clientX - ((rect == null ? void 0 : rect.left) || 0) - target.clientLeft,\n    y: clientY - ((rect == null ? void 0 : rect.top) || 0) - target.clientTop\n  };\n};\nconst getPointFromMatrix = (event, matrix) => {\n  const parent = getParentSVG(event);\n  if (!parent) {\n    return null;\n  }\n  const {\n    top,\n    left\n  } = parent.getBoundingClientRect();\n  const x = event.clientX - left;\n  const y = event.clientY - top;\n  return applyToPoint(inverse(matrix), {\n    x,\n    y\n  });\n};\nconst getLimitMatrix = (height, width, matrix) => applyToPoints(matrix, [{\n  x: 0,\n  y: 0\n}, {\n  x: width,\n  y: height\n}]);\nconst constrainMatrix = (height, width, matrix) => {\n  const [min2, max2] = getLimitMatrix(height, width, matrix);\n  if (max2.x < width || max2.y < height) {\n    return true;\n  }\n  if (min2.x > 0 || min2.y > 0) {\n    return true;\n  }\n  return false;\n};\nconst lessThanScaleFactorMin = (value2, scaleFactor) => value2.scaleFactorMin && value2.d * scaleFactor <= value2.scaleFactorMin;\nconst moreThanScaleFactorMax = (value2, scaleFactor) => value2.scaleFactorMax && value2.d * scaleFactor >= value2.scaleFactorMax;\nconst isZoomLevelGoingOutOfBounds = (value2, scaleFactor) => {\n  const a = lessThanScaleFactorMin(value2, scaleFactor) && scaleFactor < 1;\n  const b = moreThanScaleFactorMax(value2, scaleFactor) && scaleFactor > 1;\n  return a || b;\n};\nfunction toggleTextSelection(allowSelection) {\n  const style = allowSelection ? \"\" : \"none\";\n  [\"-webkit-touch-callout\", \"-webkit-user-select\", \"-khtml-user-select\", \"-moz-user-select\", \"-ms-user-select\", \"user-select\"].forEach(prop => document.body.style[prop] = style);\n}\nfunction calculateShowStroke(current, data) {\n  const i = data.indexOf(current);\n  let showLine = false;\n  const prev = data[i - 1];\n  if (i > 0 && prev.y) {\n    showLine = true;\n  }\n  const cur = data[i];\n  if (cur.y) {\n    showLine = true;\n  }\n  const next = data[i + 1];\n  if (i < data.length - 1 && next.y) {\n    showLine = true;\n  }\n  return showLine;\n}\nconst getDegrees = radians => radians / Math.PI * 180 - 90;\nconst functionProps = (prop, val, data) => {\n  if (typeof val === \"function\") {\n    return val(data);\n  } else if (prop === \"className\") {\n    return classNames(val);\n  } else if (val !== void 0 || val !== null) {\n    return val;\n  }\n  return {};\n};\nconst constructFunctionProps = (props, data) => ({\n  className: functionProps(\"className\", props.className, data),\n  style: functionProps(\"style\", props.style, data)\n});\nfunction uniqueBy(data) {\n  for (var _len = arguments.length, accessors = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    accessors[_key - 1] = arguments[_key];\n  }\n  const result = [];\n  const ittr = (arr, depth) => {\n    for (const a of arr) {\n      const acc = accessors[depth];\n      if (acc === void 0) {\n        throw new Error(\"Accessor not found for depth: \".concat(depth));\n      }\n      const val = acc(a);\n      if (Array.isArray(val)) {\n        ittr(val, depth + 1);\n      } else if (!result.includes(val)) {\n        result.push(val);\n      }\n    }\n  };\n  ittr(data, 0);\n  return result;\n}\nfunction wrapText(_ref19) {\n  let {\n    key,\n    x = 0,\n    size,\n    paddingY,\n    wrap = true,\n    paddingX,\n    width,\n    height,\n    fontFamily,\n    fontSize,\n    visibility = \"auto\"\n  } = _ref19;\n  size = size || calculateDimensions(key, fontFamily, fontSize);\n  const words = key.toString().split(/\\s+/);\n  if (words.length > 1 && size.width > width) {\n    let rows = [];\n    let maxWidth = 0;\n    let maxHeight = 0;\n    let curText = \"\";\n    let currWidth = 0;\n    let nextText = \"\";\n    let nextWidth = 0;\n    for (const word of words) {\n      nextText = curText === \"\" ? word : \"\".concat(curText, \" \").concat(word);\n      nextWidth = calculateDimensions(nextText, fontFamily, fontSize).width;\n      if (nextWidth <= width - (paddingX ? 2 * paddingX : 0)) {\n        curText = nextText;\n        currWidth = nextWidth;\n      } else {\n        rows.push(curText);\n        maxWidth = Math.max(maxWidth, currWidth);\n        curText = word;\n        currWidth = calculateDimensions(curText, fontFamily, fontSize).width;\n      }\n    }\n    rows.push(curText);\n    maxHeight = rows.length * size.height;\n    if (visibility !== \"always\") {\n      if (height && maxHeight >= height - (paddingY ? 2 * paddingY : 0)) {\n        return null;\n      }\n      if (width && maxWidth >= width - (paddingX ? 2 * paddingX : 0)) {\n        return null;\n      }\n    }\n    if (!wrap && rows.length > 1) {\n      return rows[0];\n    }\n    return rows.map((r, i) => /* @__PURE__ */jsx(\"tspan\", {\n      dominantBaseline: \"alphabetic\",\n      style: {\n        baselineShift: \"0%\"\n      },\n      dy: i > 0 ? size.height : height ? size.height / 2 - 5 : -maxHeight / 2 + size.height,\n      x,\n      children: r\n    }, i));\n  }\n  if (visibility !== \"always\") {\n    if (height && size.height + paddingY >= height) {\n      return null;\n    }\n    if (width && size.width + paddingX >= width) {\n      return null;\n    }\n  }\n  return /* @__PURE__ */jsx(\"tspan\", {\n    dominantBaseline: \"alphabetic\",\n    style: {\n      baselineShift: \"0%\"\n    },\n    dy: size.height / 2 - 5,\n    x,\n    children: key\n  });\n}\nconst RadialAxis = _ref20 => {\n  let {\n    arcs,\n    ticks,\n    xScale,\n    height,\n    width,\n    innerRadius,\n    type,\n    startAngle,\n    endAngle\n  } = _ref20;\n  const outerRadius = Math.min(height, width) / 2;\n  const tickValues = getTicks(xScale, ticks.props.tickValues, type, ticks.props.count, ticks.props.interval || ticks.props.count);\n  return /* @__PURE__ */jsxs(Fragment, {\n    children: [arcs && /* @__PURE__ */jsx(CloneElement, {\n      element: arcs,\n      outerRadius,\n      innerRadius,\n      tickValues,\n      startAngle,\n      endAngle\n    }), ticks && /* @__PURE__ */jsx(CloneElement, {\n      element: ticks,\n      scale: xScale,\n      type,\n      innerRadius,\n      outerRadius,\n      startAngle,\n      endAngle\n    })]\n  });\n};\nRadialAxis.defaultProps = {\n  innerRadius: 10,\n  type: \"value\",\n  arcs: /* @__PURE__ */jsx(RadialAxisArcSeries, {}),\n  ticks: /* @__PURE__ */jsx(RadialAxisTickSeries, {}),\n  startAngle: 0,\n  endAngle: 2 * Math.PI\n};\nconst Move = props => {\n  let started = false;\n  let deltaX = 0;\n  let deltaY = 0;\n  let prevXPosition = 0;\n  let prevYPosition = 0;\n  const rqf = useRef();\n  useEffect(() => {\n    return () => {\n      cancelAnimationFrame(rqf.current);\n      disposeHandlers();\n    };\n  }, []);\n  const disposeHandlers = () => {\n    window.removeEventListener(\"mousemove\", onMouseMove);\n    window.removeEventListener(\"mouseup\", onMouseUp);\n    window.removeEventListener(\"touchmove\", onTouchMove);\n    window.removeEventListener(\"touchend\", onTouchEnd);\n    setCursor(false);\n    disableText(true);\n  };\n  const disableText = shouldDisable => {\n    if (props.disableText) {\n      toggleTextSelection(shouldDisable);\n    }\n  };\n  const setCursor = set => {\n    let {\n      cursor\n    } = props;\n    if (cursor) {\n      if (!set) {\n        cursor = \"inherit\";\n      }\n      document.body.style[\"cursor\"] = cursor;\n    }\n  };\n  const checkThreshold = () => {\n    const {\n      threshold\n    } = props;\n    return !started && (Math.abs(deltaX) > threshold || Math.abs(deltaY) > threshold);\n  };\n  const getTouchCoords = event => {\n    const {\n      clientX,\n      clientY\n    } = event.touches[0];\n    return {\n      clientX,\n      clientY\n    };\n  };\n  const onMouseDown = event => {\n    const {\n      preventRightClick,\n      disabled\n    } = props;\n    const shouldCancel = event.nativeEvent.which === 3 && preventRightClick;\n    if (shouldCancel || disabled) {\n      return;\n    }\n    event.preventDefault();\n    event.stopPropagation();\n    started = false;\n    window.addEventListener(\"mousemove\", onMouseMove);\n    window.addEventListener(\"mouseup\", onMouseUp);\n  };\n  const onMouseMove = event => {\n    event.preventDefault();\n    event.stopPropagation();\n    const {\n      movementX,\n      movementY\n    } = event;\n    let localDeltaX = deltaX + movementX;\n    let localDeltaY = deltaY + movementY;\n    if (checkThreshold()) {\n      disableText(true);\n      setCursor(true);\n      localDeltaX = 0;\n      localDeltaY = 0;\n      started = true;\n      props.onMoveStart({\n        nativeEvent: event,\n        type: \"mouse\"\n      });\n    } else {\n      rqf.current = requestAnimationFrame(() => {\n        props.onMove({\n          nativeEvent: event,\n          type: \"mouse\",\n          x: localDeltaX,\n          y: localDeltaY\n        });\n      });\n    }\n    deltaX = localDeltaX;\n    deltaY = localDeltaY;\n  };\n  const onMouseUp = event => {\n    event.preventDefault();\n    event.stopPropagation();\n    disposeHandlers();\n    if (started) {\n      props.onMoveEnd({\n        nativeEvent: event,\n        type: \"mouse\"\n      });\n    } else {\n      props.onMoveCancel({\n        nativeEvent: event,\n        type: \"mouse\"\n      });\n    }\n  };\n  const onTouchStart = event => {\n    const {\n      disabled\n    } = props;\n    if (disabled || event.touches.length !== 1) {\n      return;\n    }\n    event.preventDefault();\n    event.stopPropagation();\n    started = false;\n    prevXPosition = event.touches[0].clientX;\n    prevYPosition = event.touches[0].clientY;\n    window.addEventListener(\"touchmove\", onTouchMove);\n    window.addEventListener(\"touchend\", onTouchEnd);\n  };\n  const onTouchMove = event => {\n    event.preventDefault();\n    event.stopPropagation();\n    const {\n      clientX,\n      clientY\n    } = getTouchCoords(event);\n    let localDeltaX = clientX - prevXPosition;\n    let localDeltaY = clientY - prevYPosition;\n    localDeltaX = localDeltaX + localDeltaX;\n    localDeltaY = localDeltaY + localDeltaY;\n    if (checkThreshold()) {\n      disableText(true);\n      setCursor(true);\n      localDeltaX = 0;\n      localDeltaY = 0;\n      started = true;\n      props.onMoveStart({\n        // TODO: Come back and clean this up...\n        nativeEvent: {\n          ...event,\n          clientX,\n          clientY\n        },\n        type: \"touch\"\n      });\n    } else {\n      rqf.current = requestAnimationFrame(() => {\n        props.onMove({\n          // TODO: Come back and clean this up...\n          nativeEvent: {\n            ...event,\n            clientX,\n            clientY\n          },\n          type: \"touch\",\n          x: localDeltaX,\n          y: localDeltaY\n        });\n      });\n    }\n    prevXPosition = clientX;\n    prevYPosition = clientY;\n  };\n  const onTouchEnd = event => {\n    event.preventDefault();\n    event.stopPropagation();\n    disposeHandlers();\n    if (started) {\n      props.onMoveEnd({\n        nativeEvent: event,\n        type: \"touch\"\n      });\n    } else {\n      props.onMoveCancel({\n        nativeEvent: event,\n        type: \"touch\"\n      });\n    }\n  };\n  return Children.map(props.children, child => cloneElement(child, {\n    ...child.props,\n    onMouseDown: e => {\n      onMouseDown(e);\n      if (child.props.onMouseDown) {\n        child.props.onMouseDown(e);\n      }\n    },\n    onTouchStart: e => {\n      onTouchStart(e);\n      if (child.props.onTouchStart) {\n        child.props.onTouchStart(e);\n      }\n    }\n  }));\n};\nMove.defaultProps = {\n  preventRightClick: true,\n  disableText: true,\n  threshold: 0,\n  onMoveStart: () => void 0,\n  onMove: () => void 0,\n  onMoveEnd: () => void 0,\n  onMoveCancel: () => void 0\n};\nconst handle = \"_handle_bk7m7_1\";\nconst dragging = \"_dragging_bk7m7_6\";\nconst dot = \"_dot_bk7m7_10\";\nconst line = \"_line_bk7m7_14\";\nconst css$s = {\n  handle,\n  dragging,\n  dot,\n  line\n};\nconst BrushHandle = props => {\n  const {\n    height,\n    onHandleDrag\n  } = props;\n  const [isDragging, setIsDragging] = useState(false);\n  return /* @__PURE__ */jsx(Move, {\n    cursor: \"ew-resize\",\n    onMoveStart: () => setIsDragging(true),\n    onMove: _ref21 => {\n      let {\n        x\n      } = _ref21;\n      return onHandleDrag(x);\n    },\n    onMoveEnd: () => setIsDragging(false),\n    children: /* @__PURE__ */jsxs(\"g\", {\n      children: [/* @__PURE__ */jsx(\"line\", {\n        className: css$s.line,\n        y1: \"0\",\n        y2: height,\n        x1: \"5\",\n        x2: \"5\"\n      }), /* @__PURE__ */jsx(\"rect\", {\n        className: classNames(css$s.handle, {\n          [css$s.dragging]: isDragging\n        }),\n        height: height - 10,\n        style: {\n          cursor: \"ew-resize\"\n        },\n        width: 8,\n        y: \"5\",\n        y1: height - 5\n      }), /* @__PURE__ */jsx(\"g\", {\n        transform: \"translate(-1, \".concat(height / 2 - 10, \")\"),\n        style: {\n          pointerEvents: \"none\"\n        },\n        children: range(5).map(i => /* @__PURE__ */jsx(\"circle\", {\n          cy: i * 5,\n          cx: \"5\",\n          r: \".5\",\n          className: css$s.dot\n        }, i))\n      })]\n    })\n  });\n};\nBrushHandle.defaultProps = {};\nconst slice = \"_slice_1knu8_1\";\nconst unsliced = \"_unsliced_1knu8_5\";\nconst css$r = {\n  slice,\n  unsliced\n};\nconst BrushSlice = props => {\n  const {\n    height,\n    start: start2,\n    end: end2,\n    width,\n    onBrushChange\n  } = props;\n  const [isDragging, setIsDragging] = useState(false);\n  const sliceWidth = Math.max(end2 - start2, 0);\n  const endSliceWidth = Math.max(width - end2, 0);\n  const hasNoSlice = start2 === 0 && end2 === width;\n  const onMoveStart = useCallback(() => {\n    const hasNoSlice2 = start2 === 0 && end2 === width;\n    if (!hasNoSlice2) {\n      setIsDragging(true);\n    }\n  }, [end2, start2, width]);\n  const onMove = useCallback(_ref22 => {\n    let {\n      x\n    } = _ref22;\n    const startUpdated = start2 + x;\n    const endUpdated = end2 + x;\n    if (startUpdated >= 0 && endUpdated <= width) {\n      onBrushChange({\n        start: startUpdated,\n        end: endUpdated\n      });\n    }\n  }, [start2, end2, width, onBrushChange]);\n  const onHandleDrag = useCallback((direction, deltaX) => {\n    const startUpdated = direction === \"start\" ? start2 + deltaX : start2;\n    const endUpdated = direction !== \"start\" ? end2 + deltaX : end2;\n    onBrushChange({\n      start: startUpdated,\n      end: endUpdated\n    });\n  }, [end2, onBrushChange, start2]);\n  return /* @__PURE__ */jsxs(Fragment, {\n    children: [/* @__PURE__ */jsx(\"rect\", {\n      className: css$r.unsliced,\n      height,\n      width: start2\n    }), /* @__PURE__ */jsx(\"rect\", {\n      transform: \"translate(\".concat(end2, \", 0)\"),\n      className: css$r.unsliced,\n      height,\n      width: endSliceWidth\n    }), /* @__PURE__ */jsxs(\"g\", {\n      transform: \"translate(\".concat(start2, \", 0)\"),\n      children: [/* @__PURE__ */jsx(Move, {\n        cursor: \"grabbing\",\n        onMoveStart,\n        onMove,\n        onMoveEnd: () => setIsDragging(false),\n        children: /* @__PURE__ */jsx(\"rect\", {\n          className: css$r.slice,\n          height,\n          width: sliceWidth,\n          style: {\n            cursor: isDragging ? \"grabbing\" : \"grab\",\n            opacity: hasNoSlice ? 0 : 0.1,\n            pointerEvents: !hasNoSlice ? \"initial\" : \"none\"\n          }\n        })\n      }), /* @__PURE__ */jsx(\"g\", {\n        transform: \"translate(-4, 0)\",\n        children: /* @__PURE__ */jsx(BrushHandle, {\n          height,\n          onHandleDrag: deltaX => onHandleDrag(\"start\", deltaX)\n        })\n      }), /* @__PURE__ */jsx(\"g\", {\n        transform: \"translate(\".concat(sliceWidth - 5, \", 0)\"),\n        children: /* @__PURE__ */jsx(BrushHandle, {\n          height,\n          onHandleDrag: deltaX => onHandleDrag(\"end\", deltaX)\n        })\n      })]\n    })]\n  });\n};\nBrushSlice.defaultProps = {};\nconst Brush = props => {\n  const {\n    children,\n    disabled,\n    height,\n    width,\n    start: startProp,\n    end: endProp,\n    onBrushChange\n  } = props;\n  const [isSlicing, setIsSlicing] = useState(false);\n  const [initial, setInitial] = useState();\n  const [range2, setRange] = useState({\n    start: props.start || 0,\n    end: props.end || props.width\n  });\n  const {\n    start: start2,\n    end: end2\n  } = range2;\n  const ref = useRef();\n  const ensurePositionInBounds = useCallback((newStart, newEnd) => {\n    let startUpdated = newStart;\n    let endUpdated = newEnd;\n    if (startUpdated === void 0 || startUpdated <= 0) {\n      startUpdated = 0;\n    }\n    if (end2 === void 0) {\n      endUpdated = width;\n    }\n    if (startUpdated > endUpdated) {\n      startUpdated = start2;\n    }\n    if (endUpdated < startUpdated) {\n      endUpdated = end2;\n    }\n    if (endUpdated >= width) {\n      endUpdated = width;\n    }\n    return {\n      start: startUpdated,\n      end: endUpdated\n    };\n  }, [end2, start2, width]);\n  const getPositionsForPanEvent = useCallback(event => {\n    const eventObj = {\n      target: ref.current,\n      clientX: event.clientX,\n      clientY: event.clientY\n    };\n    return getPositionForTarget(eventObj);\n  }, []);\n  const getStartEnd = useCallback(event => {\n    const {\n      x\n    } = getPositionsForPanEvent(event);\n    if (x < initial) {\n      return ensurePositionInBounds(x, initial);\n    } else {\n      return ensurePositionInBounds(initial, x);\n    }\n  }, [ensurePositionInBounds, getPositionsForPanEvent, initial]);\n  const onMoveStart = useCallback(event => {\n    if (!disabled) {\n      const positions = getPositionsForPanEvent(event.nativeEvent);\n      setIsSlicing(true);\n      setInitial(positions.x);\n    }\n  }, [disabled, getPositionsForPanEvent]);\n  const onMove = useCallback(event => {\n    if (!disabled) {\n      const {\n        start: start22,\n        end: end22\n      } = getStartEnd(event.nativeEvent);\n      if (onBrushChange) {\n        onBrushChange({\n          start: start22,\n          end: end22\n        });\n      }\n      setRange({\n        start: start22,\n        end: end22\n      });\n    }\n  }, [disabled, getStartEnd, onBrushChange]);\n  const onMoveEnd = useCallback(() => {\n    setIsSlicing(false);\n  }, []);\n  const onMoveCancel = useCallback(() => {\n    const val = {\n      start: 0,\n      end: width\n    };\n    setRange(val);\n    if (onBrushChange) {\n      onBrushChange(val);\n    }\n  }, [onBrushChange, width]);\n  const onSliceChange = useCallback(event => {\n    const val = ensurePositionInBounds(event.start, event.end);\n    setRange(state => ({\n      ...state,\n      ...val\n    }));\n    if (onBrushChange) {\n      onBrushChange(val);\n    }\n  }, [ensurePositionInBounds, onBrushChange]);\n  useEffect(() => {\n    if (end2 === width) {\n      setRange(prev => ({\n        ...prev,\n        end: width\n      }));\n    }\n  }, [end2, width]);\n  useEffect(() => {\n    if (!isSlicing) {\n      const startUpdated = startProp !== start2;\n      const endUpdated = endProp !== end2;\n      if (startUpdated || endUpdated) {\n        setRange(ensurePositionInBounds(start2, end2));\n      }\n    }\n  }, [end2, endProp, ensurePositionInBounds, isSlicing, start2, startProp]);\n  return /* @__PURE__ */jsx(Move, {\n    cursor: \"crosshair\",\n    onMoveStart: bind(onMoveStart, void 0),\n    onMove: bind(onMove, void 0),\n    onMoveEnd: bind(onMoveEnd, void 0),\n    onMoveCancel: bind(onMoveCancel, void 0),\n    children: /* @__PURE__ */jsxs(\"g\", {\n      style: {\n        pointerEvents: isSlicing ? \"none\" : \"auto\",\n        cursor: disabled ? \"\" : \"crosshair\"\n      },\n      children: [children, !disabled && /* @__PURE__ */jsxs(Fragment$1, {\n        children: [/* @__PURE__ */jsx(\"rect\", {\n          ref,\n          height,\n          width,\n          opacity: 0\n        }), start2 !== void 0 && end2 !== void 0 && /* @__PURE__ */jsx(BrushSlice, {\n          start: start2,\n          end: end2,\n          height,\n          width,\n          onBrushChange: bind(onSliceChange, void 0)\n        })]\n      })]\n    })\n  });\n};\nconst ChartBrush = props => {\n  const {\n    disabled,\n    domain,\n    scale: scale2,\n    onBrushChange,\n    width,\n    children\n  } = props;\n  const getBrushOffset = useCallback(() => {\n    let start2;\n    let end2;\n    if (!disabled && domain) {\n      start2 = scale2(domain[0]);\n      end2 = scale2(domain[1]);\n    }\n    return {\n      start: start2,\n      end: end2\n    };\n  }, [disabled, domain, scale2]);\n  const onBrushChangeHandler = useCallback(event => {\n    if (onBrushChange) {\n      let domain2;\n      if (event.start !== void 0 && event.end !== void 0 && (event.start !== 0 || event.end !== width)) {\n        if (scale2.invert) {\n          const start2 = scale2.invert(event.start);\n          const end2 = scale2.invert(event.end);\n          domain2 = [start2, end2];\n        } else {\n          const band = scale2.step();\n          const start2 = Math.ceil((event.start - band / 2) / band);\n          const end2 = Math.ceil((event.end - band / 2) / band);\n          domain2 = [scale2.domain()[start2], scale2.domain()[end2]];\n        }\n      }\n      onBrushChange({\n        domain: domain2\n      });\n    }\n  }, [onBrushChange, scale2, width]);\n  return /* @__PURE__ */jsx(Brush, {\n    ...props,\n    ...getBrushOffset(),\n    onBrushChange: onBrushChangeHandler,\n    children\n  });\n};\nChartBrush.defaultProps = {};\nconst ChartContext = createContext({});\nconst {\n  Provider: ChartProvider,\n  Consumer: ChartConsumer\n} = ChartContext;\nconst useChart = () => {\n  const context = useContext(ChartContext);\n  if (context === void 0) {\n    throw new Error(\"`useChart` hook must be used within a `ChartProvider`\");\n  }\n  return context;\n};\nconst container$3 = \"_container_1u3dt_1\";\nconst svg = \"_svg_1u3dt_30\";\nconst css$q = {\n  container: container$3,\n  svg\n};\nconst ChartContainer = _ref23 => {\n  let {\n    className,\n    children,\n    center,\n    centerX,\n    centerY,\n    style,\n    margins,\n    containerClassName,\n    xAxisVisible,\n    yAxisVisible,\n    id,\n    ...rest\n  } = _ref23;\n  const curId = useId(id);\n  const [xAxisSized, setXAxisSized] = useState(false);\n  const [yAxisSized, setYAxisSized] = useState(false);\n  const [xOffset, setXOffset] = useState(0);\n  const [yOffset, setYOffset] = useState(0);\n  const {\n    observe,\n    width,\n    height\n  } = useDimensions();\n  const chartSized = useMemo(() => {\n    if (!height || !width) {\n      return false;\n    }\n    if (xAxisVisible && !xAxisSized) {\n      return false;\n    }\n    if (yAxisVisible && !yAxisSized) {\n      return false;\n    }\n    return true;\n  }, [height, width, xAxisSized, xAxisVisible, yAxisVisible, yAxisSized]);\n  const onUpdateAxes = useCallback((orientation, event) => {\n    if (orientation === \"horizontal\") {\n      setXAxisSized(true);\n    } else {\n      setYAxisSized(true);\n    }\n    if (event.height) {\n      setYOffset(event.height);\n    }\n    if (event.width) {\n      setXOffset(event.width);\n    }\n  }, []);\n  const childProps = useMemo(() => ({\n    chartSized,\n    id: curId,\n    updateAxes: onUpdateAxes,\n    yAxisSized,\n    xAxisSized,\n    ...getDimension({\n      margins,\n      height,\n      width,\n      yOffset,\n      xOffset\n    })\n  }), [chartSized, curId, onUpdateAxes, yAxisSized, xAxisSized, margins, height, width, yOffset, xOffset]);\n  const translateX = center || centerX ? width / 2 : childProps.xMargin;\n  const translateY = center || centerY ? height / 2 : childProps.yMargin;\n  const styleHeight = rest.height !== void 0 && rest.height !== null ? rest.height : \"100%\";\n  const styleWidth = rest.width !== void 0 && rest.width !== null ? rest.width : \"100%\";\n  return /* @__PURE__ */jsx(\"div\", {\n    ref: observe,\n    style: {\n      height: styleHeight,\n      width: styleWidth\n    },\n    className: classNames(containerClassName, css$q.container),\n    ...rest,\n    children: /* @__PURE__ */jsx(ChartProvider, {\n      value: childProps,\n      children: height > 0 && width > 0 && /* @__PURE__ */jsx(\"svg\", {\n        width,\n        height,\n        className: classNames(css$q.svg, className),\n        style,\n        tabIndex: 0,\n        children: /* @__PURE__ */jsx(\"g\", {\n          transform: \"translate(\".concat(translateX, \", \").concat(translateY, \")\"),\n          children: children(childProps)\n        })\n      })\n    })\n  });\n};\nfunction normalizeValue(value2, maxBigInt) {\n  if (bigInt.isInstance(value2)) {\n    if (maxBigInt.greater(1e6)) {\n      const divideBy = maxBigInt.divide(1e6);\n      return value2.divide(divideBy).toJSNumber();\n    } else {\n      return value2.toJSNumber();\n    }\n  } else {\n    return value2;\n  }\n}\nfunction normalizeValueForFormatting(value2) {\n  if (bigInt.isInstance(value2)) {\n    return bigIntegerToLocaleString(value2);\n  }\n  return value2;\n}\nfunction getMaxBigIntegerForNested(series) {\n  let maxBigInteger = bigInt.one;\n  for (const group of series) {\n    const maxBigIntegerForGroup = getMaxBigIntegerForShallow(group.data);\n    if (maxBigIntegerForGroup.greater(maxBigInteger)) {\n      maxBigInteger = maxBigIntegerForGroup;\n    }\n  }\n  return maxBigInteger;\n}\nfunction getMaxBigIntegerForShallow(series) {\n  let maxBigInteger = bigInt.one;\n  for (const point2 of series) {\n    if (bigInt.isInstance(point2.data)) {\n      const bigInteger = point2.data;\n      if (bigInteger.greater(maxBigInteger)) {\n        maxBigInteger = bigInteger;\n      }\n    }\n  }\n  return maxBigInteger;\n}\nfunction buildNestedChartData(series) {\n  let sort = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  let direction = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"vertical\";\n  let result = [];\n  const maxBigInteger = getMaxBigIntegerForNested(series);\n  const isVertical = direction === \"vertical\";\n  for (const point2 of series) {\n    for (const nestedPoint of point2.data) {\n      const key = normalizeValueForFormatting(point2.key);\n      let idx = result.findIndex(r => {\n        const left = r.key;\n        if (left instanceof Date && key instanceof Date) {\n          return left.getTime() === key.getTime();\n        }\n        return left === key;\n      });\n      if (idx === -1) {\n        result.push({\n          key,\n          metadata: point2.metadata,\n          data: []\n        });\n        idx = result.length - 1;\n      }\n      const x = normalizeValue(isVertical ? nestedPoint.key : nestedPoint.data, maxBigInteger);\n      const y = normalizeValue(isVertical ? nestedPoint.data : nestedPoint.key, maxBigInteger);\n      result[idx].data.push({\n        key,\n        value: normalizeValueForFormatting(nestedPoint.data),\n        metadata: nestedPoint.metadata,\n        id: point2.id,\n        x,\n        x0: isVertical ? x : 0,\n        x1: x,\n        y,\n        y0: isVertical ? 0 : y,\n        y1: y\n      });\n    }\n  }\n  if (sort) {\n    result = result.sort((a, b) => {\n      const aMax = median(a.data, d => d.y);\n      const bMax = median(b.data, d => d.y);\n      return aMax < bMax ? 1 : -1;\n    });\n  }\n  return result;\n}\nfunction addToChartType(a, b) {\n  if (bigInt.isInstance(a) && bigInt.isInstance(b)) {\n    return a.add(b);\n  } else if (a instanceof Date && typeof b === \"number\") {\n    return new Date(a.valueOf() + b);\n  } else if (typeof a === \"number\" && typeof b === \"number\") {\n    return a + b;\n  } else {\n    throw new Error(\"Invalid types to addToChartTypes\");\n  }\n}\nfunction buildShallowChartData(series) {\n  let direction = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"vertical\";\n  let binSize = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : void 0;\n  const result = [];\n  const maxBigInteger = getMaxBigIntegerForShallow(series);\n  const isVertical = direction === \"vertical\";\n  for (const point2 of series) {\n    const isTuple = Array.isArray(point2.data);\n    let k1 = point2.key;\n    if (binSize) {\n      k1 = addToChartType(point2.key, binSize);\n    }\n    const props = {\n      k0: normalizeValue(point2.key, maxBigInteger),\n      k1: normalizeValue(k1, maxBigInteger),\n      v0: normalizeValue(isTuple ? point2.data[0] : 0, maxBigInteger),\n      v1: normalizeValue(isTuple ? point2.data[1] : point2.data, maxBigInteger)\n    };\n    const xProp = isVertical ? \"k\" : \"v\";\n    const yProp = isVertical ? \"v\" : \"k\";\n    result.push({\n      key: normalizeValueForFormatting(props.k0),\n      value: normalizeValueForFormatting(props.v1),\n      metadata: point2.metadata,\n      id: point2.id,\n      x: props[\"\".concat(xProp, \"1\")],\n      x0: props[\"\".concat(xProp, \"0\")],\n      x1: props[\"\".concat(xProp, \"1\")],\n      y: props[\"\".concat(yProp, \"1\")],\n      y0: props[\"\".concat(yProp, \"0\")],\n      y1: props[\"\".concat(yProp, \"1\")]\n    });\n  }\n  return result;\n}\nfunction buildBins(xScale, thresholds, data) {\n  const layout2 = histogram().value(d => d.x).domain(xScale.domain()).thresholds(xScale.ticks(thresholds));\n  const bins = layout2(data);\n  return bins.map(bin => ({\n    x0: bin.x0,\n    x1: bin.x1,\n    y: bin.length,\n    y0: 0,\n    y1: bin.length\n  }));\n}\nfunction transformDataToStack$1(data) {\n  const result = [];\n  const maxBigInteger = getMaxBigIntegerForNested(data);\n  for (const category of data) {\n    for (const value2 of category.data) {\n      let idx = result.findIndex(r => {\n        if (r.x instanceof Date && category.key instanceof Date) {\n          return r.x.getTime() === category.key.getTime();\n        }\n        return r.x === category.key;\n      });\n      if (idx === -1) {\n        result.push({\n          metadata: category.metadata,\n          x: category.key,\n          formattedValues: {}\n        });\n        idx = result.length - 1;\n      }\n      result[idx].metadata = value2.metadata;\n      result[idx][value2.key] = normalizeValue(value2.data, maxBigInteger);\n      result[idx].formattedValues[value2.key] = normalizeValueForFormatting(value2.data);\n    }\n  }\n  return result;\n}\nfunction transformStackToData$1(stackData) {\n  let direction = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"vertical\";\n  const result = [];\n  const isVertical = direction === \"vertical\";\n  for (const category of stackData) {\n    for (const point2 of category) {\n      const key = point2.data.x;\n      let idx = result.findIndex(r => {\n        if (r.key instanceof Date && key instanceof Date) {\n          return r.key.getTime() === key.getTime();\n        }\n        return r.key === key;\n      });\n      if (idx === -1) {\n        result.push({\n          key,\n          data: []\n        });\n        idx = result.length - 1;\n      }\n      const categoryKey = category.key;\n      const y = point2.data[categoryKey];\n      const [y0, y1] = point2;\n      result[idx].data.push({\n        metadata: point2.data.metadata,\n        key,\n        x: isVertical ? categoryKey : y1,\n        x0: isVertical ? categoryKey : y0,\n        x1: isVertical ? categoryKey : y1,\n        y: isVertical ? y : categoryKey,\n        y0: isVertical ? y0 : categoryKey,\n        y1: isVertical ? y1 : categoryKey,\n        value: point2.data.formattedValues[categoryKey]\n      });\n    }\n  }\n  return result;\n}\nfunction buildBarStackData() {\n  let data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  let offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"default\";\n  let direction = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"vertical\";\n  const keys = uniqueBy(data, d => d.data, d => d.key);\n  const stackData = transformDataToStack$1(data);\n  let stackFn = stack();\n  if (offset === \"expand\") {\n    stackFn = stackFn.offset(stackOffsetExpand);\n  } else if (offset === \"diverging\") {\n    stackFn = stackFn.offset(stackOffsetDiverging);\n  }\n  const result = stackFn.keys(keys)(stackData);\n  return transformStackToData$1(result, direction);\n}\nfunction buildMarimekkoData() {\n  let data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  const result = buildBarStackData(data, \"expand\");\n  const sums = {};\n  let totalSum = 0;\n  for (const series of result) {\n    const sum = series.data.reduce((acc, cur) => acc + cur.y, 0);\n    sums[series.key] = sum;\n    totalSum += sum;\n  }\n  let prev = 0;\n  for (const series of result) {\n    const x0 = prev;\n    const x1 = prev + sums[series.key] / totalSum;\n    prev = x1;\n    for (const point2 of series.data) {\n      point2.x0 = x0;\n      point2.x1 = x1;\n    }\n  }\n  return result;\n}\nfunction transformDataToStack(data) {\n  const result = [];\n  const maxBigInteger = getMaxBigIntegerForNested(data);\n  for (const category of data) {\n    for (const value2 of category.data) {\n      let idx = result.findIndex(r => {\n        if (r.x instanceof Date && value2.key instanceof Date) {\n          return r.x.getTime() === value2.key.getTime();\n        }\n        return r.x === value2.key;\n      });\n      if (idx === -1) {\n        result.push({\n          x: value2.key,\n          formattedValues: {}\n        });\n        idx = result.length - 1;\n      }\n      result[idx][category.key] = normalizeValue(value2.data, maxBigInteger);\n      result[idx].formattedValues[category.key] = normalizeValueForFormatting(value2.data);\n    }\n  }\n  return result;\n}\nfunction transformStackToData(stackData) {\n  const result = [];\n  for (const category of stackData) {\n    const series = [];\n    for (const point2 of category) {\n      const [y0, y1] = point2;\n      const x = point2.data.x;\n      series.push({\n        key: category.key,\n        x,\n        x0: x,\n        x1: x,\n        y: y1 - y0,\n        y0,\n        y1,\n        value: point2.data.formattedValues[category.key]\n      });\n    }\n    result.push({\n      key: category.key,\n      data: series\n    });\n  }\n  return result;\n}\nfunction buildStackData(data) {\n  let normalized = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  const keys = uniqueBy(data, d => d.key);\n  const stackData = transformDataToStack(data);\n  const stackFn = !normalized ? stack() : stack().offset(stackOffsetExpand);\n  const result = stackFn.keys(keys)(stackData);\n  return transformStackToData(result);\n}\nconst buildWaterfall = function (series) {\n  let direction = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"vertical\";\n  let binSize = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : void 0;\n  const data = buildShallowChartData(series, direction, binSize);\n  const isVertical = direction === \"vertical\";\n  const v = isVertical ? \"y\" : \"x\";\n  let cumulative = 0;\n  for (const point2 of data) {\n    point2[\"\".concat(v, \"0\")] = cumulative;\n    cumulative += point2[v];\n    point2[\"\".concat(v, \"1\")] = cumulative;\n    point2[v] = cumulative;\n  }\n  return data;\n};\nclass Pan extends Component {\n  constructor() {\n    super(...arguments);\n    this.prevXPosition = 0;\n    this.prevYPosition = 0;\n    this.started = false;\n    this.deltaX = 0;\n    this.deltaY = 0;\n    this.childRef = createRef();\n    this.onMouseDown = event => {\n      if (this.props.disabled) {\n        return;\n      }\n      if (event.which === 3) {\n        return;\n      }\n      if (!this.props.globalPanning && event.target && !event.target.classList.contains(\"pan-container\")) {\n        return;\n      }\n      event.preventDefault();\n      event.stopPropagation();\n      toggleTextSelection(false);\n      this.started = false;\n      window.addEventListener(\"mousemove\", this.onMouseMove);\n      window.addEventListener(\"mouseup\", this.onMouseUp);\n    };\n    this.onMouseMove = event => {\n      event.preventDefault();\n      event.stopPropagation();\n      this.deltaX = this.deltaX + event.movementX;\n      this.deltaY = this.deltaY + event.movementY;\n      if (this.checkThreshold()) {\n        if (this.props.cursor) {\n          document.body.style[\"cursor\"] = this.props.cursor;\n        }\n        this.deltaX = 0;\n        this.deltaY = 0;\n        this.started = true;\n        this.onPanStart(event, \"mouse\");\n      } else {\n        this.pan(event.movementX, event.movementY, event, \"mouse\");\n      }\n    };\n    this.onMouseUp = event => {\n      event.preventDefault();\n      event.stopPropagation();\n      this.disposeHandlers();\n      toggleTextSelection(true);\n      if (this.started) {\n        this.onPanEnd(event, \"mouse\");\n      } else {\n        this.props.onPanCancel({\n          nativeEvent: event,\n          source: \"mouse\"\n        });\n      }\n    };\n    this.onTouchStart = event => {\n      if (this.props.disabled) {\n        return;\n      }\n      if (event.touches.length !== 1) {\n        return;\n      }\n      event.preventDefault();\n      event.stopPropagation();\n      toggleTextSelection(false);\n      this.started = false;\n      this.prevXPosition = event.touches[0].clientX;\n      this.prevYPosition = event.touches[0].clientY;\n      window.addEventListener(\"touchmove\", this.onTouchMove);\n      window.addEventListener(\"touchend\", this.onTouchEnd);\n    };\n    this.onTouchMove = event => {\n      event.preventDefault();\n      event.stopPropagation();\n      const x = event.touches[0].clientX;\n      const y = event.touches[0].clientY;\n      const deltaX = x - this.prevXPosition;\n      const deltaY = y - this.prevYPosition;\n      this.deltaX = this.deltaX + deltaX;\n      this.deltaY = this.deltaY + deltaY;\n      if (this.checkThreshold()) {\n        this.deltaX = 0;\n        this.deltaY = 0;\n        this.started = true;\n        this.onPanStart(event, \"touch\");\n      } else {\n        const contrained = this.pan(deltaX, deltaY, event, \"touch\");\n        if (!contrained) {\n          this.prevXPosition = x;\n          this.prevYPosition = y;\n        }\n      }\n    };\n    this.onTouchEnd = event => {\n      event.preventDefault();\n      event.stopPropagation();\n      this.disposeHandlers();\n      toggleTextSelection(true);\n      if (this.started) {\n        this.onPanEnd(event, \"touch\");\n      } else {\n        this.props.onPanCancel({\n          nativeEvent: event,\n          source: \"touch\"\n        });\n      }\n    };\n  }\n  componentDidMount() {\n    if (this.childRef.current) {\n      this.childRef.current.addEventListener(\"mousedown\", this.onMouseDown, {\n        passive: false\n      });\n      this.childRef.current.addEventListener(\"touchstart\", this.onTouchStart, {\n        passive: false\n      });\n    }\n  }\n  componentWillUnmount() {\n    this.disposeHandlers();\n    if (this.childRef.current) {\n      this.childRef.current.removeEventListener(\"mousedown\", this.onMouseDown);\n      this.childRef.current.removeEventListener(\"touchstart\", this.onTouchStart);\n    }\n  }\n  disposeHandlers() {\n    window.removeEventListener(\"mousemove\", this.onMouseMove);\n    window.removeEventListener(\"mouseup\", this.onMouseUp);\n    window.removeEventListener(\"touchmove\", this.onTouchMove);\n    window.removeEventListener(\"touchend\", this.onTouchEnd);\n    document.body.style[\"cursor\"] = \"inherit\";\n    toggleTextSelection(true);\n  }\n  checkThreshold() {\n    const {\n      threshold\n    } = this.props;\n    return !this.started && (Math.abs(this.deltaX) > threshold || Math.abs(this.deltaY) > threshold);\n  }\n  onPanStart(nativeEvent, source) {\n    this.props.onPanStart({\n      nativeEvent,\n      source\n    });\n  }\n  onPanMove(x, y, source, nativeEvent) {\n    this.props.onPanMove({\n      source,\n      nativeEvent,\n      x,\n      y\n    });\n  }\n  onPanEnd(nativeEvent, source) {\n    const {\n      onPanEnd\n    } = this.props;\n    onPanEnd({\n      nativeEvent,\n      source\n    });\n  }\n  pan(x, y, nativeEvent, source) {\n    const {\n      scale: scale2,\n      constrain,\n      width,\n      height,\n      matrix\n    } = this.props;\n    const newMatrix = smoothMatrix(transform(matrix, translate(x / scale2, y / scale2)), 100);\n    const shouldConstrain = constrain && constrainMatrix(height, width, newMatrix);\n    if (!shouldConstrain) {\n      this.onPanMove(newMatrix.e, newMatrix.f, source, nativeEvent);\n    }\n    return shouldConstrain;\n  }\n  render() {\n    return /* @__PURE__ */jsx(\"g\", {\n      ref: this.childRef,\n      children: this.props.children\n    });\n  }\n}\nPan.defaultProps = {\n  x: 0,\n  y: 0,\n  disabled: false,\n  scale: 1,\n  threshold: 10,\n  globalPanning: true,\n  onPanStart: () => void 0,\n  onPanMove: () => void 0,\n  onPanEnd: () => void 0,\n  onPanCancel: () => void 0\n};\nconst getMidpoint = (pointA, pointB) => ({\n  x: (pointA.x + pointB.x) / 2,\n  y: (pointA.y + pointB.y) / 2\n});\nconst getDistanceBetweenPoints = (pointA, pointB) => Math.sqrt(Math.pow(pointB.y - pointA.y, 2) + Math.pow(pointB.x - pointA.x, 2));\nfunction getTouchPoints(event, node2) {\n  const {\n    left,\n    top\n  } = node2.getBoundingClientRect();\n  const [pointA, pointB] = [...event.touches].map(touch => ({\n    x: touch.clientX - Math.round(left),\n    y: touch.clientY - Math.round(top)\n  }));\n  const distance = getDistanceBetweenPoints(pointA, pointB);\n  const midpoint = getMidpoint(pointA, pointB);\n  return {\n    pointA,\n    pointB,\n    distance,\n    midpoint\n  };\n}\nclass Zoom extends Component {\n  constructor() {\n    super(...arguments);\n    this.childRef = createRef();\n    this.onMouseWheel = event => {\n      const {\n        disableMouseWheel,\n        requireZoomModifier,\n        matrix,\n        onZoomEnd\n      } = this.props;\n      if (disableMouseWheel) {\n        return false;\n      }\n      const hasModifier = event.metaKey || event.ctrlKey;\n      if (requireZoomModifier && !hasModifier) {\n        return false;\n      }\n      event.preventDefault();\n      event.stopPropagation();\n      const point2 = getPointFromMatrix(event, matrix);\n      if (point2) {\n        const {\n          x,\n          y\n        } = point2;\n        const step = this.getStep(event.deltaY);\n        this.scale(x, y, step, event);\n        clearTimeout(this.timeout);\n        this.timeout = setTimeout(() => onZoomEnd(), 500);\n      }\n    };\n    this.onTouchStart = event => {\n      if (event.touches.length === 2) {\n        event.preventDefault();\n        event.stopPropagation();\n        toggleTextSelection(false);\n        this.firstTouch = getTouchPoints(event, this.childRef.current);\n        this.lastDistance = this.firstTouch.distance;\n        window.addEventListener(\"touchmove\", this.onTouchMove);\n        window.addEventListener(\"touchend\", this.onTouchEnd);\n      }\n    };\n    this.onTouchMove = event => {\n      if (event.touches.length === 2) {\n        event.preventDefault();\n        event.stopPropagation();\n        const {\n          distance\n        } = getTouchPoints(event, this.childRef.current);\n        const distanceFactor = distance / this.lastDistance;\n        const point2 = applyToPoint(inverse(this.props.matrix), {\n          x: this.firstTouch.midpoint.x,\n          y: this.firstTouch.midpoint.y\n        });\n        if (point2.x && point2.y) {\n          const outside = this.scale(point2.x, point2.y, distanceFactor, event);\n          if (!outside) {\n            this.lastDistance = distance;\n          }\n        }\n      }\n    };\n    this.onTouchEnd = event => {\n      event.preventDefault();\n      event.stopPropagation();\n      window.removeEventListener(\"touchmove\", this.onTouchMove);\n      window.removeEventListener(\"touchend\", this.onTouchEnd);\n      toggleTextSelection(true);\n      this.props.onZoomEnd();\n    };\n  }\n  componentDidMount() {\n    const {\n      disabled,\n      disableMouseWheel\n    } = this.props;\n    const ref = this.childRef.current;\n    if (!disabled && ref) {\n      if (!disableMouseWheel) {\n        ref.addEventListener(\"mousewheel\", this.onMouseWheel, {\n          passive: false\n        });\n      }\n      ref.addEventListener(\"touchstart\", this.onTouchStart, {\n        passive: false\n      });\n    }\n  }\n  componentWillUnmount() {\n    window.removeEventListener(\"touchmove\", this.onTouchMove);\n    window.removeEventListener(\"touchend\", this.onTouchEnd);\n    cancelAnimationFrame(this.rqf);\n    clearTimeout(this.timeout);\n    const ref = this.childRef.current;\n    if (ref) {\n      ref.removeEventListener(\"mousewheel\", this.onMouseWheel);\n      ref.removeEventListener(\"touchstart\", this.onTouchStart);\n    }\n    toggleTextSelection(true);\n  }\n  getStep(delta) {\n    const {\n      scaleFactor\n    } = this.props;\n    return -delta > 0 ? scaleFactor + 1 : 1 - scaleFactor;\n  }\n  scale(x, y, step, nativeEvent) {\n    const {\n      minZoom,\n      maxZoom,\n      onZoom,\n      matrix\n    } = this.props;\n    const outside = isZoomLevelGoingOutOfBounds({\n      d: matrix.a,\n      scaleFactorMin: minZoom,\n      scaleFactorMax: maxZoom\n    }, step);\n    if (!outside) {\n      const newMatrix = smoothMatrix(transform(matrix, translate(x, y), scale(step, step), translate(-x, -y)), 100);\n      this.rqf = requestAnimationFrame(() => {\n        onZoom({\n          scale: newMatrix.a,\n          x: newMatrix.e,\n          y: newMatrix.f,\n          nativeEvent\n        });\n      });\n    }\n    return outside;\n  }\n  render() {\n    const {\n      style,\n      children\n    } = this.props;\n    return /* @__PURE__ */jsx(\"g\", {\n      ref: this.childRef,\n      style,\n      children\n    });\n  }\n}\nZoom.defaultProps = {\n  x: 0,\n  y: 0,\n  scale: 1,\n  scaleFactor: 0.1,\n  minZoom: 1,\n  maxZoom: 10\n};\nconst container$2 = \"_container_19vag_1\";\nconst horizontal$2 = \"_horizontal_19vag_5\";\nconst vertical$2 = \"_vertical_19vag_10\";\nconst css$p = {\n  container: container$2,\n  horizontal: horizontal$2,\n  vertical: vertical$2\n};\nconst DiscreteLegend = _ref24 => {\n  let {\n    entries,\n    orientation,\n    style,\n    className\n  } = _ref24;\n  return /* @__PURE__ */jsx(\"div\", {\n    className: classNames(css$p.container, className, {\n      [css$p.horizontal]: orientation === \"horizontal\",\n      [css$p.vertical]: orientation === \"vertical\"\n    }),\n    style,\n    children: entries.map((entry2, index) => /* @__PURE__ */jsx(CloneElement, {\n      element: entry2,\n      orientation\n    }, \"dle-\".concat(index)))\n  });\n};\nDiscreteLegend.defaultProps = {\n  orientation: \"vertical\"\n};\nconst symbol = \"_symbol_f5unn_1\";\nconst css$o = {\n  symbol\n};\nconst DiscreteLegendSymbol = _ref25 => {\n  let {\n    className,\n    color\n  } = _ref25;\n  return /* @__PURE__ */jsx(\"div\", {\n    className: classNames(css$o.symbol, className),\n    style: {\n      background: color\n    }\n  });\n};\nconst entry = \"_entry_1493o_1\";\nconst vertical$1 = \"_vertical_1493o_8\";\nconst label$3 = \"_label_1493o_20\";\nconst horizontal$1 = \"_horizontal_1493o_30\";\nconst css$n = {\n  entry,\n  vertical: vertical$1,\n  label: label$3,\n  horizontal: horizontal$1\n};\nconst DiscreteLegendEntry = _ref26 => {\n  let {\n    label: label2,\n    symbol: symbol2,\n    title,\n    className,\n    color,\n    style,\n    orientation,\n    onMouseEnter,\n    onMouseLeave,\n    onClick\n  } = _ref26;\n  return /* @__PURE__ */jsxs(\"div\", {\n    title,\n    className: classNames(css$n.entry, className, {\n      [css$n.vertical]: orientation === \"vertical\",\n      [css$n.horizontal]: orientation === \"horizontal\"\n    }),\n    onClick,\n    onMouseEnter,\n    onMouseLeave,\n    style,\n    children: [/* @__PURE__ */jsx(CloneElement, {\n      element: symbol2,\n      color\n    }), /* @__PURE__ */jsx(\"span\", {\n      className: css$n.label,\n      children: label2\n    })]\n  });\n};\nDiscreteLegendEntry.defaultProps = {\n  symbol: /* @__PURE__ */jsx(DiscreteLegendSymbol, {}),\n  orientation: \"horizontal\"\n};\nconst container$1 = \"_container_1gnp9_1\";\nconst vertical = \"_vertical_1gnp9_5\";\nconst start = \"_start_1gnp9_9\";\nconst end = \"_end_1gnp9_10\";\nconst gradient = \"_gradient_1gnp9_16\";\nconst horizontal = \"_horizontal_1gnp9_22\";\nconst css$m = {\n  container: container$1,\n  vertical,\n  start,\n  end,\n  gradient,\n  horizontal\n};\nconst SequentialLegend = _ref27 => {\n  let {\n    className,\n    gradientClassName,\n    style,\n    data,\n    colorScheme = [\"rgba(28, 107, 86, 0.5)\", \"#2da283\"],\n    orientation = \"orientation\"\n  } = _ref27;\n  const color = chroma.scale(colorScheme).colors(10).reverse().map((c, i) => \"\".concat(c, \" \").concat(i * 10, \"%\")).join(\",\");\n  const [end2, start2] = useMemo(() => extent$1(uniqueBy(data, d => d.data, d => d.data)), [data]);\n  const gradientDir = orientation === \"vertical\" ? \"\" : \"to left,\";\n  return /* @__PURE__ */jsxs(\"div\", {\n    style,\n    className: classNames(css$m.container, className, {\n      [css$m.vertical]: orientation === \"vertical\",\n      [css$m.horizontal]: orientation === \"horizontal\"\n    }),\n    children: [/* @__PURE__ */jsx(\"div\", {\n      className: css$m.start,\n      children: formatValue(start2)\n    }), /* @__PURE__ */jsx(\"div\", {\n      className: classNames(css$m.gradient, gradientClassName),\n      style: {\n        background: \"linear-gradient(\".concat(gradientDir).concat(color, \")\")\n      }\n    }), /* @__PURE__ */jsx(\"div\", {\n      className: css$m.end,\n      children: formatValue(end2)\n    })]\n  });\n};\nSequentialLegend.defaultProps = {\n  colorScheme: [\"rgba(28, 107, 86, 0.5)\", \"#2da283\"],\n  orientation: \"vertical\"\n};\nconst gridLine = \"_gridLine_5yx3q_1\";\nconst css$l = {\n  gridLine\n};\nconst Gridline = _ref28 => {\n  let {\n    strokeWidth,\n    direction,\n    className,\n    strokeColor,\n    data,\n    height,\n    width,\n    scale: scale2,\n    strokeDasharray\n  } = _ref28;\n  const coords = useMemo(() => {\n    const pos = scale2(data);\n    if (direction === \"x\") {\n      return {\n        x1: pos,\n        x2: pos,\n        y1: 0,\n        y2: height\n      };\n    } else {\n      return {\n        y1: pos,\n        y2: pos,\n        x1: 0,\n        x2: width\n      };\n    }\n  }, [direction, data, height, width, scale2]);\n  return /* @__PURE__ */jsx(\"line\", {\n    ...coords,\n    className: classNames(css$l.gridLine, className),\n    strokeDasharray,\n    strokeWidth,\n    stroke: strokeColor,\n    fill: \"none\"\n  });\n};\nGridline.defaultProps = {\n  strokeWidth: 1,\n  strokeDasharray: \"2 5\",\n  direction: \"all\",\n  strokeColor: \"rgba(153, 153, 153, 0.5)\"\n};\nconst GridlineSeries = _ref29 => {\n  let {\n    line: line2,\n    stripe,\n    yScale,\n    xScale,\n    yAxis,\n    xAxis,\n    height,\n    width\n  } = _ref29;\n  const shouldRenderY = direction => direction === \"all\" || direction === \"y\";\n  const shouldRenderX = direction => direction === \"all\" || direction === \"x\";\n  const {\n    yAxisGrid,\n    xAxisGrid\n  } = useMemo(() => {\n    return {\n      yAxisGrid: getTicks(yScale, yAxis.tickSeries.props.tickValues, yAxis.type, getMaxTicks(yAxis.tickSeries.props.tickSize, height), yAxis.tickSeries.props.interval),\n      xAxisGrid: getTicks(xScale, xAxis.tickSeries.props.tickValues, xAxis.type, getMaxTicks(xAxis.tickSeries.props.tickSize, width), xAxis.tickSeries.props.interval)\n    };\n  }, [height, width, xAxis, yAxis, yScale, xScale]);\n  const renderGroup = useCallback((element, grid, scale2, direction, type) => {\n    return grid.map((point2, index) => /* @__PURE__ */jsx(Fragment, {\n      children: /* @__PURE__ */jsx(CloneElement, {\n        element,\n        index,\n        scale: scale2,\n        data: point2,\n        height,\n        width,\n        direction\n      })\n    }, \"\".concat(type, \"-\").concat(direction, \"-\").concat(index)));\n  }, [height, width]);\n  const renderSeries = useCallback((yAxisGrid2, xAxisGrid2, element, type) => {\n    return /* @__PURE__ */jsxs(Fragment, {\n      children: [shouldRenderY(element.props.direction) && renderGroup(element, yAxisGrid2, yScale, \"y\", type), shouldRenderX(element.props.direction) && renderGroup(element, xAxisGrid2, xScale, \"x\", type)]\n    });\n  }, [renderGroup, xScale, yScale]);\n  return /* @__PURE__ */jsxs(\"g\", {\n    style: {\n      pointerEvents: \"none\"\n    },\n    children: [line2 && renderSeries(yAxisGrid, xAxisGrid, line2, \"line\"), stripe && renderSeries(yAxisGrid, xAxisGrid, stripe, \"stripe\")]\n  });\n};\nGridlineSeries.defaultProps = {\n  line: /* @__PURE__ */jsx(Gridline, {\n    direction: \"all\"\n  }),\n  stripe: null\n};\nconst gridStripe = \"_gridStripe_xcrvl_1\";\nconst css$k = {\n  gridStripe\n};\nconst GridStripe = _ref30 => {\n  let {\n    fill,\n    className,\n    position,\n    data,\n    height,\n    width,\n    scale: scale2,\n    index\n  } = _ref30;\n  const coords = useMemo(() => {\n    const pos = scale2(data);\n    const stripeFill = index % 2 ? \"none\" : fill;\n    const dim = scale2.bandwidth();\n    if (position === \"vertical\") {\n      return {\n        y: 0,\n        x: pos,\n        height,\n        width: dim,\n        fill: stripeFill\n      };\n    } else {\n      return {\n        y: pos,\n        x: 0,\n        height: dim,\n        width,\n        fill: stripeFill\n      };\n    }\n  }, [scale2, data, index, height, width, fill, position]);\n  return /* @__PURE__ */jsx(\"rect\", {\n    className: classNames(css$k.gridStripe, className),\n    ...coords\n  });\n};\nGridStripe.defaultProps = {\n  fill: \"#393c3e\"\n};\nconst markLine = \"_markLine_1sfls_1\";\nconst css$j = {\n  markLine\n};\nconst MarkLine = _ref31 => {\n  let {\n    pointX,\n    height,\n    strokeWidth = 1,\n    strokeColor = \"#eee\"\n  } = _ref31;\n  return /* @__PURE__ */jsx(\"line\", {\n    stroke: strokeColor,\n    strokeWidth,\n    y1: \"0\",\n    vectorEffect: \"non-scaling-stroke\",\n    y2: height,\n    x1: pointX,\n    x2: pointX,\n    className: css$j.markLine\n  });\n};\nconst GradientStop = _ref32 => {\n  let {\n    color,\n    offset,\n    stopOpacity = 1\n  } = _ref32;\n  return /* @__PURE__ */jsx(\"stop\", {\n    offset,\n    stopOpacity,\n    stopColor: color\n  });\n};\nconst Gradient = _ref33 => {\n  let {\n    id,\n    color,\n    direction,\n    stops\n  } = _ref33;\n  if (direction === \"radial\") {\n    return /* @__PURE__ */jsx(\"radialGradient\", {\n      id,\n      children: stops.map((stop, index) => /* @__PURE__ */jsx(CloneElement, {\n        element: stop,\n        color: stop.props.color || color\n      }, \"gradient-\".concat(index)))\n    });\n  }\n  const pos = direction === \"vertical\" ? {\n    x1: \"10%\",\n    x2: \"10%\",\n    y1: \"100%\",\n    y2: \"0%\"\n  } : {\n    y1: \"0%\",\n    y2: \"0%\",\n    x1: \"0%\",\n    x2: \"100%\"\n  };\n  return /* @__PURE__ */jsx(\"linearGradient\", {\n    spreadMethod: \"pad\",\n    id,\n    ...pos,\n    children: stops.map((stop, index) => /* @__PURE__ */jsx(CloneElement, {\n      element: stop,\n      color: stop.props.color || color\n    }, \"gradient-\".concat(index)))\n  });\n};\nGradient.defaultProps = {\n  direction: \"vertical\",\n  stops: [/* @__PURE__ */jsx(GradientStop, {\n    offset: \"0%\",\n    stopOpacity: 0.3\n  }, \"start\"), /* @__PURE__ */jsx(GradientStop, {\n    offset: \"80%\",\n    stopOpacity: 1\n  }, \"stop\")]\n};\nconst RadialGradient = _ref34 => {\n  let {\n    id,\n    color,\n    radius = \"30%\",\n    stops = [/* @__PURE__ */jsx(GradientStop, {\n      offset: \"0%\",\n      stopOpacity: 0.2\n    }, \"start\"), /* @__PURE__ */jsx(GradientStop, {\n      offset: \"80%\",\n      stopOpacity: 0.7\n    }, \"stop\")]\n  } = _ref34;\n  return /* @__PURE__ */jsx(\"radialGradient\", {\n    id,\n    cx: 0,\n    cy: 0,\n    r: radius,\n    gradientUnits: \"userSpaceOnUse\",\n    children: stops.map((stop, index) => /* @__PURE__ */jsx(CloneElement, {\n      element: stop,\n      color\n    }, \"gradient-\".concat(index)))\n  });\n};\nconst Mask = _ref35 => {\n  let {\n    id,\n    fill\n  } = _ref35;\n  return /* @__PURE__ */jsx(\"mask\", {\n    id,\n    children: /* @__PURE__ */jsx(\"rect\", {\n      x: \"0\",\n      y: \"0\",\n      width: \"100%\",\n      height: \"100%\",\n      fill\n    })\n  });\n};\nconst Stripes = _ref36 => {\n  let {\n    id,\n    fill\n  } = _ref36;\n  return /* @__PURE__ */jsx(\"pattern\", {\n    id,\n    width: \"4\",\n    height: \"4\",\n    patternUnits: \"userSpaceOnUse\",\n    patternTransform: \"rotate(45)\",\n    children: /* @__PURE__ */jsx(\"rect\", {\n      className: \"area-stripe\",\n      width: \"1\",\n      height: \"4\",\n      fill\n    })\n  });\n};\nconst label$2 = \"_label_uiu20_1\";\nconst value = \"_value_uiu20_7\";\nconst subValue = \"_subValue_uiu20_13\";\nconst subValueColor = \"_subValueColor_uiu20_18\";\nconst subValueName = \"_subValueName_uiu20_25\";\nconst css$i = {\n  label: label$2,\n  value,\n  subValue,\n  subValueColor,\n  subValueName\n};\nconst TooltipTemplate = _ref37 => {\n  let {\n    value: value2,\n    color,\n    className\n  } = _ref37;\n  if (!value2) {\n    return null;\n  }\n  const renderValues = (data, index) => {\n    const fill = color(data, index);\n    return /* @__PURE__ */jsxs(\"span\", {\n      className: css$i.subValue,\n      children: [/* @__PURE__ */jsx(\"span\", {\n        className: css$i.subValueColor,\n        style: {\n          backgroundColor: fill\n        }\n      }), /* @__PURE__ */jsxs(\"span\", {\n        className: css$i.subValueName,\n        children: [formatValue(data.key || data.x), \":\"]\n      }), /* @__PURE__ */jsx(\"span\", {\n        children: formatValue(data.value || data.y)\n      })]\n    });\n  };\n  const renderMultiple = value22 => {\n    const excessCount = value22.data.length - 15;\n    const pagedValues = value22.data.slice(0, 15);\n    return /* @__PURE__ */jsxs(Fragment, {\n      children: [pagedValues.map((point2, i) => /* @__PURE__ */jsx(Fragment, {\n        children: renderValues(point2, i)\n      }, i)), excessCount > 0 && /* @__PURE__ */jsxs(\"div\", {\n        children: [\"...\", excessCount, \" more...\"]\n      })]\n    });\n  };\n  const isMultiple = Array.isArray(value2.data);\n  return /* @__PURE__ */jsxs(\"div\", {\n    className,\n    role: \"tooltip\",\n    children: [/* @__PURE__ */jsx(\"div\", {\n      className: css$i.label,\n      children: formatValue(value2.x)\n    }), /* @__PURE__ */jsxs(\"div\", {\n      className: css$i.value,\n      children: [isMultiple && renderMultiple(value2), !isMultiple && /* @__PURE__ */jsx(Fragment, {\n        children: formatValue(value2.value || value2.y)\n      })]\n    })]\n  });\n};\nconst base = \"_base_b22et_1\";\nconst disablePointer = \"_disablePointer_b22et_10\";\nconst css$h = {\n  base,\n  disablePointer\n};\nconst tooltipTheme = {\n  base: css$h.base,\n  disablePointer: css$h.disablePointer\n};\nconst ChartTooltip = _ref38 => {\n  let {\n    content,\n    value: value2,\n    data,\n    color,\n    ...rest\n  } = _ref38;\n  return /* @__PURE__ */jsx(Tooltip, {\n    theme: tooltipTheme,\n    ...rest,\n    content: () => {\n      if (!value2 && !data) {\n        return null;\n      }\n      return typeof content === \"function\" ? content(data || value2, color) : cloneElement(content, {\n        ...content.props,\n        value: value2,\n        color\n      });\n    }\n  });\n};\nChartTooltip.defaultProps = {\n  content: /* @__PURE__ */jsx(TooltipTemplate, {})\n};\nconst TooltipArea = forwardRef((_ref39, childRef) => {\n  let {\n    children,\n    inverse: inverse2,\n    tooltip: tooltip2,\n    disabled,\n    color,\n    isRadial,\n    isContinous,\n    width,\n    height,\n    xScale,\n    yScale,\n    onValueEnter,\n    data,\n    isHorizontal,\n    innerRadius,\n    outerRadius,\n    placement: placementProp,\n    onValueLeave,\n    startAngle,\n    endAngle\n  } = _ref39;\n  const [visible, setVisible] = useState();\n  const [placement, setPlacement] = useState();\n  const [value2, setValue] = useState();\n  const [offsetX, setOffsetX] = useState();\n  const [offsetY, setOffsetY] = useState();\n  const [prevX, setPrevX] = useState();\n  const [prevY, setPrevY] = useState();\n  const ref = useRef();\n  const fullCircleref = useRef(null);\n  const isFullCircle = Math.abs(endAngle - startAngle) >= 2 * Math.PI;\n  const range2 = Math.abs(endAngle - startAngle);\n  const rotationFactor = 0.5;\n  const getXCoord = useCallback((x, y) => {\n    if (isRadial) {\n      const outerRadiusNew = outerRadius || Math.min(width, height) / 2;\n      let rad = Math.atan2(y - outerRadiusNew, x - outerRadiusNew) + rotationFactor * Math.PI;\n      rad = (rad - startAngle) % (2 * Math.PI);\n      if (rad < 0) {\n        rad += Math.PI * 2;\n      }\n      const scale2 = scaleLinear().domain([0, range2]).range([startAngle, endAngle]);\n      rad = scale2(rad);\n      return rad;\n    }\n    return x;\n  }, [endAngle, height, isRadial, outerRadius, range2, startAngle, width]);\n  const transformData = useCallback(series => {\n    const result = [];\n    if (inverse2) {\n      for (const point2 of series) {\n        const seriesPoint = point2;\n        if (Array.isArray(seriesPoint.data)) {\n          for (const nestedPoint of seriesPoint.data) {\n            const right = nestedPoint.x;\n            let idx = result.findIndex(r => {\n              const left = r.x;\n              if (left instanceof Date && right instanceof Date) {\n                return left.getTime() === right.getTime();\n              }\n              return left === right;\n            });\n            if (idx === -1) {\n              result.push({\n                x: nestedPoint.x,\n                data: []\n              });\n              idx = result.length - 1;\n            }\n            const data2 = result[idx].data;\n            if (Array.isArray(data2)) {\n              data2.push(nestedPoint);\n            }\n          }\n        } else {\n          result.push(point2);\n        }\n      }\n    } else {\n      for (const point2 of series) {\n        const nestedPoint = point2;\n        if (Array.isArray(nestedPoint.data)) {\n          result.push({\n            ...nestedPoint,\n            x: nestedPoint.key,\n            data: nestedPoint.data.map(d => ({\n              ...d,\n              key: !isHorizontal ? d.x : d.y,\n              value: !isHorizontal ? d.y : d.x\n            }))\n          });\n        } else {\n          const shallowPoint = point2;\n          result.push({\n            ...shallowPoint,\n            // Histograms special logic...\n            x: shallowPoint.key === void 0 ? shallowPoint.x0 : point2.key,\n            y: shallowPoint.value === void 0 ? shallowPoint.y : shallowPoint.value\n          });\n        }\n      }\n    }\n    return result;\n  }, [inverse2, isHorizontal]);\n  const onMouseMove = useCallback(event => {\n    const transformed = transformData(data);\n    let newPlacement = placementProp;\n    if (!placementProp) {\n      if (isHorizontal) {\n        newPlacement = \"right\";\n      } else {\n        newPlacement = \"top\";\n      }\n    }\n    let target = fullCircleref.current || ref.current;\n    const {\n      y,\n      x\n    } = getPositionForTarget({\n      target,\n      // Manually pass the x/y from the event\n      clientX: event.clientX,\n      clientY: event.clientY\n    });\n    let keyScale;\n    let valueScale;\n    let coord;\n    let attr = \"x\";\n    if (isHorizontal) {\n      keyScale = yScale;\n      valueScale = xScale;\n      coord = y;\n    } else {\n      coord = getXCoord(x, y);\n      keyScale = xScale;\n      valueScale = yScale;\n    }\n    if (typeof transformed[0].i === \"number\") {\n      attr = \"i\";\n    }\n    const newValue = keyScale.invert ? getClosestContinousScalePoint({\n      pos: coord,\n      scale: keyScale,\n      data: transformed,\n      attr,\n      roundDown: !isContinous\n    }) : getClosestBandScalePoint({\n      pos: coord,\n      scale: keyScale,\n      data: transformed,\n      attr,\n      roundClosest: isRadial\n    });\n    if (!isEqual(newValue, value2) && newValue) {\n      const pointX = keyScale(newValue.x);\n      let pointY = valueScale(newValue.y);\n      let marginX = 0;\n      let marginY = 0;\n      if (isNaN(pointY)) {\n        pointY = height / 2;\n        marginX = 10;\n        if (!placement) {\n          newPlacement = \"right\";\n        }\n      } else {\n        marginY = -10;\n      }\n      if (pointX === prevX && pointY === prevY) {\n        return;\n      }\n      setPrevX(pointX);\n      setPrevY(pointY);\n      const target2 = event.target;\n      const {\n        top,\n        left\n      } = target2.getBoundingClientRect();\n      let offsetX2 = 0;\n      let offsetY2 = 0;\n      if (isRadial) {\n        const outerRadius2 = Math.min(width, height) / 2;\n        offsetX2 = pointY * Math.cos(pointX - rotationFactor * Math.PI) + outerRadius2;\n        offsetY2 = pointY * Math.sin(pointX - rotationFactor * Math.PI) + outerRadius2;\n      } else {\n        offsetX2 = pointX;\n        offsetY2 = pointY;\n      }\n      offsetX2 += left + marginX;\n      offsetY2 += top + marginY;\n      setPlacement(newPlacement);\n      setVisible(true);\n      setValue(newValue);\n      setOffsetX(offsetX2);\n      setOffsetY(offsetY2);\n      onValueEnter({\n        visible: true,\n        value: newValue,\n        pointY,\n        pointX,\n        offsetX: offsetX2,\n        offsetY: offsetY2,\n        nativeEvent: event\n      });\n    }\n  }, [data, getXCoord, height, isContinous, isHorizontal, isRadial, onValueEnter, placement, placementProp, prevX, prevY, transformData, value2, width, xScale, yScale]);\n  const onMouseLeave = useCallback(() => {\n    setPrevX(void 0);\n    setPrevY(void 0);\n    setValue(void 0);\n    setVisible(false);\n    onValueLeave();\n  }, [onValueLeave]);\n  useImperativeHandle(childRef, () => ({\n    triggerMouseMove(e) {\n      onMouseMove(e);\n    }\n  }));\n  const tooltipReference = useMemo(() => ({\n    width: 4,\n    height: 4,\n    top: offsetY,\n    left: offsetX\n  }), [offsetX, offsetY]);\n  const renderRadial = useCallback(() => {\n    const innerRadiusNew = innerRadius || 0;\n    const outerRadiusNew = outerRadius || Math.min(width, height) / 2;\n    const d = arc()({\n      innerRadius: innerRadiusNew,\n      outerRadius: outerRadiusNew,\n      startAngle: isFullCircle ? 0 : startAngle,\n      endAngle: isFullCircle ? 2 * Math.PI : endAngle\n    });\n    const fullCircle = arc()({\n      innerRadius: innerRadiusNew,\n      outerRadius: outerRadiusNew,\n      startAngle: 0,\n      endAngle: 2 * Math.PI\n    });\n    return /* @__PURE__ */jsxs(Fragment$1, {\n      children: [/* @__PURE__ */jsx(\"path\", {\n        d: fullCircle,\n        opacity: \"0\",\n        cursor: \"auto\",\n        ref: fullCircleref\n      }), /* @__PURE__ */jsx(\"path\", {\n        d,\n        opacity: \"0\",\n        cursor: \"auto\",\n        ref,\n        onMouseMove\n      })]\n    });\n  }, [endAngle, height, innerRadius, isFullCircle, onMouseMove, outerRadius, startAngle, width]);\n  const renderLinear = useCallback(() => {\n    return /* @__PURE__ */jsx(\"rect\", {\n      height,\n      ref,\n      width,\n      opacity: 0,\n      cursor: \"auto\",\n      onMouseMove\n    });\n  }, [height, onMouseMove, width]);\n  return /* @__PURE__ */jsxs(Fragment, {\n    children: [disabled && children, !disabled && /* @__PURE__ */jsxs(\"g\", {\n      onMouseLeave,\n      ref: childRef,\n      children: [isRadial && renderRadial(), !isRadial && renderLinear(), /* @__PURE__ */jsx(CloneElement, {\n        element: tooltip2,\n        visible,\n        placement,\n        modifiers: {\n          offset: {\n            offset: \"0, 15px\"\n          }\n        },\n        reference: tooltipReference,\n        color,\n        value: value2\n      }), children]\n    })]\n  });\n});\nTooltipArea.defaultProps = {\n  isRadial: false,\n  isContinous: true,\n  tooltip: /* @__PURE__ */jsx(ChartTooltip, {}),\n  inverse: true,\n  onValueEnter: () => void 0,\n  onValueLeave: () => void 0,\n  startAngle: 0,\n  endAngle: 2 * Math.PI\n};\nconst ZoomPan = _ref40 => {\n  let {\n    height,\n    width,\n    children,\n    disabled,\n    pannable,\n    maxZoom,\n    minZoom,\n    zoomable,\n    scale: scale2,\n    x,\n    y,\n    disableMouseWheel,\n    constrain,\n    zoomStep,\n    onPanCancel,\n    requireZoomModifier,\n    globalPanning,\n    onPanStart,\n    onZoomPan,\n    onPanMove,\n    onPanEnd,\n    onZoom,\n    onZoomEnd\n  } = _ref40;\n  const zoomRef = useRef();\n  const panRef = useRef();\n  const [isZooming, setIsZooming] = useState();\n  const [isPanning, setIsPanning] = useState();\n  const [matrix, setMatrix] = useState(identity());\n  useEffect(() => {\n    const newMatrix = transform(fromDefinition([{\n      type: \"translate\",\n      tx: x,\n      ty: y\n    }, {\n      type: \"scale\",\n      sx: scale2,\n      sy: scale2\n    }]));\n    if (!isEqual(newMatrix, matrix)) {\n      setMatrix(newMatrix);\n    }\n  }, [x, y, scale2, matrix]);\n  const onPanStartHandler = useCallback(event => {\n    setIsPanning(true);\n    onPanStart(event);\n  }, [onPanStart]);\n  const onPanMoveHandler = useCallback(event => {\n    onZoomPan({\n      scale: scale2,\n      x: event.x,\n      y: event.y,\n      type: \"pan\",\n      nativeEvent: event.nativeEvent\n    });\n    onPanMove(event);\n  }, [onPanMove, onZoomPan, scale2]);\n  const onPanEndHandler = useCallback(event => {\n    setIsPanning(false);\n    onPanEnd(event);\n  }, [onPanEnd]);\n  const onZoomHandler = useCallback(event => {\n    onZoomPan({\n      x: event.x,\n      y: event.y,\n      scale: event.scale,\n      nativeEvent: event.nativeEvent,\n      type: \"zoom\"\n    });\n    onZoom(event);\n  }, [onZoom, onZoomPan]);\n  const onZoomEndHandler = useCallback(() => {\n    setIsZooming(false);\n    onZoomEnd();\n  }, [onZoomEnd]);\n  const cursor = pannable ? \"move\" : \"auto\";\n  const selection = isZooming || isPanning ? \"none\" : \"auto\";\n  const matrixObj = fromObject(matrix);\n  return /* @__PURE__ */jsx(Pan, {\n    x,\n    y,\n    scale: scale2,\n    matrix: matrixObj,\n    constrain,\n    height,\n    width,\n    disabled: !pannable || disabled,\n    ref: panRef,\n    globalPanning,\n    onPanStart: bind(onPanStartHandler),\n    onPanMove: bind(onPanMoveHandler),\n    onPanEnd: bind(onPanEndHandler),\n    onPanCancel,\n    children: /* @__PURE__ */jsxs(Zoom, {\n      ref: zoomRef,\n      disabled: !zoomable || disabled,\n      scaleFactor: zoomStep,\n      disableMouseWheel,\n      maxZoom,\n      minZoom,\n      scale: scale2,\n      x,\n      y,\n      style: {\n        cursor\n      },\n      requireZoomModifier,\n      matrix,\n      onZoom: bind(onZoomHandler),\n      onZoomEnd: bind(onZoomEndHandler),\n      children: [!disabled && /* @__PURE__ */jsx(\"rect\", {\n        height,\n        width,\n        opacity: 0,\n        className: \"pan-container\"\n      }), /* @__PURE__ */jsx(\"g\", {\n        style: {\n          pointerEvents: selection,\n          userSelect: selection\n        },\n        children\n      })]\n    })\n  });\n};\nZoomPan.defaultProps = {\n  maxZoom: 10,\n  minZoom: 0,\n  zoomStep: 0.1,\n  pannable: true,\n  zoomable: true,\n  constrain: true,\n  height: 0,\n  width: 0,\n  x: 0,\n  y: 0,\n  scale: 1,\n  globalPanning: true,\n  onPanStart: () => void 0,\n  onPanMove: () => void 0,\n  onPanEnd: () => void 0,\n  onPanCancel: () => void 0,\n  onZoom: () => void 0,\n  onZoomEnd: () => void 0\n};\nfunction getXScale(_ref41) {\n  let {\n    type,\n    roundDomains,\n    data,\n    width,\n    domain,\n    padding,\n    scaled,\n    isMultiSeries = false,\n    isDiverging = false\n  } = _ref41;\n  let scale2;\n  if (type === \"time\" || type === \"duration\" || type === \"value\") {\n    if (type === \"time\") {\n      scale2 = scaleTime().rangeRound([0, width]);\n    } else {\n      scale2 = scaleLinear().rangeRound([0, width]);\n    }\n    scale2 = scale2.domain(domain || getXDomain({\n      data,\n      scaled,\n      isDiverging\n    }));\n  } else {\n    if (!domain) {\n      if (isMultiSeries) {\n        domain = uniqueBy(data, d => d.key);\n      } else {\n        domain = uniqueBy(data, d => d.x);\n      }\n    }\n    scale2 = scaleBand().rangeRound([0, width]).padding(padding || 0).domain(domain);\n  }\n  return roundDomains ? scale2.nice() : scale2;\n}\nfunction getYScale(_ref42) {\n  let {\n    type,\n    height,\n    data,\n    domain,\n    roundDomains = false,\n    scaled = false,\n    padding = 0,\n    isMultiSeries = false,\n    isDiverging = false\n  } = _ref42;\n  let scale2;\n  if (type === \"time\" || type === \"value\" || type === \"duration\") {\n    scale2 = scaleLinear().range([height, 0]).domain(domain || getYDomain({\n      data,\n      scaled,\n      isDiverging\n    }));\n  } else {\n    if (!domain) {\n      if (isMultiSeries) {\n        domain = uniqueBy(data, d => d.key);\n      } else {\n        domain = uniqueBy(data, d => d.y);\n      }\n    }\n    scale2 = scaleBand().rangeRound([height, 0]).padding(padding).domain(domain);\n  }\n  return roundDomains ? scale2.nice() : scale2;\n}\nconst getMarimekkoScale = (width, roundDomains) => {\n  const scale2 = scaleLinear().rangeRound([0, width]);\n  return roundDomains ? scale2.nice() : scale2;\n};\nconst getMarimekkoGroupScale = _ref43 => {\n  let {\n    data,\n    width,\n    valueScale,\n    padding\n  } = _ref43;\n  const domain = uniqueBy(data, d => d.key);\n  const barCount = data.length;\n  const widthMinusPadding = width - padding * (barCount - 1);\n  const xMultiplier = widthMinusPadding / width;\n  const getXRange = series => {\n    const [val] = series.data;\n    const x0 = valueScale(val.x0);\n    const x1 = valueScale(val.x1);\n    return {\n      x0,\n      x1\n    };\n  };\n  const scale2 = arg => {\n    let result = 0;\n    const index = data.findIndex(d => d.key === arg);\n    const series = data[index];\n    if (series && series.data && series.data.length) {\n      const {\n        x1,\n        x0\n      } = getXRange(series);\n      result = (x1 - x0) / 2 + x0;\n      if (padding) {\n        result = result * xMultiplier + index * padding;\n      }\n    }\n    return result;\n  };\n  scale2.range = () => [0, width];\n  scale2.domain = () => domain;\n  scale2.mariemkoInvert = offset => {\n    let found;\n    for (let i = 0; i < domain.length; i++) {\n      const attr = domain[i];\n      const series = data[i];\n      const {\n        x1,\n        x0\n      } = getXRange(series);\n      if (offset >= x0 - padding / 2 && offset <= x1 - padding / 2) {\n        found = attr;\n        break;\n      }\n    }\n    return found;\n  };\n  return scale2;\n};\nfunction getGroupScale(_ref44) {\n  let {\n    dimension,\n    padding,\n    data,\n    direction = \"vertical\"\n  } = _ref44;\n  const domain = uniqueBy(data, d => d.key);\n  const spacing = domain.length / (dimension / padding + 1);\n  const range2 = direction === \"vertical\" ? [0, dimension] : [dimension, 0];\n  return scaleBand().rangeRound(range2).paddingInner(spacing).paddingOuter(spacing / 2).domain(domain);\n}\nfunction getInnerScale(_ref45) {\n  let {\n    groupScale,\n    padding,\n    data,\n    prop = \"x\"\n  } = _ref45;\n  const dimension = groupScale.bandwidth();\n  const domain = uniqueBy(data, d => d.data, d => d[prop]);\n  const spacing = domain.length / (dimension / padding + 1);\n  return scaleBand().rangeRound([0, dimension]).paddingInner(spacing).domain(domain);\n}\nconst getRadialYScale = (innerRadius, outerRadius, domain) => {\n  if (domain[0] === 0 && domain[1] === 0) {\n    domain = [0, 1];\n  }\n  const y = scaleLinear().range([innerRadius * innerRadius, outerRadius * outerRadius]).domain(domain);\n  const yScale = Object.assign(d => Math.sqrt(y(d)), y);\n  return yScale;\n};\nconst ChartZoomPan = _ref46 => {\n  let {\n    data,\n    height,\n    children,\n    disabled,\n    domain,\n    width,\n    axisType,\n    roundDomains,\n    onZoomPan,\n    ...rest\n  } = _ref46;\n  const onZoomPanHandler = useCallback(event => {\n    const can = event.type === \"zoom\" || event.type === \"pan\" && event.scale > 1;\n    if (can) {\n      const scale2 = getXScale({\n        width,\n        type: axisType,\n        roundDomains,\n        data\n      });\n      const newScale = scale2.copy().domain(scale2.range().map(x => (x - event.x) / event.scale).map(scale2.clamp(true).invert, event.x));\n      onZoomPan({\n        domain: newScale.domain(),\n        isZoomed: event.scale !== 1\n      });\n    }\n  }, [axisType, data, onZoomPan, roundDomains, width]);\n  const zoomOffset = useMemo(() => {\n    let zoomOffset2 = {\n      scale: void 0,\n      x: void 0\n    };\n    if (!disabled && domain) {\n      const xScale = getXScale({\n        width,\n        type: axisType,\n        roundDomains,\n        data\n      });\n      let offset = xScale(domain[0]);\n      const endOffset = xScale(domain[1]);\n      const scale2 = width / (endOffset - offset);\n      offset = offset * scale2;\n      zoomOffset2 = {\n        scale: scale2,\n        x: -offset\n      };\n    }\n    return zoomOffset2;\n  }, [axisType, data, disabled, domain, roundDomains, width]);\n  return /* @__PURE__ */jsx(ZoomPan, {\n    ...rest,\n    scale: zoomOffset.scale,\n    x: zoomOffset.x,\n    height,\n    width,\n    pannable: zoomOffset.scale > 1,\n    onZoomPan: onZoomPanHandler,\n    children\n  });\n};\nChartZoomPan.defaultProps = {\n  onZoomPan: () => void 0\n};\nconst DEFAULT_TRANSITION = {\n  type: \"spring\",\n  velocity: 5,\n  damping: 20,\n  // https://github.com/framer/motion/issues/1513#issuecomment-1121133717\n  restDelta: 0.01,\n  restSpeed: 0.01\n};\nconst MotionPath = _ref47 => {\n  let {\n    custom,\n    transition,\n    ...rest\n  } = _ref47;\n  const d = useMotionValue(custom.exit.d);\n  const spring = useSpring(0, DEFAULT_TRANSITION);\n  useEffect(() => {\n    const interpolator = interpolate$1(d.get(), custom.enter.d);\n    const prevSpring = spring.get();\n    spring.set(prevSpring + 1);\n    return spring.on(\"change\", v => d.set(interpolator(v - prevSpring)));\n  }, [custom.enter.d, custom.exit.d, d, spring]);\n  const {\n    d: enterD,\n    ...enterRest\n  } = custom.enter;\n  const {\n    d: exitD,\n    ...exitRest\n  } = custom.exit;\n  return /* @__PURE__ */jsx(motion.path, {\n    ...rest,\n    initial: exitRest,\n    exit: exitRest,\n    animate: enterRest,\n    transition,\n    d: transition.type !== false ? d : enterD\n  });\n};\nconst schemes = {\n  cybertron: chroma.scale([\"#2d60e8\", \"#26efb5\"]).correctLightness().colors(8),\n  ...chroma.brewer\n};\nfunction isColorSchemeStyleArray(colorScheme) {\n  return Array.isArray(colorScheme) && typeof colorScheme[0] === \"object\";\n}\nconst rangeHelper = (point2, attribute) => point2.map((r, i) => {\n  if (r) {\n    if (r[attribute] !== void 0) {\n      return r[attribute];\n    } else if (r.data && r.data[attribute] !== void 0) {\n      return r.data[attribute];\n    }\n  }\n  return i;\n});\nconst getColor = props => {\n  let {\n    point: point2,\n    colorScheme,\n    attribute,\n    index,\n    data,\n    active,\n    isMultiSeries,\n    domain,\n    key,\n    scale: scale2\n  } = {\n    attribute: \"key\",\n    isMultiSeries: false,\n    scale: scaleOrdinal,\n    ...props\n  };\n  if (typeof colorScheme === \"string\" && schemes[colorScheme]) {\n    colorScheme = schemes[colorScheme];\n  }\n  if (Array.isArray(colorScheme)) {\n    if (!domain) {\n      if (isMultiSeries && Array.isArray(data)) {\n        const maxIdx = maxIndex(data, d => d.data.length);\n        const maxVal = data[maxIdx];\n        data = maxVal.data;\n      }\n      domain = rangeHelper(data, attribute);\n    }\n    key = key !== void 0 ? key : point2[attribute];\n    return scale2(colorScheme).domain(domain)(key);\n  } else if (typeof colorScheme === \"function\") {\n    return colorScheme(point2, index, active);\n  } else {\n    return colorScheme;\n  }\n};\nconst getValueScale = (data, colorScheme, emptyColor, selections) => {\n  const valueDomain = extent$1(uniqueBy(data, d => d.data, d => d.value));\n  return point2 => {\n    if ((point2 == null ? void 0 : point2.value) === void 0 || (point2 == null ? void 0 : point2.value) === null) {\n      return emptyColor;\n    }\n    return getColor({\n      scale: scaleQuantile,\n      domain: valueDomain,\n      key: point2.value,\n      colorScheme,\n      point: point2,\n      active: selections\n    });\n  };\n};\nconst getColorSchemeStyles = (point2, valueScales) => Array.from(valueScales).reduce((acc, _ref48) => {\n  let [key, valueScale] = _ref48;\n  return {\n    ...acc,\n    [key]: valueScale(point2)\n  };\n}, {});\nconst getColorSchemeForProperty = (colorScheme, colorSchemeProperty) => colorScheme.map(schemeItem => schemeItem == null ? void 0 : schemeItem[colorSchemeProperty]);\nconst createColorSchemeValueScales = (data, colorScheme, emptyColor, selections) => {\n  const valueScales = /* @__PURE__ */new Map();\n  if (isColorSchemeStyleArray(colorScheme)) {\n    const colorSchemeProperties = [...new Set(colorScheme.flatMap(Object.keys))];\n    colorSchemeProperties.forEach(key => {\n      const valueScale = getValueScale(data, getColorSchemeForProperty(colorScheme, key), emptyColor, selections);\n      valueScales.set(key, valueScale);\n    });\n  } else {\n    valueScales.set(\"fill\", getValueScale(data, colorScheme, emptyColor, selections));\n  }\n  return valueScales;\n};\nconst COUNT_DEFAULTS = {\n  from: 0,\n  duration: 1,\n  delay: 0,\n  format: true,\n  decimalPlaces: 0\n};\nconst useCount = _ref49 => {\n  let {\n    from,\n    to,\n    duration,\n    delay,\n    prefix,\n    suffix,\n    decimalPlaces,\n    format\n  } = _ref49;\n  const nodeRef = useRef(null);\n  from = from || COUNT_DEFAULTS.from;\n  duration = duration || COUNT_DEFAULTS.duration;\n  delay = delay || COUNT_DEFAULTS.delay;\n  format = format || COUNT_DEFAULTS.format;\n  decimalPlaces = decimalPlaces || COUNT_DEFAULTS.decimalPlaces;\n  useEffect(() => {\n    const node2 = nodeRef.current;\n    const controls = animate(from, to, {\n      duration,\n      delay,\n      onUpdate(value2) {\n        let formatted = value2;\n        if (decimalPlaces) {\n          formatted = Number(value2.toFixed(decimalPlaces));\n        } else {\n          formatted = Number(value2.toFixed(0));\n        }\n        if (format) {\n          formatted = formatted.toLocaleString();\n        }\n        if (node2) {\n          if (prefix) {\n            formatted = \"\".concat(prefix).concat(formatted);\n          }\n          if (suffix) {\n            formatted = \"\".concat(formatted).concat(suffix);\n          }\n          node2.textContent = formatted;\n        }\n      }\n    });\n    return () => controls.stop();\n  }, [from, to, duration, delay, decimalPlaces, format, prefix, suffix]);\n  return nodeRef;\n};\nconst Count = _ref50 => {\n  let {\n    className,\n    ...rest\n  } = _ref50;\n  const ref = useCount(rest);\n  return /* @__PURE__ */jsx(\"span\", {\n    ref,\n    className\n  });\n};\nCount.defaultProps = {\n  from: 0,\n  duration: 1,\n  delay: 0,\n  localize: true,\n  decimalPlaces: 0\n};\nconst LinearValueMarker = _ref51 => {\n  let {\n    color,\n    value: value2,\n    className,\n    thickness = 1,\n    size,\n    direction = \"horizontal\"\n  } = _ref51;\n  const coordinates = direction === \"horizontal\" ? {\n    x1: 0,\n    y1: value2,\n    x2: size,\n    y2: value2\n  } : {\n    x1: value2,\n    y1: 0,\n    x2: value2,\n    y2: size\n  };\n  return /* @__PURE__ */jsx(\"line\", {\n    className,\n    stroke: color,\n    strokeWidth: thickness,\n    ...coordinates\n  });\n};\nconst RadialValueMarker = _ref52 => {\n  let {\n    color,\n    value: value2,\n    className,\n    thickness = 1\n  } = _ref52;\n  return /* @__PURE__ */jsx(\"circle\", {\n    className,\n    cx: 0,\n    cy: 0,\n    r: value2,\n    fill: \"none\",\n    stroke: color,\n    strokeWidth: thickness\n  });\n};\nconst inactive$1 = \"_inactive_jp2yc_1\";\nconst hidden$1 = \"_hidden_jp2yc_5\";\nconst css$g = {\n  inactive: inactive$1,\n  hidden: hidden$1\n};\nconst generateGlowStyles = _ref53 => {\n  let {\n    glow,\n    colorSchemeColor\n  } = _ref53;\n  if (!glow) return {};\n  let {\n    x = 0,\n    y = 0,\n    blur = 5,\n    color = colorSchemeColor || \"rgb(255, 255, 255, 0.25)\",\n    opacity = 1\n  } = glow;\n  color = chroma(color).alpha(opacity).css();\n  return blur ? {\n    filter: \"drop-shadow(\".concat(x, \"px \").concat(y, \"px \").concat(blur, \"px \").concat(color, \")\")\n  } : {};\n};\nconst ScatterPoint = _ref54 => {\n  let {\n    symbol: symbol2,\n    index,\n    id,\n    data,\n    xScale,\n    yScale,\n    active,\n    tooltip: tooltip2,\n    cursor,\n    size,\n    glow,\n    color,\n    animated,\n    onClick,\n    onMouseEnter,\n    onMouseLeave,\n    visible,\n    ...rest\n  } = _ref54;\n  const rectRef = useRef(null);\n  const [tooltipVisible, setTooltipVisible] = useState(false);\n  const extras = useMemo(() => constructFunctionProps(rest, data), [rest, data]);\n  const r = useMemo(() => typeof size === \"function\" ? size(data) : size, [size, data]);\n  const renderedSymbol = useMemo(() => symbol2 ? symbol2(data) : null, [data, symbol2]);\n  const transitionProps = useMemo(() => animated ? {\n    ...DEFAULT_TRANSITION,\n    delay: index * 5e-3\n  } : {\n    type: false,\n    delay: 0\n  }, [index, animated]);\n  const enterProps = useMemo(() => {\n    let cy = yScale(data.y1);\n    if (yScale.bandwidth) {\n      const width = yScale.bandwidth();\n      cy = cy + width / 2;\n    }\n    return {\n      x: xScale(data.x),\n      y: cy\n    };\n  }, [data, yScale]);\n  const exitProps = useMemo(() => {\n    const [yStartDomain] = yScale.domain();\n    return {\n      y: yScale(yStartDomain),\n      x: xScale(data.x)\n    };\n  }, [data, yScale]);\n  const fill = useMemo(() => getColor({\n    colorScheme: color,\n    index,\n    point: data\n  }), [data, color, index]);\n  const key = \"symbol-\".concat(id, \"-\").concat(identifier(\"\".concat(data.id)));\n  const ariaLabelData = useMemo(() => getAriaLabel(data), [data]);\n  const isVisible = visible ? visible == null ? void 0 : visible(data, index) : active;\n  return /* @__PURE__ */jsxs(Fragment, {\n    children: [/* @__PURE__ */jsx(\"g\", {\n      ref: rectRef,\n      className: classNames({\n        [css$g.inactive]: !active,\n        [css$g.hidden]: !isVisible\n      }),\n      onMouseEnter: () => {\n        setTooltipVisible(true);\n        onMouseEnter(data);\n      },\n      onMouseLeave: () => {\n        setTooltipVisible(false);\n        onMouseLeave(data);\n      },\n      onClick: () => onClick(data),\n      tabIndex: 0,\n      \"aria-label\": ariaLabelData,\n      role: \"graphics-document\",\n      children: symbol2 ? /* @__PURE__ */jsx(motion.g, {\n        ...extras,\n        initial: {\n          translateX: exitProps.x,\n          translateY: exitProps.y,\n          opacity: 0\n        },\n        animate: {\n          translateX: enterProps.x,\n          translateY: enterProps.y,\n          opacity: 1\n        },\n        exit: {\n          translateX: exitProps.x,\n          translateY: exitProps.y,\n          opacity: 0\n        },\n        transition: transitionProps,\n        children: renderedSymbol\n      }, key) : /* @__PURE__ */jsx(motion.circle, {\n        className: extras.className,\n        style: {\n          ...extras.style,\n          ...generateGlowStyles({\n            glow\n          }),\n          cursor\n        },\n        fill,\n        initial: {\n          cx: exitProps.x,\n          cy: exitProps.y,\n          r,\n          opacity: 0\n        },\n        animate: {\n          cx: enterProps.x,\n          cy: enterProps.y,\n          opacity: 1,\n          r\n        },\n        exit: {\n          cx: exitProps.x,\n          cy: exitProps.y,\n          r,\n          opacity: 0\n        },\n        transition: transitionProps\n      }, key)\n    }), tooltip2 && !tooltip2.props.disabled && /* @__PURE__ */jsx(CloneElement, {\n      element: tooltip2,\n      visible: tooltipVisible,\n      reference: rectRef,\n      value: data\n    })]\n  });\n};\nScatterPoint.defaultProps = {\n  active: true,\n  tooltip: /* @__PURE__ */jsx(ChartTooltip, {}),\n  cursor: \"pointer\",\n  size: 4,\n  color: schemes.cybertron[0],\n  animated: true,\n  onClick: () => void 0,\n  onMouseEnter: () => void 0,\n  onMouseLeave: () => void 0\n};\nconst PADDING$1 = 25;\nconst HALF_PADDING$1 = PADDING$1 / 2;\nconst ScatterSeries = _ref55 => {\n  let {\n    data,\n    height,\n    width,\n    id,\n    isZoomed,\n    activeIds,\n    point: point2,\n    valueMarkers,\n    xScale,\n    yScale,\n    ...rest\n  } = _ref55;\n  const renderPoint = useCallback((pointData, index) => {\n    let pointId;\n    if (pointData.id) {\n      pointId = pointData.id;\n    }\n    const key = identifier(\"\".concat(pointId || index));\n    const active = !(activeIds && activeIds.length) || activeIds.includes(pointId);\n    return /* @__PURE__ */jsx(CloneElement, {\n      element: point2,\n      xScale,\n      yScale,\n      ...rest,\n      id,\n      data: pointData,\n      index,\n      active\n    }, key);\n  }, [activeIds, point2, yScale, rest, id]);\n  const renderValueMarkers = useCallback(() => /* @__PURE__ */jsx(Fragment$1, {\n    children: (valueMarkers == null ? void 0 : valueMarkers.length) && valueMarkers.map(marker2 => {\n      var _a;\n      const isVertical = ((_a = marker2 == null ? void 0 : marker2.props) == null ? void 0 : _a.direction) === \"vertical\";\n      const size = isVertical ? height : width;\n      const value2 = isVertical ? xScale(marker2.props.value) : yScale(marker2.props.value);\n      return /* @__PURE__ */jsx(CloneElement, {\n        element: marker2,\n        size,\n        value: value2\n      }, marker2.key);\n    })\n  }), [valueMarkers, width, yScale]);\n  return /* @__PURE__ */jsxs(Fragment, {\n    children: [/* @__PURE__ */jsx(\"defs\", {\n      children: /* @__PURE__ */jsx(\"clipPath\", {\n        id: \"\".concat(id, \"-path\"),\n        children: /* @__PURE__ */jsx(\"rect\", {\n          width: isZoomed ? width : width + PADDING$1,\n          height: height + PADDING$1,\n          x: isZoomed ? 0 : -HALF_PADDING$1,\n          y: -HALF_PADDING$1\n        })\n      })\n    }), renderValueMarkers(), /* @__PURE__ */jsx(\"g\", {\n      clipPath: \"url(#\".concat(id, \"-path)\"),\n      children: data.map(renderPoint)\n    })]\n  });\n};\nScatterSeries.defaultProps = {\n  point: /* @__PURE__ */jsx(ScatterPoint, {})\n};\nconst scatterPlot = \"_scatterPlot_gc5eo_1\";\nconst css$f = {\n  scatterPlot\n};\nconst ScatterPlot = _ref56 => {\n  let {\n    id,\n    width,\n    height,\n    margins,\n    className,\n    series,\n    xAxis,\n    yAxis,\n    data,\n    gridlines,\n    containerClassName,\n    brush,\n    zoomPan,\n    secondaryAxis\n  } = _ref56;\n  const zoomControlled = useMemo(() => {\n    var _a, _b;\n    return (\n      // eslint-disable-next-line\n      !((_b = (_a = zoomPan == null ? void 0 : zoomPan.props) == null ? void 0 : _a.domain) == null ? void 0 : _b.hasOwnProperty(\"domain\"))\n    );\n  }, [zoomPan]);\n  const timeout = useRef(null);\n  const [preventAnimation, setPreventAnimation] = useState(false);\n  const [zoomDomain, setZoomDomain] = useState(null);\n  const [isZoomed, setIsZoomed] = useState(false);\n  const aggregatedData = useMemo(() => buildShallowChartData(data), [data]);\n  const getScales = useCallback((chartHeight, chartWidth) => {\n    const yScale = getYScale({\n      roundDomains: yAxis.props.roundDomains,\n      type: yAxis.props.type,\n      height: chartHeight,\n      data: aggregatedData,\n      domain: yAxis.props.domain\n    });\n    const xScale = getXScale({\n      width: chartWidth,\n      type: xAxis.props.type,\n      roundDomains: xAxis.props.roundDomains,\n      data: aggregatedData,\n      domain: zoomDomain || xAxis.props.domain\n    });\n    return {\n      yScale,\n      xScale\n    };\n  }, [yAxis, xAxis, aggregatedData, zoomDomain]);\n  const onZoomPan = useCallback(event => {\n    if (zoomControlled) {\n      setPreventAnimation(true);\n      setZoomDomain(event.domain);\n      setIsZoomed(event.isZoomed);\n      clearTimeout(timeout.current);\n      timeout.current = setTimeout(() => setPreventAnimation(true), 500);\n    }\n  }, [zoomControlled]);\n  const renderChart = useCallback(_ref57 => {\n    let {\n      chartHeight,\n      chartWidth,\n      id: id2,\n      updateAxes,\n      chartSized\n    } = _ref57;\n    const {\n      yScale,\n      xScale\n    } = getScales(chartHeight, chartWidth);\n    const animated = preventAnimation === true ? false : series.props.animated;\n    const disableBrush = aggregatedData.length <= 1;\n    return /* @__PURE__ */jsxs(Fragment, {\n      children: [chartSized && gridlines && /* @__PURE__ */jsx(CloneElement, {\n        element: gridlines,\n        height: chartHeight,\n        width: chartWidth,\n        yScale,\n        xScale,\n        yAxis: yAxis.props,\n        xAxis: xAxis.props\n      }), /* @__PURE__ */jsx(CloneElement, {\n        element: xAxis,\n        height: chartHeight,\n        width: chartWidth,\n        scale: xScale,\n        visibility: chartSized ? \"visible\" : \"hidden\",\n        onDimensionsChange: e => updateAxes(\"horizontal\", e)\n      }), /* @__PURE__ */jsx(CloneElement, {\n        element: yAxis,\n        height: chartHeight,\n        width: chartWidth,\n        scale: yScale,\n        visibility: chartSized ? \"visible\" : \"hidden\",\n        onDimensionsChange: e => updateAxes(\"vertical\", e)\n      }), secondaryAxis && secondaryAxis.map((axis, i) => /* @__PURE__ */jsx(CloneElement, {\n        element: axis,\n        height: chartHeight,\n        width: chartWidth,\n        visibility: chartSized ? \"visible\" : \"hidden\",\n        onDimensionsChange: e => updateAxes(\"horizontal\", e)\n      }, i)), chartSized && /* @__PURE__ */jsx(CloneElement, {\n        disabled: disableBrush,\n        element: brush,\n        height: chartHeight,\n        width: chartWidth,\n        scale: xScale,\n        children: /* @__PURE__ */jsx(CloneElement, {\n          element: zoomPan,\n          onZoomPan,\n          height: chartHeight,\n          width: chartWidth,\n          axisType: xAxis.props.type,\n          roundDomains: xAxis.props.roundDomains,\n          data: aggregatedData,\n          domain: zoomDomain,\n          children: /* @__PURE__ */jsx(CloneElement, {\n            element: series,\n            id: \"area-series-\".concat(id2),\n            data: aggregatedData,\n            height: chartHeight,\n            width: chartWidth,\n            yScale,\n            xScale,\n            isZoomed,\n            animated\n          })\n        })\n      })]\n    });\n  }, [getScales, preventAnimation, series, gridlines, yAxis, xAxis, secondaryAxis, brush, zoomPan, onZoomPan, aggregatedData, zoomDomain, isZoomed]);\n  return /* @__PURE__ */jsx(ChartContainer, {\n    id,\n    width,\n    height,\n    containerClassName,\n    margins,\n    xAxisVisible: isAxisVisible(xAxis.props),\n    yAxisVisible: isAxisVisible(yAxis.props),\n    className: classNames(css$f.scatterPlot, className),\n    children: renderChart\n  });\n};\nScatterPlot.defaultProps = {\n  data: [],\n  xAxis: /* @__PURE__ */jsx(LinearXAxis, {\n    type: \"time\"\n  }),\n  yAxis: /* @__PURE__ */jsx(LinearYAxis, {\n    type: \"value\"\n  }),\n  series: /* @__PURE__ */jsx(ScatterSeries, {}),\n  gridlines: /* @__PURE__ */jsx(GridlineSeries, {}),\n  brush: null,\n  zoomPan: null\n};\nconst point = \"_point_u68jv_1\";\nconst css$e = {\n  point\n};\nconst PointSeries = _ref58 => {\n  let {\n    data,\n    xScale,\n    yScale,\n    animated,\n    point: point2,\n    color,\n    height,\n    width,\n    id,\n    activeValues,\n    show\n  } = _ref58;\n  const getIsVisible = useCallback((point22, index) => {\n    const isActive = activeValues && point22 && isEqual(activeValues.x, point22.x);\n    if (show === \"hover\") {\n      return isActive;\n    } else if (show === \"first\") {\n      if (activeValues) {\n        return isActive;\n      } else {\n        return index === 0;\n      }\n    } else if (show === \"last\") {\n      if (activeValues) {\n        return isActive;\n      } else {\n        return index === data.length - 1;\n      }\n    }\n    return show;\n  }, [activeValues, data.length, show]);\n  return /* @__PURE__ */jsx(ScatterSeries, {\n    height,\n    width,\n    id,\n    animated,\n    data,\n    xScale,\n    yScale,\n    point: /* @__PURE__ */jsx(CloneElement, {\n      element: point2,\n      color,\n      className: css$e.point,\n      size: 4,\n      tooltip: null,\n      visible: getIsVisible\n    })\n  });\n};\nPointSeries.defaultProps = {\n  show: \"hover\",\n  point: /* @__PURE__ */jsx(ScatterPoint, {})\n};\nconst Area = _ref59 => {\n  let {\n    id,\n    gradient: gradient2,\n    glow,\n    mask,\n    data,\n    color,\n    index,\n    total,\n    xScale,\n    yScale,\n    animated,\n    interpolation,\n    ...rest\n  } = _ref59;\n  const stroke = color(data, index);\n  const coords = useMemo(() => {\n    return data.map(item2 => ({\n      x: xScale(item2.x),\n      x1: xScale(item2.x) - xScale(item2.x1),\n      y: yScale(item2.y),\n      y0: yScale(item2.y0),\n      y1: yScale(item2.y1)\n    }));\n  }, [data, xScale, yScale]);\n  const getAreaPath = useCallback(d => {\n    if (d.length === 1 && total === 1) {\n      const [point2] = d;\n      const midpoint = point2.x;\n      d = [{\n        ...point2\n      }, {\n        ...point2\n      }];\n      const [start2, end2] = d;\n      start2.x = 0;\n      end2.x = midpoint * 2;\n    }\n    const fn = area().x(d2 => d2.x).y0(d2 => d2.y0).y1(d2 => d2.y1).curve(interpolate(interpolation));\n    return fn(d);\n  }, [interpolation, total]);\n  const enter = useMemo(() => {\n    const areaPath = getAreaPath(coords);\n    return {\n      d: areaPath === null ? void 0 : areaPath\n    };\n  }, [coords, getAreaPath]);\n  const exit = useMemo(() => {\n    const maxY = Math.max(...yScale.range());\n    const coords2 = data.map(item2 => ({\n      x: xScale(item2.x),\n      x1: 0,\n      y: 0,\n      y1: maxY,\n      y0: maxY\n    }));\n    const areaPath = getAreaPath(coords2);\n    return {\n      d: areaPath === null ? void 0 : areaPath\n    };\n  }, [data, getAreaPath, xScale, yScale]);\n  const fill = useMemo(() => {\n    if (mask) {\n      return \"url(#mask-pattern-\".concat(id, \")\");\n    } else {\n      if (gradient2) {\n        return \"url(#gradient-\".concat(id, \")\");\n      }\n      return \"\";\n    }\n  }, [gradient2, id, mask]);\n  const transition = useMemo(() => {\n    if (animated) {\n      return {\n        ...DEFAULT_TRANSITION,\n        delay: index * 0.05\n      };\n    } else {\n      return {\n        type: false,\n        delay: 0\n      };\n    }\n  }, [animated, index]);\n  const renderArea = useCallback(() => {\n    const maskPath = mask ? \"url(#mask-\".concat(id, \")\") : \"\";\n    const extras = constructFunctionProps(rest, data);\n    return /* @__PURE__ */jsx(MotionPath, {\n      ...extras,\n      pointerEvents: \"none\",\n      mask: maskPath,\n      fill,\n      transition,\n      custom: {\n        enter,\n        exit\n      },\n      style: {\n        ...extras.style,\n        ...generateGlowStyles({\n          glow,\n          colorSchemeColor: stroke\n        })\n      }\n    });\n  }, [data, enter, exit, fill, glow, id, mask, rest, stroke, transition]);\n  return /* @__PURE__ */jsxs(Fragment, {\n    children: [renderArea(), mask && /* @__PURE__ */jsxs(Fragment, {\n      children: [/* @__PURE__ */jsx(Mask, {\n        id: \"mask-\".concat(id),\n        fill: \"url(#gradient-\".concat(id, \")\")\n      }), /* @__PURE__ */jsx(CloneElement, {\n        element: mask,\n        id: \"mask-pattern-\".concat(id),\n        fill: stroke\n      })]\n    }), gradient2 && /* @__PURE__ */jsx(CloneElement, {\n      element: gradient2,\n      id: \"gradient-\".concat(id),\n      color: stroke\n    })]\n  });\n};\nArea.defaultProps = {\n  gradient: /* @__PURE__ */jsx(Gradient, {}),\n  interpolation: \"linear\"\n};\nconst Line = _ref60 => {\n  let {\n    id,\n    width,\n    data,\n    color,\n    index,\n    strokeWidth,\n    hasArea,\n    animated,\n    yScale,\n    xScale,\n    showZeroStroke,\n    interpolation,\n    gradient: gradient2,\n    glow,\n    ...rest\n  } = _ref60;\n  const [pathLength, setPathLength] = useState(null);\n  const ghostPathRef = useRef(null);\n  useEffect(() => {\n    if (ghostPathRef.current) {\n      setPathLength(ghostPathRef.current.getTotalLength());\n    }\n  }, [data, xScale, yScale, width]);\n  const getLinePath = useCallback(point2 => {\n    const fn = line$1().x(d => d.x).y(d => d.y1).defined(d => showZeroStroke || calculateShowStroke(d, point2)).curve(interpolate(interpolation));\n    return fn(point2);\n  }, [interpolation, showZeroStroke]);\n  const transition = useMemo(() => {\n    if (animated) {\n      return {\n        ...DEFAULT_TRANSITION,\n        delay: hasArea ? 0 : index * 0.05\n      };\n    } else {\n      return {\n        type: false,\n        delay: 0\n      };\n    }\n  }, [animated, hasArea, index]);\n  const coords = useMemo(() => {\n    return data.map(item2 => ({\n      x: xScale(item2.x),\n      x1: xScale(item2.x) - xScale(item2.x1),\n      y: yScale(item2.y),\n      y0: yScale(item2.y0),\n      y1: yScale(item2.y1)\n    }));\n  }, [data, xScale, yScale]);\n  const enter = useMemo(() => {\n    const linePath = getLinePath(coords);\n    let strokeDasharray = \"\";\n    if (!hasArea && pathLength !== null) {\n      strokeDasharray = \"\".concat(pathLength, \" \").concat(pathLength);\n    }\n    return {\n      d: linePath === null ? void 0 : linePath,\n      strokeDashoffset: 0,\n      strokeDasharray\n    };\n  }, [coords, getLinePath, hasArea, pathLength]);\n  const exit = useMemo(() => {\n    let newCoords = coords;\n    if (hasArea) {\n      const maxY = Math.max(...yScale.range());\n      newCoords = data.map(item2 => ({\n        x: xScale(item2.x),\n        x1: 0,\n        y: maxY,\n        y1: maxY,\n        y0: maxY\n      }));\n    }\n    const linePath = getLinePath(newCoords);\n    let strokeDasharray = \"\";\n    let strokeDashoffset = 0;\n    if (!hasArea && pathLength !== null) {\n      strokeDasharray = \"\".concat(pathLength, \" \").concat(pathLength);\n      strokeDashoffset = pathLength;\n    }\n    return {\n      d: linePath === null ? void 0 : linePath,\n      strokeDasharray,\n      strokeDashoffset\n    };\n  }, [coords, data, getLinePath, hasArea, pathLength, xScale, yScale]);\n  const stroke = color(data, index);\n  const extras = constructFunctionProps(rest, data);\n  const showLine = hasArea || pathLength !== null;\n  const strokeFill = useMemo(() => {\n    if (gradient2) {\n      return \"url(#gradient-\".concat(id, \")\");\n    }\n    return stroke;\n  }, [gradient2, id]);\n  if (hasArea) {\n    delete enter.strokeDashoffset;\n    delete exit.strokeDashoffset;\n  }\n  return /* @__PURE__ */jsxs(Fragment, {\n    children: [showLine && /* @__PURE__ */jsx(MotionPath, {\n      ...extras,\n      pointerEvents: \"none\",\n      stroke: strokeFill,\n      strokeWidth,\n      fill: \"none\",\n      transition,\n      custom: {\n        enter,\n        exit\n      },\n      style: {\n        ...extras.style,\n        ...generateGlowStyles({\n          glow,\n          colorSchemeColor: strokeFill\n        })\n      }\n    }), !hasArea && /* @__PURE__ */jsx(\"path\", {\n      opacity: \"0\",\n      d: enter.d,\n      ref: ghostPathRef,\n      pointerEvents: \"none\"\n    }), gradient2 && /* @__PURE__ */jsx(CloneElement, {\n      element: gradient2,\n      id: \"gradient-\".concat(id),\n      color: stroke\n    })]\n  });\n};\nLine.defaultProps = {\n  showZeroStroke: true,\n  strokeWidth: 3\n};\nconst PADDING = 25;\nconst HALF_PADDING = PADDING / 2;\nconst AreaSeries = _ref61 => {\n  let {\n    data,\n    height,\n    id,\n    width,\n    isZoomed,\n    tooltip: tooltip2,\n    xScale,\n    yScale,\n    type,\n    markLine: markLine2,\n    symbols,\n    animated,\n    area: area2,\n    interpolation,\n    line: line2,\n    colorScheme,\n    valueMarkers\n  } = _ref61;\n  const [activeValues, setActiveValues] = useState(null);\n  const [activePoint, setActivePoint] = useState(null);\n  const onValueEnter = useCallback(event => {\n    setActivePoint(event.pointX);\n    setActiveValues(event.value);\n  }, []);\n  const onValueLeave = useCallback(() => {\n    setActivePoint(void 0);\n    setActiveValues(void 0);\n  }, []);\n  const isMulti = type === \"grouped\" || type === \"stacked\" || type === \"stackedNormalized\";\n  const getPointColor = useCallback((point2, index) => {\n    var _a;\n    const key = Array.isArray(point2) ? (_a = point2 == null ? void 0 : point2[0]) == null ? void 0 : _a.key : point2 == null ? void 0 : point2.key;\n    return getColor({\n      data,\n      colorScheme,\n      active: activeValues,\n      point: point2,\n      index,\n      key\n    });\n  }, [activeValues, colorScheme, data]);\n  const renderArea = useCallback(function (data2) {\n    let index = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    let total = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n    return /* @__PURE__ */jsxs(Fragment, {\n      children: [line2 && /* @__PURE__ */jsx(CloneElement, {\n        element: line2,\n        xScale,\n        yScale,\n        data: data2,\n        width,\n        index,\n        hasArea: area2 !== null,\n        animated,\n        interpolation,\n        color: getPointColor\n      }), area2 && /* @__PURE__ */jsx(CloneElement, {\n        element: area2,\n        id: \"\".concat(id, \"-area-\").concat(index),\n        xScale,\n        yScale,\n        data: data2,\n        index,\n        total,\n        animated,\n        interpolation,\n        color: getPointColor\n      })]\n    });\n  }, [animated, area2, getPointColor, id, interpolation, line2, width, xScale, yScale]);\n  const renderSymbols = useCallback(function (data2) {\n    let index = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    const visible = symbols !== null;\n    const activeSymbols = symbols && symbols.props.activeValues || activeValues;\n    const isAnimated = area2 !== void 0 && animated && !activeSymbols;\n    return /* @__PURE__ */jsx(Fragment, {\n      children: visible && /* @__PURE__ */jsx(CloneElement, {\n        element: symbols,\n        id,\n        height,\n        width,\n        activeValues: activeSymbols,\n        xScale,\n        yScale,\n        index,\n        data: data2,\n        animated: isAnimated,\n        color: () => getPointColor(data2, index)\n      }, \"point-series-\".concat(id))\n    });\n  }, [activeValues, animated, area2, getPointColor, height, id, symbols, width, xScale, yScale]);\n  const renderMarkLine = useCallback(() => /* @__PURE__ */jsx(Fragment$1, {\n    children: activeValues && markLine2 && /* @__PURE__ */jsx(CloneElement, {\n      element: markLine2,\n      height,\n      pointX: activePoint\n    })\n  }), [activePoint, activeValues, height, markLine2]);\n  const renderSingleSeries = useCallback(data2 => /* @__PURE__ */jsxs(Fragment, {\n    children: [renderArea(data2), renderMarkLine(), renderSymbols(data2)]\n  }), [renderArea, renderMarkLine, renderSymbols]);\n  const renderMultiSeries = useCallback(data2 => /* @__PURE__ */jsxs(Fragment, {\n    children: [data2.map((point2, index) => /* @__PURE__ */jsx(Fragment, {\n      children: renderArea(point2.data, index, data2.length)\n    }, identifier(\"\".concat(point2.key)))).reverse(), renderMarkLine(), data2.map((point2, index) => /* @__PURE__ */jsx(Fragment, {\n      children: renderSymbols(point2.data, index)\n    }, identifier(\"\".concat(point2.key)))).reverse()]\n  }), [renderArea, renderMarkLine, renderSymbols]);\n  const renderValueMarkers = useCallback(() => /* @__PURE__ */jsx(Fragment$1, {\n    children: (valueMarkers == null ? void 0 : valueMarkers.length) && valueMarkers.map(marker2 => {\n      var _a;\n      const isVertical = ((_a = marker2 == null ? void 0 : marker2.props) == null ? void 0 : _a.direction) === \"vertical\";\n      const size = isVertical ? height : width;\n      const value2 = isVertical ? xScale(marker2.props.value) : yScale(marker2.props.value);\n      return /* @__PURE__ */jsx(CloneElement, {\n        element: marker2,\n        size,\n        value: value2\n      }, marker2.key);\n    })\n  }), [valueMarkers, width, yScale]);\n  return /* @__PURE__ */jsxs(Fragment, {\n    children: [/* @__PURE__ */jsx(\"defs\", {\n      children: /* @__PURE__ */jsx(\"clipPath\", {\n        id: \"\".concat(id, \"-path\"),\n        children: /* @__PURE__ */jsx(\"rect\", {\n          width: isZoomed ? width : width + PADDING,\n          height: height + PADDING,\n          x: isZoomed ? 0 : -HALF_PADDING,\n          y: -HALF_PADDING\n        })\n      })\n    }), /* @__PURE__ */jsx(CloneElement, {\n      element: tooltip2,\n      xScale,\n      yScale,\n      data,\n      height,\n      width,\n      color: getPointColor,\n      onValueEnter,\n      onValueLeave,\n      children: /* @__PURE__ */jsxs(\"g\", {\n        clipPath: \"url(#\".concat(id, \"-path)\"),\n        children: [isMulti && renderMultiSeries(data), !isMulti && renderSingleSeries(data), renderValueMarkers()]\n      })\n    })]\n  });\n};\nAreaSeries.defaultProps = {\n  colorScheme: \"cybertron\",\n  animated: true,\n  interpolation: \"linear\",\n  type: \"standard\",\n  line: /* @__PURE__ */jsx(Line, {}),\n  area: /* @__PURE__ */jsx(Area, {}),\n  markLine: /* @__PURE__ */jsx(MarkLine, {}),\n  tooltip: /* @__PURE__ */jsx(TooltipArea, {}),\n  symbols: /* @__PURE__ */jsx(PointSeries, {})\n};\nconst StackedNormalizedAreaSeries = _ref62 => {\n  let {\n    type,\n    symbols,\n    ...rest\n  } = _ref62;\n  return /* @__PURE__ */jsx(AreaSeries, {\n    ...rest,\n    type: \"stackedNormalized\",\n    symbols: symbols && /* @__PURE__ */jsx(CloneElement, {\n      element: symbols,\n      ...symbols.props,\n      point: /* @__PURE__ */jsx(CloneElement, {\n        element: symbols.props.point,\n        ...symbols.props.point.props,\n        tooltip: null\n      })\n    })\n  });\n};\nStackedNormalizedAreaSeries.defaultProps = {\n  ...AreaSeries.defaultProps,\n  type: \"stackedNormalized\",\n  tooltip: /* @__PURE__ */jsx(TooltipArea, {\n    tooltip: /* @__PURE__ */jsx(ChartTooltip, {\n      content: (series, color) => {\n        if (!series) {\n          return null;\n        }\n        const value2 = {\n          ...series,\n          data: series.data.map(d => ({\n            ...d,\n            value: \"\".concat(formatValue(d.value), \" \\u2219 \").concat(formatValue(Math.floor((d.y1 - d.y0) * 100)), \"%\")\n          }))\n        };\n        return /* @__PURE__ */jsx(TooltipTemplate, {\n          color,\n          value: value2\n        });\n      }\n    })\n  })\n};\nconst StackedAreaSeries = _ref63 => {\n  let {\n    type,\n    symbols,\n    ...rest\n  } = _ref63;\n  return /* @__PURE__ */jsx(AreaSeries, {\n    ...rest,\n    type: \"stacked\",\n    symbols: symbols && /* @__PURE__ */jsx(CloneElement, {\n      element: symbols,\n      ...symbols.props,\n      point: /* @__PURE__ */jsx(CloneElement, {\n        element: symbols.props.point,\n        ...symbols.props.point.props,\n        tooltip: null\n      })\n    })\n  });\n};\nStackedAreaSeries.defaultProps = {\n  ...AreaSeries.defaultProps,\n  type: \"stacked\"\n};\nconst areaChart = \"_areaChart_yyojn_1\";\nconst css$d = {\n  areaChart\n};\nconst AreaChart = _ref64 => {\n  let {\n    xAxis,\n    yAxis,\n    id,\n    data,\n    width,\n    height,\n    margins,\n    className,\n    containerClassName,\n    series,\n    gridlines,\n    brush,\n    zoomPan,\n    secondaryAxis\n  } = _ref64;\n  const zoom = zoomPan ? zoomPan.props : {};\n  const [zoomDomain, setZoomDomain] = useState(zoom.domain);\n  const [preventAnimation, setPreventAnimation] = useState(false);\n  const [isZoomed, setIsZoomed] = useState(!!zoom.domain);\n  const [zoomControlled] = useState(!zoom.hasOwnProperty(\"domain\"));\n  const timeoutRef = useRef(null);\n  const seriesType = series.props.type;\n  const isMultiSeries = seriesType === \"stacked\" || seriesType === \"stackedNormalized\" || seriesType === \"grouped\";\n  const animated = preventAnimation === true ? false : series.props.animated;\n  useEffect(() => {\n    if (zoomPan) {\n      const zoom2 = zoomPan.props;\n      if (!zoomControlled && zoom2.domain !== zoomDomain) {\n        setZoomDomain(zoom2.domain);\n        setIsZoomed(!!zoom2.domain);\n      }\n    }\n  }, [zoomControlled, zoomDomain, zoomPan]);\n  const aggregatedData = useMemo(() => {\n    if (seriesType === \"stacked\" || seriesType === \"stackedNormalized\") {\n      return buildStackData(data, seriesType === \"stackedNormalized\");\n    } else if (seriesType === \"grouped\") {\n      return buildNestedChartData(data, true);\n    } else {\n      return buildShallowChartData(data);\n    }\n  }, [data, seriesType]);\n  const getScales = useCallback((chartWidth, chartHeight) => {\n    const xScale = getXScale({\n      width: chartWidth,\n      type: xAxis.props.type,\n      roundDomains: xAxis.props.roundDomains,\n      data: aggregatedData,\n      domain: zoomDomain || xAxis.props.domain,\n      isMultiSeries\n    });\n    const yScale = getYScale({\n      roundDomains: yAxis.props.roundDomains,\n      type: yAxis.props.type,\n      height: chartHeight,\n      data: aggregatedData,\n      domain: yAxis.props.domain,\n      isMultiSeries\n    });\n    return {\n      xScale,\n      yScale\n    };\n  }, [aggregatedData, isMultiSeries, xAxis.props.domain, xAxis.props.roundDomains, xAxis.props.type, yAxis.props.domain, yAxis.props.roundDomains, yAxis.props.type, zoomDomain]);\n  const onZoomPan = useCallback(event => {\n    if (zoomControlled) {\n      setZoomDomain(event.domain);\n      setIsZoomed(event.isZoomed);\n      setPreventAnimation(true);\n      clearTimeout(timeoutRef.current);\n      timeoutRef.current = setTimeout(() => setPreventAnimation(false));\n    }\n  }, [zoomControlled]);\n  const renderChart = useCallback(_ref65 => {\n    let {\n      chartHeight,\n      chartWidth,\n      id: id2,\n      updateAxes,\n      chartSized\n    } = _ref65;\n    const {\n      xScale,\n      yScale\n    } = getScales(chartWidth, chartHeight);\n    const disableBrush = aggregatedData.length <= 1;\n    return /* @__PURE__ */jsxs(Fragment, {\n      children: [chartSized && gridlines && /* @__PURE__ */jsx(CloneElement, {\n        element: gridlines,\n        height: chartHeight,\n        width: chartWidth,\n        yScale,\n        xScale,\n        yAxis: yAxis.props,\n        xAxis: xAxis.props\n      }), /* @__PURE__ */jsx(CloneElement, {\n        element: xAxis,\n        height: chartHeight,\n        width: chartWidth,\n        scale: xScale,\n        visibility: chartSized ? \"visible\" : \"hidden\",\n        onDimensionsChange: event => updateAxes(\"horizontal\", event)\n      }), /* @__PURE__ */jsx(CloneElement, {\n        element: yAxis,\n        height: chartHeight,\n        width: chartWidth,\n        scale: yScale,\n        visibility: chartSized ? \"visible\" : \"hidden\",\n        onDimensionsChange: event => updateAxes(\"vertical\", event)\n      }), secondaryAxis && secondaryAxis.map((axis, i) => /* @__PURE__ */jsx(CloneElement, {\n        element: axis,\n        height: chartHeight,\n        width: chartWidth,\n        visibility: chartSized ? \"visible\" : \"hidden\",\n        onDimensionsChange: event => updateAxes(\"horizontal\", event)\n      }, i)), chartSized && /* @__PURE__ */jsx(CloneElement, {\n        disabled: disableBrush,\n        element: brush,\n        height: chartHeight,\n        width: chartWidth,\n        scale: xScale,\n        children: /* @__PURE__ */jsx(CloneElement, {\n          element: zoomPan,\n          onZoomPan,\n          height: chartHeight,\n          width: chartWidth,\n          axisType: xAxis.props.type,\n          roundDomains: xAxis.props.roundDomains,\n          data: aggregatedData,\n          domain: zoomDomain,\n          children: /* @__PURE__ */jsx(CloneElement, {\n            element: series,\n            id: \"area-series-\".concat(id2),\n            data: aggregatedData,\n            height: chartHeight,\n            width: chartWidth,\n            yScale,\n            xScale,\n            isZoomed,\n            animated\n          })\n        })\n      })]\n    });\n  }, [aggregatedData, animated, brush, getScales, gridlines, isZoomed, onZoomPan, secondaryAxis, series, xAxis, yAxis, zoomDomain, zoomPan]);\n  return /* @__PURE__ */jsx(ChartContainer, {\n    id,\n    width,\n    height,\n    margins,\n    containerClassName,\n    xAxisVisible: isAxisVisible(xAxis.props),\n    yAxisVisible: isAxisVisible(yAxis.props),\n    className: classNames(css$d.areaChart, className, series.type),\n    children: renderChart\n  });\n};\nAreaChart.defaultProps = {\n  data: [],\n  xAxis: /* @__PURE__ */jsx(LinearXAxis, {\n    type: \"time\"\n  }),\n  yAxis: /* @__PURE__ */jsx(LinearYAxis, {\n    type: \"value\"\n  }),\n  series: /* @__PURE__ */jsx(AreaSeries, {}),\n  gridlines: /* @__PURE__ */jsx(GridlineSeries, {}),\n  brush: null,\n  zoomPan: null\n};\nconst StackedAreaChart = props => /* @__PURE__ */jsx(AreaChart, {\n  ...props\n});\nStackedAreaChart.defaultProps = {\n  series: /* @__PURE__ */jsx(StackedAreaSeries, {})\n};\nconst StackedNormalizedAreaChart = props => /* @__PURE__ */jsx(AreaChart, {\n  ...props\n});\nStackedNormalizedAreaChart.defaultProps = {\n  series: /* @__PURE__ */jsx(StackedNormalizedAreaSeries, {}),\n  yAxis: /* @__PURE__ */jsx(LinearYAxis, {\n    type: \"value\",\n    tickSeries: /* @__PURE__ */jsx(LinearYAxisTickSeries, {\n      label: /* @__PURE__ */jsx(LinearYAxisTickLabel, {\n        rotation: false,\n        format: data => \"\".concat(data * 100, \"%\")\n      })\n    })\n  })\n};\nconst Bar = _ref66 => {\n  let {\n    activeBrightness,\n    id,\n    gradient: gradient2,\n    data,\n    barIndex,\n    color,\n    yScale,\n    barCount,\n    glow,\n    xScale,\n    groupIndex,\n    minHeight,\n    rangeLines,\n    animated,\n    active,\n    type,\n    tooltip: tooltip2,\n    layout: layout2,\n    mask,\n    label: label2,\n    cursor,\n    rx,\n    ry,\n    isCategorical,\n    className,\n    style,\n    width,\n    padding,\n    guide,\n    xScale1,\n    onMouseEnter,\n    onClick,\n    onMouseMove,\n    onMouseLeave\n  } = _ref66;\n  const isVertical = useMemo(() => layout2 === \"vertical\", [layout2]);\n  const rect = useRef(null);\n  const [internalActive, setInternalActive] = useState(active);\n  const calculateLinearScalePadding = useCallback((scale22, offset, size) => {\n    const totalSize = scale22.range()[1];\n    const sizeMinusPadding = totalSize - padding * (barCount - 1);\n    const multiplier = sizeMinusPadding / totalSize;\n    offset = offset * multiplier + groupIndex * padding;\n    size = size * multiplier;\n    return {\n      size,\n      offset\n    };\n  }, [barCount, groupIndex, padding]);\n  const getExit = useCallback(_ref67 => {\n    let {\n      x,\n      y,\n      width: width2,\n      height\n    } = _ref67;\n    let newX = isVertical ? x : Math.min(...xScale.range());\n    let newY = isVertical ? Math.max(...yScale.range()) : y;\n    const newHeight = isVertical ? 0 : height;\n    const newWidth = isVertical ? width2 : 0;\n    if (type === \"stackedDiverging\") {\n      if (isVertical) {\n        newY = newY / 2;\n      } else {\n        newX = newX / 2;\n      }\n    }\n    return {\n      x: newX,\n      y: newY,\n      height: newHeight,\n      width: newWidth\n    };\n  }, [isVertical, type, xScale, yScale]);\n  const getKeyCoords = useCallback((v, v0, v1, scale22, sizeOverride, isCategorical2, padding2) => {\n    let offset;\n    let size;\n    if (isCategorical2) {\n      if (scale22.bandwidth) {\n        offset = scale22(v);\n        size = scale22.bandwidth();\n        if (sizeOverride) {\n          if (offset) {\n            offset = offset + size / 2 - sizeOverride / 2;\n          } else {\n            offset = size / 2 - sizeOverride / 2;\n          }\n          size = sizeOverride;\n        }\n      } else {\n        if (sizeOverride) {\n          throw new Error(\"Not a valid option for this scale type\");\n        }\n        offset = scale22(v0);\n        size = scale22(v1 - v0);\n        if (padding2) {\n          const calc = calculateLinearScalePadding(scale22, offset, size);\n          offset = calc.offset;\n          size = calc.size;\n        }\n      }\n    } else {\n      if (sizeOverride) {\n        throw new Error(\"Not a valid option for this scale type\");\n      }\n      const c0 = scale22(v0);\n      const c1 = scale22(v1);\n      const delta = c1 - c0;\n      offset = c0;\n      size = Math.max(delta - 1, 0);\n    }\n    return {\n      offset: isNaN(offset) ? 0 : offset,\n      size: isNaN(size) ? 0 : size\n    };\n  }, [calculateLinearScalePadding]);\n  const getValueCoords = useCallback((v0, v1, scale22) => {\n    const c0 = scale22(v0);\n    const c1 = scale22(v1);\n    const size = Math.abs(c0 - c1);\n    const minSize = Math.max(minHeight || 0, size);\n    const offset = Math.min(c0, c1);\n    return {\n      offset: isNaN(offset) ? 0 : offset,\n      size: isNaN(minSize) ? 0 : minSize\n    };\n  }, [minHeight]);\n  const getCoords = useCallback(data2 => {\n    let newYScale = yScale;\n    let newXScale = xScale;\n    if (xScale1) {\n      if (isVertical) {\n        newXScale = xScale1;\n      } else {\n        newYScale = xScale1;\n      }\n    }\n    if (isVertical) {\n      const xCoords = getKeyCoords(data2.x, data2.x0, data2.x1, newXScale, width, isCategorical, padding);\n      const yCoords = getValueCoords(data2.y0, data2.y1, newYScale);\n      return {\n        x: xCoords.offset,\n        width: xCoords.size,\n        y: yCoords.offset,\n        height: yCoords.size\n      };\n    } else {\n      const yCoords = getKeyCoords(data2.y, data2.y0, data2.y1, newYScale, width, isCategorical, padding);\n      const xCoords = getValueCoords(data2.x0, data2.x1, newXScale);\n      return {\n        x: xCoords.offset,\n        width: xCoords.size,\n        y: yCoords.offset,\n        height: yCoords.size\n      };\n    }\n  }, [getKeyCoords, getValueCoords, isCategorical, isVertical, padding, width, xScale, xScale1, yScale]);\n  const onMouseEnterInternal = useCallback(event => {\n    if (tooltip2) {\n      setInternalActive(true);\n    }\n    onMouseEnter == null ? void 0 : onMouseEnter({\n      value: data,\n      nativeEvent: event\n    });\n  }, [data, onMouseEnter, tooltip2]);\n  const onMouseLeaveInternal = useCallback(event => {\n    if (tooltip2) {\n      setInternalActive(false);\n    }\n    onMouseLeave == null ? void 0 : onMouseLeave({\n      value: data,\n      nativeEvent: event\n    });\n  }, [data, onMouseLeave, tooltip2]);\n  const onMouseClick = useCallback(event => {\n    onClick == null ? void 0 : onClick({\n      value: data,\n      nativeEvent: event\n    });\n  }, [data, onClick]);\n  const getFill = useCallback(color2 => {\n    if (mask) {\n      return \"url(#mask-pattern-\".concat(id, \")\");\n    } else {\n      if (gradient2) {\n        return \"url(#gradient-\".concat(id, \")\");\n      }\n      return color2;\n    }\n  }, [gradient2, id, mask]);\n  const tooltipData = useMemo(() => {\n    const xAttr = isCategorical ? \"x\" : \"x0\";\n    let x = data[xAttr];\n    if (data.x0 < 0) {\n      x = data.x0;\n    }\n    const matches = isVertical ? data.key && data.key !== x : data.key && data.key !== data.y;\n    if (matches) {\n      x = \"\".concat(data.key, \" \\u2219 \").concat(x);\n    }\n    return {\n      y: data.y,\n      x\n    };\n  }, [data, isCategorical, isVertical]);\n  const ariaLabelData = useMemo(() => getAriaLabel(tooltipData), [tooltipData]);\n  const getTransition = useCallback(index2 => {\n    if (animated) {\n      let delay = 0;\n      if (layout2 === \"vertical\") {\n        delay = index2 / barCount * 0.5;\n      } else {\n        delay = (barCount - index2) / barCount * 0.5;\n      }\n      return {\n        ...DEFAULT_TRANSITION,\n        delay\n      };\n    } else {\n      return {\n        type: false,\n        delay: 0\n      };\n    }\n  }, [animated, barCount, layout2]);\n  const renderBar = useCallback((currentColorShade2, coords2, index2) => {\n    const maskPath = mask ? \"url(#mask-\".concat(id, \")\") : \"\";\n    const fill = getFill(currentColorShade2);\n    const initialExit = getExit(coords2);\n    const extras = constructFunctionProps({\n      className,\n      style\n    }, data);\n    const transition = getTransition(index2);\n    const initial = {\n      ...initialExit,\n      attrX: initialExit.x,\n      attrY: initialExit.y,\n      fill\n    };\n    delete initial.x;\n    delete initial.y;\n    const animate2 = {\n      ...coords2,\n      attrX: coords2.x,\n      attrY: coords2.y,\n      fill\n    };\n    delete animate2.x;\n    delete animate2.y;\n    return /* @__PURE__ */jsx(\"g\", {\n      ref: rect,\n      children: /* @__PURE__ */jsx(motion.rect, {\n        className: classNames(extras.className),\n        style: {\n          ...extras.style,\n          ...generateGlowStyles({\n            glow,\n            colorSchemeColor: currentColorShade2\n          }),\n          cursor\n        },\n        mask: maskPath,\n        rx,\n        ry,\n        initial,\n        animate: animate2,\n        exit: initial,\n        transition,\n        onMouseEnter: onMouseEnterInternal,\n        onMouseLeave: onMouseLeaveInternal,\n        onClick: onMouseClick,\n        onMouseMove,\n        tabIndex: 0,\n        \"aria-label\": ariaLabelData,\n        role: \"graphics-document\"\n      })\n    });\n  }, [className, cursor, data, getExit, getFill, getTransition, glow, id, mask, onMouseClick, onMouseEnterInternal, onMouseLeaveInternal, onMouseMove, rx, ry, style, tooltipData]);\n  const renderGuideBar = useCallback(() => {\n    if (!guide) {\n      return null;\n    }\n    if (type === \"stacked\" && barIndex !== 0) {\n      return null;\n    }\n    if (type === \"stackedNormalized\" || type === \"marimekko\") {\n      console.error(\"Guide bars are not supported for these chart types\");\n      return null;\n    }\n    const valueScale = isVertical ? yScale : xScale;\n    const [start2, end2] = valueScale.domain();\n    const attr = isVertical ? \"y\" : \"x\";\n    const attrStart = type === \"stackedDiverging\" ? \"0\" : \"1\";\n    const endPoint = type === \"stackedDiverging\" ? start2 : end2;\n    const startPoint = type === \"stackedDiverging\" && data[attr] > 0 ? end2 : endPoint;\n    const coords2 = getCoords({\n      ...data,\n      [attr]: endPoint,\n      [\"\".concat(attr).concat(attrStart)]: startPoint\n    });\n    return /* @__PURE__ */jsx(CloneElement, {\n      element: guide,\n      ...coords2,\n      active\n    });\n  }, [active, barIndex, data, getCoords, guide, isVertical, type, xScale, yScale]);\n  const isActive = tooltip2 ? internalActive : active;\n  const stroke = color(data, barIndex);\n  const coords = getCoords(data);\n  const currentColorShade = active ? chroma(stroke).brighten(activeBrightness).hex() : stroke;\n  const rangeLineColor = rangeLines && rangeLines.props.color || stroke;\n  const rangeLineColorShade = active ? chroma(rangeLineColor).brighten(activeBrightness) : rangeLineColor;\n  const index = groupIndex !== void 0 ? groupIndex : barIndex;\n  const scale2 = isVertical ? yScale : xScale;\n  const barLabel = isVertical ? tooltipData.y : tooltipData.x;\n  const placement = layout2 === \"vertical\" ? \"top\" : \"right\";\n  return /* @__PURE__ */jsxs(Fragment, {\n    children: [renderGuideBar(), renderBar(currentColorShade, coords, index), rangeLines && /* @__PURE__ */jsx(CloneElement, {\n      element: rangeLines,\n      ...coords,\n      index,\n      data,\n      scale: scale2,\n      color: rangeLineColorShade,\n      barCount,\n      animated,\n      layout: layout2,\n      type\n    }), mask && /* @__PURE__ */jsxs(Fragment, {\n      children: [/* @__PURE__ */jsx(Mask, {\n        id: \"mask-\".concat(id),\n        fill: \"url(#gradient-\".concat(id, \")\")\n      }), /* @__PURE__ */jsx(CloneElement, {\n        element: mask,\n        id: \"mask-pattern-\".concat(id),\n        fill: stroke\n      })]\n    }), gradient2 && /* @__PURE__ */jsx(CloneElement, {\n      element: gradient2,\n      id: \"gradient-\".concat(id),\n      direction: layout2,\n      color: currentColorShade\n    }), label2 && /* @__PURE__ */jsx(CloneElement, {\n      element: label2,\n      ...coords,\n      text: formatValue(barLabel),\n      index,\n      data,\n      scale: scale2,\n      fill: label2.props.fill || currentColorShade,\n      barCount,\n      animated,\n      layout: layout2,\n      type\n    }), tooltip2 && /* @__PURE__ */jsx(CloneElement, {\n      element: tooltip2,\n      visible: !!isActive,\n      reference: rect,\n      color,\n      value: tooltipData,\n      placement: tooltip2.props.placement || placement,\n      data\n    })]\n  });\n};\nBar.defaultProps = {\n  activeBrightness: 0.5,\n  rx: 0,\n  ry: 0,\n  cursor: \"auto\",\n  rangeLines: null,\n  label: null,\n  tooltip: null,\n  layout: \"vertical\",\n  guide: null,\n  gradient: /* @__PURE__ */jsx(Gradient, {})\n};\nconst BarSeries = _ref68 => {\n  let {\n    data,\n    tooltip: tooltip2,\n    xScale,\n    yScale,\n    height,\n    width,\n    colorScheme,\n    xScale1,\n    bar: bar2,\n    padding,\n    animated,\n    isCategorical,\n    layout: layout2,\n    type,\n    id,\n    valueMarkers\n  } = _ref68;\n  const ref = useRef(null);\n  const [activeValues, setActiveValues] = useState(null);\n  const isVertical = useMemo(() => layout2 === \"vertical\", [layout2]);\n  const isMultiSeries = useMemo(() => {\n    return type === \"grouped\" || type === \"stacked\" || type === \"marimekko\" || type === \"stackedNormalized\" || type === \"stackedDiverging\";\n  }, [type]);\n  const getTransform = useCallback(data2 => {\n    let xPos = 0;\n    let yPos = 0;\n    if (type !== \"marimekko\") {\n      if (layout2 === \"vertical\") {\n        const val = xScale(data2.key);\n        xPos = val;\n      } else {\n        const val = yScale(data2.key);\n        yPos = val;\n      }\n    }\n    return \"translate(\".concat(xPos, \", \").concat(yPos, \")\");\n  }, [layout2, type, xScale, yScale]);\n  const getBarColor = useCallback((point2, index) => {\n    let key = \"key\";\n    if (isMultiSeries) {\n      if (layout2 === \"vertical\") {\n        key = \"x\";\n      } else {\n        key = \"y\";\n      }\n    }\n    if (point2[key] === void 0) {\n      key = \"x0\";\n    }\n    return getColor({\n      colorScheme,\n      point: point2,\n      index,\n      data,\n      isMultiSeries,\n      attribute: key\n    });\n  }, [colorScheme, data, isMultiSeries, layout2]);\n  const onMouseMove = useCallback(event => {\n    var _a;\n    (_a = ref.current) == null ? void 0 : _a.triggerMouseMove(event);\n  }, []);\n  const onValueEnter = useCallback(event => {\n    setActiveValues(event.value);\n  }, []);\n  const onValueLeave = useCallback(() => {\n    setActiveValues(null);\n  }, []);\n  const renderBar = useCallback((data2, barIndex, barCount, groupIndex) => {\n    const active = activeValues && activeValues.x === data2.key;\n    let newYScale = yScale;\n    let newXScale = xScale;\n    if (xScale1) {\n      if (isVertical) {\n        newXScale = xScale1;\n      } else {\n        newYScale = xScale1;\n      }\n    }\n    let key = barIndex.toString();\n    if (data2.key) {\n      key = \"\".concat(data2.key.toString(), \"-\").concat(groupIndex, \"-\").concat(data2.x);\n    }\n    let barElements = Array.isArray(bar2) ? bar2[barIndex] : bar2;\n    if (!bar2) {\n      barElements = /* @__PURE__ */jsx(Bar, {});\n    }\n    return /* @__PURE__ */jsx(Fragment, {\n      children: /* @__PURE__ */jsx(CloneElement, {\n        element: barElements,\n        id: \"\".concat(id, \"-bar-\").concat(groupIndex, \"-\").concat(barIndex),\n        animated,\n        active,\n        xScale: newXScale,\n        xScale1,\n        yScale: newYScale,\n        padding,\n        barCount,\n        groupIndex,\n        barIndex,\n        data: data2,\n        isCategorical,\n        color: getBarColor,\n        layout: layout2,\n        type,\n        onMouseMove\n      })\n    }, key);\n  }, [activeValues, animated, bar2, getBarColor, id, isCategorical, isVertical, layout2, onMouseMove, padding, type, xScale, xScale1, yScale]);\n  const renderBarGroup = useCallback((data2, barCount, groupIndex) => {\n    return /* @__PURE__ */jsx(Fragment, {\n      children: data2.map((barData, barIndex) => renderBar(barData, barIndex, barCount, groupIndex))\n    });\n  }, [renderBar]);\n  const renderValueMarkers = useCallback(() => /* @__PURE__ */jsx(Fragment$1, {\n    children: (valueMarkers == null ? void 0 : valueMarkers.length) && valueMarkers.map(marker2 => /* @__PURE__ */jsx(CloneElement, {\n      element: marker2,\n      size: layout2 === \"vertical\" ? width : height,\n      value: layout2 === \"vertical\" ? yScale(marker2.props.value) : xScale(marker2.props.value),\n      isHorizontal: layout2 === \"vertical\"\n    }, marker2.key))\n  }), [height, layout2, valueMarkers, width, xScale, yScale]);\n  return /* @__PURE__ */jsxs(CloneElement, {\n    element: tooltip2,\n    childRef: ref,\n    xScale,\n    yScale,\n    data,\n    height,\n    width,\n    inverse: false,\n    isHorizontal: layout2 === \"horizontal\",\n    color: getBarColor,\n    onValueEnter,\n    onValueLeave,\n    isContinous: false,\n    children: [isMultiSeries && data.map((groupData, index) => /* @__PURE__ */jsx(\"g\", {\n      transform: getTransform(groupData),\n      children: renderBarGroup(groupData.data, data.length, index)\n    }, \"bar-group-\".concat(index))), !isMultiSeries && renderBarGroup(data, data.length), renderValueMarkers()]\n  });\n};\nBarSeries.defaultProps = {\n  type: \"standard\",\n  padding: 0.1,\n  groupPadding: 16,\n  animated: true,\n  tooltip: /* @__PURE__ */jsx(TooltipArea, {\n    tooltip: /* @__PURE__ */jsx(ChartTooltip, {\n      followCursor: true,\n      modifiers: {\n        offset: \"5px, 5px\"\n      }\n    })\n  }),\n  colorScheme: \"cybertron\",\n  bar: /* @__PURE__ */jsx(Bar, {}),\n  layout: \"vertical\"\n};\nconst RangeLines = _ref69 => {\n  let {\n    layout: layout2,\n    color,\n    x,\n    y,\n    scale: scale2,\n    type,\n    height,\n    position,\n    strokeWidth,\n    width,\n    animated,\n    index,\n    barCount,\n    data\n  } = _ref69;\n  const isVertical = useMemo(() => layout2 === \"vertical\", [layout2]);\n  const rangeLineHeight = useMemo(() => Math.min(strokeWidth, isVertical ? height : width), [height, isVertical, strokeWidth, width]);\n  const [newWidth, newHeight] = useMemo(() => [isVertical ? width : rangeLineHeight, isVertical ? rangeLineHeight : height], [height, isVertical, rangeLineHeight, width]);\n  const enterProps = useMemo(() => {\n    let newY = y;\n    let newX = x;\n    const isTop = position === \"top\";\n    const direction = isVertical ? data.y < 0 && isTop ? \"bottom\" : position : data.x0 < 0 && isTop ? \"bottom\" : position;\n    if (isVertical) {\n      if (direction === \"top\") {\n        newY = y;\n      } else {\n        newY = y + height - rangeLineHeight;\n      }\n    } else {\n      if (direction === \"top\") {\n        newX = x + width - rangeLineHeight;\n      } else {\n        newX = x;\n      }\n    }\n    return {\n      x: newX,\n      y: newY,\n      opacity: 1\n    };\n  }, [data.x0, data.y, height, isVertical, position, rangeLineHeight, width, x, y]);\n  const exitProps = useMemo(() => {\n    let newY = y;\n    let newX = x;\n    if (isVertical) {\n      const maxY = Math.max(...scale2.range());\n      if (position === \"top\") {\n        newY = maxY;\n      } else {\n        newY = maxY + height - rangeLineHeight;\n      }\n    } else {\n      const minX = Math.min(...scale2.range());\n      if (position === \"top\") {\n        newX = minX;\n      } else {\n        newX = minX + width - rangeLineHeight;\n      }\n    }\n    if (type === \"stackedDiverging\") {\n      if (isVertical) {\n        newY = newY / 2;\n      } else {\n        newX = newX / 2;\n      }\n    }\n    return {\n      y: newY,\n      x: newX,\n      opacity: 0\n    };\n  }, [height, isVertical, position, rangeLineHeight, scale2, type, width, x, y]);\n  const delay = useMemo(() => {\n    let delay2 = 0;\n    if (animated) {\n      if (layout2 === \"vertical\") {\n        return index / barCount * 0.5;\n      } else {\n        return (barCount - index) / barCount * 0.5;\n      }\n    }\n    return delay2;\n  }, [animated, barCount, index, layout2]);\n  const initial = useMemo(() => {\n    const r = {\n      ...exitProps,\n      attrX: exitProps.x,\n      attrY: exitProps.y\n    };\n    delete r.x;\n    delete r.y;\n    return r;\n  }, [exitProps]);\n  const animate2 = useMemo(() => {\n    const r = {\n      ...enterProps,\n      attrX: enterProps.x,\n      attrY: enterProps.y\n    };\n    delete r.x;\n    delete r.y;\n    return r;\n  }, [enterProps]);\n  return /* @__PURE__ */jsx(motion.rect, {\n    pointerEvents: \"none\",\n    fill: color,\n    width: newWidth,\n    height: newHeight,\n    initial,\n    animate: animate2,\n    exit: initial,\n    transition: {\n      ...DEFAULT_TRANSITION,\n      delay\n    }\n  });\n};\nRangeLines.defaultProps = {\n  position: \"top\",\n  strokeWidth: 1,\n  layout: \"vertical\"\n};\nconst StackedBarSeries = props => /* @__PURE__ */jsx(BarSeries, {\n  type: \"stackedNormalized\",\n  ...props\n});\nStackedBarSeries.defaultProps = {\n  ...BarSeries.defaultProps,\n  type: \"stacked\",\n  bar: /* @__PURE__ */jsx(Bar, {\n    gradient: /* @__PURE__ */jsx(Gradient, {\n      stops: [/* @__PURE__ */jsx(GradientStop, {\n        offset: \"5%\",\n        stopOpacity: 0.1\n      }, \"start\"), /* @__PURE__ */jsx(GradientStop, {\n        offset: \"90%\",\n        stopOpacity: 0.7\n      }, \"stop\")]\n    }),\n    rangeLines: /* @__PURE__ */jsx(RangeLines, {\n      position: \"top\",\n      strokeWidth: 3\n    })\n  })\n};\nconst StackedNormalizedBarSeries = props => /* @__PURE__ */jsx(BarSeries, {\n  type: \"stackedNormalized\",\n  ...props\n});\nStackedNormalizedBarSeries.defaultProps = {\n  ...BarSeries.defaultProps,\n  type: \"stackedNormalized\",\n  tooltip: /* @__PURE__ */jsx(TooltipArea, {\n    tooltip: /* @__PURE__ */jsx(ChartTooltip, {\n      followCursor: true,\n      modifiers: {\n        offset: \"5px, 5px\"\n      },\n      content: (point2, color) => {\n        point2.data = point2.data.map(d => {\n          const start2 = isNaN(d.y0) ? d.x0 : d.y0;\n          const end2 = isNaN(d.y1) ? d.x1 : d.y1;\n          return {\n            ...d,\n            value: \"\".concat(formatValue(Math.floor((end2 - start2) * 100)), \"%\")\n          };\n        });\n        return /* @__PURE__ */jsx(TooltipTemplate, {\n          value: point2,\n          color\n        });\n      }\n    })\n  }),\n  bar: /* @__PURE__ */jsx(Bar, {\n    gradient: /* @__PURE__ */jsx(Gradient, {\n      stops: [/* @__PURE__ */jsx(GradientStop, {\n        offset: \"5%\",\n        stopOpacity: 0.1\n      }, \"start\"), /* @__PURE__ */jsx(GradientStop, {\n        offset: \"90%\",\n        stopOpacity: 0.7\n      }, \"stop\")]\n    }),\n    rangeLines: /* @__PURE__ */jsx(RangeLines, {\n      position: \"top\",\n      strokeWidth: 3\n    })\n  })\n};\nconst MarimekkoBarSeries = props => /* @__PURE__ */jsx(BarSeries, {\n  type: \"marimekko\",\n  ...props\n});\nMarimekkoBarSeries.defaultProps = {\n  ...BarSeries.defaultProps,\n  type: \"marimekko\",\n  padding: 10,\n  tooltip: /* @__PURE__ */jsx(TooltipArea, {\n    tooltip: /* @__PURE__ */jsx(ChartTooltip, {\n      followCursor: true,\n      modifiers: {\n        offset: \"5px, 5px\"\n      },\n      content: (point2, color) => {\n        const data = {\n          ...point2,\n          data: point2.data.map(d => ({\n            ...d,\n            value: \"\".concat(formatValue(d.value), \" \\u2219 \").concat(formatValue(Math.floor((d.y1 - d.y0) * 100)), \"%\")\n          }))\n        };\n        return /* @__PURE__ */jsx(TooltipTemplate, {\n          value: data,\n          color\n        });\n      }\n    })\n  }),\n  bar: /* @__PURE__ */jsx(Bar, {\n    padding: 10,\n    gradient: /* @__PURE__ */jsx(Gradient, {\n      stops: [/* @__PURE__ */jsx(GradientStop, {\n        offset: \"5%\",\n        stopOpacity: 0.1\n      }, \"start\"), /* @__PURE__ */jsx(GradientStop, {\n        offset: \"90%\",\n        stopOpacity: 0.7\n      }, \"stop\")]\n    }),\n    rangeLines: /* @__PURE__ */jsx(RangeLines, {\n      position: \"top\",\n      strokeWidth: 3\n    })\n  })\n};\nconst BarLabel = _ref70 => {\n  let {\n    fontSize,\n    fontFamily,\n    fill,\n    layout: layout2,\n    className,\n    text,\n    x,\n    y,\n    height,\n    position,\n    width,\n    data,\n    padding,\n    scale: scale2,\n    type,\n    animated,\n    index,\n    barCount\n  } = _ref70;\n  const isVertical = useMemo(() => layout2 === \"vertical\", [layout2]);\n  const textAnchor = isVertical ? \"middle\" : \"start\";\n  const enterProps = useMemo(() => {\n    let newY = y;\n    let newX = x;\n    const isTop = position === \"top\";\n    const direction = isVertical ? data.y < 0 && isTop ? \"bottom\" : position : data.x0 < 0 && isTop ? \"bottom\" : position;\n    if (isVertical) {\n      if (direction === \"top\") {\n        newY = y - padding;\n      } else if (direction === \"center\") {\n        newY = y + height / 2;\n      } else if (direction === \"bottom\") {\n        newY = y + height - padding;\n      }\n      newX = newX + width / 2;\n    } else {\n      if (direction === \"top\") {\n        newX = x + width + padding;\n      } else if (direction === \"center\") {\n        newX = x + width / 2;\n      } else if (direction === \"bottom\") {\n        newX = x + padding;\n      }\n      newY = newY + height / 2;\n    }\n    return {\n      translateX: newX,\n      translateY: newY,\n      opacity: 1\n    };\n  }, [data.x0, data.y, height, isVertical, padding, position, width, x, y]);\n  const exitProps = useMemo(() => {\n    let newY = y;\n    let newX = x;\n    if (isVertical) {\n      const maxY = Math.max(...scale2.range());\n      if (position === \"top\") {\n        newY = maxY;\n      } else {\n        newY = maxY + height + padding;\n      }\n      newX = newX + width / 2;\n    } else {\n      const minX = Math.min(...scale2.range());\n      if (position === \"top\") {\n        newX = minX;\n      } else {\n        newX = minX + width + padding;\n      }\n      newY = newY + height / 2;\n    }\n    if (type === \"stackedDiverging\") {\n      if (isVertical) {\n        newY = newY / 2;\n      } else {\n        newX = newX / 2;\n      }\n    }\n    return {\n      translateY: newY,\n      translateX: newX,\n      opacity: 0\n    };\n  }, [height, isVertical, padding, position, scale2, type, width, x, y]);\n  const delay = useMemo(() => {\n    let delay2 = 0;\n    if (animated) {\n      if (layout2 === \"vertical\") {\n        return index / barCount * 0.5;\n      } else {\n        return (barCount - index) / barCount * 0.5;\n      }\n    }\n    return delay2;\n  }, [animated, barCount, index, layout2]);\n  return /* @__PURE__ */jsx(motion.g, {\n    initial: exitProps,\n    animate: enterProps,\n    exit: exitProps,\n    transition: {\n      ...DEFAULT_TRANSITION,\n      delay\n    },\n    fontSize,\n    fontFamily,\n    children: /* @__PURE__ */jsx(\"text\", {\n      fill,\n      className,\n      textAnchor,\n      children: text\n    })\n  });\n};\nBarLabel.defaultProps = {\n  position: \"top\",\n  layout: \"vertical\",\n  fontSize: 13,\n  padding: 5,\n  fontFamily: \"sans-serif\",\n  fill: \"#000\"\n};\nconst HistogramBarSeries = _ref71 => {\n  let {\n    type,\n    ...rest\n  } = _ref71;\n  return /* @__PURE__ */jsx(BarSeries, {\n    ...rest\n  });\n};\nHistogramBarSeries.defaultProps = {\n  ...BarSeries.defaultProps,\n  colorScheme: schemes.cybertron[0],\n  tooltip: /* @__PURE__ */jsx(TooltipArea, {\n    tooltip: /* @__PURE__ */jsx(ChartTooltip, {\n      followCursor: true,\n      modifiers: {\n        offset: \"5px, 5px\"\n      },\n      content: (point2, color) => {\n        const data = {\n          ...point2,\n          x: \"\".concat(formatValue(point2.x0), \" - \").concat(formatValue(point2.x1)),\n          value: point2.y\n        };\n        return /* @__PURE__ */jsx(TooltipTemplate, {\n          value: data,\n          color\n        });\n      }\n    })\n  })\n};\nconst GuideBar = _ref72 => {\n  let {\n    active,\n    opacity = 0.15,\n    ...rest\n  } = _ref72;\n  const {\n    x,\n    y,\n    ...other\n  } = rest;\n  return /* @__PURE__ */jsx(motion.rect, {\n    ...other,\n    pointerEvents: \"none\",\n    initial: \"hidden\",\n    animate: active ? \"visible\" : \"hidden\",\n    variants: {\n      hidden: {\n        opacity: 0,\n        attrX: x,\n        attrY: y\n      },\n      visible: {\n        opacity,\n        attrX: x,\n        attrY: y\n      }\n    }\n  });\n};\nGuideBar.defaultProps = {\n  fill: \"#eee\",\n  opacity: 0.15\n};\nconst barChart = \"_barChart_sfjii_1\";\nconst stackedNormalized = \"_stackedNormalized_sfjii_4\";\nconst stacked = \"_stacked_sfjii_4\";\nconst marimekko = \"_marimekko_sfjii_6\";\nconst css$c = {\n  barChart,\n  stackedNormalized,\n  stacked,\n  marimekko\n};\nconst BarChart = _ref73 => {\n  let {\n    id,\n    width,\n    height,\n    margins,\n    className,\n    data,\n    xAxis,\n    yAxis,\n    series,\n    brush,\n    gridlines,\n    secondaryAxis,\n    containerClassName\n  } = _ref73;\n  const isVertical = useMemo(() => series.props.layout === \"vertical\", [series]);\n  const keyAxis = useMemo(() => isVertical ? xAxis : yAxis, [yAxis, xAxis, isVertical]);\n  const isDiverging = useMemo(() => series.props.type === \"stackedDiverging\", [series.props.type]);\n  const getMarimekkoGroupScales = useCallback((aggregatedData, axis, width2) => {\n    const keyScale = getMarimekkoScale(width2, axis.props.roundDomains);\n    const groupScale = getMarimekkoGroupScale({\n      width: width2,\n      padding: series.props.padding,\n      data: aggregatedData,\n      valueScale: keyScale\n    });\n    return {\n      keyScale,\n      groupScale\n    };\n  }, [series.props.padding]);\n  const getMultiGroupScales = useCallback((aggregatedData, height2, width2) => {\n    const {\n      groupPadding,\n      layout: layout2\n    } = series.props;\n    const groupScale = getGroupScale({\n      dimension: isVertical ? width2 : height2,\n      direction: layout2,\n      padding: groupPadding,\n      data: aggregatedData\n    });\n    const keyScale = getInnerScale({\n      groupScale,\n      padding: series.props.padding,\n      data: aggregatedData,\n      prop: isVertical ? \"x\" : \"y\"\n    });\n    return {\n      groupScale,\n      keyScale\n    };\n  }, [isVertical, series.props]);\n  const getKeyScale = useCallback((aggregatedData, axis, isMultiSeries, width2) => {\n    return getXScale({\n      width: width2,\n      type: axis.props.type,\n      roundDomains: axis.props.roundDomains,\n      data: aggregatedData,\n      padding: series.props.padding,\n      domain: axis.props.domain,\n      isMultiSeries,\n      isDiverging\n    });\n  }, [isDiverging, series]);\n  const getValueScale2 = useCallback((aggregatedData, axis, isMultiSeries, height2) => {\n    return getYScale({\n      roundDomains: axis.props.roundDomains,\n      padding: series.props.padding,\n      type: axis.props.type,\n      height: height2,\n      data: aggregatedData,\n      domain: axis.props.domain,\n      isMultiSeries,\n      isDiverging\n    });\n  }, [isDiverging, series]);\n  const getScalesAndData = useCallback((chartHeight, chartWidth) => {\n    const {\n      type,\n      layout: layout2\n    } = series.props;\n    const isMarimekko = type === \"marimekko\";\n    const isGrouped = type === \"grouped\";\n    const isStacked = type === \"stacked\" || type === \"stackedNormalized\" || type === \"stackedDiverging\";\n    const isMultiSeries = isGrouped || isStacked;\n    let aggregatedData;\n    if (isStacked) {\n      let distroType = \"default\";\n      if (type === \"stackedNormalized\") {\n        distroType = \"expand\";\n      } else if (type === \"stackedDiverging\") {\n        distroType = \"diverging\";\n      }\n      aggregatedData = buildBarStackData(data, distroType, layout2);\n    } else if (type === \"waterfall\") {\n      aggregatedData = buildWaterfall(data, layout2, series.props.binSize);\n    } else if (isMarimekko) {\n      aggregatedData = buildMarimekkoData(data);\n    } else if (isGrouped) {\n      aggregatedData = buildNestedChartData(data, false, layout2);\n    } else {\n      aggregatedData = buildShallowChartData(data, layout2, series.props.binSize);\n    }\n    let yScale;\n    let xScale;\n    let xScale1;\n    if (isVertical) {\n      if (isGrouped) {\n        const {\n          keyScale,\n          groupScale\n        } = getMultiGroupScales(aggregatedData, chartHeight, chartWidth);\n        xScale = groupScale;\n        xScale1 = keyScale;\n      } else if (isMarimekko) {\n        const {\n          keyScale,\n          groupScale\n        } = getMarimekkoGroupScales(aggregatedData, xAxis, chartWidth);\n        xScale = groupScale;\n        xScale1 = keyScale;\n      } else {\n        xScale = getKeyScale(aggregatedData, xAxis, isMultiSeries, chartWidth);\n      }\n      yScale = getValueScale2(aggregatedData, yAxis, isMultiSeries, chartHeight);\n    } else {\n      if (isGrouped) {\n        const {\n          keyScale,\n          groupScale\n        } = getMultiGroupScales(aggregatedData, chartHeight, chartWidth);\n        yScale = groupScale;\n        xScale1 = keyScale;\n        xScale = getKeyScale(aggregatedData, xAxis, isMultiSeries, chartWidth);\n      } else if (isMarimekko) {\n        throw new Error(\"Marimekko is currently not supported for horizontal layouts\");\n      } else {\n        xScale = getKeyScale(aggregatedData, xAxis, isMultiSeries, chartWidth);\n        yScale = getValueScale2(aggregatedData, yAxis, isMultiSeries, chartHeight);\n      }\n    }\n    return {\n      xScale,\n      xScale1,\n      yScale,\n      aggregatedData\n    };\n  }, [getKeyScale, data, getMarimekkoGroupScales, getMultiGroupScales, getValueScale2, isVertical, series.props, xAxis, yAxis]);\n  const renderChart = useCallback(containerProps => {\n    const {\n      chartHeight,\n      chartWidth,\n      id: id2,\n      updateAxes,\n      chartSized\n    } = containerProps;\n    const {\n      xScale,\n      xScale1,\n      yScale,\n      aggregatedData\n    } = getScalesAndData(chartHeight, chartWidth);\n    const isCategorical = keyAxis.props.type === \"category\";\n    const disableBrush = aggregatedData.length <= 1;\n    return /* @__PURE__ */jsxs(Fragment, {\n      children: [chartSized && gridlines && /* @__PURE__ */jsx(CloneElement, {\n        element: gridlines,\n        height: chartHeight,\n        width: chartWidth,\n        yScale,\n        xScale,\n        yAxis: yAxis.props,\n        xAxis: xAxis.props\n      }), /* @__PURE__ */jsx(CloneElement, {\n        element: xAxis,\n        height: chartHeight,\n        width: chartWidth,\n        scale: xScale,\n        visibility: chartSized ? \"visible\" : \"hidden\",\n        onDimensionsChange: event => updateAxes(isVertical ? \"horizontal\" : \"vertical\", event)\n      }), /* @__PURE__ */jsx(CloneElement, {\n        element: yAxis,\n        height: chartHeight,\n        width: chartWidth,\n        scale: yScale,\n        visibility: chartSized ? \"visible\" : \"hidden\",\n        onDimensionsChange: event => updateAxes(isVertical ? \"vertical\" : \"horizontal\", event)\n      }), secondaryAxis && secondaryAxis.map((axis, i) => /* @__PURE__ */jsx(CloneElement, {\n        element: axis,\n        height: chartHeight,\n        width: chartWidth,\n        visibility: chartSized ? \"visible\" : \"hidden\",\n        onDimensionsChange: event => updateAxes(\"horizontal\", event)\n      }, i)), chartSized && /* @__PURE__ */jsx(CloneElement, {\n        disabled: disableBrush,\n        element: brush,\n        height: chartHeight,\n        width: chartWidth,\n        scale: xScale,\n        children: /* @__PURE__ */jsx(CloneElement, {\n          element: series,\n          id: \"bar-series-\".concat(id2),\n          data: aggregatedData,\n          height: chartHeight,\n          width: chartWidth,\n          isCategorical,\n          xScale,\n          xScale1,\n          yScale\n        })\n      })]\n    });\n  }, [brush, getScalesAndData, gridlines, isVertical, keyAxis, secondaryAxis, series, xAxis, yAxis]);\n  return /* @__PURE__ */jsx(ChartContainer, {\n    id,\n    width,\n    height,\n    margins,\n    containerClassName,\n    xAxisVisible: isAxisVisible(xAxis.props),\n    yAxisVisible: isAxisVisible(yAxis.props),\n    className: classNames(css$c.barChart, className, css$c[series.props.type]),\n    children: renderChart\n  });\n};\nBarChart.defaultProps = {\n  data: [],\n  xAxis: /* @__PURE__ */jsx(LinearXAxis, {\n    type: \"category\",\n    tickSeries: /* @__PURE__ */jsx(LinearXAxisTickSeries, {\n      tickSize: 20\n    })\n  }),\n  yAxis: /* @__PURE__ */jsx(LinearYAxis, {\n    type: \"value\"\n  }),\n  series: /* @__PURE__ */jsx(BarSeries, {}),\n  gridlines: /* @__PURE__ */jsx(GridlineSeries, {}),\n  brush: null\n};\nconst MarimekkoChart = props => /* @__PURE__ */jsx(BarChart, {\n  ...props\n});\nMarimekkoChart.defaultProps = {\n  series: /* @__PURE__ */jsx(MarimekkoBarSeries, {}),\n  xAxis: /* @__PURE__ */jsx(LinearXAxis, {\n    type: \"category\",\n    tickSeries: /* @__PURE__ */jsx(LinearXAxisTickSeries, {\n      tickSize: 15\n    })\n  }),\n  yAxis: /* @__PURE__ */jsx(LinearYAxis, {\n    type: \"value\",\n    tickSeries: /* @__PURE__ */jsx(LinearYAxisTickSeries, {\n      label: /* @__PURE__ */jsx(LinearYAxisTickLabel, {\n        rotation: false,\n        format: data => \"\".concat(data * 100, \"%\")\n      })\n    })\n  })\n};\nconst StackedBarChart = props => /* @__PURE__ */jsx(BarChart, {\n  ...props\n});\nStackedBarChart.defaultProps = {\n  series: /* @__PURE__ */jsx(StackedBarSeries, {})\n};\nconst StackedNormalizedBarChart = props => /* @__PURE__ */jsx(BarChart, {\n  ...props\n});\nStackedNormalizedBarChart.defaultProps = {\n  series: /* @__PURE__ */jsx(StackedNormalizedBarSeries, {}),\n  yAxis: /* @__PURE__ */jsx(LinearYAxis, {\n    type: \"value\",\n    tickSeries: /* @__PURE__ */jsx(LinearYAxisTickSeries, {\n      label: /* @__PURE__ */jsx(LinearYAxisTickLabel, {\n        rotation: false,\n        format: data => \"\".concat(data * 100, \"%\")\n      })\n    })\n  })\n};\nconst HistogramBarChart = props => /* @__PURE__ */jsx(BarChart, {\n  ...props\n});\nHistogramBarChart.defaultProps = {\n  series: /* @__PURE__ */jsx(HistogramBarSeries, {})\n};\nconst LineSeries = props => /* @__PURE__ */jsx(AreaSeries, {\n  ...props\n});\nLineSeries.defaultProps = {\n  ...AreaSeries.defaultProps,\n  area: null,\n  line: /* @__PURE__ */jsx(Line, {\n    strokeWidth: 3\n  })\n};\nconst LineChart = props => /* @__PURE__ */jsx(AreaChart, {\n  ...props\n});\nLineChart.defaultProps = {\n  ...AreaChart.defaultProps,\n  series: /* @__PURE__ */jsx(LineSeries, {})\n};\nconst Map$1 = _ref74 => {\n  let {\n    id,\n    width,\n    height,\n    margins,\n    className,\n    containerClassName,\n    markers,\n    data,\n    fill,\n    projection = \"mercator\"\n  } = _ref74;\n  const getProjection = useCallback(_ref75 => {\n    let {\n      chartWidth,\n      chartHeight\n    } = _ref75;\n    if (projection === \"natural-earth\") {\n      return geoNaturalEarth1().fitSize([chartWidth, chartHeight], data).center([0, 0]);\n    }\n    return geoMercator().fitSize([chartWidth, chartHeight], data).center([0, 35]);\n  }, [data, projection]);\n  const renderMarker = useCallback((marker2, index, projection2) => {\n    const position = projection2(marker2.props.coordinates);\n    if (!position) {\n      console.warn(\"Position for \".concat(marker2.props.coordinates.toString(), \" not found.\"));\n      return null;\n    }\n    return /* @__PURE__ */jsx(CloneElement, {\n      element: marker2,\n      cx: position[0],\n      cy: position[1],\n      index\n    });\n  }, []);\n  const renderCountry = useCallback((point2, index, path2) => {\n    if (point2.id === \"010\") {\n      return null;\n    }\n    return /* @__PURE__ */jsx(\"path\", {\n      d: path2(point2),\n      fill\n    }, \"path-\".concat(index));\n  }, [fill]);\n  const renderChart = useCallback(containerProps => {\n    if (!data) {\n      return null;\n    }\n    const geoProjection = getProjection(containerProps);\n    const path2 = geoPath().projection(geoProjection);\n    return /* @__PURE__ */jsxs(motion.g, {\n      initial: {\n        opacity: 0\n      },\n      animate: {\n        opacity: 1\n      },\n      children: [data.features.map((point2, index) => renderCountry(point2, index, path2)), markers && markers.map((marker2, index) => /* @__PURE__ */jsx(Fragment, {\n        children: renderMarker(marker2, index, geoProjection)\n      }, \"marker-\".concat(index)))]\n    });\n  }, [data, getProjection, markers, renderCountry, renderMarker]);\n  return /* @__PURE__ */jsx(ChartContainer, {\n    id,\n    width,\n    height,\n    margins,\n    containerClassName,\n    xAxisVisible: false,\n    yAxisVisible: false,\n    className,\n    children: props => renderChart(props)\n  });\n};\nMap$1.defaultProps = {\n  fill: \"rgba(255, 255, 255, 0.3)\"\n};\nconst marker = \"_marker_agib4_1\";\nconst css$b = {\n  marker\n};\nconst modifiers$1 = {\n  offset: {\n    offset: \"0, 3px\"\n  }\n};\nconst MapMarker = _ref76 => {\n  let {\n    size = 3,\n    index,\n    tooltip: tooltip2,\n    cx,\n    cy,\n    onClick = () => void 0\n  } = _ref76;\n  const ref = useRef(null);\n  const [active, setActive] = useState(false);\n  const ariaLabelData = useMemo(() => typeof tooltip2 === \"string\" ? tooltip2 : \"map marker\", [tooltip2]);\n  return /* @__PURE__ */jsxs(Fragment, {\n    children: [/* @__PURE__ */jsx(motion.circle, {\n      initial: {\n        opacity: 0,\n        scale: 0.02\n      },\n      animate: {\n        opacity: 1,\n        scale: 1\n      },\n      transition: {\n        delay: index * 0.3\n      },\n      ref,\n      className: css$b.marker,\n      cx,\n      cy,\n      r: size,\n      onMouseEnter: () => setActive(true),\n      onMouseLeave: () => setActive(false),\n      onClick,\n      tabIndex: 0,\n      \"aria-label\": ariaLabelData,\n      role: \"graphics-document\"\n    }), tooltip2 && /* @__PURE__ */jsx(Tooltip, {\n      theme: tooltipTheme,\n      visible: active,\n      reference: ref,\n      modifiers: modifiers$1,\n      content: tooltip2\n    })]\n  });\n};\nconst useInterpolate$1 = _ref77 => {\n  let {\n    data,\n    animated,\n    arc: arc2\n  } = _ref77;\n  const exit = useMemo(() => {\n    const startAngle = data.startAngle;\n    const endAngle = animated ? startAngle : data.endAngle;\n    return {\n      ...data,\n      startAngle,\n      endAngle\n    };\n  }, [data, animated]);\n  const prevData = useRef(exit);\n  const d = useMotionValue(exit);\n  const spring = useSpring(0, DEFAULT_TRANSITION);\n  useEffect(() => {\n    const interpolator = interpolate$1(prevData.current, data);\n    const prevSpring = spring.get();\n    spring.set(prevSpring + 1);\n    return spring.on(\"change\", v => {\n      const newData = interpolator(v - prevSpring);\n      prevData.current = newData;\n      d.set(arc2(newData));\n    });\n  }, [arc2, d, data, exit, spring]);\n  return d;\n};\nconst useHoverIntent = _ref78 => {\n  let {\n    sensitivity = 7,\n    interval = 50,\n    timeout = 10,\n    disabled,\n    onPointerOver,\n    onPointerOut\n  } = _ref78;\n  const mouseOver = useRef(false);\n  const timer = useRef(null);\n  const state = useRef(0);\n  const coords = useRef({\n    x: null,\n    y: null,\n    px: null,\n    py: null\n  });\n  const onMouseMove = useCallback(event => {\n    coords.current.x = event.clientX;\n    coords.current.y = event.clientY;\n  }, []);\n  const comparePosition = useCallback(event => {\n    timer.current = clearTimeout(timer.current);\n    const {\n      px,\n      x,\n      py,\n      y\n    } = coords.current;\n    if (Math.abs(px - x) + Math.abs(py - y) < sensitivity) {\n      state.current = 1;\n      onPointerOver(event);\n    } else {\n      coords.current.px = x;\n      coords.current.py = y;\n      timer.current = setTimeout(() => comparePosition(event), interval);\n    }\n  }, [interval, onPointerOver, sensitivity]);\n  const cleanup = useCallback(() => {\n    clearTimeout(timer.current);\n    document.removeEventListener(\"mousemove\", onMouseMove, false);\n  }, [onMouseMove]);\n  const pointerOver = useCallback(event => {\n    if (!disabled) {\n      mouseOver.current = true;\n      cleanup();\n      if (state.current !== 1) {\n        coords.current.px = event.nativeEvent.x;\n        coords.current.py = event.nativeEvent.y;\n        document.addEventListener(\"mousemove\", onMouseMove, false);\n        timer.current = setTimeout(() => comparePosition(event), timeout);\n      }\n    }\n  }, [cleanup, comparePosition, disabled, onMouseMove, timeout]);\n  const delay = useCallback(event => {\n    timer.current = clearTimeout(timer.current);\n    state.current = 0;\n    onPointerOut(event);\n  }, [onPointerOut]);\n  const pointerOut = useCallback(event => {\n    mouseOver.current = false;\n    cleanup();\n    if (state.current === 1) {\n      timer.current = setTimeout(() => delay(event), timeout);\n    }\n  }, [cleanup, delay, timeout]);\n  return {\n    pointerOver,\n    pointerOut\n  };\n};\nconst PieArc = _ref79 => {\n  let {\n    id,\n    color,\n    data,\n    arc: arc2,\n    cursor,\n    animated,\n    gradient: gradient2,\n    disabled,\n    onClick,\n    onMouseEnter,\n    onMouseLeave,\n    tooltip: tooltip2\n  } = _ref79;\n  var _a;\n  const arcRef = useRef(null);\n  const d = useInterpolate$1({\n    animated,\n    arc: arc2,\n    data\n  });\n  const [active, setActive] = useState(false);\n  const fill = useMemo(() => active ? chroma(color).brighten(0.5) : color, [color, active]);\n  const {\n    pointerOut,\n    pointerOver\n  } = useHoverIntent({\n    onPointerOver: event => {\n      if (!disabled) {\n        setActive(true);\n        onMouseEnter == null ? void 0 : onMouseEnter({\n          value: data.data,\n          nativeEvent: event\n        });\n      }\n    },\n    onPointerOut: event => {\n      if (!disabled) {\n        setActive(false);\n        onMouseLeave == null ? void 0 : onMouseLeave({\n          value: data.data,\n          nativeEvent: event\n        });\n      }\n    }\n  });\n  const internalFill = useMemo(() => {\n    if (gradient2) {\n      return \"url(#gradient-\".concat(id, \")\");\n    }\n    return color;\n  }, [gradient2, id, color]);\n  const tooltipData = useMemo(() => ({\n    y: data.data.data,\n    x: data.data.key\n  }), [data]);\n  const ariaLabelData = useMemo(() => getAriaLabel(tooltipData), [tooltipData]);\n  return /* @__PURE__ */jsxs(\"g\", {\n    ref: arcRef,\n    tabIndex: 0,\n    \"aria-label\": ariaLabelData,\n    role: \"graphics-document\",\n    children: [/* @__PURE__ */jsx(motion.path, {\n      role: \"graphics-symbol\",\n      d,\n      style: {\n        cursor\n      },\n      fill: internalFill,\n      onPointerOver: pointerOver,\n      onPointerOut: pointerOut,\n      onClick: event => {\n        if (!disabled) {\n          onClick == null ? void 0 : onClick({\n            value: data.data,\n            nativeEvent: event\n          });\n        }\n      }\n    }), gradient2 && /* @__PURE__ */jsx(CloneElement, {\n      element: gradient2,\n      id: \"gradient-\".concat(id),\n      direction: \"horizontal\",\n      color: fill\n    }), !((_a = tooltip2 == null ? void 0 : tooltip2.props) == null ? void 0 : _a.disabled) && /* @__PURE__ */jsx(CloneElement, {\n      element: tooltip2,\n      visible: !!active,\n      reference: arcRef,\n      value: tooltipData\n    })]\n  });\n};\nPieArc.defaultProps = {\n  cursor: \"initial\",\n  animated: true,\n  disabled: false,\n  tooltip: /* @__PURE__ */jsx(ChartTooltip, {})\n};\nfunction findBreakPoint(_ref80, _ref81) {\n  let [startX, startY] = _ref80;\n  let [endX, endY] = _ref81;\n  let breakPoint = [0, 0];\n  const breakPointCondition = (endY - startY) * Math.sign(startY) >= 0;\n  if (breakPointCondition) {\n    let scale2 = Math.abs(endY / startY) || 1;\n    const minScale = 1;\n    const maxScale = Math.abs(endX / startX) || 1;\n    scale2 = Math.max(Math.min(maxScale, scale2), minScale);\n    breakPoint = [startX * scale2, endY];\n  } else {\n    let scale2 = 0.85;\n    const minScale = Math.abs(startX / endX) || 1;\n    const maxScale = 1;\n    scale2 = Math.max(Math.min(maxScale, scale2), minScale);\n    breakPoint = [endX * scale2, startY];\n  }\n  return breakPoint;\n}\nconst getTextAnchor = _ref82 => {\n  let {\n    startAngle,\n    endAngle\n  } = _ref82;\n  return (\n    // we could also use the sign of position[0]\n    startAngle + (endAngle - startAngle) / 2 < Math.PI ? \"start\" : \"end\"\n  );\n};\nconst PieArcLabel = _ref83 => {\n  let {\n    centroid,\n    data,\n    lineStroke,\n    padding,\n    fontSize,\n    fontFill,\n    format,\n    fontFamily,\n    position,\n    outerRadius,\n    width,\n    height\n  } = _ref83;\n  const textAnchor = getTextAnchor(data);\n  const text = format ? format({\n    ...data.data,\n    textAnchor\n  }) : formatValue(data.data.key);\n  const [posX, posY] = position;\n  const minRadius = outerRadius + 4;\n  const startPoint = centroid(data);\n  const innerPoint = arc().innerRadius(minRadius).outerRadius(minRadius).centroid(data);\n  const breakPoint = findBreakPoint(innerPoint, position);\n  return /* @__PURE__ */jsxs(motion.g, {\n    initial: {\n      opacity: 0\n    },\n    animate: {\n      opacity: 1\n    },\n    exit: {\n      opacity: 0\n    },\n    transition: {\n      duration: 0.1\n    },\n    children: [typeof text === \"string\" ? /* @__PURE__ */jsxs(Fragment$1, {\n      children: [/* @__PURE__ */jsx(\"title\", {\n        children: text\n      }), /* @__PURE__ */jsx(\"text\", {\n        dy: padding,\n        fill: fontFill,\n        fontSize,\n        fontFamily,\n        textAnchor,\n        style: {\n          shapeRendering: \"crispEdges\",\n          transform: \"translate3d(\".concat(posX, \"px,\").concat(posY, \"px, 0)\")\n        },\n        children: text\n      })]\n    }) : /* @__PURE__ */jsx(\"foreignObject\", {\n      width,\n      height,\n      style: {\n        transform: \"translate3d(\".concat(textAnchor === \"start\" ? posX : posX - width, \"px,\").concat(posY - height / 2, \"px, 0)\"),\n        color: fontFill,\n        fontFamily,\n        fontSize\n      },\n      children: text\n    }), /* @__PURE__ */jsx(\"polyline\", {\n      fill: \"none\",\n      stroke: lineStroke,\n      points: \"\".concat(startPoint, \",\").concat(innerPoint, \",\").concat(breakPoint, \",\").concat(position)\n    })]\n  });\n};\nPieArcLabel.defaultProps = {\n  format: void 0,\n  lineStroke: \"rgba(127,127,127,0.5)\",\n  fontFill: \"#8F979F\",\n  fontSize: 11,\n  fontFamily: \"sans-serif\",\n  padding: \".35em\",\n  height: 11\n};\nconst factor = 1.2;\nconst midAngle = d => d.startAngle + (d.endAngle - d.startAngle) / 2;\nconst labelVisible = arc2 => arc2.endAngle - arc2.startAngle > Math.PI / 30;\nfunction shouldDisplayLabel(displayAllLabels, arcData) {\n  return displayAllLabels || labelVisible(arcData);\n}\nfunction calculateOuterRadius(outerRadius, data, point2, explode) {\n  if (!explode || data === void 0) {\n    return outerRadius;\n  }\n  const maxVal = max(data, d => d.value);\n  return outerRadius * point2.value / maxVal;\n}\nfunction calculateCentroid(data, innerRadius, outerRadius, explode) {\n  return point2 => {\n    const newOuter = calculateOuterRadius(outerRadius, data, point2, explode);\n    return arc().innerRadius(innerRadius).outerRadius(newOuter).centroid(point2);\n  };\n}\nfunction calculateRadius(height, width, label2, arcWidth, doughnut) {\n  const minDimension = Math.min(width, height);\n  let outerRadius = minDimension / 2;\n  let labelWidth = 0;\n  if (label2) {\n    labelWidth = label2.props.width;\n    if (labelWidth) {\n      const outerArcRadius = width / 2 - labelWidth;\n      outerRadius = Math.min(outerArcRadius / factor, height / 2);\n    } else {\n      outerRadius = minDimension / 3;\n      labelWidth = width / 2 - outerRadius * factor;\n    }\n  }\n  const innerRadius = doughnut ? outerRadius * (1 - arcWidth) : 0;\n  return {\n    outerRadius,\n    innerRadius,\n    labelWidth\n  };\n}\nfunction calculateInnerArc(data, innerRadius, outerRadius, cornerRadius, padAngle, padRadius, explode) {\n  return point2 => {\n    const newOuter = calculateOuterRadius(outerRadius, data, point2, explode);\n    return arc().innerRadius(innerRadius).outerRadius(newOuter).cornerRadius(cornerRadius).padRadius(padRadius).padAngle(padAngle)(point2);\n  };\n}\nfunction calculateLabelPositions(data, outerRadius, minDistance, cornerRadius, padAngle, padRadius, displayAllLabels) {\n  const outerArcRadius = outerRadius * factor;\n  const outerArc = arc().innerRadius(outerArcRadius).outerRadius(outerArcRadius).cornerRadius(cornerRadius).padAngle(padAngle).padRadius(padRadius);\n  const positions = data.map(d => {\n    if (!shouldDisplayLabel(displayAllLabels, d)) {\n      return null;\n    }\n    const pos = outerArc.centroid(d);\n    pos[0] = outerArcRadius * (midAngle(d) < Math.PI ? 1 : -1);\n    return pos;\n  });\n  for (let i = 0; i < data.length - 1; i++) {\n    if (!positions[i]) {\n      continue;\n    }\n    const [aPosX, aPosY] = positions[i];\n    for (let j = i + 1; j < data.length; j++) {\n      if (!positions[j]) {\n        continue;\n      }\n      const [bPosX, bPosY] = positions[j];\n      if (bPosX * aPosX > 0) {\n        const overlap = minDistance - Math.abs(bPosY - aPosY);\n        if (overlap > 0) {\n          positions[j][1] += Math.sign(bPosX) * overlap;\n        }\n      }\n    }\n  }\n  return positions;\n}\nconst PieArcSeries = _ref84 => {\n  let {\n    doughnut,\n    arcWidth,\n    label: label2,\n    colorScheme,\n    width,\n    displayAllLabels,\n    height,\n    explode,\n    id,\n    animated,\n    cornerRadius,\n    padAngle,\n    padRadius,\n    arc: arc2,\n    data\n  } = _ref84;\n  const {\n    outerRadius,\n    innerRadius,\n    labelWidth\n  } = calculateRadius(height, width, label2, arcWidth, doughnut);\n  const innerArc = calculateInnerArc(data, innerRadius, outerRadius, cornerRadius, padAngle, padRadius, explode);\n  const positions = label2 ? calculateLabelPositions(data, outerRadius,\n  // 4 is for vertical margins between labels\n  label2.props.height + 4, cornerRadius, padAngle, padRadius, displayAllLabels) : [];\n  const centroid = calculateCentroid(data, innerRadius, outerRadius, explode);\n  function renderItem(arcData, index) {\n    const safeKey = identifier(arcData.data.key.toString());\n    const color = getColor({\n      data,\n      colorScheme,\n      point: arcData.data,\n      index\n    });\n    return /* @__PURE__ */jsxs(Fragment, {\n      children: [positions[index] && /* @__PURE__ */jsx(CloneElement, {\n        id,\n        element: label2,\n        data: arcData,\n        centroid,\n        outerRadius,\n        width: labelWidth,\n        position: positions[index]\n      }), /* @__PURE__ */jsx(CloneElement, {\n        element: arc2,\n        id: \"\".concat(id, \"-arc-\").concat(safeKey),\n        data: arcData,\n        animated,\n        arc: innerArc,\n        color\n      })]\n    }, safeKey);\n  }\n  return /* @__PURE__ */jsx(Fragment$1, {\n    children: data.map(renderItem)\n  });\n};\nPieArcSeries.defaultProps = {\n  animated: true,\n  colorScheme: \"cybertron\",\n  innerRadius: 0,\n  cornerRadius: 0,\n  padAngle: 0,\n  padRadius: 0,\n  explode: false,\n  displayAllLabels: false,\n  arcWidth: 0.25,\n  label: /* @__PURE__ */jsx(PieArcLabel, {}),\n  arc: /* @__PURE__ */jsx(PieArc, {})\n};\nconst PieChart = _ref85 => {\n  let {\n    id,\n    width,\n    height,\n    className,\n    containerClassName,\n    displayAllLabels,\n    data = [],\n    margins,\n    series\n  } = _ref85;\n  const newId = useId(id);\n  const internalData = useMemo(() => {\n    const pieLayout = pie().value(d => Number(d.data));\n    if (!series.props.explode) {\n      pieLayout.sort(null);\n    }\n    return pieLayout(data);\n  }, [data, series]);\n  const renderSeries = useCallback(_ref86 => {\n    let {\n      chartWidth,\n      chartHeight\n    } = _ref86;\n    return /* @__PURE__ */jsx(CloneElement, {\n      element: series,\n      id: newId,\n      data: internalData,\n      height: chartHeight,\n      width: chartWidth,\n      displayAllLabels\n    });\n  }, [displayAllLabels, internalData, newId, series]);\n  return /* @__PURE__ */jsx(ChartContainer, {\n    id,\n    width,\n    height,\n    margins,\n    containerClassName,\n    xAxisVisible: false,\n    yAxisVisible: false,\n    center: true,\n    className: classNames(className),\n    children: renderSeries\n  });\n};\nPieChart.defaultProps = {\n  margins: 10,\n  series: /* @__PURE__ */jsx(PieArcSeries, {})\n};\nconst DEFAULT_COLOR = \"rgba(255, 255, 255, 0.2)\";\nconst LABEL_PADDING_PERCENT = 0.1;\nconst JUSTIFICATION = {\n  justify: sankeyJustify,\n  center: sankeyCenter,\n  left: sankeyLeft,\n  right: sankeyRight\n};\nconst Sankey = _ref87 => {\n  let {\n    width,\n    height,\n    margins,\n    className,\n    animated,\n    links,\n    justification,\n    nodeWidth,\n    nodePadding,\n    labelPosition,\n    nodeSort,\n    colorScheme,\n    nodes,\n    containerClassName,\n    ...rest\n  } = _ref87;\n  const id = useId(rest.id);\n  const [activeNodes, setActiveNodes] = useState([]);\n  const [activeLinks, setActiveLinks] = useState([]);\n  const getNodeColor = useCallback((node2, index) => {\n    if (colorScheme) {\n      return getColor({\n        data: nodes,\n        colorScheme,\n        point: nodes[index],\n        index\n      });\n    } else {\n      return node2.props.color;\n    }\n  }, [colorScheme, nodes]);\n  const onNodeActive = useCallback(node2 => {\n    const activeNodes2 = [node2];\n    const activeLinks2 = [];\n    if (node2.sourceLinks) {\n      activeLinks2.push(...node2.sourceLinks);\n      node2.sourceLinks.forEach(sourceLink => {\n        const sourceLinkTarget = sourceLink.target;\n        if (sourceLinkTarget.index !== node2.index) {\n          activeNodes2.push(sourceLinkTarget);\n        }\n      });\n    }\n    if (node2.targetLinks) {\n      activeLinks2.push(...node2.targetLinks);\n      node2.targetLinks.forEach(targetLink => {\n        const targetLinkSource = targetLink.source;\n        if (targetLinkSource.index !== node2.index) {\n          activeNodes2.push(targetLinkSource);\n        }\n      });\n    }\n    setActiveNodes(activeNodes2);\n    setActiveLinks(activeLinks2);\n  }, []);\n  const onLinkActive = useCallback(link2 => {\n    const activeNodes2 = [link2.source, link2.target];\n    const activeLinks2 = [link2];\n    setActiveNodes(activeNodes2);\n    setActiveLinks(activeLinks2);\n  }, []);\n  const onInactive = useCallback(() => {\n    setActiveNodes([]);\n    setActiveLinks([]);\n  }, []);\n  const nodeMap = useMemo(() => {\n    const nodeMap2 = /* @__PURE__ */new Map();\n    nodes.forEach(node2 => node2 && nodeMap2.set(node2.props.title, node2));\n    return nodeMap2;\n  }, [nodes]);\n  const renderNode = useCallback((computedNode, index, chartWidth, node2) => {\n    const active = activeNodes.some(node22 => node22.index === computedNode.index);\n    const disabled = activeNodes.length > 0 && !active;\n    const labelPadding = labelPosition === \"outside\" ? LABEL_PADDING_PERCENT : 0;\n    return /* @__PURE__ */jsx(CloneElement, {\n      element: node2,\n      active,\n      animated,\n      disabled,\n      chartWidth,\n      onMouseEnter: () => onNodeActive(computedNode),\n      onMouseLeave: () => onInactive(),\n      labelPosition,\n      labelPadding,\n      ...computedNode\n    }, \"node-\".concat(index));\n  }, [activeNodes, animated, onInactive, onNodeActive, labelPosition]);\n  const renderLink = useCallback((computedLink, index) => {\n    const active = activeLinks.some(link2 => link2.index === computedLink.index);\n    const disabled = activeLinks.length > 0 && !active;\n    return /* @__PURE__ */jsx(CloneElement, {\n      element: links[index],\n      active,\n      animated,\n      chartId: \"sankey-\".concat(id),\n      disabled,\n      ...computedLink,\n      onMouseEnter: () => onLinkActive(computedLink),\n      onMouseLeave: () => onInactive()\n    }, \"link-\".concat(index));\n  }, [activeLinks, id, animated, links, onInactive, onLinkActive]);\n  const getNodesAndLinks = useCallback((chartWidth, chartHeight) => {\n    const labelPadding = labelPosition === \"outside\" ? LABEL_PADDING_PERCENT : 0;\n    const padding = labelPadding * chartWidth;\n    const sankeyChart = sankey().extent([[1 + padding, 1], [chartWidth - padding, chartHeight]]).nodeWidth(nodeWidth).nodePadding(nodePadding).nodeSort(nodeSort).nodeAlign(JUSTIFICATION[justification]).nodeId(node2 => node2.id || node2.index);\n    const nodesCopy = nodes.map((node2, index) => ({\n      id: node2.props.id,\n      title: node2.props.title,\n      color: getNodeColor(node2, index)\n    }));\n    const linksCopy = links.map(link2 => ({\n      source: link2.props.source,\n      target: link2.props.target,\n      value: link2.props.value\n    }));\n    const {\n      nodes: sankeyNodes,\n      links: sankeyLinks\n    } = sankeyChart({\n      nodes: nodesCopy,\n      links: linksCopy\n    });\n    return {\n      sankeyNodes,\n      sankeyLinks\n    };\n  }, [getNodeColor, nodeSort, justification, links, nodePadding, nodeWidth, nodes, labelPosition]);\n  const renderChart = useCallback(_ref88 => {\n    let {\n      id: id2,\n      chartWidth,\n      chartHeight,\n      chartSized\n    } = _ref88;\n    if (!chartSized) {\n      return null;\n    }\n    const {\n      sankeyNodes,\n      sankeyLinks\n    } = getNodesAndLinks(chartWidth, chartHeight);\n    return /* @__PURE__ */jsxs(Fragment, {\n      children: [sankeyLinks.map((link2, index) => renderLink(link2, index)), sankeyNodes.map((node2, index) => renderNode(node2, index, chartWidth, nodeMap.get(node2.title)))]\n    }, \"group\");\n  }, [getNodesAndLinks, nodeMap, renderLink, renderNode]);\n  return /* @__PURE__ */jsx(ChartContainer, {\n    id,\n    width,\n    containerClassName,\n    height,\n    margins,\n    className,\n    children: renderChart\n  });\n};\nSankey.defaultProps = {\n  animated: true,\n  justification: \"justify\",\n  nodeWidth: 15,\n  nodePadding: 10,\n  nodePosition: \"inside\"\n};\nconst label$1 = \"_label_qd893_1\";\nconst css$a = {\n  label: label$1\n};\nconst LABEL_PADDING = 5;\nconst LABEL_TRUNCATE_LENGTH = 10;\nconst SankeyLabel = _ref89 => {\n  let {\n    active,\n    chartWidth,\n    className,\n    nodeWidth,\n    disabled,\n    fill,\n    format,\n    node: node2,\n    position,\n    opacity,\n    padding,\n    visible,\n    ellipsis,\n    labelPadding\n  } = _ref89;\n  const x0 = (node2 == null ? void 0 : node2.x0) || 0;\n  const x1 = (node2 == null ? void 0 : node2.x1) || 0;\n  const y0 = (node2 == null ? void 0 : node2.y0) || 0;\n  const y1 = (node2 == null ? void 0 : node2.y1) || 0;\n  const paddedWidth = nodeWidth + LABEL_PADDING;\n  const width = chartWidth || 0;\n  const showRightSide = x0 < width / 2;\n  let x = showRightSide ? x1 + paddedWidth : x0 - paddedWidth;\n  const y = (y1 + y0) / 2;\n  let textAnchor = showRightSide ? \"start\" : \"end\";\n  if (position === \"outside\") {\n    textAnchor = showRightSide ? \"end\" : \"start\";\n    x = showRightSide ? x1 - paddedWidth : x0 + paddedWidth;\n  }\n  if (!visible || !node2) {\n    return null;\n  }\n  let truncatedTitle = \"\";\n  if (ellipsis === \"auto\") {\n    const avaialableWidth = showRightSide ? x : width - x;\n    truncatedTitle = ellipsize(node2.title, Math.min(LABEL_TRUNCATE_LENGTH, avaialableWidth / (labelPadding * 100)));\n  } else if (ellipsis === \"none\") {\n    truncatedTitle = node2.title;\n  } else {\n    truncatedTitle = ellipsize(node2.title, ellipsis);\n  }\n  return /* @__PURE__ */jsx(\"text\", {\n    className: classNames(css$a.label, className),\n    x,\n    y,\n    dy: \"0.35em\",\n    textAnchor,\n    fill,\n    opacity: opacity(active, disabled),\n    style: {\n      padding\n    },\n    children: typeof format === \"function\" ? format({\n      x,\n      y,\n      textAnchor,\n      node: node2\n    }) : truncatedTitle\n  });\n};\nSankeyLabel.defaultProps = {\n  active: false,\n  fill: \"#fff\",\n  position: \"inside\",\n  opacity: (active, disabled) => active ? 1 : disabled ? 0.2 : 0.9,\n  visible: true,\n  ellipsis: \"auto\"\n};\nconst link = \"_link_1oi50_1\";\nconst tooltip$1 = \"_tooltip_1oi50_7\";\nconst tooltipLabel$1 = \"_tooltipLabel_1oi50_11\";\nconst tooltipValue$1 = \"_tooltipValue_1oi50_18\";\nconst css$9 = {\n  link,\n  tooltip: tooltip$1,\n  tooltipLabel: tooltipLabel$1,\n  tooltipValue: tooltipValue$1\n};\nconst SankeyLink = _ref90 => {\n  let {\n    gradient: gradient2,\n    index,\n    source,\n    target,\n    tooltip: tooltip2,\n    chartId,\n    value: value2,\n    active,\n    className,\n    disabled,\n    opacity,\n    style,\n    width,\n    color,\n    y0,\n    y1,\n    onClick,\n    onMouseEnter,\n    onMouseLeave\n  } = _ref90;\n  var _a;\n  const linkSource = source;\n  const linkTarget = target;\n  const [hovered, setHovered] = useState(false);\n  const linkRef = useRef(null);\n  const getLink = useCallback(() => {\n    return {\n      index,\n      y0,\n      y1,\n      value: value2,\n      width,\n      source,\n      target\n    };\n  }, [index, source, target, value2, width, y0, y1]);\n  const stroke = useMemo(() => {\n    if (gradient2) {\n      return \"url(#\".concat(chartId, \"-gradient-\").concat(index, \")\");\n    } else if (color) {\n      return color;\n    }\n    return DEFAULT_COLOR;\n  }, [chartId, gradient2, index, color]);\n  const enterProps = useMemo(() => {\n    const path2 = sankeyLinkHorizontal();\n    const d = path2(getLink());\n    const strokeWidth = Math.max(1, width);\n    return {\n      d,\n      strokeWidth\n    };\n  }, [getLink, width]);\n  const exitProps = useMemo(() => {\n    const path2 = sankeyLinkHorizontal();\n    const d = path2({\n      ...getLink(),\n      width: 0\n    });\n    return {\n      d,\n      strokeWidth: 0\n    };\n  }, [getLink]);\n  const renderTooltipContent = useCallback(() => {\n    return /* @__PURE__ */jsxs(\"div\", {\n      className: css$9.tooltip,\n      children: [/* @__PURE__ */jsx(\"div\", {\n        className: css$9.tooltipLabel,\n        children: \"\".concat(source.title, \" \\u2192 \").concat(target.title)\n      }), /* @__PURE__ */jsx(\"div\", {\n        className: css$9.tooltipValue,\n        children: formatValue(value2)\n      })]\n    });\n  }, [source, target, value2]);\n  const {\n    pointerOut,\n    pointerOver\n  } = useHoverIntent({\n    onPointerOver: event => {\n      setHovered(true);\n      onMouseEnter == null ? void 0 : onMouseEnter(event);\n    },\n    onPointerOut: event => {\n      setHovered(false);\n      onMouseLeave == null ? void 0 : onMouseLeave(event);\n    }\n  });\n  const ariaLabelData = useMemo(() => \"\".concat(source.title, \" \\u2192 \").concat(target.title, \": \").concat(formatValue(value2)), [source, target, value2]);\n  return /* @__PURE__ */jsxs(Fragment, {\n    children: [gradient2 && /* @__PURE__ */jsxs(\"linearGradient\", {\n      id: \"\".concat(chartId, \"-gradient-\").concat(index),\n      gradientUnits: \"userSpaceOnUse\",\n      x1: linkSource.x1,\n      x2: linkTarget.x0,\n      children: [/* @__PURE__ */jsx(\"stop\", {\n        offset: \"0%\",\n        stopColor: linkSource.color\n      }), /* @__PURE__ */jsx(\"stop\", {\n        offset: \"100%\",\n        stopColor: linkTarget.color\n      })]\n    }), /* @__PURE__ */jsx(\"g\", {\n      ref: linkRef,\n      children: /* @__PURE__ */jsx(motion.path, {\n        className: classNames(css$9.link, className),\n        style,\n        initial: exitProps,\n        animate: enterProps,\n        exit: exitProps,\n        transition: {\n          duration: 0.5\n        },\n        stroke,\n        strokeOpacity: opacity(active, disabled),\n        onClick,\n        onPointerOver: pointerOver,\n        onPointerOut: pointerOut,\n        \"aria-label\": ariaLabelData,\n        role: \"graphics-document\"\n      }, \"sankey-link-\".concat(enterProps.d, \"-\").concat(index))\n    }), !((_a = tooltip2 == null ? void 0 : tooltip2.props) == null ? void 0 : _a.disabled) && /* @__PURE__ */jsx(CloneElement, {\n      content: renderTooltipContent,\n      element: tooltip2,\n      visible: hovered,\n      reference: linkRef\n    })]\n  });\n};\nSankeyLink.defaultProps = {\n  active: false,\n  animated: true,\n  disabled: false,\n  gradient: true,\n  opacity: (active, disabled) => active ? 0.5 : disabled ? 0.1 : 0.35,\n  tooltip: /* @__PURE__ */jsx(Tooltip, {\n    theme: tooltipTheme,\n    followCursor: true,\n    modifiers: {\n      offset: {\n        offset: \"0, 5px\"\n      }\n    }\n  }),\n  width: 0\n};\nconst node = \"_node_oqk6h_1\";\nconst tooltip = \"_tooltip_oqk6h_5\";\nconst tooltipLabel = \"_tooltipLabel_oqk6h_10\";\nconst tooltipValue = \"_tooltipValue_oqk6h_17\";\nconst css$8 = {\n  node,\n  tooltip,\n  tooltipLabel,\n  tooltipValue\n};\nconst SankeyNode = _ref91 => {\n  let {\n    active,\n    chartWidth,\n    label: label2,\n    labelPosition,\n    labelPadding,\n    tooltip: tooltip2,\n    title,\n    value: value2,\n    className,\n    color,\n    disabled,\n    index,\n    opacity,\n    style,\n    width,\n    x0,\n    x1,\n    y0,\n    y1,\n    id,\n    sourceLinks,\n    targetLinks,\n    onClick,\n    onMouseEnter,\n    onMouseLeave\n  } = _ref91;\n  var _a;\n  const node2 = {\n    id,\n    title,\n    color,\n    sourceLinks,\n    targetLinks,\n    value: value2,\n    index,\n    x0,\n    x1,\n    y0,\n    y1\n  };\n  const nodeWidth = width || (x1 && x0 && x1 - x0 > 0 ? x1 - x0 : 0);\n  const nodeHeight = y1 && y0 && y1 - y0 > 0 ? y1 - y0 : 0;\n  const [hovered, setHovered] = useState(false);\n  const rectRef = useRef(null);\n  const renderTooltipContent = useCallback(() => {\n    return /* @__PURE__ */jsxs(\"div\", {\n      className: css$8.tooltip,\n      children: [/* @__PURE__ */jsx(\"div\", {\n        className: css$8.tooltipLabel,\n        children: title\n      }), /* @__PURE__ */jsx(\"div\", {\n        className: css$8.tooltipValue,\n        children: formatValue(value2)\n      })]\n    });\n  }, [title, value2]);\n  const {\n    pointerOut,\n    pointerOver\n  } = useHoverIntent({\n    onPointerOver: event => {\n      setHovered(true);\n      onMouseEnter == null ? void 0 : onMouseEnter(event);\n    },\n    onPointerOut: event => {\n      setHovered(false);\n      onMouseLeave == null ? void 0 : onMouseLeave(event);\n    }\n  });\n  const ariaLabelData = useMemo(() => \"\".concat(title, \": \").concat(formatValue(value2)), [title, value2]);\n  return /* @__PURE__ */jsxs(Fragment, {\n    children: [/* @__PURE__ */jsx(motion.g, {\n      ref: rectRef,\n      tabIndex: 0,\n      \"aria-label\": ariaLabelData,\n      role: \"graphics-document\",\n      children: /* @__PURE__ */jsx(motion.rect, {\n        className: classNames(css$8.node, className),\n        fillOpacity: opacity(active, disabled),\n        style,\n        width: nodeWidth,\n        height: nodeHeight,\n        fill: color,\n        initial: {\n          opacity: 0,\n          attrX: x0,\n          attrY: y0\n        },\n        animate: {\n          opacity: 1,\n          attrX: x0,\n          attrY: y0\n        },\n        exit: {\n          opacity: 0,\n          attrX: x0,\n          attrY: y0\n        },\n        transition: {\n          duration: 0.1\n        },\n        onClick,\n        onPointerOver: pointerOver,\n        onPointerOut: pointerOut\n      }, \"sankey-node-\".concat(x0, \"-\").concat(x1, \"-\").concat(y0, \"-\").concat(y1, \"-\").concat(index))\n    }), label2 !== null && /* @__PURE__ */jsx(CloneElement, {\n      active,\n      element: label2,\n      disabled,\n      chartWidth,\n      nodeWidth,\n      node: node2,\n      position: labelPosition,\n      labelPadding\n    }), !((_a = tooltip2 == null ? void 0 : tooltip2.props) == null ? void 0 : _a.disabled) && /* @__PURE__ */jsx(CloneElement, {\n      content: renderTooltipContent,\n      element: tooltip2,\n      visible: hovered,\n      reference: rectRef\n    })]\n  });\n};\nSankeyNode.defaultProps = {\n  active: false,\n  animated: true,\n  color: DEFAULT_COLOR,\n  disabled: false,\n  label: /* @__PURE__ */jsx(SankeyLabel, {}),\n  opacity: (active, disabled) => active ? 1 : disabled ? 0.2 : 0.9,\n  tooltip: /* @__PURE__ */jsx(Tooltip, {\n    theme: tooltipTheme,\n    followCursor: true,\n    modifiers: {\n      offset: {\n        offset: \"0, 5px\"\n      }\n    }\n  })\n};\nconst SparklineChart = props => /* @__PURE__ */jsx(LineChart, {\n  ...props\n});\nSparklineChart.defaultProps = {\n  gridlines: null,\n  series: /* @__PURE__ */jsx(AreaSeries, {\n    symbols: /* @__PURE__ */jsx(PointSeries, {\n      show: \"hover\"\n    }),\n    interpolation: \"smooth\",\n    markLine: null,\n    area: null,\n    line: /* @__PURE__ */jsx(Line, {\n      strokeWidth: 2\n    })\n  }),\n  yAxis: /* @__PURE__ */jsx(LinearYAxis, {\n    scaled: true,\n    type: \"value\",\n    axisLine: null,\n    tickSeries: /* @__PURE__ */jsx(LinearYAxisTickSeries, {\n      line: null,\n      label: null\n    })\n  }),\n  xAxis: /* @__PURE__ */jsx(LinearXAxis, {\n    type: \"time\",\n    scaled: true,\n    axisLine: null,\n    tickSeries: /* @__PURE__ */jsx(LinearXAxisTickSeries, {\n      line: null,\n      label: null\n    })\n  })\n};\nconst AreaSparklineChart = props => /* @__PURE__ */jsx(AreaChart, {\n  ...props\n});\nAreaSparklineChart.defaultProps = {\n  gridlines: null,\n  series: /* @__PURE__ */jsx(AreaSeries, {\n    symbols: /* @__PURE__ */jsx(PointSeries, {\n      show: \"hover\"\n    }),\n    interpolation: \"smooth\",\n    markLine: null,\n    area: /* @__PURE__ */jsx(Area, {\n      mask: /* @__PURE__ */jsx(Stripes, {}),\n      gradient: /* @__PURE__ */jsx(Gradient, {\n        stops: [/* @__PURE__ */jsx(GradientStop, {\n          offset: \"10%\",\n          stopOpacity: 0\n        }, \"start\"), /* @__PURE__ */jsx(GradientStop, {\n          offset: \"80%\",\n          stopOpacity: 1\n        }, \"stop\")]\n      })\n    }),\n    line: /* @__PURE__ */jsx(Line, {\n      strokeWidth: 3\n    })\n  }),\n  yAxis: /* @__PURE__ */jsx(LinearYAxis, {\n    type: \"value\",\n    scaled: true,\n    axisLine: null,\n    tickSeries: /* @__PURE__ */jsx(LinearYAxisTickSeries, {\n      line: null,\n      label: null\n    })\n  }),\n  xAxis: /* @__PURE__ */jsx(LinearXAxis, {\n    type: \"time\",\n    scaled: true,\n    axisLine: null,\n    tickSeries: /* @__PURE__ */jsx(LinearXAxisTickSeries, {\n      line: null,\n      label: null\n    })\n  })\n};\nconst BarSparklineChart = props => /* @__PURE__ */jsx(BarChart, {\n  ...props\n});\nBarSparklineChart.defaultProps = {\n  gridlines: null,\n  series: /* @__PURE__ */jsx(BarSeries, {\n    colorScheme: schemes.cybertron[0]\n  }),\n  yAxis: /* @__PURE__ */jsx(LinearYAxis, {\n    type: \"value\",\n    axisLine: null,\n    tickSeries: /* @__PURE__ */jsx(LinearYAxisTickSeries, {\n      line: null,\n      label: null\n    })\n  }),\n  xAxis: /* @__PURE__ */jsx(LinearXAxis, {\n    type: \"category\",\n    axisLine: null,\n    tickSeries: /* @__PURE__ */jsx(LinearXAxisTickSeries, {\n      line: null,\n      label: null\n    })\n  })\n};\nconst SonarChart = props => /* @__PURE__ */jsx(StackedBarChart, {\n  ...props,\n  margins: 0,\n  gridlines: null,\n  series: /* @__PURE__ */jsx(StackedBarSeries, {\n    type: \"stackedDiverging\",\n    colorScheme: \"rgb(17, 207, 247)\",\n    tooltip: /* @__PURE__ */jsx(TooltipArea, {\n      tooltip: /* @__PURE__ */jsx(ChartTooltip, {\n        followCursor: true,\n        modifiers: {\n          offset: \"5px, 5px\"\n        },\n        content: (data, color) => /* @__PURE__ */jsx(TooltipTemplate, {\n          color,\n          value: {\n            x: formatValue(data.x),\n            y: \"\".concat(formatValue(Math.abs(data.data[0].y)))\n          }\n        })\n      })\n    }),\n    bar: [/* @__PURE__ */jsx(Bar, {\n      width: 1,\n      rangeLines: null,\n      minHeight: 1,\n      gradient: /* @__PURE__ */jsx(Gradient, {\n        stops: [/* @__PURE__ */jsx(GradientStop, {\n          offset: \"5%\",\n          stopOpacity: 0.7\n        }, \"start\"), /* @__PURE__ */jsx(GradientStop, {\n          offset: \"90%\",\n          stopOpacity: 1\n        }, \"stop\")]\n      })\n    }, \"first\"), /* @__PURE__ */jsx(Bar, {\n      width: 1,\n      rangeLines: null,\n      minHeight: 1,\n      gradient: /* @__PURE__ */jsx(Gradient, {\n        stops: [/* @__PURE__ */jsx(GradientStop, {\n          offset: \"5%\",\n          stopOpacity: 1\n        }, \"stop\"), /* @__PURE__ */jsx(GradientStop, {\n          offset: \"90%\",\n          stopOpacity: 0.7\n        }, \"start\")]\n      })\n    }, \"second\")]\n  }),\n  yAxis: /* @__PURE__ */jsx(LinearYAxis, {\n    type: \"value\",\n    axisLine: null,\n    tickSeries: /* @__PURE__ */jsx(LinearYAxisTickSeries, {\n      line: null,\n      label: null\n    })\n  }),\n  xAxis: /* @__PURE__ */jsx(LinearXAxis, {\n    type: \"category\",\n    axisLine: null,\n    tickSeries: /* @__PURE__ */jsx(LinearXAxisTickSeries, {\n      line: null,\n      label: null\n    })\n  })\n});\nconst RadialArea = _ref92 => {\n  let {\n    id,\n    data,\n    className,\n    yScale,\n    color,\n    animated,\n    index,\n    outerRadius,\n    xScale,\n    innerRadius,\n    interpolation,\n    gradient: gradient2,\n    isClosedCurve\n  } = _ref92;\n  const transition = useMemo(() => animated ? {\n    ...DEFAULT_TRANSITION,\n    delay: index * 0.05\n  } : {\n    type: false,\n    delay: 0\n  }, [animated, index]);\n  const getFill = useCallback(c => {\n    if (!gradient2) {\n      return c;\n    }\n    return \"url(#\".concat(id, \"-gradient)\");\n  }, [id, gradient2]);\n  const getPath = useCallback(d => {\n    const curve = interpolation === \"smooth\" ? isClosedCurve ? curveCardinalClosed : curveCardinal : isClosedCurve ? curveLinearClosed : curveLinear;\n    const radialFn = radialArea().angle(dd => xScale(dd.x)).innerRadius(_ => innerRadius).outerRadius(d2 => yScale(d2.y)).curve(curve);\n    return radialFn(d);\n  }, [interpolation, isClosedCurve, xScale, innerRadius, yScale]);\n  const enter = useMemo(() => ({\n    d: getPath(data),\n    opacity: 1\n  }), [data, getPath]);\n  const exit = useMemo(() => {\n    const [yStart] = yScale.domain();\n    return {\n      d: getPath(data.map(d => ({\n        ...d,\n        y: yStart\n      }))),\n      opacity: 0\n    };\n  }, [data, getPath, yScale]);\n  const fill = color(data, 0);\n  return /* @__PURE__ */jsxs(Fragment, {\n    children: [/* @__PURE__ */jsx(MotionPath, {\n      custom: {\n        enter,\n        exit\n      },\n      transition,\n      pointerEvents: \"none\",\n      className,\n      fill: getFill(color)\n    }), gradient2 && /* @__PURE__ */jsx(CloneElement, {\n      element: gradient2,\n      id: \"\".concat(id, \"-gradient\"),\n      radius: outerRadius,\n      color: fill\n    })]\n  });\n};\nRadialArea.defaultProps = {\n  gradient: /* @__PURE__ */jsx(RadialGradient, {}),\n  isClosedCurve: true\n};\nconst RadialLine = _ref93 => {\n  let {\n    xScale,\n    yScale,\n    className,\n    index,\n    hasArea,\n    color,\n    data,\n    interpolation,\n    strokeWidth,\n    animated,\n    isClosedCurve\n  } = _ref93;\n  const fill = color(data, index);\n  const getPath = useCallback(preData => {\n    const curve = interpolation === \"smooth\" ? isClosedCurve ? curveCardinalClosed : curveCardinal : isClosedCurve ? curveLinearClosed : curveLinear;\n    const radialFn = radialLine().angle(d => xScale(d.x)).radius(d => yScale(d.y)).curve(curve);\n    return radialFn(preData);\n  }, [interpolation, isClosedCurve, xScale, yScale]);\n  const transition = useMemo(() => animated ? {\n    ...DEFAULT_TRANSITION,\n    delay: hasArea ? 0 : index * 0.05\n  } : {\n    type: false,\n    delay: 0\n  }, [animated, index, hasArea]);\n  const enter = useMemo(() => ({\n    d: getPath(data),\n    opacity: 1\n  }), [data, getPath]);\n  const exit = useMemo(() => {\n    const [yStart] = yScale.domain();\n    return {\n      d: getPath(data.map(d => ({\n        ...d,\n        y: yStart\n      }))),\n      opacity: 0\n    };\n  }, [data, yScale, getPath]);\n  return /* @__PURE__ */jsx(MotionPath, {\n    custom: {\n      enter,\n      exit\n    },\n    transition,\n    className,\n    pointerEvents: \"none\",\n    stroke: fill,\n    fill: \"none\",\n    strokeWidth\n  });\n};\nRadialLine.defaultProps = {\n  strokeWidth: 2,\n  animated: true,\n  isClosedCurve: true\n};\nconst RadialScatterPlot = _ref94 => {\n  let {\n    id,\n    width,\n    height,\n    margins,\n    className,\n    containerClassName,\n    innerRadius,\n    series,\n    axis,\n    data\n  } = _ref94;\n  const getScales = useCallback((aggregatedData, outer, inner) => {\n    let xScale;\n    if ((axis == null ? void 0 : axis.props.type) === \"category\") {\n      const xDomain = uniqueBy(aggregatedData, dd => dd.x);\n      xScale = scaleBand().range([0, 2 * Math.PI]).domain(xDomain);\n    } else {\n      const xDomain = getXDomain({\n        data: aggregatedData\n      });\n      xScale = scaleTime().range([0, 2 * Math.PI]).domain(xDomain);\n    }\n    const yDomain = getYDomain({\n      data: aggregatedData,\n      scaled: false\n    });\n    const yScale = getRadialYScale(inner, outer, yDomain);\n    return {\n      yScale,\n      xScale\n    };\n  }, []);\n  const renderChart = useCallback(containerProps => {\n    const {\n      chartWidth,\n      chartHeight,\n      id: id2\n    } = containerProps;\n    const outerRadius = Math.min(chartWidth, chartHeight) / 2;\n    const aggregatedData = buildShallowChartData(data);\n    const {\n      yScale,\n      xScale\n    } = getScales(aggregatedData, outerRadius, innerRadius);\n    return /* @__PURE__ */jsxs(Fragment, {\n      children: [axis && /* @__PURE__ */jsx(CloneElement, {\n        element: axis,\n        xScale,\n        height: chartHeight,\n        width: chartWidth,\n        innerRadius\n      }), /* @__PURE__ */jsx(CloneElement, {\n        element: series,\n        id: id2,\n        data: aggregatedData,\n        xScale,\n        yScale\n      })]\n    });\n  }, [data, getScales, innerRadius, series, axis]);\n  return /* @__PURE__ */jsx(ChartContainer, {\n    id,\n    containerClassName,\n    width,\n    height,\n    margins,\n    xAxisVisible: false,\n    yAxisVisible: false,\n    center: true,\n    className,\n    children: renderChart\n  });\n};\nconst inactive = \"_inactive_kwc4n_1\";\nconst hidden = \"_hidden_kwc4n_6\";\nconst css$7 = {\n  inactive,\n  hidden\n};\nconst RadialScatterPoint = _ref95 => {\n  let {\n    size,\n    data,\n    color,\n    index,\n    symbol: symbol2,\n    active,\n    tooltip: tooltip2,\n    yScale,\n    xScale,\n    animated,\n    className,\n    visible,\n    ...rest\n  } = _ref95;\n  const ref = useRef(null);\n  const [hovered, setHovered] = useState(false);\n  function onMouseEnter(event) {\n    setHovered(true);\n    rest.onMouseEnter({\n      value: data,\n      nativeEvent: event\n    });\n  }\n  function onMouseLeave(event) {\n    setHovered(false);\n    rest.onMouseLeave({\n      value: data,\n      nativeEvent: event\n    });\n  }\n  function onClick(event) {\n    rest.onClick({\n      value: data,\n      nativeEvent: event\n    });\n  }\n  function getTranslate(data2) {\n    const fn = radialLine().radius(d => yScale(d.y)).angle(d => xScale(d.x));\n    const path2 = fn([data2]);\n    if (path2) {\n      const [translateX, translateY] = path2.slice(1).slice(0, -1).split(\",\");\n      return {\n        translateX: parseFloat(translateX),\n        translateY: parseFloat(translateY)\n      };\n    }\n  }\n  function getTransition() {\n    if (animated) {\n      return {\n        ...DEFAULT_TRANSITION,\n        delay: index * 5e-3\n      };\n    } else {\n      return {\n        type: false,\n        delay: 0\n      };\n    }\n  }\n  const fill = typeof color === \"function\" ? color(data, index) : color;\n  const transform2 = getTranslate(data);\n  const sizeVal = typeof size === \"function\" ? size(data) : size;\n  const transition = getTransition();\n  const [yStart] = yScale.domain();\n  const exitTransform = getTranslate({\n    ...data,\n    y: yStart\n  });\n  const ariaLabelData = useMemo(() => getAriaLabel(data), [data]);\n  const isVisible = visible ? visible == null ? void 0 : visible(data, index) : active;\n  return /* @__PURE__ */jsxs(Fragment, {\n    children: [/* @__PURE__ */jsxs(motion.g, {\n      initial: {\n        ...exitTransform,\n        opacity: 0\n      },\n      animate: {\n        ...transform2,\n        opacity: 1\n      },\n      exit: {\n        ...exitTransform,\n        opacity: 0\n      },\n      transition,\n      ref,\n      onMouseEnter,\n      onMouseLeave,\n      onClick,\n      className: classNames(className, {\n        [css$7.inactive]: !active,\n        [css$7.hidden]: !isVisible\n      }),\n      tabIndex: 0,\n      \"aria-label\": ariaLabelData,\n      role: \"graphics-document\",\n      children: [symbol2 && symbol2(data), !symbol2 && /* @__PURE__ */jsx(\"circle\", {\n        r: sizeVal,\n        fill\n      })]\n    }), tooltip2 && /* @__PURE__ */jsx(CloneElement, {\n      element: tooltip2,\n      visible: hovered,\n      reference: ref,\n      value: data\n    })]\n  });\n};\nRadialScatterPoint.defaultProps = {\n  size: 3,\n  color: schemes.cybertron[0],\n  tooltip: /* @__PURE__ */jsx(ChartTooltip, {}),\n  active: true,\n  onClick: () => void 0,\n  onMouseEnter: () => void 0,\n  onMouseLeave: () => void 0\n};\nconst RadialScatterSeries = _ref96 => {\n  let {\n    data,\n    point: point2,\n    xScale,\n    yScale,\n    animated,\n    activeIds,\n    show = true,\n    valueMarkers\n  } = _ref96;\n  const [internalActiveIds, setInternalActiveIds] = useState(activeIds);\n  useEffect(() => {\n    setInternalActiveIds(activeIds || []);\n  }, [activeIds]);\n  const onMouseEnter = useCallback(_ref97 => {\n    let {\n      value: value2\n    } = _ref97;\n    if (!activeIds) {\n      setInternalActiveIds([value2.id]);\n    }\n  }, [activeIds]);\n  const onMouseLeave = useCallback(() => {\n    if (!activeIds) {\n      setInternalActiveIds([]);\n    }\n  }, [activeIds]);\n  const isVisible = useCallback(() => show, [show]);\n  const renderPoint = useCallback((d, index) => {\n    var _a;\n    let dataId;\n    if (d.id) {\n      dataId = d.id;\n    } else {\n      console.warn(\"No 'id' property provided for scatter point; provide one via 'id'.\");\n    }\n    const key = identifier(\"\".concat(dataId || index));\n    const active = !(internalActiveIds && internalActiveIds.length) || internalActiveIds.includes(dataId);\n    const pointVisible = (_a = point2.props) == null ? void 0 : _a.visible;\n    return /* @__PURE__ */createElement(CloneElement, {\n      ...(pointVisible ? {} : {\n        visible: isVisible\n      }),\n      element: point2,\n      key,\n      data: d,\n      index,\n      active,\n      xScale,\n      yScale,\n      animated,\n      onMouseEnter,\n      onMouseLeave\n    });\n  }, [isVisible, point2, internalActiveIds, xScale, yScale, animated, onMouseEnter, onMouseLeave]);\n  const renderValueMarkers = useCallback(() => /* @__PURE__ */jsx(Fragment$1, {\n    children: (valueMarkers == null ? void 0 : valueMarkers.length) && valueMarkers.map(marker2 => /* @__PURE__ */jsx(CloneElement, {\n      element: marker2,\n      value: yScale(marker2.props.value)\n    }, marker2.key))\n  }), [valueMarkers, yScale]);\n  return /* @__PURE__ */jsxs(Fragment, {\n    children: [renderValueMarkers(), data.map(renderPoint)]\n  });\n};\nRadialScatterSeries.defaultProps = {\n  point: /* @__PURE__ */jsx(RadialScatterPoint, {}),\n  animated: true\n};\nconst RadialPointSeries = _ref98 => {\n  let {\n    data,\n    xScale,\n    yScale,\n    animated,\n    color,\n    activeValues,\n    show,\n    point: point2\n  } = _ref98;\n  const isVisible = useCallback((point22, index) => {\n    const isActive = activeValues && point22 && isEqual(activeValues.x, point22.x);\n    if (show === \"hover\") {\n      return isActive;\n    } else if (show === \"first\") {\n      if (activeValues) {\n        return isActive;\n      } else {\n        return index === 0;\n      }\n    } else if (show === \"last\") {\n      if (activeValues) {\n        return isActive;\n      } else {\n        return index === data.length - 1;\n      }\n    }\n    return show;\n  }, [data, activeValues, show]);\n  return /* @__PURE__ */jsx(RadialScatterSeries, {\n    animated,\n    data,\n    xScale,\n    yScale,\n    point: /* @__PURE__ */jsx(CloneElement, {\n      element: point2,\n      color,\n      tooltip: null,\n      visible: isVisible\n    })\n  });\n};\nRadialPointSeries.defaultProps = {\n  show: \"hover\",\n  type: \"standard\",\n  point: /* @__PURE__ */jsx(RadialScatterPoint, {})\n};\nconst RadialAreaSeries = _ref99 => {\n  let {\n    area: area2,\n    line: line2,\n    symbols,\n    tooltip: tooltip2,\n    xScale,\n    yScale,\n    data,\n    id,\n    animated,\n    width,\n    height,\n    innerRadius,\n    outerRadius,\n    type,\n    colorScheme,\n    interpolation,\n    startAngle,\n    endAngle,\n    isClosedCurve,\n    valueMarkers\n  } = _ref99;\n  const [activeValues, setActiveValues] = useState(null);\n  const isMulti = type === \"grouped\";\n  const getColorForPoint = useCallback((point2, index) => {\n    var _a;\n    const key = Array.isArray(point2) ? (_a = point2 == null ? void 0 : point2[0]) == null ? void 0 : _a.key : point2 == null ? void 0 : point2.key;\n    return getColor({\n      colorScheme,\n      data,\n      index,\n      point: point2,\n      key\n    });\n  }, [colorScheme, data]);\n  const renderArea = useCallback(function (point2) {\n    let index = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    return /* @__PURE__ */jsxs(Fragment$1, {\n      children: [area2 && /* @__PURE__ */jsx(CloneElement, {\n        element: area2,\n        id: \"\".concat(id, \"-radial-area-\").concat(index),\n        xScale,\n        yScale,\n        animated,\n        color: getColorForPoint,\n        index,\n        data: point2,\n        interpolation,\n        outerRadius,\n        innerRadius,\n        isClosedCurve\n      }), line2 && /* @__PURE__ */jsx(CloneElement, {\n        element: line2,\n        xScale,\n        yScale,\n        hasArea: area2 !== null,\n        index,\n        animated,\n        interpolation,\n        color: getColorForPoint,\n        data: point2,\n        isClosedCurve\n      })]\n    });\n  }, [animated, area2, getColorForPoint, id, innerRadius, interpolation, isClosedCurve, line2, outerRadius, xScale, yScale]);\n  const renderSymbols = useCallback(function (data2) {\n    let index = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    const activeSymbols = symbols && symbols.props.activeValues || activeValues;\n    const isAnimated = area2 !== void 0 && animated && !activeSymbols;\n    return /* @__PURE__ */jsx(CloneElement, {\n      element: symbols,\n      activeValues,\n      xScale,\n      index,\n      yScale,\n      data: data2,\n      animated: isAnimated,\n      color: getColorForPoint\n    });\n  }, [activeValues, animated, area2, getColorForPoint, symbols, xScale, yScale]);\n  const renderSingleSeries = useCallback(points => /* @__PURE__ */jsxs(Fragment, {\n    children: [renderArea(points), symbols && renderSymbols(points)]\n  }), [renderArea, renderSymbols, symbols]);\n  const renderMultiSeries = useCallback(points => /* @__PURE__ */jsxs(Fragment, {\n    children: [points.map((point2, index) => /* @__PURE__ */jsx(Fragment, {\n      children: renderArea(point2.data, index)\n    }, \"\".concat(point2.key.toString()))).reverse(), points.map((point2, index) => /* @__PURE__ */jsx(Fragment, {\n      children: renderSymbols(point2.data, index)\n    }, \"\".concat(point2.key.toString()))).reverse()]\n  }), [renderArea, renderSymbols]);\n  const renderValueMarkers = useCallback(() => /* @__PURE__ */jsx(Fragment$1, {\n    children: (valueMarkers == null ? void 0 : valueMarkers.length) && valueMarkers.map(marker2 => /* @__PURE__ */jsx(CloneElement, {\n      element: marker2,\n      value: yScale(marker2.props.value)\n    }, marker2.key))\n  }), [valueMarkers, yScale]);\n  return /* @__PURE__ */jsx(CloneElement, {\n    element: tooltip2,\n    xScale,\n    yScale,\n    data,\n    height,\n    width,\n    isRadial: true,\n    innerRadius,\n    outerRadius,\n    color: getColorForPoint,\n    onValueEnter: event => setActiveValues(event.value),\n    onValueLeave: () => setActiveValues(null),\n    startAngle,\n    endAngle,\n    children: /* @__PURE__ */jsxs(\"g\", {\n      clipPath: \"url(#\".concat(id, \"-path)\"),\n      children: [isMulti && renderMultiSeries(data), !isMulti && renderSingleSeries(data), renderValueMarkers()]\n    })\n  });\n};\nRadialAreaSeries.defaultProps = {\n  colorScheme: schemes.cybertron,\n  interpolation: \"smooth\",\n  type: \"standard\",\n  animated: true,\n  area: /* @__PURE__ */jsx(RadialArea, {}),\n  line: /* @__PURE__ */jsx(RadialLine, {}),\n  symbols: /* @__PURE__ */jsx(RadialPointSeries, {}),\n  tooltip: /* @__PURE__ */jsx(TooltipArea, {}),\n  startAngle: 0,\n  endAngle: 2 * Math.PI,\n  isClosedCurve: true\n};\nconst RadialAreaChart = _ref100 => {\n  let {\n    id,\n    width,\n    height,\n    className,\n    data,\n    containerClassName,\n    innerRadius,\n    series,\n    axis,\n    margins,\n    startAngle,\n    endAngle,\n    isClosedCurve\n  } = _ref100;\n  const getXScale2 = useCallback(points => {\n    const isFullCircle = Math.abs(endAngle - startAngle) >= 2 * Math.PI;\n    let xScale;\n    if ((axis == null ? void 0 : axis.props.type) === \"category\") {\n      const isMultiSeries = series.props.type === \"grouped\";\n      let xDomain;\n      if (isMultiSeries) {\n        xDomain = uniqueBy(points, dd => dd.data, dd => dd.x);\n      } else {\n        xDomain = uniqueBy(points, dd => dd.x);\n      }\n      if (isFullCircle) {\n        xScale = scaleBand().range([0, 2 * Math.PI]).domain(xDomain);\n      } else {\n        xScale = scalePoint().range([startAngle, endAngle]).domain(xDomain);\n      }\n    } else {\n      const xDomain = getXDomain({\n        data: points\n      });\n      xScale = scaleTime().range([startAngle, endAngle]).domain(xDomain);\n    }\n    return xScale;\n  }, [axis == null ? void 0 : axis.props.type, endAngle, series.props.type, startAngle]);\n  const getScales = useCallback((preData, outerRadius, innerRadius2) => {\n    const isMultiSeries = series.props.type === \"grouped\";\n    let d;\n    if (isMultiSeries) {\n      d = buildNestedChartData(preData, true);\n    } else {\n      d = buildShallowChartData(preData);\n    }\n    const xScale = getXScale2(d);\n    const yDomain = getYDomain({\n      data: d,\n      scaled: false\n    });\n    const yScale = getRadialYScale(innerRadius2, outerRadius, yDomain);\n    return {\n      yScale,\n      xScale,\n      result: d\n    };\n  }, [getXScale2, series.props.type]);\n  const renderChart = useCallback(containerProps => {\n    const {\n      chartWidth,\n      chartHeight,\n      id: id2\n    } = containerProps;\n    const outerRadius = Math.min(chartWidth, chartHeight) / 2;\n    const {\n      yScale,\n      xScale,\n      result\n    } = getScales(data, outerRadius, innerRadius);\n    return /* @__PURE__ */jsxs(Fragment, {\n      children: [axis && /* @__PURE__ */jsx(CloneElement, {\n        element: axis,\n        xScale,\n        height: chartHeight,\n        width: chartWidth,\n        innerRadius,\n        startAngle,\n        endAngle\n      }), /* @__PURE__ */jsx(CloneElement, {\n        element: series,\n        id: id2,\n        data: result,\n        xScale,\n        yScale,\n        height: chartHeight,\n        width: chartWidth,\n        outerRadius,\n        innerRadius,\n        startAngle,\n        endAngle,\n        isClosedCurve\n      })]\n    });\n  }, [getScales, data, innerRadius, axis, startAngle, endAngle, series, isClosedCurve]);\n  return /* @__PURE__ */jsx(ChartContainer, {\n    id,\n    width,\n    height,\n    containerClassName,\n    margins,\n    xAxisVisible: false,\n    yAxisVisible: false,\n    center: true,\n    className,\n    children: renderChart\n  });\n};\nRadialAreaChart.defaultProps = {\n  innerRadius: 0.1,\n  series: /* @__PURE__ */jsx(RadialAreaSeries, {}),\n  axis: /* @__PURE__ */jsx(RadialAxis, {}),\n  margins: 75,\n  startAngle: 0,\n  endAngle: 2 * Math.PI,\n  isClosedCurve: true\n};\nconst pi = Math.PI,\n  tau = 2 * pi,\n  epsilon = 1e-6,\n  tauEpsilon = tau - epsilon;\nfunction append(strings) {\n  this._ += strings[0];\n  for (let i = 1, n = strings.length; i < n; ++i) {\n    this._ += arguments[i] + strings[i];\n  }\n}\nfunction appendRound(digits) {\n  let d = Math.floor(digits);\n  if (!(d >= 0)) throw new Error(\"invalid digits: \".concat(digits));\n  if (d > 15) return append;\n  const k = 10 ** d;\n  return function (strings) {\n    this._ += strings[0];\n    for (let i = 1, n = strings.length; i < n; ++i) {\n      this._ += Math.round(arguments[i] * k) / k + strings[i];\n    }\n  };\n}\nclass Path {\n  constructor(digits) {\n    this._x0 = this._y0 =\n    // start of current subpath\n    this._x1 = this._y1 = null;\n    this._ = \"\";\n    this._append = digits == null ? append : appendRound(digits);\n  }\n  moveTo(x, y) {\n    this._append(_templateObject || (_templateObject = _taggedTemplateLiteral([\"M\", \",\", \"\"])), this._x0 = this._x1 = +x, this._y0 = this._y1 = +y);\n  }\n  closePath() {\n    if (this._x1 !== null) {\n      this._x1 = this._x0, this._y1 = this._y0;\n      this._append(_templateObject2 || (_templateObject2 = _taggedTemplateLiteral([\"Z\"])));\n    }\n  }\n  lineTo(x, y) {\n    this._append(_templateObject3 || (_templateObject3 = _taggedTemplateLiteral([\"L\", \",\", \"\"])), this._x1 = +x, this._y1 = +y);\n  }\n  quadraticCurveTo(x1, y1, x, y) {\n    this._append(_templateObject4 || (_templateObject4 = _taggedTemplateLiteral([\"Q\", \",\", \",\", \",\", \"\"])), +x1, +y1, this._x1 = +x, this._y1 = +y);\n  }\n  bezierCurveTo(x1, y1, x2, y2, x, y) {\n    this._append(_templateObject5 || (_templateObject5 = _taggedTemplateLiteral([\"C\", \",\", \",\", \",\", \",\", \",\", \"\"])), +x1, +y1, +x2, +y2, this._x1 = +x, this._y1 = +y);\n  }\n  arcTo(x1, y1, x2, y2, r) {\n    x1 = +x1, y1 = +y1, x2 = +x2, y2 = +y2, r = +r;\n    if (r < 0) throw new Error(\"negative radius: \".concat(r));\n    let x0 = this._x1,\n      y0 = this._y1,\n      x21 = x2 - x1,\n      y21 = y2 - y1,\n      x01 = x0 - x1,\n      y01 = y0 - y1,\n      l01_2 = x01 * x01 + y01 * y01;\n    if (this._x1 === null) {\n      this._append(_templateObject6 || (_templateObject6 = _taggedTemplateLiteral([\"M\", \",\", \"\"])), this._x1 = x1, this._y1 = y1);\n    } else if (!(l01_2 > epsilon)) ;else if (!(Math.abs(y01 * x21 - y21 * x01) > epsilon) || !r) {\n      this._append(_templateObject7 || (_templateObject7 = _taggedTemplateLiteral([\"L\", \",\", \"\"])), this._x1 = x1, this._y1 = y1);\n    } else {\n      let x20 = x2 - x0,\n        y20 = y2 - y0,\n        l21_2 = x21 * x21 + y21 * y21,\n        l20_2 = x20 * x20 + y20 * y20,\n        l21 = Math.sqrt(l21_2),\n        l01 = Math.sqrt(l01_2),\n        l = r * Math.tan((pi - Math.acos((l21_2 + l01_2 - l20_2) / (2 * l21 * l01))) / 2),\n        t01 = l / l01,\n        t21 = l / l21;\n      if (Math.abs(t01 - 1) > epsilon) {\n        this._append(_templateObject8 || (_templateObject8 = _taggedTemplateLiteral([\"L\", \",\", \"\"])), x1 + t01 * x01, y1 + t01 * y01);\n      }\n      this._append(_templateObject9 || (_templateObject9 = _taggedTemplateLiteral([\"A\", \",\", \",0,0,\", \",\", \",\", \"\"])), r, r, +(y01 * x20 > x01 * y20), this._x1 = x1 + t21 * x21, this._y1 = y1 + t21 * y21);\n    }\n  }\n  arc(x, y, r, a0, a1, ccw) {\n    x = +x, y = +y, r = +r, ccw = !!ccw;\n    if (r < 0) throw new Error(\"negative radius: \".concat(r));\n    let dx = r * Math.cos(a0),\n      dy = r * Math.sin(a0),\n      x0 = x + dx,\n      y0 = y + dy,\n      cw = 1 ^ ccw,\n      da = ccw ? a0 - a1 : a1 - a0;\n    if (this._x1 === null) {\n      this._append(_templateObject10 || (_templateObject10 = _taggedTemplateLiteral([\"M\", \",\", \"\"])), x0, y0);\n    } else if (Math.abs(this._x1 - x0) > epsilon || Math.abs(this._y1 - y0) > epsilon) {\n      this._append(_templateObject11 || (_templateObject11 = _taggedTemplateLiteral([\"L\", \",\", \"\"])), x0, y0);\n    }\n    if (!r) return;\n    if (da < 0) da = da % tau + tau;\n    if (da > tauEpsilon) {\n      this._append(_templateObject12 || (_templateObject12 = _taggedTemplateLiteral([\"A\", \",\", \",0,1,\", \",\", \",\", \"A\", \",\", \",0,1,\", \",\", \",\", \"\"])), r, r, cw, x - dx, y - dy, r, r, cw, this._x1 = x0, this._y1 = y0);\n    } else if (da > epsilon) {\n      this._append(_templateObject13 || (_templateObject13 = _taggedTemplateLiteral([\"A\", \",\", \",0,\", \",\", \",\", \",\", \"\"])), r, r, +(da >= pi), cw, this._x1 = x + r * Math.cos(a1), this._y1 = y + r * Math.sin(a1));\n    }\n  }\n  rect(x, y, w, h) {\n    this._append(_templateObject14 || (_templateObject14 = _taggedTemplateLiteral([\"M\", \",\", \"h\", \"v\", \"h\", \"Z\"])), this._x0 = this._x1 = +x, this._y0 = this._y1 = +y, w = +w, +h, -w);\n  }\n  toString() {\n    return this._;\n  }\n}\nfunction path() {\n  return new Path();\n}\npath.prototype = Path.prototype;\nconst MotionBar = _ref101 => {\n  let {\n    custom,\n    transition,\n    arc: arc2,\n    ...rest\n  } = _ref101;\n  const d = useMotionValue(\"\");\n  const currentYRef = useRef(custom.exit.y);\n  const spring = useSpring(0, DEFAULT_TRANSITION);\n  useEffect(() => {\n    const interpolator = interpolate$1(currentYRef.current, custom.enter.y);\n    const prevSpring = spring.get();\n    let timeoutId;\n    if (transition == null ? void 0 : transition.delay) {\n      timeoutId = setTimeout(() => {\n        spring.set(prevSpring + 1);\n      }, transition.delay * 1e3);\n    } else {\n      spring.set(prevSpring + 1);\n    }\n    const unsubscribe = spring.onChange(v => {\n      currentYRef.current = interpolator(v - prevSpring);\n      d.set(arc2({\n        ...custom.enter,\n        y: currentYRef.current\n      }));\n    });\n    return () => {\n      if (timeoutId) {\n        clearTimeout(timeoutId);\n      }\n      unsubscribe();\n    };\n  }, [arc2, custom.enter, d, spring, transition.delay]);\n  const {\n    d: enterD,\n    ...enterRest\n  } = custom.enter;\n  const {\n    d: exitD,\n    ...exitRest\n  } = custom.exit;\n  return /* @__PURE__ */jsx(motion.path, {\n    ...rest,\n    initial: exitRest,\n    exit: exitRest,\n    animate: enterRest,\n    transition,\n    d: transition.type !== false ? d : enterD,\n    tabIndex: 0\n  });\n};\nconst RadialGuideBar = _ref102 => {\n  let {\n    active,\n    path: path2,\n    fill = \"#eee\",\n    opacity = 0.2\n  } = _ref102;\n  return /* @__PURE__ */jsx(motion.path, {\n    d: path2,\n    fill,\n    pointerEvents: \"none\",\n    initial: \"hidden\",\n    animate: active ? \"visible\" : \"hidden\",\n    variants: {\n      hidden: {\n        opacity: 0\n      },\n      visible: {\n        opacity\n      }\n    }\n  });\n};\nRadialGuideBar.defaultProps = {\n  fill: \"#eee\",\n  opacity: 0.2\n};\nconst RadialBar = _ref103 => {\n  let {\n    animated,\n    innerRadius,\n    xScale,\n    yScale,\n    curved,\n    id,\n    gradient: gradient2,\n    barCount,\n    innerBarCount,\n    groupIndex,\n    className,\n    data,\n    active,\n    guide,\n    index,\n    color,\n    onClick,\n    onMouseEnter,\n    onMouseLeave\n  } = _ref103;\n  const previousEnter = useRef(null);\n  const fill = color(data, index);\n  const currentColorShade = active ? chroma(fill).brighten(0.5) : fill;\n  const transition = useMemo(() => {\n    if (animated) {\n      return {\n        ...DEFAULT_TRANSITION,\n        delay: index / barCount * 0.9\n      };\n    } else {\n      return {\n        type: false,\n        delay: 0\n      };\n    }\n  }, [animated, barCount, index]);\n  const getFill = useCallback(color2 => {\n    if (!gradient2) {\n      return color2;\n    }\n    return \"url(#\".concat(id, \"-gradient)\");\n  }, [gradient2, id]);\n  const getArc = useCallback(data2 => {\n    const outerRadius = yScale(data2.y);\n    if (curved) {\n      const startAngle = xScale(data2.x);\n      const endAngle = startAngle + xScale.bandwidth();\n      const arcFn = arc().innerRadius(innerRadius).outerRadius(outerRadius).startAngle(startAngle).endAngle(endAngle).padAngle(0.01).padRadius(innerRadius);\n      return arcFn(data2);\n    } else {\n      const isMultiSeries = groupIndex !== void 0;\n      const xScaleDomain = xScale.domain();\n      const xScaleRange = xScale.range();\n      const isFullCircle = Math.abs(xScaleRange[1] - xScaleRange[0]) >= 2 * Math.PI;\n      let xScaleBandwidth;\n      let rotateMid;\n      let startAngle;\n      let endAngle;\n      if (isFullCircle) {\n        xScaleBandwidth = xScale.bandwidth();\n        rotateMid = isMultiSeries && xScaleBandwidth ? xScaleBandwidth / 2 : 0;\n        startAngle = xScale(data2.x) - Math.PI * 0.5 - rotateMid;\n        endAngle = startAngle + xScaleBandwidth;\n      } else {\n        xScaleBandwidth = scaleBand().domain(xScaleDomain).range(xScaleRange).bandwidth();\n        rotateMid = isMultiSeries && xScaleBandwidth ? xScaleBandwidth / 2 : 0;\n        if (index === 0) {\n          startAngle = xScale(data2.x) - Math.PI * 0.5;\n          endAngle = startAngle + xScaleBandwidth - rotateMid;\n        } else if (index === barCount - 1) {\n          endAngle = xScaleRange[1] - Math.PI * 0.5;\n          startAngle = endAngle - xScaleBandwidth + rotateMid;\n        } else {\n          startAngle = xScale(data2.x) - Math.PI * 0.5 - rotateMid;\n          endAngle = startAngle + xScaleBandwidth;\n        }\n      }\n      const innerAngleDistance = endAngle - startAngle;\n      const arcLength = innerRadius * innerAngleDistance;\n      const outerAngleDistance = arcLength / outerRadius;\n      const halfAngleDistanceDelta = (innerAngleDistance - outerAngleDistance) / 2;\n      const innerDiff = innerAngleDistance / innerBarCount;\n      const innerStart = isMultiSeries ? startAngle + groupIndex * innerDiff : startAngle;\n      const innerEnd = isMultiSeries ? innerStart + innerDiff : endAngle;\n      const outerDiff = outerAngleDistance / innerBarCount;\n      const halfAngleDiffDistanceDelta = isMultiSeries ? (innerDiff - outerDiff) / 2 : halfAngleDistanceDelta;\n      const pathFn = path();\n      pathFn.arc(0, 0, innerRadius, innerStart, innerEnd);\n      pathFn.arc(0, 0, outerRadius, innerEnd - halfAngleDiffDistanceDelta, innerStart + halfAngleDiffDistanceDelta, true);\n      return pathFn.toString();\n    }\n  }, [barCount, curved, groupIndex, index, innerBarCount, innerRadius, xScale, yScale]);\n  const renderBar = useCallback(color2 => {\n    const fill2 = getFill(color2);\n    const prev = previousEnter.current ? {\n      ...previousEnter.current\n    } : void 0;\n    previousEnter.current = {\n      ...data\n    };\n    const [yStart, yEnd] = yScale.domain();\n    const exit = {\n      ...data,\n      y: yStart\n    };\n    const guidePath = getArc({\n      ...data,\n      y: yEnd\n    });\n    return /* @__PURE__ */jsxs(Fragment, {\n      children: [guide && /* @__PURE__ */jsx(CloneElement, {\n        element: guide,\n        active,\n        path: guidePath\n      }), /* @__PURE__ */jsx(MotionBar, {\n        arc: getArc,\n        custom: {\n          enter: data,\n          exit,\n          previousEnter: prev\n        },\n        transition,\n        fill: fill2,\n        className,\n        onMouseEnter: event => onMouseEnter == null ? void 0 : onMouseEnter({\n          value: data,\n          nativeEvent: event\n        }),\n        onMouseLeave: event => onMouseLeave == null ? void 0 : onMouseLeave({\n          value: data,\n          nativeEvent: event\n        }),\n        onClick: event => onClick == null ? void 0 : onClick({\n          value: data,\n          nativeEvent: event\n        })\n      })]\n    });\n  }, [active, className, data, getArc, getFill, guide, onClick, onMouseEnter, onMouseLeave, transition, yScale]);\n  return /* @__PURE__ */jsxs(Fragment, {\n    children: [renderBar(currentColorShade), gradient2 && /* @__PURE__ */jsx(Gradient, {\n      id: \"\".concat(id, \"-gradient\"),\n      color: currentColorShade\n    })]\n  });\n};\nRadialBar.defaultProps = {\n  gradient: true,\n  curved: false,\n  guide: /* @__PURE__ */jsx(RadialGuideBar, {}),\n  onClick: () => void 0,\n  onMouseEnter: () => void 0,\n  onMouseLeave: () => void 0\n};\nconst RadialBarSeries = _ref104 => {\n  let {\n    data,\n    id,\n    innerRadius,\n    outerRadius,\n    xScale,\n    yScale,\n    height,\n    width,\n    tooltip: tooltip2,\n    colorScheme,\n    bar: bar2,\n    animated,\n    startAngle,\n    endAngle,\n    type,\n    valueMarkers\n  } = _ref104;\n  const [activeValues, setActiveValues] = useState(null);\n  const isMultiSeries = useMemo(() => type === \"grouped\", [type]);\n  const renderBar = useCallback((point2, innerBarCount, index, barCount, groupIndex) => {\n    const active = activeValues && data && isEqual(activeValues.x, point2.x);\n    return /* @__PURE__ */jsx(Fragment, {\n      children: /* @__PURE__ */jsx(CloneElement, {\n        element: bar2,\n        id: \"radialbar-\".concat(id, \"-\").concat(index),\n        index,\n        data: point2,\n        xScale,\n        active,\n        yScale,\n        innerRadius,\n        color: point22 => getColor({\n          data,\n          point: point22,\n          index: 0,\n          colorScheme\n        }),\n        barCount,\n        innerBarCount,\n        groupIndex,\n        animated,\n        startAngle,\n        endAngle\n      })\n    }, index);\n  }, [activeValues, animated, bar2, colorScheme, data, endAngle, id, innerRadius, startAngle, xScale, yScale]);\n  const renderBarGroup = useCallback((data2, innerBarCount, barCount, groupIndex) => {\n    return /* @__PURE__ */jsx(Fragment, {\n      children: data2.map((barData, barIndex) => renderBar(barData, innerBarCount, barIndex, barCount, groupIndex))\n    });\n  }, [renderBar]);\n  const renderValueMarkers = useCallback(() => /* @__PURE__ */jsx(Fragment$1, {\n    children: (valueMarkers == null ? void 0 : valueMarkers.length) && valueMarkers.map(marker2 => /* @__PURE__ */jsx(CloneElement, {\n      element: marker2,\n      value: yScale(marker2.props.value)\n    }, marker2.key))\n  }), [valueMarkers, yScale]);\n  return /* @__PURE__ */jsxs(CloneElement, {\n    element: tooltip2,\n    xScale,\n    yScale,\n    data,\n    height,\n    width,\n    isRadial: true,\n    innerRadius,\n    outerRadius,\n    onValueEnter: event => setActiveValues(event.value),\n    onValueLeave: () => setActiveValues(null),\n    color: (point2, index) => getColor({\n      data,\n      point: point2,\n      index,\n      colorScheme\n    }),\n    startAngle,\n    endAngle,\n    children: [isMultiSeries ? data.map((groupData, index) => /* @__PURE__ */jsx(\"g\", {\n      children: renderBarGroup(groupData.data, data.length, groupData.data.length, index)\n    }, \"bar-group-\".concat(index))) : renderBarGroup(data, 1, data.length), renderValueMarkers()]\n  });\n};\nRadialBarSeries.defaultProps = {\n  colorScheme: schemes.cybertron[0],\n  tooltip: /* @__PURE__ */jsx(TooltipArea, {\n    tooltip: /* @__PURE__ */jsx(ChartTooltip, {\n      followCursor: true\n    })\n  }),\n  bar: /* @__PURE__ */jsx(RadialBar, {}),\n  animated: true,\n  startAngle: 0,\n  endAngle: 2 * Math.PI,\n  type: \"standard\"\n};\nconst RadialBarChart = _ref105 => {\n  let {\n    id,\n    width,\n    height,\n    margins,\n    className,\n    containerClassName,\n    data,\n    innerRadius,\n    series,\n    axis,\n    startAngle,\n    endAngle\n  } = _ref105;\n  const getXScale2 = useCallback(points => {\n    const isFullCircle = Math.abs(endAngle - startAngle) >= 2 * Math.PI;\n    let xScale;\n    if ((axis == null ? void 0 : axis.props.type) === \"category\") {\n      const isMultiSeries = series.props.type === \"grouped\";\n      let xDomain;\n      if (isMultiSeries) {\n        xDomain = uniqueBy(points, dd => dd.data, dd => dd.x);\n      } else {\n        xDomain = uniqueBy(points, dd => dd.x);\n      }\n      if (isFullCircle) {\n        xScale = scaleBand().range([0, 2 * Math.PI]).domain(xDomain);\n      } else {\n        xScale = scalePoint().range([startAngle, endAngle]).domain(xDomain);\n      }\n    } else {\n      const xDomain = uniqueBy(points, d => d.x);\n      xScale = scaleBand().range([startAngle, endAngle]).domain(xDomain);\n    }\n    return xScale;\n  }, [axis == null ? void 0 : axis.props.type, endAngle, series.props.type, startAngle]);\n  const getScales = useCallback((preData, innerRadius2, outerRadius) => {\n    const isMultiSeries = series.props.type === \"grouped\";\n    let newData;\n    if (isMultiSeries) {\n      newData = buildNestedChartData(preData, true);\n    } else {\n      newData = buildShallowChartData(preData);\n    }\n    const yDomain = getYDomain({\n      data: newData,\n      scaled: false\n    });\n    const yScale = getRadialYScale(innerRadius2, outerRadius, yDomain);\n    const xScale = getXScale2(newData);\n    return {\n      xScale,\n      yScale,\n      newData\n    };\n  }, [getXScale2, series.props.type]);\n  const renderChart = useCallback(_ref106 => {\n    let {\n      chartWidth,\n      chartHeight,\n      id: id2\n    } = _ref106;\n    const outerRadius = Math.min(chartWidth, chartHeight) / 2;\n    const {\n      yScale,\n      xScale,\n      newData\n    } = getScales(data, innerRadius, outerRadius);\n    return /* @__PURE__ */jsxs(Fragment, {\n      children: [axis && /* @__PURE__ */jsx(CloneElement, {\n        element: axis,\n        xScale,\n        height: chartHeight,\n        width: chartWidth,\n        innerRadius,\n        startAngle,\n        endAngle\n      }), /* @__PURE__ */jsx(CloneElement, {\n        element: series,\n        id: id2,\n        data: newData,\n        height: chartHeight,\n        width: chartWidth,\n        xScale,\n        yScale,\n        innerRadius,\n        outerRadius,\n        startAngle,\n        endAngle\n      })]\n    });\n  }, [axis, data, endAngle, getScales, innerRadius, series, startAngle]);\n  return /* @__PURE__ */jsx(ChartContainer, {\n    id,\n    width,\n    height,\n    margins,\n    xAxisVisible: false,\n    yAxisVisible: false,\n    center: true,\n    className,\n    containerClassName,\n    children: renderChart\n  });\n};\nRadialBarChart.defaultProps = {\n  innerRadius: 10,\n  margins: 75,\n  axis: /* @__PURE__ */jsx(RadialAxis, {}),\n  series: /* @__PURE__ */jsx(RadialBarSeries, {}),\n  startAngle: 0,\n  endAngle: 2 * Math.PI\n};\nconst RadialGaugeArc = _ref107 => {\n  let {\n    data,\n    gradient: gradient2,\n    startAngle,\n    id,\n    endAngle,\n    innerRadius,\n    outerRadius,\n    cornerRadius,\n    padAngle,\n    color,\n    animated,\n    disabled,\n    fill,\n    onClick,\n    onMouseEnter,\n    onMouseLeave,\n    tooltip: tooltip2\n  } = _ref107;\n  const arcGenerator = useMemo(() => {\n    return arc().innerRadius(innerRadius).outerRadius(outerRadius).cornerRadius(cornerRadius);\n  }, [innerRadius, outerRadius, cornerRadius]);\n  const arcElement = useMemo(() => {\n    const arcData = {\n      // @ts-ignore Data must be passed\n      data: data || {},\n      startAngle,\n      endAngle,\n      padAngle\n    };\n    return /* @__PURE__ */jsx(PieArc, {\n      id,\n      arc: arcGenerator,\n      data: arcData,\n      animated,\n      color,\n      gradient: gradient2,\n      disabled,\n      tooltip: tooltip2,\n      onClick,\n      onMouseEnter,\n      onMouseLeave\n    });\n  }, [id, arcGenerator, startAngle, endAngle, padAngle, data, animated, color, gradient2, disabled, tooltip2, onClick, onMouseEnter, onMouseLeave]);\n  return /* @__PURE__ */jsxs(\"g\", {\n    children: [fill && /* @__PURE__ */jsx(\"circle\", {\n      fill,\n      r: outerRadius\n    }), arcElement]\n  });\n};\nRadialGaugeArc.defaultProps = {\n  cornerRadius: 0,\n  padAngle: 0,\n  padRadius: 0,\n  color: \"#353d44\",\n  animated: true,\n  disabled: false,\n  tooltip: /* @__PURE__ */jsx(ChartTooltip, {})\n};\nconst valueLabel$2 = \"_valueLabel_1eyd5_1\";\nconst css$6 = {\n  valueLabel: valueLabel$2\n};\nconst RadialGaugeLabel = _ref108 => {\n  let {\n    data,\n    className,\n    offset,\n    onClick = () => void 0\n  } = _ref108;\n  const label2 = formatValue(data.key);\n  return /* @__PURE__ */jsx(\"text\", {\n    x: \"0\",\n    y: offset,\n    textAnchor: \"middle\",\n    alignmentBaseline: \"text-after-edge\",\n    onClick: nativeEvent => onClick({\n      data,\n      nativeEvent\n    }),\n    className: classNames(className, css$6.valueLabel),\n    children: label2\n  });\n};\nconst valueLabel$1 = \"_valueLabel_1h164_1\";\nconst css$5 = {\n  valueLabel: valueLabel$1\n};\nconst RadialGaugeValueLabel = _ref109 => {\n  let {\n    data,\n    className\n  } = _ref109;\n  const ref = useCount({\n    to: data.data\n  });\n  return /* @__PURE__ */jsx(\"text\", {\n    dy: \"-0.5em\",\n    x: \"0\",\n    y: \"15\",\n    textAnchor: \"middle\",\n    className: classNames(className, css$5.valueLabel),\n    ref\n  });\n};\nconst RadialGaugeOuterArc = props => /* @__PURE__ */jsx(RadialGaugeArc, {\n  ...props\n});\nRadialGaugeOuterArc.defaultProps = {\n  animated: false,\n  disabled: true\n};\nconst RadialGaugeSeries = _ref110 => {\n  let {\n    data,\n    scale: scale2,\n    startAngle,\n    endAngle,\n    arcWidth,\n    outerArc,\n    innerArc,\n    label: label2,\n    valueLabel: valueLabel2,\n    colorScheme,\n    id,\n    padding,\n    minGaugeWidth,\n    ...props\n  } = _ref110;\n  const {\n    columns,\n    width,\n    height,\n    xScale,\n    yScale\n  } = useMemo(() => {\n    let rows = 1;\n    let columns2 = data.length;\n    if (props.width / data.length < minGaugeWidth) {\n      while (props.width / columns2 < minGaugeWidth) {\n        rows += 1;\n        columns2 = Math.ceil(data.length / rows);\n      }\n    }\n    const xScale2 = scaleBand();\n    xScale2.domain(range(columns2));\n    xScale2.rangeRound([0, props.width], 0.1);\n    const yScale2 = scaleBand();\n    yScale2.domain(range(rows));\n    yScale2.rangeRound([0, props.height], 0.1);\n    return {\n      columns: columns2,\n      xScale: xScale2,\n      yScale: yScale2,\n      width: xScale2.bandwidth(),\n      height: yScale2.bandwidth()\n    };\n  }, [data.length, minGaugeWidth, props.height, props.width]);\n  const renderGauge = useCallback((point2, index) => {\n    var _a;\n    const dataEndAngle = scale2(point2.data);\n    const outerRadius = min([width - padding * 2, height - padding * 2]) / 2;\n    const innerRadius = outerRadius - arcWidth;\n    const labelOffset = height / 2;\n    const x = xScale(index % columns);\n    const y = yScale(Math.floor(index / columns));\n    const xOffset = x + width / 2;\n    const yOffset = y + height / 2;\n    const key = identifier((_a = point2.key) == null ? void 0 : _a.toLocaleString());\n    return /* @__PURE__ */jsxs(\"g\", {\n      transform: \"translate(\".concat(xOffset, \", \").concat(yOffset, \")\"),\n      children: [outerArc && cloneElement(outerArc, {\n        id: \"\".concat(id, \"-\").concat(key, \"-outer\"),\n        outerRadius,\n        innerRadius,\n        startAngle,\n        endAngle\n      }), innerArc && cloneElement(innerArc, {\n        id: \"\".concat(id, \"-\").concat(key, \"-inner\"),\n        outerRadius,\n        innerRadius,\n        startAngle,\n        endAngle: dataEndAngle,\n        data: point2,\n        color: getColor({\n          data,\n          colorScheme,\n          point: point2,\n          index\n        })\n      }), valueLabel2 && cloneElement(valueLabel2, {\n        data: point2\n      }), label2 && cloneElement(label2, {\n        data: point2,\n        offset: labelOffset\n      })]\n    }, key);\n  }, [id, arcWidth, colorScheme, columns, data, endAngle, height, innerArc, label2, outerArc, padding, scale2, startAngle, valueLabel2, width, xScale, yScale]);\n  return /* @__PURE__ */jsx(Fragment, {\n    children: data.map(renderGauge)\n  });\n};\nRadialGaugeSeries.defaultProps = {\n  arcWidth: 5,\n  outerArc: /* @__PURE__ */jsx(RadialGaugeOuterArc, {}),\n  innerArc: /* @__PURE__ */jsx(RadialGaugeArc, {}),\n  label: /* @__PURE__ */jsx(RadialGaugeLabel, {}),\n  valueLabel: /* @__PURE__ */jsx(RadialGaugeValueLabel, {}),\n  colorScheme: [\"#00ECB1\"],\n  padding: 20,\n  minGaugeWidth: 50\n};\nconst RadialGaugeStackedArc = _ref111 => {\n  let {\n    id,\n    data,\n    scale: scale2,\n    innerRadius,\n    outerRadius,\n    cornerRadius,\n    padAngle,\n    startAngle,\n    colorScheme,\n    ...restProps\n  } = _ref111;\n  const arcGenerator = useMemo(() => {\n    return arc().innerRadius(innerRadius).outerRadius(outerRadius).cornerRadius(cornerRadius);\n  }, [innerRadius, outerRadius, cornerRadius]);\n  const stackedArcs = useMemo(() => {\n    let prevEndAngle = startAngle;\n    function renderArc(point2, index) {\n      const value2 = point2.data;\n      const startArcAngle = prevEndAngle;\n      const endArcAngle = startArcAngle + scale2(value2) - startAngle;\n      prevEndAngle = endArcAngle;\n      const arcData = {\n        data: point2,\n        startAngle: startArcAngle,\n        endAngle: endArcAngle,\n        padAngle,\n        value: value2,\n        index\n      };\n      const color = getColor({\n        colorScheme,\n        data: [data],\n        point: point2,\n        index,\n        active: [data],\n        isMultiSeries: true\n      });\n      return /* @__PURE__ */createElement(PieArc, {\n        ...restProps,\n        id: point2.key.toLocaleString(),\n        key: point2.key.toLocaleString(),\n        arc: arcGenerator,\n        data: arcData,\n        color\n      });\n    }\n    return data.data.map(renderArc);\n  }, [arcGenerator, colorScheme, data, padAngle, restProps, scale2, startAngle]);\n  return /* @__PURE__ */jsx(\"g\", {\n    children: stackedArcs\n  }, id);\n};\nRadialGaugeStackedArc.defaultProps = {\n  cornerRadius: 0,\n  padAngle: 0,\n  padRadius: 0,\n  animated: true,\n  disabled: false,\n  tooltip: /* @__PURE__ */jsx(ChartTooltip, {})\n};\nconst stackedValueLabel = \"_stackedValueLabel_1w6zx_1\";\nconst css$4 = {\n  stackedValueLabel\n};\nconst StackedRadialGaugeValueLabel = _ref112 => {\n  let {\n    label: label2,\n    className,\n    yOffset\n  } = _ref112;\n  return /* @__PURE__ */jsx(Fragment$1, {\n    children: label2 && /* @__PURE__ */jsx(\"text\", {\n      x: \"0\",\n      y: yOffset,\n      textAnchor: \"middle\",\n      alignmentBaseline: \"middle\",\n      className: classNames(className, css$4.stackedValueLabel),\n      children: label2\n    })\n  });\n};\nStackedRadialGaugeValueLabel.defaultProps = {\n  yOffset: 0\n};\nconst isChartNestedData = point2 => {\n  return Array.isArray(point2.data);\n};\nconst StackedRadialGaugeSeries = _ref113 => {\n  let {\n    data,\n    width,\n    height,\n    scale: scale2,\n    startAngle,\n    endAngle,\n    outerArc,\n    innerArc,\n    stackedInnerArc,\n    label: label2,\n    descriptionLabel,\n    colorScheme,\n    fillFactor,\n    arcPadding\n  } = _ref113;\n  const radius = Math.min(width, height) / 2;\n  const innerRadius = radius * (1 - Math.min(fillFactor, 1));\n  const rAxis = scaleBand().domain(range(data.length)).range([innerRadius, radius]).paddingInner(arcPadding);\n  const renderOuterArc = useCallback((outerRadius, innerRadius2) => {\n    return outerArc && cloneElement(outerArc, {\n      outerRadius,\n      innerRadius: innerRadius2,\n      startAngle,\n      endAngle\n    });\n  }, [outerArc, startAngle, endAngle]);\n  const renderInnerArc = useCallback((outerRadius, innerRadius2, dataEndAngle, point2, index) => {\n    const color = getColor({\n      data,\n      colorScheme,\n      point: point2,\n      index\n    });\n    return innerArc && cloneElement(innerArc, {\n      outerRadius,\n      innerRadius: innerRadius2,\n      startAngle,\n      endAngle: dataEndAngle,\n      data: point2,\n      color\n    });\n  }, [innerArc, startAngle, data, colorScheme]);\n  const renderStackedArc = useCallback((outerRadius, innerRadius2, point2, index) => {\n    var _ref114, _ref115;\n    return /* @__PURE__ */jsx(Fragment$1, {\n      children: stackedInnerArc && cloneElement(stackedInnerArc, {\n        outerRadius,\n        innerRadius: innerRadius2,\n        colorScheme,\n        startAngle,\n        scale: (_ref114 = (_ref115 = scale2 == null ? void 0 : scale2[index]) !== null && _ref115 !== void 0 ? _ref115 : scale2 == null ? void 0 : scale2[index]) !== null && _ref114 !== void 0 ? _ref114 : scale2,\n        data: point2\n      })\n    });\n  }, [stackedInnerArc, colorScheme, startAngle, scale2]);\n  const renderStackedGauges = useCallback((point2, index) => {\n    var _ref116, _ref117;\n    var _a, _b;\n    const outerRadius = rAxis(index);\n    const innerRadius2 = outerRadius - rAxis.bandwidth();\n    return /* @__PURE__ */jsxs(\"g\", {\n      children: [renderOuterArc(outerRadius, innerRadius2), isChartNestedData(point2) ? renderStackedArc(outerRadius, innerRadius2, point2, index) : renderInnerArc(outerRadius, innerRadius2, (_ref116 = (_ref117 = (_a = scale2 == null ? void 0 : scale2[index]) == null ? void 0 : _a.call(scale2, point2.data)) !== null && _ref117 !== void 0 ? _ref117 : (_b = scale2 == null ? void 0 : scale2[0]) == null ? void 0 : _b.call(scale2, point2.data)) !== null && _ref116 !== void 0 ? _ref116 : scale2(point2.data), point2, index)]\n    }, point2.key.toLocaleString());\n  }, [rAxis, renderOuterArc, renderStackedArc, renderInnerArc, scale2]);\n  return /* @__PURE__ */jsx(Fragment$1, {\n    children: /* @__PURE__ */jsxs(\"g\", {\n      transform: \"translate(\".concat(width / 2, \", \").concat(height / 2, \")\"),\n      children: [data.map(renderStackedGauges), descriptionLabel, label2]\n    })\n  });\n};\nStackedRadialGaugeSeries.defaultProps = {\n  outerArc: /* @__PURE__ */jsx(RadialGaugeArc, {\n    disabled: true,\n    animated: false\n  }),\n  innerArc: /* @__PURE__ */jsx(RadialGaugeArc, {\n    animated: true\n  }),\n  stackedInnerArc: /* @__PURE__ */jsx(RadialGaugeStackedArc, {\n    animated: true\n  }),\n  label: /* @__PURE__ */jsx(StackedRadialGaugeValueLabel, {}),\n  colorScheme: [\"#00ECB1\"],\n  fillFactor: 0.2,\n  arcPadding: 0.15\n};\nconst stackedDescriptionLabel = \"_stackedDescriptionLabel_1h95t_1\";\nconst css$3 = {\n  stackedDescriptionLabel\n};\nconst StackedRadialGaugeDescriptionLabel = _ref118 => {\n  let {\n    label: label2,\n    className,\n    yOffset\n  } = _ref118;\n  return /* @__PURE__ */jsx(Fragment$1, {\n    children: label2 && /* @__PURE__ */jsx(\"text\", {\n      x: \"0\",\n      y: yOffset - 20,\n      textAnchor: \"middle\",\n      alignmentBaseline: \"middle\",\n      className: classNames(className, css$3.stackedDescriptionLabel),\n      children: label2\n    })\n  });\n};\nStackedRadialGaugeDescriptionLabel.defaultProps = {\n  yOffset: 0\n};\nconst RadialGauge = _ref119 => {\n  let {\n    id,\n    width,\n    height,\n    margins,\n    className,\n    data,\n    minValue,\n    maxValue,\n    startAngle,\n    endAngle,\n    series,\n    containerClassName\n  } = _ref119;\n  const newId = useId(id);\n  const renderSeries = useCallback(_ref120 => {\n    let {\n      chartHeight,\n      chartWidth\n    } = _ref120;\n    let scale2;\n    if (Array.isArray(maxValue)) {\n      scale2 = maxValue.map((max2, index) => {\n        var _ref121, _ref122;\n        return scaleLinear().domain([(_ref121 = (_ref122 = minValue == null ? void 0 : minValue[index]) !== null && _ref122 !== void 0 ? _ref122 : minValue == null ? void 0 : minValue[0]) !== null && _ref121 !== void 0 ? _ref121 : minValue, max2]).range([startAngle, endAngle]);\n      });\n    } else if (Array.isArray(minValue)) {\n      scale2 = minValue.map((min2, index) => {\n        var _ref123, _ref124;\n        return scaleLinear().domain([min2, (_ref123 = (_ref124 = maxValue == null ? void 0 : maxValue[index]) !== null && _ref124 !== void 0 ? _ref124 : maxValue == null ? void 0 : maxValue[0]) !== null && _ref123 !== void 0 ? _ref123 : maxValue]).range([startAngle, endAngle]);\n      });\n    } else {\n      scale2 = scaleLinear().domain([minValue, maxValue]).range([startAngle, endAngle]);\n    }\n    return cloneElement(series, {\n      id: newId,\n      scale: scale2,\n      data,\n      startAngle,\n      endAngle,\n      width: chartWidth,\n      height: chartHeight\n    });\n  }, [data, endAngle, maxValue, minValue, series, startAngle, newId]);\n  return /* @__PURE__ */jsx(ChartContainer, {\n    id,\n    width,\n    height,\n    margins,\n    xAxisVisible: false,\n    yAxisVisible: false,\n    className,\n    containerClassName,\n    children: renderSeries\n  });\n};\nRadialGauge.defaultProps = {\n  minValue: 0,\n  maxValue: 100,\n  startAngle: 0,\n  endAngle: Math.PI * 2,\n  series: /* @__PURE__ */jsx(RadialGaugeSeries, {})\n};\nconst cell = \"_cell_r3f8c_1\";\nconst css$2 = {\n  cell\n};\nconst modifiers = {\n  offset: {\n    offset: \"0, 3px\"\n  }\n};\nconst HeatmapCell = _ref125 => {\n  let {\n    rx,\n    ry,\n    cursor,\n    tooltip: tooltip2,\n    onClick,\n    onMouseEnter,\n    onMouseLeave,\n    data,\n    animated,\n    cellIndex,\n    cellCount,\n    fill,\n    stroke,\n    symbol: symbol2,\n    x,\n    y,\n    style,\n    className,\n    ...rest\n  } = _ref125;\n  const [active, setActive] = useState(false);\n  const rect = useRef(null);\n  const {\n    pointerOut,\n    pointerOver\n  } = useHoverIntent({\n    onPointerOver: event => {\n      setActive(true);\n      onMouseEnter({\n        value: data,\n        nativeEvent: event\n      });\n    },\n    onPointerOut: event => {\n      setActive(false);\n      onMouseLeave({\n        value: data,\n        nativeEvent: event\n      });\n    }\n  });\n  const onMouseClick = event => {\n    onClick({\n      value: data,\n      nativeEvent: event\n    });\n  };\n  const tooltipData = useMemo(() => ({\n    y: data.value,\n    x: \"\".concat(data.key, \" \\u2219 \").concat(data.x),\n    data\n  }), [data]);\n  const transition = useMemo(() => {\n    if (animated) {\n      return {\n        ...DEFAULT_TRANSITION,\n        delay: cellIndex / cellCount * 5e-3\n      };\n    } else {\n      return {\n        type: false,\n        delay: 0\n      };\n    }\n  }, [animated, cellIndex, cellCount]);\n  const extras = constructFunctionProps({\n    style,\n    className\n  }, data);\n  const isTransparent = fill === \"transparent\";\n  const appliedStroke = active && !isTransparent ? chroma(stroke || fill).brighten(1) : stroke || fill;\n  const ariaLabelData = useMemo(() => getAriaLabel({\n    ...tooltipData,\n    data: null\n  }), [tooltipData]);\n  const renderedSymbol = useMemo(() => symbol2 ? symbol2(data) : null, [data, symbol2]);\n  return /* @__PURE__ */jsxs(Fragment, {\n    children: [/* @__PURE__ */jsx(\"g\", {\n      ref: rect,\n      children: renderedSymbol ? /* @__PURE__ */jsx(motion.g, {\n        ...rest,\n        fill,\n        stroke: appliedStroke,\n        style: {\n          ...extras.style,\n          cursor\n        },\n        className: extras == null ? void 0 : extras.className,\n        transform: \"translate(\".concat(x, \", \").concat(y, \")\"),\n        initial: {\n          opacity: 0\n        },\n        animate: {\n          opacity: 1\n        },\n        exit: {\n          opacity: 0\n        },\n        transition,\n        onPointerOver: pointerOver,\n        onPointerOut: pointerOut,\n        onClick: onMouseClick,\n        tabIndex: 0,\n        \"aria-label\": ariaLabelData,\n        role: \"graphics-document\",\n        children: renderedSymbol\n      }) : /* @__PURE__ */jsx(motion.rect, {\n        ...rest,\n        fill,\n        stroke: appliedStroke,\n        x,\n        y,\n        rx,\n        ry,\n        style: {\n          ...extras.style,\n          cursor\n        },\n        className: classNames(css$2.cell, extras.className),\n        initial: {\n          opacity: 0\n        },\n        animate: {\n          opacity: 1\n        },\n        exit: {\n          opacity: 0\n        },\n        transition,\n        onPointerOver: pointerOver,\n        onPointerOut: pointerOut,\n        onClick: onMouseClick,\n        tabIndex: 0,\n        \"aria-label\": ariaLabelData,\n        role: \"graphics-document\"\n      })\n    }), tooltip2 && !tooltip2.props.disabled && !isTransparent && /* @__PURE__ */jsx(CloneElement, {\n      element: tooltip2,\n      visible: active,\n      modifiers: tooltip2.props.modifiers || modifiers,\n      reference: rect,\n      value: tooltipData\n    })]\n  });\n};\nHeatmapCell.defaultProps = {\n  rx: 2,\n  ry: 2,\n  cursor: \"auto\",\n  tooltip: /* @__PURE__ */jsx(ChartTooltip, {}),\n  onClick: () => void 0,\n  onMouseEnter: () => void 0,\n  onMouseLeave: () => void 0\n};\nconst HeatmapSeries = _ref126 => {\n  let {\n    animated,\n    emptyColor,\n    colorScheme,\n    cell: cellElement,\n    xScale,\n    yScale,\n    data,\n    id,\n    selections\n  } = _ref126;\n  const valueScales = createColorSchemeValueScales(data, colorScheme, emptyColor, selections);\n  const height = yScale.bandwidth();\n  const width = xScale.bandwidth();\n  const cellCount = [...yScale.domain(), ...xScale.domain()].length;\n  const renderCell = _ref127 => {\n    let {\n      row,\n      cell: cell2,\n      rowIndex,\n      cellIndex,\n      width: width2,\n      height: height2,\n      cellCount: cellCount2\n    } = _ref127;\n    const x = xScale(row.key);\n    const y = yScale(cell2.x);\n    const style = getColorSchemeStyles(cell2, valueScales);\n    return /* @__PURE__ */jsx(CloneElement, {\n      element: cellElement,\n      animated,\n      cellIndex: rowIndex + cellIndex,\n      cellCount: cellCount2,\n      x,\n      y,\n      fill: style == null ? void 0 : style.fill,\n      stroke: style == null ? void 0 : style.stroke,\n      width: width2,\n      height: height2,\n      data: cell2,\n      style\n    }, \"\".concat(id, \"-\").concat(rowIndex, \"-\").concat(cellIndex));\n  };\n  return /* @__PURE__ */jsx(Fragment, {\n    children: data.map((row, rowIndex) => row.data.map((cell2, cellIndex) => renderCell({\n      height,\n      width,\n      cellCount,\n      row,\n      cell: cell2,\n      rowIndex,\n      cellIndex\n    })))\n  });\n};\nHeatmapSeries.defaultProps = {\n  padding: 0.1,\n  animated: true,\n  emptyColor: \"rgba(200,200,200,0.08)\",\n  colorScheme: [\"rgba(28, 107, 86, 0.5)\", \"#2da283\"],\n  cell: /* @__PURE__ */jsx(HeatmapCell, {})\n};\nconst Heatmap = _ref128 => {\n  let {\n    data,\n    margins,\n    series,\n    yAxis,\n    xAxis,\n    secondaryAxis,\n    id,\n    width,\n    height,\n    className,\n    containerClassName\n  } = _ref128;\n  const getScalesData = useCallback((chartHeight, chartWidth) => {\n    const nestedData = buildNestedChartData(data);\n    const xDomain = xAxis.props.domain || uniqueBy(nestedData, d => d.key);\n    const xScale = scaleBand().range([0, chartWidth]).domain(xDomain).paddingInner(series.props.padding || 0.1);\n    const yDomain = yAxis.props.domain || uniqueBy(nestedData, d => d.data, d => d.x);\n    const yScale = scaleBand().domain(yDomain).range([chartHeight, 0]).paddingInner(series.props.padding || 0.1);\n    return {\n      yScale,\n      xScale,\n      data: nestedData\n    };\n  }, [data, xAxis, yAxis, series]);\n  const renderChart = useCallback(containerProps => {\n    const {\n      chartWidth,\n      chartHeight,\n      updateAxes,\n      id: id2,\n      chartSized\n    } = containerProps;\n    const {\n      xScale,\n      yScale,\n      data: scalesData\n    } = getScalesData(chartHeight, chartWidth);\n    return /* @__PURE__ */jsxs(Fragment, {\n      children: [/* @__PURE__ */jsx(CloneElement, {\n        element: xAxis,\n        height: chartHeight,\n        width: chartWidth,\n        scale: xScale,\n        visibility: chartSized ? \"visible\" : \"hidden\",\n        onDimensionsChange: event => updateAxes(\"horizontal\", event)\n      }), /* @__PURE__ */jsx(CloneElement, {\n        element: yAxis,\n        height: chartHeight,\n        width: chartWidth,\n        scale: yScale,\n        visibility: chartSized ? \"visible\" : \"hidden\",\n        onDimensionsChange: event => updateAxes(\"vertical\", event)\n      }), secondaryAxis && secondaryAxis.map((axis, i) => /* @__PURE__ */jsx(CloneElement, {\n        element: axis,\n        height: chartHeight,\n        width: chartWidth,\n        visibility: chartSized ? \"visible\" : \"hidden\",\n        onDimensionsChange: event => updateAxes(\"horizontal\", event)\n      }, i)), chartSized && /* @__PURE__ */jsx(CloneElement, {\n        element: series,\n        id: \"heat-series-\".concat(id2),\n        data: scalesData,\n        xScale,\n        yScale\n      })]\n    });\n  }, [getScalesData, secondaryAxis, series, xAxis, yAxis]);\n  return /* @__PURE__ */jsx(ChartContainer, {\n    id,\n    width,\n    height,\n    margins,\n    containerClassName,\n    xAxisVisible: isAxisVisible(xAxis.props),\n    yAxisVisible: isAxisVisible(yAxis.props),\n    className,\n    children: renderChart\n  });\n};\nHeatmap.defaultProps = {\n  data: [],\n  margins: 10,\n  series: /* @__PURE__ */jsx(HeatmapSeries, {\n    padding: 0.3\n  }),\n  yAxis: /* @__PURE__ */jsx(LinearYAxis, {\n    type: \"category\",\n    axisLine: null,\n    tickSeries: /* @__PURE__ */jsx(LinearYAxisTickSeries, {\n      line: null,\n      label: /* @__PURE__ */jsx(LinearYAxisTickLabel, {\n        padding: 5\n      })\n    })\n  }),\n  xAxis: /* @__PURE__ */jsx(LinearXAxis, {\n    type: \"category\",\n    axisLine: null,\n    tickSeries: /* @__PURE__ */jsx(LinearXAxisTickSeries, {\n      line: null,\n      label: /* @__PURE__ */jsx(LinearXAxisTickLabel, {\n        padding: 5\n      })\n    })\n  })\n};\nconst getFirstOfMonth = date => new Date(date.getFullYear(), date.getMonth(), 1);\nconst addWeeksToDate = (date, weeks) => {\n  const d = new Date(date.getTime());\n  d.setDate(d.getDate() + weeks * 7);\n  return d;\n};\nconst getStartOfDay = date => {\n  const d = new Date(date.getTime());\n  d.setHours(0, 0, 0, 0);\n  return d;\n};\nconst getNewDayFromDay = (date, num) => {\n  const d = new Date(date.getTime());\n  d.setDate(d.getDate() + num);\n  return d;\n};\nconst weekDays = (() => {\n  const base2 = new Date(Date.UTC(2017, 0, 2));\n  return range(7).map(() => {\n    const name = base2.toLocaleDateString(\"default\", {\n      weekday: \"short\"\n    });\n    base2.setDate(base2.getDate() + 1);\n    return name;\n  });\n})();\nconst buildDataScales = (rawData, view) => {\n  const startDate = min(rawData, d => d.key) || /* @__PURE__ */new Date();\n  const start2 = getFirstOfMonth(startDate);\n  const endDomain = view === \"year\" ? 53 : 5;\n  const end2 = addWeeksToDate(start2, endDomain);\n  const xDomainRange = view === \"year\" ? 53 : 5;\n  const yDomain = range(7).reverse();\n  const xDomain = range(xDomainRange);\n  const dates = rawData.filter(d => d.key.getTime() > start2.getTime() || d.key.getTime() < end2.getTime()).map(d => ({\n    key: getStartOfDay(d.key),\n    data: d.data\n  }));\n  const firstDayOfStart = start2.getDay();\n  const curDate = getNewDayFromDay(start2, -firstDayOfStart);\n  const rows = [];\n  for (let week = 0; week < xDomainRange; week++) {\n    const row = {\n      key: week,\n      data: []\n    };\n    for (let day = 0; day <= 6; day++) {\n      var _ref129;\n      const dayValue = dates.find(d => d.key.getTime() === curDate.getTime());\n      row.data.push({\n        key: day,\n        data: (_ref129 = dayValue == null ? void 0 : dayValue.data) !== null && _ref129 !== void 0 ? _ref129 : void 0,\n        metadata: {\n          date: new Date(curDate.getTime()),\n          start: start2,\n          end: end2\n        }\n      });\n      curDate.setDate(curDate.getDate() + 1);\n    }\n    rows.push(row);\n  }\n  return {\n    data: rows,\n    yDomain,\n    xDomain,\n    start: start2\n  };\n};\nconst xAxisLabelFormat = start2 => weeks => addWeeksToDate(start2, weeks).toLocaleString(\"default\", {\n  month: \"long\"\n});\nconst CalendarHeatmap = _ref130 => {\n  let {\n    view,\n    data,\n    ...rest\n  } = _ref130;\n  const {\n    data: domainData,\n    yDomain,\n    xDomain,\n    start: start2\n  } = useMemo(() => buildDataScales(data, view), [data, view]);\n  const xTickValues = view === \"year\" ? void 0 : [1];\n  const yAxisLabelFormat = view === \"year\" ? d => weekDays[d] : () => null;\n  return /* @__PURE__ */jsx(Heatmap, {\n    ...rest,\n    data: domainData,\n    yAxis: /* @__PURE__ */jsx(LinearYAxis, {\n      type: \"category\",\n      axisLine: null,\n      domain: yDomain,\n      tickSeries: /* @__PURE__ */jsx(LinearYAxisTickSeries, {\n        tickSize: 20,\n        line: null,\n        label: /* @__PURE__ */jsx(LinearYAxisTickLabel, {\n          padding: 5,\n          format: yAxisLabelFormat\n        })\n      })\n    }),\n    xAxis: /* @__PURE__ */jsx(LinearXAxis, {\n      type: \"category\",\n      axisLine: null,\n      domain: xDomain,\n      tickSeries: /* @__PURE__ */jsx(LinearXAxisTickSeries, {\n        line: null,\n        tickValues: xTickValues,\n        label: /* @__PURE__ */jsx(LinearXAxisTickLabel, {\n          padding: 5,\n          align: \"end\",\n          format: xAxisLabelFormat(start2)\n        })\n      })\n    })\n  });\n};\nCalendarHeatmap.defaultProps = {\n  view: \"year\",\n  series: /* @__PURE__ */jsx(HeatmapSeries, {\n    padding: 0.3,\n    emptyColor: \"transparent\",\n    cell: /* @__PURE__ */jsx(HeatmapCell, {\n      tooltip: /* @__PURE__ */jsx(ChartTooltip, {\n        content: d => \"\".concat(formatValue(d.data.metadata.date), \" \\u2219 \").concat(formatValue(d.data.value))\n      })\n    })\n  })\n};\nconst LinearGaugeBar = props => /* @__PURE__ */jsx(Bar, {\n  ...props\n});\nLinearGaugeBar.defaultProps = {\n  tooltip: /* @__PURE__ */jsx(ChartTooltip, {\n    placement: \"top\",\n    content: data => /* @__PURE__ */jsx(TooltipTemplate, {\n      value: {\n        y: data.value,\n        x: data.y\n      }\n    })\n  })\n};\nconst LinearGaugeOuterBar = _ref131 => {\n  let {\n    height,\n    width,\n    fill,\n    ...rest\n  } = _ref131;\n  return /* @__PURE__ */jsx(\"rect\", {\n    ...rest,\n    fill,\n    width: Math.max(width, 0),\n    height: Math.max(height, 0)\n  });\n};\nLinearGaugeOuterBar.defaultProps = {\n  fill: \"#484848\"\n};\nconst LinearGaugeSeries = _ref132 => {\n  let {\n    height,\n    width,\n    bar: bar2,\n    outerBar: outerBar2,\n    isMultiSeries,\n    ...rest\n  } = _ref132;\n  return /* @__PURE__ */jsxs(Fragment, {\n    children: [!isMultiSeries && outerBar2 && /* @__PURE__ */jsx(CloneElement, {\n      element: outerBar2,\n      height,\n      width\n    }), /* @__PURE__ */jsx(BarSeries, {\n      ...rest,\n      layout: \"horizontal\",\n      tooltip: null,\n      bar: /* @__PURE__ */jsx(CloneElement, {\n        element: bar2\n      })\n    })]\n  });\n};\nLinearGaugeSeries.defaultProps = {\n  outerBar: /* @__PURE__ */jsx(LinearGaugeOuterBar, {}),\n  bar: /* @__PURE__ */jsx(LinearGaugeBar, {})\n};\nconst LinearGauge = _ref133 => {\n  let {\n    id,\n    width,\n    height,\n    margins,\n    className,\n    containerClassName,\n    series,\n    data,\n    minValue,\n    maxValue\n  } = _ref133;\n  const transformedData = useMemo(() => {\n    if (Array.isArray(data)) {\n      return buildBarStackData([{\n        key: \"default\",\n        data\n      }], \"expand\", \"horizontal\");\n    } else {\n      return buildShallowChartData([data], \"horizontal\");\n    }\n  }, [data]);\n  const getScales = useCallback((isMultiSeries, data2, width2, height2, minValue2, maxValue2) => {\n    const domain = !isMultiSeries ? [minValue2, maxValue2] : void 0;\n    const keyScale = getXScale({\n      width: width2,\n      type: \"value\",\n      data: data2,\n      domain,\n      isMultiSeries\n    });\n    const valueScale = getYScale({\n      type: \"category\",\n      height: height2,\n      data: data2,\n      isMultiSeries\n    });\n    return {\n      keyScale,\n      valueScale\n    };\n  }, []);\n  const renderChart = useCallback(_ref134 => {\n    let {\n      chartHeight,\n      chartWidth,\n      id: id2,\n      chartSized\n    } = _ref134;\n    const isMultiSeries = Array.isArray(data);\n    const type = isMultiSeries ? \"stackedNormalized\" : \"standard\";\n    const {\n      keyScale,\n      valueScale\n    } = getScales(isMultiSeries, transformedData, chartWidth, chartHeight, minValue, maxValue);\n    return /* @__PURE__ */jsx(Fragment, {\n      children: chartSized && /* @__PURE__ */jsx(CloneElement, {\n        element: series,\n        id: \"linear-gauge-series-\".concat(id2),\n        data: transformedData,\n        isCategorical: true,\n        xScale: keyScale,\n        yScale: valueScale,\n        type,\n        height: chartHeight,\n        width: chartWidth,\n        isMultiSeries\n      })\n    });\n  }, [data, getScales, maxValue, minValue, series, transformedData]);\n  return /* @__PURE__ */jsx(ChartContainer, {\n    id,\n    width,\n    height,\n    margins,\n    className,\n    containerClassName,\n    children: renderChart\n  });\n};\nLinearGauge.defaultProps = {\n  minValue: 0,\n  maxValue: 100,\n  series: /* @__PURE__ */jsx(LinearGaugeSeries, {})\n};\nconst useInterpolate = _ref135 => {\n  let {\n    data,\n    animated\n  } = _ref135;\n  const transition = animated ? {\n    ...DEFAULT_TRANSITION\n  } : {\n    delay: 0,\n    type: false\n  };\n  const d = useMotionValue(data.path);\n  const spring = useSpring(0, {\n    stiffness: 300,\n    damping: 30\n  });\n  useEffect(() => {\n    const interpolator = interpolate$1(d.get(), data.path);\n    const prevSpring = spring.get();\n    spring.set(1 + prevSpring);\n    return spring.on(\"change\", v => d.set(interpolator(v - prevSpring)));\n  }, [d, data.path, spring]);\n  return {\n    transition,\n    d\n  };\n};\nconst VennArc = _ref136 => {\n  let {\n    data,\n    fill,\n    disabled,\n    animated,\n    stroke,\n    mask,\n    id,\n    style,\n    active,\n    inactiveStyle,\n    activeStyle,\n    initialStyle,\n    strokeWidth,\n    gradient: gradient2,\n    glow,\n    tooltip: tooltip2,\n    onClick,\n    onMouseEnter,\n    onMouseLeave\n  } = _ref136;\n  const [internalActive, setInternalActive] = useState(false);\n  const arcRef = useRef(null);\n  const {\n    transition,\n    d\n  } = useInterpolate({\n    animated,\n    data\n  });\n  const currentStyle = active ? activeStyle : active === null ? inactiveStyle : initialStyle;\n  const arcFill = gradient2 && !mask ? \"url(#gradient-\".concat(id, \")\") : mask ? \"url(#mask-pattern-\".concat(id, \")\") : fill;\n  const {\n    pointerOut,\n    pointerOver\n  } = useHoverIntent({\n    onPointerOver: event => {\n      if (!disabled) {\n        setInternalActive(true);\n        onMouseEnter == null ? void 0 : onMouseEnter({\n          value: data.data,\n          nativeEvent: event\n        });\n      }\n    },\n    onPointerOut: event => {\n      if (!disabled) {\n        setInternalActive(false);\n        onMouseLeave == null ? void 0 : onMouseLeave({\n          value: data.data,\n          nativeEvent: event\n        });\n      }\n    }\n  });\n  const tooltipData = useMemo(() => {\n    var _a, _b;\n    return {\n      y: data.data.size,\n      x: (_b = (_a = data.data) == null ? void 0 : _a.sets) == null ? void 0 : _b.join(\" | \")\n    };\n  }, [data]);\n  const ariaLabelData = useMemo(() => getAriaLabel(tooltipData), [tooltipData]);\n  return /* @__PURE__ */jsxs(\"g\", {\n    title: data.data.key,\n    onPointerOver: pointerOver,\n    onPointerOut: pointerOut,\n    onClick: event => {\n      if (!disabled) {\n        onClick == null ? void 0 : onClick({\n          value: data.data,\n          nativeEvent: event\n        });\n      }\n    },\n    tabIndex: 0,\n    \"aria-label\": ariaLabelData,\n    role: \"graphics-document\",\n    children: [/* @__PURE__ */jsx(motion.path, {\n      ref: arcRef,\n      fill: arcFill,\n      id: \"\".concat(id, \"-arc\"),\n      strokeWidth,\n      stroke,\n      transition,\n      d,\n      initial: initialStyle,\n      animate: currentStyle,\n      style: {\n        ...style,\n        ...generateGlowStyles({\n          glow,\n          colorSchemeColor: typeof stroke === \"string\" ? stroke : null\n        })\n      }\n    }), mask && /* @__PURE__ */jsxs(Fragment, {\n      children: [/* @__PURE__ */jsx(Mask, {\n        id: \"mask-\".concat(id),\n        fill: \"url(#gradient-\".concat(id, \")\")\n      }), /* @__PURE__ */jsx(CloneElement, {\n        element: mask,\n        id: \"mask-pattern-\".concat(id),\n        fill\n      })]\n    }), gradient2 && /* @__PURE__ */jsx(CloneElement, {\n      element: gradient2,\n      id: \"gradient-\".concat(id),\n      color: fill\n    }), tooltip2 && !tooltip2.props.disabled && /* @__PURE__ */jsx(CloneElement, {\n      element: tooltip2,\n      visible: !!internalActive,\n      reference: arcRef,\n      value: tooltipData\n    })]\n  });\n};\nVennArc.defaultProps = {\n  active: false,\n  inactiveStyle: {\n    opacity: 0.3\n  },\n  activeStyle: {\n    opacity: 0.8\n  },\n  initialStyle: {\n    opacity: 0.6\n  },\n  strokeWidth: 3,\n  gradient: /* @__PURE__ */jsx(Gradient, {}),\n  tooltip: /* @__PURE__ */jsx(ChartTooltip, {}),\n  onClick: () => void 0,\n  onMouseEnter: () => void 0,\n  onMouseLeave: () => void 0\n};\nconst VennLabel = _ref137 => {\n  let {\n    data,\n    format,\n    id,\n    active,\n    labelType,\n    showAll,\n    wrap,\n    animated,\n    fill,\n    fontSize,\n    fontFamily\n  } = _ref137;\n  var _a, _b, _c, _d, _e;\n  if (!showAll && !((_a = data.arcs) == null ? void 0 : _a.filter(a => a.large).length)) {\n    return null;\n  }\n  const key = labelType === \"key\" ? (_c = (_b = data.data) == null ? void 0 : _b.sets) == null ? void 0 : _c.join(\" | \") : data.data.size;\n  const transition = animated ? DEFAULT_TRANSITION : {\n    delay: 0,\n    type: false\n  };\n  const text = wrap ? wrapText({\n    key,\n    x: data.text.x,\n    fontFamily,\n    fontSize,\n    width: (_e = (_d = data == null ? void 0 : data.circles) == null ? void 0 : _d[0]) == null ? void 0 : _e.radius\n  }) : key;\n  return /* @__PURE__ */jsx(motion.text, {\n    id: \"\".concat(id, \"-text\"),\n    fill,\n    pointerEvents: \"none\",\n    fontFamily,\n    fontSize,\n    initial: {\n      attrX: data.text.x,\n      attrY: data.text.y,\n      opacity: 1\n    },\n    animate: {\n      attrX: data.text.x,\n      attrY: data.text.y,\n      opacity: active === null ? 0.3 : 1\n    },\n    transition,\n    textAnchor: \"middle\",\n    children: format ? format(data) : text\n  });\n};\nVennLabel.defaultProps = {\n  labelType: \"key\",\n  showAll: false,\n  wrap: true,\n  animated: true,\n  fontSize: 11,\n  fontFamily: \"sans-serif\"\n};\nconst VennOuterLabel = _ref138 => {\n  let {\n    data,\n    format,\n    animated,\n    fill,\n    fontSize,\n    fontFamily\n  } = _ref138;\n  const transition = animated ? DEFAULT_TRANSITION : {\n    delay: 0,\n    type: false\n  };\n  const text = data.set.data.key;\n  const label2 = format ? format(data) : text;\n  const isElement = isValidElement(label2);\n  const showIcon = isElement && data.set.icon;\n  const pos = {\n    x: showIcon ? data.set.icon.x : data.set.text.x,\n    y: showIcon ? data.set.icon.y : data.set.text.y\n  };\n  return /* @__PURE__ */jsx(Fragment, {\n    children: isElement ? /* @__PURE__ */jsx(\"g\", {\n      style: {\n        transform: \"translate(\".concat(pos.x, \"px, \").concat(pos.y, \"px)\")\n      },\n      children: label2\n    }) : /* @__PURE__ */jsx(motion.text, {\n      fill,\n      style: {\n        pointerEvents: \"none\",\n        fontFamily,\n        fontSize\n      },\n      textAnchor: data.set.align === \"middle\" ? \"center\" : data.set.align,\n      alignmentBaseline: data.set.verticalAlign,\n      initial: {\n        attrX: pos.x,\n        attrY: pos.y\n      },\n      animate: {\n        attrX: pos.x,\n        attrY: pos.y\n      },\n      transition,\n      children: label2\n    })\n  });\n};\nVennOuterLabel.defaultProps = {\n  animated: true,\n  fill: \"#000\",\n  fontSize: 14,\n  fontFamily: \"sans-serif\"\n};\nconst VennSeries = _ref139 => {\n  let {\n    data,\n    id,\n    selections,\n    animated,\n    disabled,\n    colorScheme,\n    outerLabel,\n    arc: arc2,\n    label: label2\n  } = _ref139;\n  const transition = animated ? DEFAULT_TRANSITION : {\n    type: false,\n    delay: 0\n  };\n  const [actives, setActives] = useState([]);\n  const [hovered, setHovered] = useState(null);\n  const onActivate = useCallback(point2 => {\n    setHovered(point2);\n    setActives(data.filter(d => {\n      var _a;\n      return ((_a = d.data) == null ? void 0 : _a.key.indexOf(point2)) > -1;\n    }).map(d => {\n      var _a;\n      return (_a = d.data) == null ? void 0 : _a.key;\n    }));\n  }, [data]);\n  const renderArc = useCallback((d, index) => {\n    var _a, _b;\n    const fill = getColor({\n      data,\n      colorScheme,\n      point: d.data,\n      index\n    });\n    const textFill = fill ? invert(chroma(fill).darken(0.5).hex(), true) : \"white\";\n    const arcFill = arc2.props.fill || fill;\n    const key = (_a = d == null ? void 0 : d.data) == null ? void 0 : _a.key;\n    const safeKey = identifier((_b = d.data) == null ? void 0 : _b.key);\n    const isSelected = selections == null ? void 0 : selections.includes(key);\n    const isHovered = hovered === key || isSelected;\n    const isActive = isSelected || actives.includes(key) || (actives.length > 0 ? null : false);\n    const getStrokeColor = () => {\n      if (typeof arc2.props.stroke === \"function\") {\n        return arc2.props.stroke(data, index, isActive, isHovered);\n      }\n      if (arc2.props.stroke !== void 0) {\n        return arc2.props.stroke;\n      }\n      return fill;\n    };\n    const stroke = getStrokeColor();\n    const arcStroke = stroke || chroma(arcFill).darken(isActive ? 0.8 : 0.5).hex();\n    return /* @__PURE__ */jsxs(Fragment, {\n      children: [/* @__PURE__ */jsx(CloneElement, {\n        element: arc2,\n        id: \"\".concat(id, \"-\").concat(safeKey),\n        data: d,\n        fill: arcFill,\n        stroke: arcStroke,\n        disabled,\n        animated,\n        active: isActive,\n        onMouseEnter: () => onActivate(key),\n        onMouseLeave: () => {\n          setActives([]);\n          setHovered(null);\n        }\n      }), label2 && /* @__PURE__ */jsx(CloneElement, {\n        element: label2,\n        data: d,\n        id: \"\".concat(id, \"-\").concat(safeKey),\n        active: isActive,\n        animated,\n        fill: textFill,\n        ...label2.props\n      }), d.set && outerLabel && /* @__PURE__ */jsx(CloneElement, {\n        element: outerLabel,\n        data: d,\n        animated\n      })]\n    }, safeKey);\n  }, [data, colorScheme, arc2, selections, hovered, actives, id, disabled, animated, label2, outerLabel, onActivate]);\n  const topArcs = useMemo(() => {\n    const result = [];\n    if (actives.length > 0) {\n      result.push(...actives.filter(s => s !== hovered));\n    }\n    if (selections == null ? void 0 : selections.length) {\n      result.push(...selections.filter(s => !actives.includes(s) && s !== hovered));\n    }\n    if (hovered) {\n      result.push(hovered);\n    }\n    return result;\n  }, [hovered, actives, selections]);\n  return /* @__PURE__ */jsxs(motion.g, {\n    initial: {\n      opacity: 0,\n      scale: 0\n    },\n    animate: {\n      opacity: 1,\n      scale: 1\n    },\n    transition,\n    children: [data.map(renderArc), topArcs.length > 0 && topArcs.map(a => /* @__PURE__ */jsx(\"use\", {\n      xlinkHref: \"#\".concat(id, \"-\").concat(a, \"-arc\"),\n      style: {\n        pointerEvents: \"none\"\n      }\n    }, a)), data.map((d, index) => {\n      var _a;\n      return /* @__PURE__ */jsx(\"use\", {\n        xlinkHref: \"#\".concat(id, \"-\").concat(identifier((_a = d.data) == null ? void 0 : _a.key), \"-text\"),\n        style: {\n          pointerEvents: \"none\"\n        }\n      }, index);\n    })]\n  });\n};\nVennSeries.defaultProps = {\n  animated: true,\n  disabled: false,\n  colorScheme: \"cybertron\",\n  outerLabel: /* @__PURE__ */jsx(VennOuterLabel, {}),\n  arc: /* @__PURE__ */jsx(VennArc, {}),\n  label: /* @__PURE__ */jsx(VennLabel, {})\n};\nconst sets$5 = [];\nconst intersections$5 = [];\nconst bb$5 = {\n  x: 0,\n  y: 0,\n  width: 10,\n  height: 10\n};\nconst venn0 = {\n  sets: sets$5,\n  intersections: intersections$5,\n  bb: bb$5\n};\nconst sets$4 = [{\n  cx: 0,\n  cy: 0,\n  r: 5,\n  text: {\n    x: 3.5,\n    y: -4\n  },\n  align: \"start\",\n  verticalAlign: \"bottom\"\n}];\nconst intersections$4 = [{\n  sets: [0],\n  x1: 0,\n  y1: 5,\n  arcs: [{\n    mode: \"i\",\n    ref: 0,\n    x2: 0,\n    y2: -5,\n    sweep: false,\n    large: false\n  }, {\n    mode: \"i\",\n    ref: 0,\n    x2: 0,\n    y2: 5,\n    sweep: false,\n    large: false\n  }],\n  text: {\n    x: 0,\n    y: 0\n  }\n}];\nconst bb$4 = {\n  x: -5,\n  y: -5,\n  width: 10,\n  height: 10\n};\nconst venn1 = {\n  sets: sets$4,\n  intersections: intersections$4,\n  bb: bb$4\n};\nconst sets$3 = [{\n  cx: -4,\n  cy: 0,\n  r: 5,\n  text: {\n    x: -7.5,\n    y: 4\n  },\n  align: \"end\",\n  verticalAlign: \"top\"\n}, {\n  cx: 4,\n  cy: 0,\n  r: 5,\n  text: {\n    x: 7.5,\n    y: -4\n  },\n  align: \"start\",\n  verticalAlign: \"bottom\"\n}];\nconst intersections$3 = [{\n  sets: [0],\n  x1: 0,\n  y1: -3,\n  arcs: [{\n    mode: \"i\",\n    ref: 0,\n    x2: 0,\n    y2: 3,\n    sweep: false,\n    large: true\n  }, {\n    mode: \"o\",\n    ref: 1,\n    x2: 0,\n    y2: -3,\n    sweep: true,\n    large: false\n  }],\n  text: {\n    x: -4,\n    y: 0\n  }\n}, {\n  sets: [1],\n  x1: 0,\n  y1: 3,\n  arcs: [{\n    mode: \"i\",\n    ref: 1,\n    x2: 0,\n    y2: -3,\n    sweep: false,\n    large: true\n  }, {\n    mode: \"o\",\n    ref: 0,\n    x2: 0,\n    y2: 3,\n    sweep: true,\n    large: false\n  }],\n  text: {\n    x: 4,\n    y: 0\n  }\n}, {\n  sets: [0, 1],\n  x1: 0,\n  y1: 3,\n  arcs: [{\n    mode: \"i\",\n    ref: 0,\n    x2: 0,\n    y2: -3,\n    sweep: false,\n    large: false\n  }, {\n    mode: \"i\",\n    ref: 1,\n    x2: 0,\n    y2: 3,\n    sweep: false,\n    large: false\n  }],\n  text: {\n    x: 0,\n    y: 0\n  }\n}];\nconst bb$3 = {\n  x: -9,\n  y: -5,\n  width: 18,\n  height: 10\n};\nconst venn2 = {\n  sets: sets$3,\n  intersections: intersections$3,\n  bb: bb$3\n};\nconst sets$2 = [{\n  cx: -3.464,\n  cy: -2,\n  r: 5,\n  text: {\n    x: -7,\n    y: -6\n  },\n  align: \"end\"\n}, {\n  cx: 3.464,\n  cy: -2,\n  r: 5,\n  text: {\n    x: 7,\n    y: -6\n  },\n  align: \"start\"\n}, {\n  cx: 0,\n  cy: 4,\n  r: 5,\n  text: {\n    x: 4,\n    y: 7.5\n  },\n  align: \"start\",\n  verticalAlign: \"top\"\n}];\nconst intersections$2 = [{\n  sets: [0],\n  x1: -4.855,\n  y1: 2.803,\n  arcs: [{\n    mode: \"o\",\n    ref: 2,\n    x2: -1.39,\n    y2: -0.803,\n    sweep: true,\n    large: false\n  }, {\n    mode: \"o\",\n    ref: 1,\n    x2: 0,\n    y2: -5.606,\n    sweep: true,\n    large: false\n  }, {\n    mode: \"i\",\n    ref: 0,\n    x2: -4.855,\n    y2: 2.803,\n    sweep: false,\n    large: true\n  }],\n  text: {\n    x: -4.216,\n    y: -2.434\n  }\n}, {\n  sets: [1],\n  x1: 0,\n  y1: -5.606,\n  arcs: [{\n    mode: \"o\",\n    ref: 0,\n    x2: 1.39,\n    y2: -0.803,\n    sweep: true,\n    large: false\n  }, {\n    mode: \"o\",\n    ref: 2,\n    x2: 4.855,\n    y2: 2.803,\n    sweep: true,\n    large: false\n  }, {\n    mode: \"i\",\n    ref: 1,\n    x2: 0,\n    y2: -5.606,\n    sweep: false,\n    large: true\n  }],\n  text: {\n    x: 4.216,\n    y: -2.434\n  }\n}, {\n  sets: [2],\n  x1: -4.855,\n  y1: 2.803,\n  arcs: [{\n    mode: \"o\",\n    ref: 0,\n    x2: 0,\n    y2: 1.606,\n    sweep: false,\n    large: false\n  }, {\n    mode: \"o\",\n    ref: 1,\n    x2: 4.855,\n    y2: 2.803,\n    sweep: false,\n    large: false\n  }, {\n    mode: \"i\",\n    ref: 2,\n    x2: -4.855,\n    y2: 2.803,\n    sweep: true,\n    large: true\n  }],\n  text: {\n    x: 0,\n    y: 4.869\n  }\n}, {\n  sets: [0, 1],\n  x1: 0,\n  y1: -5.606,\n  arcs: [{\n    mode: \"i\",\n    ref: 1,\n    x2: -1.39,\n    y2: -0.803,\n    sweep: false,\n    large: false\n  }, {\n    mode: \"o\",\n    ref: 2,\n    x2: 1.39,\n    y2: -0.803,\n    sweep: true,\n    large: false\n  }, {\n    mode: \"i\",\n    ref: 0,\n    x2: 0,\n    y2: -5.606,\n    sweep: false,\n    large: false\n  }],\n  text: {\n    x: 0,\n    y: -2.404\n  }\n}, {\n  sets: [0, 2],\n  x1: -4.855,\n  y1: 2.803,\n  arcs: [{\n    mode: \"i\",\n    ref: 2,\n    x2: -1.39,\n    y2: -0.803,\n    sweep: true,\n    large: false\n  }, {\n    mode: \"o\",\n    ref: 1,\n    x2: 0,\n    y2: 1.606,\n    sweep: false,\n    large: false\n  }, {\n    mode: \"i\",\n    ref: 0,\n    x2: -4.855,\n    y2: 2.803,\n    sweep: true,\n    large: false\n  }],\n  text: {\n    x: -2.082,\n    y: 1.202\n  }\n}, {\n  sets: [1, 2],\n  x1: 4.855,\n  y1: 2.803,\n  arcs: [{\n    mode: \"i\",\n    ref: 2,\n    x2: 1.39,\n    y2: -0.803,\n    sweep: false,\n    large: false\n  }, {\n    mode: \"o\",\n    ref: 0,\n    x2: 0,\n    y2: 1.606,\n    sweep: true,\n    large: false\n  }, {\n    mode: \"i\",\n    ref: 1,\n    x2: 4.855,\n    y2: 2.803,\n    sweep: false,\n    large: false\n  }],\n  text: {\n    x: 2.082,\n    y: 1.202\n  }\n}, {\n  sets: [0, 1, 2],\n  x1: 1.39,\n  y1: -0.803,\n  arcs: [{\n    mode: \"i\",\n    ref: 0,\n    x2: 0,\n    y2: 1.606,\n    sweep: true,\n    large: false\n  }, {\n    mode: \"i\",\n    ref: 1,\n    x2: -1.39,\n    y2: -0.803,\n    sweep: true,\n    large: false\n  }, {\n    mode: \"i\",\n    ref: 2,\n    x2: 1.39,\n    y2: -0.803,\n    sweep: true,\n    large: false\n  }],\n  text: {\n    x: 0,\n    y: 0\n  }\n}];\nconst bb$2 = {\n  x: -8.464,\n  y: -7,\n  width: 16.928,\n  height: 16\n};\nconst venn3 = {\n  sets: sets$2,\n  intersections: intersections$2,\n  bb: bb$2\n};\nconst sets$1 = [{\n  cx: 0.439,\n  cy: -1.061,\n  rx: 2.5,\n  ry: 5,\n  rotation: 45,\n  text: {\n    x: 4.5,\n    y: -4.5\n  },\n  align: \"start\",\n  verticalAlign: \"bottom\"\n}, {\n  cx: 2.561,\n  cy: 1.061,\n  rx: 2.5,\n  ry: 5,\n  rotation: 45,\n  text: {\n    x: 4,\n    y: 3.75\n  },\n  align: \"start\",\n  verticalAlign: \"top\"\n}, {\n  cx: -2.561,\n  cy: 1.061,\n  rx: 2.5,\n  ry: 5,\n  rotation: -45,\n  text: {\n    x: -4,\n    y: 3.7\n  },\n  align: \"end\",\n  verticalAlign: \"top\"\n}, {\n  cx: -0.439,\n  cy: -1.061,\n  rx: 2.5,\n  ry: 5,\n  rotation: -45,\n  text: {\n    x: -4.5,\n    y: -4.5\n  },\n  align: \"end\",\n  verticalAlign: \"bottom\"\n}];\nconst intersections$1 = [{\n  sets: [0],\n  x1: 0,\n  y1: -3.94,\n  arcs: [{\n    ref: 0,\n    mode: \"i\",\n    x2: 4.328,\n    y2: -2.828,\n    sweep: true,\n    large: false\n  }, {\n    ref: 1,\n    mode: \"o\",\n    x2: 2.179,\n    y2: -1.858,\n    large: false\n  }, {\n    ref: 3,\n    mode: \"o\",\n    x2: 0,\n    y2: -3.94,\n    large: false\n  }],\n  text: {\n    x: 2.914,\n    y: -3.536\n  }\n}, {\n  sets: [1],\n  x1: 4.328,\n  y1: -2.828,\n  arcs: [{\n    ref: 1,\n    mode: \"i\",\n    x2: 0,\n    y2: 5.006,\n    sweep: true,\n    large: true\n  }, {\n    ref: 2,\n    mode: \"o\",\n    x2: 1.328,\n    y2: 2.828\n  }, {\n    ref: 3,\n    mode: \"o\",\n    x2: 3.108,\n    y2: -0.328\n  }, {\n    ref: 0,\n    mode: \"o\",\n    x2: 4.328,\n    y2: -2.828\n  }],\n  text: {\n    x: 5.036,\n    y: -1.414\n  }\n}, {\n  sets: [2],\n  x1: 0,\n  y1: 5.006,\n  arcs: [{\n    ref: 2,\n    mode: \"i\",\n    x2: -4.328,\n    y2: -2.828,\n    sweep: true,\n    large: true\n  }, {\n    ref: 3,\n    mode: \"o\",\n    x2: -3.108,\n    y2: -0.328\n  }, {\n    ref: 0,\n    mode: \"o\",\n    x2: -1.328,\n    y2: 2.828\n  }, {\n    ref: 1,\n    mode: \"o\",\n    x2: 0,\n    y2: 5.006\n  }],\n  text: {\n    x: -5.036,\n    y: -1.414\n  }\n}, {\n  sets: [3],\n  x1: -4.328,\n  y1: -2.828,\n  arcs: [{\n    ref: 3,\n    mode: \"i\",\n    x2: 0,\n    y2: -3.94,\n    sweep: true,\n    large: false\n  }, {\n    ref: 0,\n    mode: \"o\",\n    x2: -2.179,\n    y2: -1.858,\n    large: false\n  }, {\n    ref: 2,\n    mode: \"o\",\n    x2: -4.328,\n    y2: -2.828,\n    large: false\n  }],\n  text: {\n    x: -2.914,\n    y: -3.536\n  }\n}, {\n  sets: [0, 1],\n  x1: 4.328,\n  y1: -2.828,\n  arcs: [{\n    ref: 1,\n    mode: \"i\",\n    x2: 3.108,\n    y2: -0.328,\n    sweep: true,\n    large: false\n  }, {\n    ref: 3,\n    mode: \"o\",\n    x2: 2.179,\n    y2: -1.858,\n    sweep: false,\n    large: false\n  }, {\n    ref: 0,\n    mode: \"i\",\n    x2: 4.328,\n    y2: -2.828,\n    sweep: true,\n    large: false\n  }],\n  text: {\n    x: 3.205,\n    y: -1.672\n  }\n}, {\n  sets: [0, 2],\n  x1: -1.328,\n  y1: 2.828,\n  arcs: [{\n    ref: 0,\n    mode: \"i\",\n    x2: -3.108,\n    y2: -0.328,\n    sweep: true,\n    large: false\n  }, {\n    ref: 3,\n    mode: \"o\",\n    x2: -0.969,\n    y2: 1.755,\n    large: false\n  }, {\n    ref: 1,\n    mode: \"o\",\n    x2: -1.328,\n    y2: 2.828,\n    large: false\n  }],\n  text: {\n    x: -2.212,\n    y: 1.591\n  }\n}, {\n  sets: [0, 3],\n  x1: 0,\n  y1: -3.94,\n  arcs: [{\n    ref: 3,\n    mode: \"i\",\n    x2: 2.179,\n    y2: -1.858,\n    sweep: true,\n    large: false\n  }, {\n    ref: 1,\n    mode: \"o\",\n    x2: 0,\n    y2: 0.188,\n    sweep: false,\n    large: false\n  }, {\n    ref: 2,\n    mode: \"o\",\n    x2: -2.179,\n    y2: -1.858,\n    sweep: false,\n    large: false\n  }, {\n    ref: 0,\n    mode: \"i\",\n    x2: 0,\n    y2: -3.94,\n    sweep: true\n  }],\n  text: {\n    x: 0,\n    y: -1.87\n  }\n}, {\n  sets: [1, 2],\n  x1: 1.328,\n  y1: 2.828,\n  arcs: [{\n    ref: 2,\n    mode: \"i\",\n    x2: 0,\n    y2: 5.006,\n    sweep: true,\n    large: false\n  }, {\n    ref: 1,\n    mode: \"i\",\n    x2: -1.328,\n    y2: 2.828,\n    sweep: true,\n    large: false\n  }, {\n    ref: 0,\n    mode: \"o\",\n    x2: 0,\n    y2: 2.346,\n    large: false\n  }, {\n    ref: 3,\n    mode: \"o\",\n    x2: 1.328,\n    y2: 2.828\n  }],\n  text: {\n    x: 0,\n    y: 3.393\n  }\n}, {\n  sets: [1, 3],\n  x1: 3.108,\n  y1: -0.328,\n  arcs: [{\n    ref: 3,\n    mode: \"i\",\n    x2: 1.328,\n    y2: 2.828,\n    sweep: true,\n    large: false\n  }, {\n    ref: 2,\n    mode: \"o\",\n    x2: 0.969,\n    y2: 1.755,\n    large: false\n  }, {\n    ref: 1,\n    mode: \"i\",\n    x2: 3.108,\n    y2: -0.328,\n    large: false\n  }],\n  text: {\n    x: 2.212,\n    y: 1.591\n  }\n}, {\n  sets: [2, 3],\n  x1: -3.108,\n  y1: -0.328,\n  arcs: [{\n    ref: 3,\n    mode: \"i\",\n    x2: -4.328,\n    y2: -2.828,\n    sweep: true,\n    large: false\n  }, {\n    ref: 2,\n    mode: \"i\",\n    x2: -2.179,\n    y2: -1.858,\n    sweep: true,\n    large: false\n  }, {\n    ref: 0,\n    mode: \"o\",\n    x2: -3.108,\n    y2: -0.328,\n    large: false\n  }],\n  text: {\n    x: -3.205,\n    y: -1.672\n  }\n}, {\n  sets: [0, 1, 2],\n  x1: 0,\n  y1: 2.346,\n  arcs: [{\n    ref: 0,\n    mode: \"i\",\n    x2: -1.328,\n    y2: 2.828,\n    sweep: true,\n    large: false\n  }, {\n    ref: 1,\n    mode: \"i\",\n    x2: -0.969,\n    y2: 1.755,\n    sweep: true,\n    large: false\n  }, {\n    ref: 3,\n    mode: \"o\",\n    x2: 0,\n    y2: 2.346,\n    large: false\n  }],\n  text: {\n    x: -0.766,\n    y: 2.31\n  }\n}, {\n  sets: [0, 1, 3],\n  x1: 2.179,\n  y1: -1.858,\n  arcs: [{\n    ref: 3,\n    mode: \"i\",\n    x2: 3.108,\n    y2: -0.328,\n    sweep: true,\n    large: false\n  }, {\n    ref: 0,\n    mode: \"i\",\n    x2: 0.969,\n    y2: 1.755,\n    sweep: true,\n    large: false\n  }, {\n    ref: 2,\n    mode: \"o\",\n    x2: 0,\n    y2: 0.188,\n    sweep: false,\n    large: false\n  }, {\n    ref: 1,\n    mode: \"i\",\n    x2: 2.179,\n    y2: -1.858,\n    sweep: true\n  }],\n  text: {\n    x: 1.558,\n    y: -0.056\n  }\n}, {\n  sets: [0, 2, 3],\n  x1: -0.969,\n  y1: 1.755,\n  arcs: [{\n    ref: 3,\n    mode: \"i\",\n    x2: -3.108,\n    y2: -0.328,\n    sweep: true,\n    large: false\n  }, {\n    ref: 0,\n    mode: \"i\",\n    x2: -2.179,\n    y2: -1.858,\n    sweep: true,\n    large: false\n  }, {\n    ref: 2,\n    mode: \"i\",\n    x2: 0,\n    y2: 0.188,\n    sweep: true,\n    large: false\n  }, {\n    ref: 1,\n    mode: \"o\",\n    x2: -0.969,\n    y2: 1.755\n  }],\n  text: {\n    x: -1.558,\n    y: -0.056\n  }\n}, {\n  sets: [1, 2, 3],\n  x1: 1.328,\n  y1: 2.828,\n  arcs: [{\n    ref: 3,\n    mode: \"i\",\n    x2: 0,\n    y2: 2.346,\n    sweep: true,\n    large: false\n  }, {\n    ref: 0,\n    mode: \"o\",\n    x2: 0.969,\n    y2: 1.755,\n    sweep: false,\n    large: false\n  }, {\n    ref: 2,\n    mode: \"i\",\n    x2: 1.328,\n    y2: 2.828,\n    sweep: true,\n    large: false\n  }],\n  text: {\n    x: 0.766,\n    y: 2.31\n  }\n}, {\n  sets: [0, 1, 2, 3],\n  x1: 0,\n  y1: 0.188,\n  arcs: [{\n    ref: 2,\n    mode: \"i\",\n    x2: 0.969,\n    y2: 1.755,\n    sweep: true,\n    large: false\n  }, {\n    ref: 0,\n    mode: \"i\",\n    x2: 0,\n    y2: 2.346,\n    sweep: true,\n    large: false\n  }, {\n    ref: 3,\n    mode: \"i\",\n    x2: -0.969,\n    y2: 1.755,\n    sweep: true,\n    large: false\n  }, {\n    ref: 1,\n    mode: \"i\",\n    x2: 0,\n    y2: 0.188,\n    sweep: true\n  }],\n  text: {\n    x: 0,\n    y: 1.43\n  }\n}];\nconst bb$1 = {\n  x: -6.5,\n  y: -5,\n  width: 13,\n  height: 10\n};\nconst venn4 = {\n  sets: sets$1,\n  intersections: intersections$1,\n  bb: bb$1\n};\nconst sets = [{\n  cx: 0.5,\n  cy: -1,\n  rx: 2.5,\n  ry: 5,\n  rotation: 0,\n  text: {\n    x: 2.25,\n    y: -5\n  },\n  icon: {\n    x: 0,\n    y: -6.3\n  },\n  align: \"start\",\n  verticalAlign: \"bottom\"\n}, {\n  cx: 1.106,\n  cy: 0.167,\n  rx: 2.5,\n  ry: 5,\n  rotation: 72,\n  text: {\n    x: 4.5,\n    y: 1.5\n  },\n  icon: {\n    x: 6.2,\n    y: -1.9\n  },\n  align: \"start\",\n  verticalAlign: \"top\"\n}, {\n  cx: 0.183,\n  cy: 1.103,\n  rx: 2.5,\n  ry: 5,\n  rotation: 144,\n  icon: {\n    x: 3.2,\n    y: 6\n  },\n  text: {\n    x: 4,\n    y: 4\n  },\n  align: \"start\",\n  verticalAlign: \"bottom\"\n}, {\n  cx: -0.992,\n  cy: 0.515,\n  rx: 2.5,\n  ry: 5,\n  rotation: 216,\n  icon: {\n    x: -4.4,\n    y: 5.2\n  },\n  text: {\n    x: -4.7,\n    y: 2\n  },\n  align: \"end\",\n  verticalAlign: \"bottom\"\n}, {\n  cx: -0.797,\n  cy: -0.785,\n  rx: 2.5,\n  ry: 5,\n  rotation: 288,\n  icon: {\n    x: -6,\n    y: -2\n  },\n  text: {\n    x: -4,\n    y: -3.6\n  },\n  align: \"end\",\n  verticalAlign: \"bottom\"\n}];\nconst intersections = [{\n  sets: [0],\n  x1: -1.653,\n  y1: -3.541,\n  arcs: [{\n    ref: 0,\n    mode: \"i\",\n    x2: 2.857,\n    y2: -2.666,\n    sweep: true,\n    large: false\n  }, {\n    ref: 1,\n    mode: \"o\",\n    x2: 2.5,\n    y2: -2.648,\n    large: false\n  }, {\n    ref: 3,\n    mode: \"o\",\n    x2: -0.495,\n    y2: -3.303,\n    large: false\n  }, {\n    ref: 4,\n    mode: \"o\",\n    x2: -1.653,\n    y2: -3.541\n  }],\n  text: {\n    x: 0.5,\n    y: -5\n  }\n}, {\n  sets: [1],\n  x1: 2.857,\n  y1: -2.666,\n  arcs: [{\n    ref: 1,\n    mode: \"i\",\n    x2: 3.419,\n    y2: 1.893,\n    sweep: true,\n    large: false\n  }, {\n    ref: 2,\n    mode: \"o\",\n    x2: 3.291,\n    y2: 1.559,\n    large: false\n  }, {\n    ref: 4,\n    mode: \"o\",\n    x2: 2.988,\n    y2: -1.492,\n    large: false\n  }, {\n    ref: 0,\n    mode: \"o\",\n    x2: 2.857,\n    y2: -2.666\n  }],\n  text: {\n    x: 4.91,\n    y: -1.07\n  }\n}, {\n  sets: [2],\n  x1: 3.419,\n  y1: 1.893,\n  arcs: [{\n    ref: 2,\n    mode: \"i\",\n    x2: -0.744,\n    y2: 3.837,\n    sweep: true,\n    large: false\n  }, {\n    ref: 3,\n    mode: \"o\",\n    x2: -0.466,\n    y2: 3.612,\n    large: false\n  }, {\n    ref: 0,\n    mode: \"o\",\n    x2: 2.342,\n    y2: 2.381,\n    large: false\n  }, {\n    ref: 1,\n    mode: \"o\",\n    x2: 3.419,\n    y2: 1.893\n  }],\n  text: {\n    x: 2.534,\n    y: 4.339\n  }\n}, {\n  sets: [3],\n  x1: -0.744,\n  y1: 3.837,\n  arcs: [{\n    ref: 3,\n    mode: \"i\",\n    x2: -3.879,\n    y2: 0.478,\n    sweep: true,\n    large: false\n  }, {\n    ref: 4,\n    mode: \"o\",\n    x2: -3.579,\n    y2: 0.673,\n    large: false\n  }, {\n    ref: 1,\n    mode: \"o\",\n    x2: -1.54,\n    y2: 2.963,\n    large: false\n  }, {\n    ref: 2,\n    mode: \"o\",\n    x2: -0.744,\n    y2: 3.837\n  }],\n  text: {\n    x: -3.343,\n    y: 3.751\n  }\n}, {\n  sets: [4],\n  x1: -3.879,\n  y1: 0.478,\n  arcs: [{\n    ref: 4,\n    mode: \"i\",\n    x2: -1.653,\n    y2: -3.541,\n    sweep: true,\n    large: false\n  }, {\n    ref: 0,\n    mode: \"o\",\n    x2: -1.746,\n    y2: -3.196,\n    large: false\n  }, {\n    ref: 2,\n    mode: \"o\",\n    x2: -3.294,\n    y2: -0.549,\n    large: false\n  }, {\n    ref: 3,\n    mode: \"o\",\n    x2: -3.879,\n    y2: 0.478\n  }],\n  text: {\n    x: -4.601,\n    y: -2.021\n  }\n}, {\n  sets: [0, 1],\n  x1: 2.5,\n  y1: -2.648,\n  arcs: [{\n    ref: 1,\n    mode: \"i\",\n    x2: 2.857,\n    y2: -2.666,\n    sweep: true,\n    large: false\n  }, {\n    ref: 0,\n    mode: \"i\",\n    x2: 2.988,\n    y2: -1.492,\n    sweep: true,\n    large: false\n  }, {\n    ref: 4,\n    mode: \"o\",\n    x2: 2.572,\n    y2: -1.839,\n    large: false\n  }, {\n    ref: 3,\n    mode: \"o\",\n    x2: 2.5,\n    y2: -2.648\n  }],\n  text: {\n    x: 2.741,\n    y: -2.152\n  }\n}, {\n  sets: [0, 2],\n  x1: 2.342,\n  y1: 2.381,\n  arcs: [{\n    ref: 0,\n    mode: \"i\",\n    x2: -0.466,\n    y2: 3.612,\n    sweep: true,\n    large: false\n  }, {\n    ref: 3,\n    mode: \"o\",\n    x2: 0.257,\n    y2: 2.922,\n    large: false\n  }, {\n    ref: 1,\n    mode: \"o\",\n    x2: 2.342,\n    y2: 2.381,\n    large: false\n  }],\n  text: {\n    x: 0.5,\n    y: 3.5\n  }\n}, {\n  sets: [0, 3],\n  x1: -0.495,\n  y1: -3.303,\n  arcs: [{\n    ref: 3,\n    mode: \"i\",\n    x2: 2.5,\n    y2: -2.648,\n    sweep: true,\n    large: false\n  }, {\n    ref: 1,\n    mode: \"o\",\n    x2: 1.51,\n    y2: -2.515,\n    large: false\n  }, {\n    ref: 4,\n    mode: \"o\",\n    x2: -0.495,\n    y2: -3.303,\n    large: false\n  }],\n  text: {\n    x: 1.653,\n    y: -3.125\n  }\n}, {\n  sets: [0, 4],\n  x1: -1.653,\n  y1: -3.541,\n  arcs: [{\n    ref: 4,\n    mode: \"i\",\n    x2: -0.495,\n    y2: -3.303,\n    sweep: true,\n    large: false\n  }, {\n    ref: 3,\n    mode: \"o\",\n    x2: -0.954,\n    y2: -3.015,\n    large: false\n  }, {\n    ref: 2,\n    mode: \"o\",\n    x2: -1.746,\n    y2: -3.196,\n    large: false\n  }, {\n    ref: 0,\n    mode: \"i\",\n    x2: -1.653,\n    y2: -3.541\n  }],\n  text: {\n    x: -1.199,\n    y: -3.272\n  }\n}, {\n  sets: [1, 2],\n  x1: 3.291,\n  y1: 1.559,\n  arcs: [{\n    ref: 2,\n    mode: \"i\",\n    x2: 3.419,\n    y2: 1.893,\n    sweep: true,\n    large: false\n  }, {\n    ref: 1,\n    mode: \"i\",\n    x2: 2.342,\n    y2: 2.381,\n    sweep: true,\n    large: false\n  }, {\n    ref: 0,\n    mode: \"o\",\n    x2: 2.544,\n    y2: 1.878,\n    large: false\n  }, {\n    ref: 4,\n    mode: \"o\",\n    x2: 3.291,\n    y2: 1.559\n  }],\n  text: {\n    x: 2.894,\n    y: 1.942\n  }\n}, {\n  sets: [1, 3],\n  x1: -1.54,\n  y1: 2.963,\n  arcs: [{\n    ref: 1,\n    mode: \"i\",\n    x2: -3.579,\n    y2: 0.673,\n    sweep: true,\n    large: false\n  }, {\n    ref: 4,\n    mode: \"o\",\n    x2: -2.7,\n    y2: 1.147,\n    large: false\n  }, {\n    ref: 2,\n    mode: \"o\",\n    x2: -1.54,\n    y2: 2.963,\n    large: false\n  }],\n  text: {\n    x: -3.174,\n    y: 1.557\n  }\n}, {\n  sets: [1, 4],\n  x1: 2.988,\n  y1: -1.492,\n  arcs: [{\n    ref: 4,\n    mode: \"i\",\n    x2: 3.291,\n    y2: 1.559,\n    sweep: true,\n    large: false\n  }, {\n    ref: 2,\n    mode: \"o\",\n    x2: 2.858,\n    y2: 0.659,\n    large: false\n  }, {\n    ref: 0,\n    mode: \"o\",\n    x2: 2.988,\n    y2: -1.492,\n    large: false\n  }],\n  text: {\n    x: 3.483,\n    y: 0.606\n  }\n}, {\n  sets: [2, 3],\n  x1: -0.466,\n  y1: 3.612,\n  arcs: [{\n    ref: 3,\n    mode: \"i\",\n    x2: -0.744,\n    y2: 3.837,\n    sweep: true,\n    large: false\n  }, {\n    ref: 2,\n    mode: \"i\",\n    x2: -1.54,\n    y2: 2.963,\n    sweep: true,\n    large: false\n  }, {\n    ref: 1,\n    mode: \"o\",\n    x2: -1,\n    y2: 3,\n    large: false\n  }, {\n    ref: 0,\n    mode: \"o\",\n    x2: -0.466,\n    y2: 3.612\n  }],\n  text: {\n    x: -0.953,\n    y: 3.352\n  }\n}, {\n  sets: [2, 4],\n  x1: -3.294,\n  y1: -0.549,\n  arcs: [{\n    ref: 2,\n    mode: \"i\",\n    x2: -1.746,\n    y2: -3.196,\n    sweep: true\n  }, {\n    ref: 0,\n    mode: \"o\",\n    x2: -1.925,\n    y2: -2.213\n  }, {\n    ref: 3,\n    mode: \"o\",\n    x2: -3.294,\n    y2: -0.549\n  }],\n  text: {\n    x: -2.462,\n    y: -2.538\n  }\n}, {\n  sets: [3, 4],\n  x1: -3.579,\n  y1: 0.673,\n  arcs: [{\n    ref: 4,\n    mode: \"i\",\n    x2: -3.879,\n    y2: 0.478,\n    sweep: true,\n    large: false\n  }, {\n    ref: 3,\n    mode: \"i\",\n    x2: -3.294,\n    y2: -0.549,\n    sweep: true,\n    large: false\n  }, {\n    ref: 2,\n    mode: \"o\",\n    x2: -3.162,\n    y2: -0.024,\n    large: false\n  }, {\n    ref: 1,\n    mode: \"o\",\n    x2: -3.579,\n    y2: 0.673\n  }],\n  text: {\n    x: -3.483,\n    y: 0.13\n  }\n}, {\n  sets: [0, 1, 2],\n  x1: 2.544,\n  y1: 1.878,\n  arcs: [{\n    ref: 0,\n    mode: \"i\",\n    x2: 2.342,\n    y2: 2.381,\n    sweep: true,\n    large: false\n  }, {\n    ref: 1,\n    mode: \"i\",\n    x2: 0.257,\n    y2: 2.922,\n    sweep: true,\n    large: false\n  }, {\n    ref: 3,\n    mode: \"o\",\n    x2: 0.983,\n    y2: 2.049,\n    large: false\n  }, {\n    ref: 4,\n    mode: \"o\",\n    x2: 2.544,\n    y2: 1.878\n  }],\n  text: {\n    x: 1.457,\n    y: 2.331\n  }\n}, {\n  sets: [0, 1, 3],\n  x1: 1.51,\n  y1: -2.515,\n  arcs: [{\n    ref: 1,\n    mode: \"i\",\n    x2: 2.5,\n    y2: -2.648,\n    sweep: true,\n    large: false\n  }, {\n    ref: 3,\n    mode: \"i\",\n    x2: 2.572,\n    y2: -1.839,\n    sweep: true,\n    large: false\n  }, {\n    ref: 4,\n    mode: \"o\",\n    x2: 1.51,\n    y2: -2.515,\n    large: false\n  }],\n  text: {\n    x: 2.194,\n    y: -2.334\n  }\n}, {\n  sets: [0, 1, 4],\n  x1: 2.572,\n  y1: -1.839,\n  arcs: [{\n    ref: 4,\n    mode: \"i\",\n    x2: 2.988,\n    y2: -1.492,\n    sweep: true,\n    large: false\n  }, {\n    ref: 0,\n    mode: \"i\",\n    x2: 2.858,\n    y2: 0.659,\n    sweep: true,\n    large: false\n  }, {\n    ref: 2,\n    mode: \"o\",\n    x2: 2.253,\n    y2: -0.302,\n    large: false\n  }, {\n    ref: 3,\n    mode: \"o\",\n    x2: 2.572,\n    y2: -1.839\n  }],\n  text: {\n    x: 2.667,\n    y: -0.665\n  }\n}, {\n  sets: [0, 2, 3],\n  x1: 0.257,\n  y1: 2.922,\n  arcs: [{\n    ref: 3,\n    mode: \"i\",\n    x2: -0.466,\n    y2: 3.612,\n    sweep: true,\n    large: false\n  }, {\n    ref: 0,\n    mode: \"i\",\n    x2: -1,\n    y2: 3,\n    sweep: true,\n    large: false\n  }, {\n    ref: 1,\n    mode: \"o\",\n    x2: 0.257,\n    y2: 2.922,\n    large: false\n  }],\n  text: {\n    x: -0.403,\n    y: 3.178\n  }\n}, {\n  sets: [0, 2, 4],\n  x1: -1.746,\n  y1: -3.196,\n  arcs: [{\n    ref: 2,\n    mode: \"i\",\n    x2: -0.954,\n    y2: -3.015,\n    sweep: true,\n    large: false\n  }, {\n    ref: 3,\n    mode: \"o\",\n    x2: -1.925,\n    y2: -2.213,\n    sweep: false,\n    large: false\n  }, {\n    ref: 0,\n    mode: \"i\",\n    x2: -1.746,\n    y2: -3.196,\n    sweep: true,\n    large: false\n  }],\n  text: {\n    x: -1.542,\n    y: -2.808\n  }\n}, {\n  sets: [0, 3, 4],\n  x1: -0.495,\n  y1: -3.303,\n  arcs: [{\n    ref: 4,\n    mode: \"i\",\n    x2: 1.51,\n    y2: -2.515,\n    sweep: true,\n    large: false\n  }, {\n    ref: 1,\n    mode: \"o\",\n    x2: 0.409,\n    y2: -2.236,\n    large: false\n  }, {\n    ref: 2,\n    mode: \"o\",\n    x2: -0.954,\n    y2: -3.015,\n    large: false\n  }, {\n    ref: 3,\n    mode: \"i\",\n    x2: -0.495,\n    y2: -3.303\n  }],\n  text: {\n    x: 0.192,\n    y: -2.742\n  }\n}, {\n  sets: [1, 2, 3],\n  x1: -1.54,\n  y1: 2.963,\n  arcs: [{\n    ref: 2,\n    mode: \"i\",\n    x2: -2.7,\n    y2: 1.147,\n    sweep: true,\n    large: false\n  }, {\n    ref: 4,\n    mode: \"o\",\n    x2: -1.645,\n    y2: 1.568,\n    large: false\n  }, {\n    ref: 0,\n    mode: \"o\",\n    x2: -1,\n    y2: 3,\n    large: false\n  }, {\n    ref: 1,\n    mode: \"i\",\n    x2: -1.54,\n    y2: 2.963\n  }],\n  text: {\n    x: -1.767,\n    y: 2.106\n  }\n}, {\n  sets: [1, 2, 4],\n  x1: 2.858,\n  y1: 0.659,\n  arcs: [{\n    ref: 2,\n    mode: \"i\",\n    x2: 3.291,\n    y2: 1.559,\n    sweep: true,\n    large: false\n  }, {\n    ref: 4,\n    mode: \"i\",\n    x2: 2.544,\n    y2: 1.878,\n    sweep: true,\n    large: false\n  }, {\n    ref: 0,\n    mode: \"o\",\n    x2: 2.858,\n    y2: 0.659,\n    large: false\n  }],\n  text: {\n    x: 2.898,\n    y: 1.365\n  }\n}, {\n  sets: [1, 3, 4],\n  x1: -2.7,\n  y1: 1.147,\n  arcs: [{\n    ref: 4,\n    mode: \"i\",\n    x2: -3.579,\n    y2: 0.673,\n    sweep: true,\n    large: false\n  }, {\n    ref: 1,\n    mode: \"i\",\n    x2: -3.162,\n    y2: -0.024,\n    sweep: true,\n    large: false\n  }, {\n    ref: 2,\n    mode: \"o\",\n    x2: -2.7,\n    y2: 1.147,\n    large: false\n  }],\n  text: {\n    x: -3.147,\n    y: 0.599\n  }\n}, {\n  sets: [2, 3, 4],\n  x1: -3.294,\n  y1: -0.549,\n  arcs: [{\n    ref: 3,\n    mode: \"i\",\n    x2: -1.925,\n    y2: -2.213,\n    sweep: true,\n    large: false\n  }, {\n    ref: 0,\n    mode: \"o\",\n    x2: -2,\n    y2: -1.08,\n    large: false\n  }, {\n    ref: 1,\n    mode: \"o\",\n    x2: -3.162,\n    y2: -0.024,\n    large: false\n  }, {\n    ref: 2,\n    mode: \"i\",\n    x2: -3.294,\n    y2: -0.549\n  }],\n  text: {\n    x: -2.548,\n    y: -1.029\n  }\n}, {\n  sets: [0, 1, 2, 3],\n  x1: 0.983,\n  y1: 2.049,\n  arcs: [{\n    ref: 3,\n    mode: \"i\",\n    x2: 0.257,\n    y2: 2.922,\n    sweep: true,\n    large: false\n  }, {\n    ref: 1,\n    mode: \"i\",\n    x2: -1,\n    y2: 3,\n    sweep: true,\n    large: false\n  }, {\n    ref: 0,\n    mode: \"i\",\n    x2: -1.645,\n    y2: 1.568,\n    sweep: true,\n    large: false\n  }, {\n    ref: 4,\n    mode: \"o\",\n    x2: 0.983,\n    y2: 2.049\n  }],\n  text: {\n    x: -0.407,\n    y: 2.31\n  }\n}, {\n  sets: [0, 1, 2, 4],\n  x1: 2.253,\n  y1: -0.302,\n  arcs: [{\n    ref: 2,\n    mode: \"i\",\n    x2: 2.858,\n    y2: 0.659,\n    sweep: true,\n    large: false\n  }, {\n    ref: 0,\n    mode: \"i\",\n    x2: 2.544,\n    y2: 1.878,\n    sweep: true,\n    large: false\n  }, {\n    ref: 4,\n    mode: \"i\",\n    x2: 0.983,\n    y2: 2.049,\n    sweep: true,\n    large: false\n  }, {\n    ref: 3,\n    mode: \"o\",\n    x2: 2.253,\n    y2: -0.302\n  }],\n  text: {\n    x: 2.071,\n    y: 1.101\n  }\n}, {\n  sets: [0, 1, 3, 4],\n  x1: 1.51,\n  y1: -2.515,\n  arcs: [{\n    ref: 4,\n    mode: \"i\",\n    x2: 2.572,\n    y2: -1.839,\n    sweep: true,\n    large: false\n  }, {\n    ref: 3,\n    mode: \"i\",\n    x2: 2.253,\n    y2: -0.302,\n    sweep: true,\n    large: false\n  }, {\n    ref: 2,\n    mode: \"o\",\n    x2: 0.409,\n    y2: -2.236,\n    sweep: false,\n    large: false\n  }, {\n    ref: 1,\n    mode: \"i\",\n    x2: 1.51,\n    y2: -2.515,\n    sweep: true\n  }],\n  text: {\n    x: 1.687,\n    y: -1.63\n  }\n}, {\n  sets: [0, 2, 3, 4],\n  x1: -2,\n  y1: -1.08,\n  arcs: [{\n    ref: 0,\n    mode: \"i\",\n    x2: -1.925,\n    y2: -2.213,\n    sweep: true,\n    large: false\n  }, {\n    ref: 3,\n    mode: \"i\",\n    x2: -0.954,\n    y2: -3.015,\n    sweep: true,\n    large: false\n  }, {\n    ref: 2,\n    mode: \"i\",\n    x2: 0.409,\n    y2: -2.236,\n    sweep: true,\n    large: false\n  }, {\n    ref: 1,\n    mode: \"o\",\n    x2: -2,\n    y2: -1.08\n  }],\n  text: {\n    x: -1.028,\n    y: -2.108\n  }\n}, {\n  sets: [1, 2, 3, 4],\n  x1: -1.645,\n  y1: 1.568,\n  arcs: [{\n    ref: 4,\n    mode: \"i\",\n    x2: -2.7,\n    y2: 1.147,\n    sweep: true,\n    large: false\n  }, {\n    ref: 2,\n    mode: \"i\",\n    x2: -3.162,\n    y2: -0.024,\n    sweep: true,\n    large: false\n  }, {\n    ref: 1,\n    mode: \"i\",\n    x2: -2,\n    y2: -1.08,\n    sweep: true,\n    large: false\n  }, {\n    ref: 0,\n    mode: \"o\",\n    x2: -1.645,\n    y2: 1.568\n  }],\n  text: {\n    x: -2.323,\n    y: 0.327\n  }\n}, {\n  sets: [0, 1, 2, 3, 4],\n  x1: 0.409,\n  y1: -2.236,\n  arcs: [{\n    ref: 2,\n    mode: \"i\",\n    x2: 2.253,\n    y2: -0.302,\n    sweep: true,\n    large: false\n  }, {\n    ref: 3,\n    mode: \"i\",\n    x2: 0.983,\n    y2: 2.049,\n    sweep: true,\n    large: false\n  }, {\n    ref: 4,\n    mode: \"i\",\n    x2: -1.645,\n    y2: 1.568,\n    sweep: true,\n    large: false\n  }, {\n    ref: 0,\n    mode: \"i\",\n    x2: -2,\n    y2: -1.08,\n    sweep: true\n  }, {\n    ref: 1,\n    mode: \"i\",\n    x2: 0.409,\n    y2: -2.236,\n    sweep: true\n  }],\n  text: {\n    x: 0,\n    y: 0\n  }\n}];\nconst bb = {\n  x: -5.5,\n  y: -6,\n  width: 11.6,\n  height: 11.8\n};\nconst venn5 = {\n  sets,\n  intersections,\n  bb\n};\nconst shapes = [venn0, venn1, venn2, venn3, venn4, venn5];\nconst upto = limit => Array.from({\n  length: limit\n}, (_, i) => i);\nfunction isEllipse(d) {\n  return typeof d.rx === \"number\";\n}\nfunction combinations(array) {\n  return new Array(1 << array.length).fill().map((_e1, i) => array.filter((_e2, j) => i & 1 << j));\n}\nfunction lookup(combo, data) {\n  const key = combo.join(\"|\");\n  const found = data.find(d => d.key === key);\n  return {\n    key,\n    sets: combo,\n    size: (found == null ? void 0 : found.size) || 0\n  };\n}\nfunction buildData(data) {\n  const uniqueSets = data.filter(d => d.sets.length === 1).sort((a, b) => b.size - a.size);\n  const uniqueSetKeys = uniqueSets.map(u => u.key);\n  const sets2 = combinations(uniqueSetKeys);\n  const filteredSets = sets2.slice(1, sets2.length);\n  const result = filteredSets.map(d => [...d].sort((a, b) => uniqueSetKeys.indexOf(a) - uniqueSetKeys.indexOf(b)));\n  result.sort((a, b) => a.length - b.length || upto(a.length).reduce((diff, i) => diff || uniqueSetKeys.indexOf(a[i]) - uniqueSetKeys.indexOf(b[i]), 0));\n  const keyedData = data.map(d => {\n    const sets22 = [...d.sets].sort((a, b) => uniqueSetKeys.indexOf(a) - uniqueSetKeys.indexOf(b));\n    const key = sets22.join(\"|\");\n    return {\n      size: d.size,\n      sets: sets22,\n      key\n    };\n  });\n  return {\n    uniqueCount: uniqueSets.length,\n    data: result.map(r => lookup(r, keyedData))\n  };\n}\nfunction generateArcSlicePath(s, refs) {\n  return \"M \".concat(s.x1, \",\").concat(s.y1, \" \").concat(s.arcs.map(arc2 => {\n    const ref = refs[arc2.ref];\n    const rx = isEllipse(ref) ? ref.rx : ref.r;\n    const ry = isEllipse(ref) ? ref.ry : ref.r;\n    const rot = isEllipse(ref) ? ref.rotation : 0;\n    return \"A \".concat(rx, \" \").concat(ry, \" \").concat(rot, \" \").concat(arc2.large ? 1 : 0, \" \").concat(arc2.sweep ? 1 : 0, \" \").concat(arc2.x2, \" \").concat(arc2.y2);\n  }).join(\" \"));\n}\nfunction buildLayout(_ref140, box) {\n  let {\n    data,\n    uniqueCount\n  } = _ref140;\n  const shape = shapes[Math.min(shapes.length - 1, uniqueCount)];\n  const f = Math.min(box.width / shape.bb.width, box.height / shape.bb.height);\n  const x = f * -shape.bb.x + (box.width - f * shape.bb.width) / 2 + 0;\n  const y = f * -shape.bb.y + (box.height - f * shape.bb.height) / 2 + 0;\n  const mx = v => x + f * v;\n  const my = v => y + f * v;\n  const shapeSets = shape.sets.map((c, i) => ({\n    ...c,\n    ...{\n      data: data[i],\n      cx: mx(c.cx),\n      cy: my(c.cy),\n      text: {\n        x: mx(c.text.x),\n        y: my(c.text.y)\n      },\n      ...(c.icon ? {\n        icon: {\n          x: mx(c.icon.x),\n          y: my(c.icon.y)\n        }\n      } : {})\n    },\n    ...(isEllipse(c) ? {\n      rx: c.rx * f,\n      ry: c.ry * f\n    } : {\n      r: c.r * f\n    })\n  }));\n  const intersections2 = shape.intersections.map((c, i) => ({\n    text: {\n      x: mx(c.text.x),\n      y: my(c.text.y)\n    },\n    x1: mx(c.x1),\n    y1: my(c.y1),\n    data: data[i],\n    set: shapeSets[i],\n    arcs: c.arcs.map(a => ({\n      ...a,\n      x2: mx(a.x2),\n      y2: my(a.y2)\n    }))\n  }));\n  return intersections2.map(i => ({\n    ...i,\n    path: generateArcSlicePath(i, shapeSets)\n  }));\n}\nfunction starEulerLayout(data, bb2) {\n  return buildLayout(buildData(data), bb2);\n}\nconst VennDiagram = _ref141 => {\n  let {\n    id,\n    type,\n    width,\n    height,\n    margins,\n    className,\n    containerClassName,\n    data,\n    disabled,\n    series\n  } = _ref141;\n  const renderChart = useCallback(containerProps => {\n    const normalized = data.map(d => ({\n      key: d.key.join(\"|\"),\n      sets: d.key,\n      size: d.data\n    }));\n    let layoutData;\n    if (type === \"starEuler\") {\n      layoutData = starEulerLayout(normalized, {\n        height: containerProps.height,\n        width: containerProps.width\n      });\n    } else {\n      layoutData = layout(normalized, {\n        height: containerProps.height,\n        width: containerProps.width,\n        distinct: type !== \"euler\"\n      });\n    }\n    return /* @__PURE__ */jsx(CloneElement, {\n      element: series,\n      data: layoutData,\n      disabled,\n      id: containerProps.id\n    });\n  }, [data, disabled, series, type]);\n  return /* @__PURE__ */jsx(ChartContainer, {\n    id,\n    width,\n    height,\n    margins,\n    containerClassName,\n    xAxisVisible: false,\n    yAxisVisible: false,\n    center: false,\n    className,\n    children: renderChart\n  });\n};\nVennDiagram.defaultProps = {\n  type: \"venn\",\n  series: /* @__PURE__ */jsx(VennSeries, {})\n};\nconst Bubble = _ref142 => {\n  let {\n    id,\n    data,\n    fill,\n    mask,\n    gradient: gradient2,\n    glow,\n    onClick,\n    onMouseEnter,\n    onMouseLeave,\n    animated,\n    tooltip: tooltip2 = /* @__PURE__ */jsx(ChartTooltip, {})\n  } = _ref142;\n  const [internalActive, setInternalActive] = useState(false);\n  const bubbleRef = useRef(null);\n  const transition = animated ? DEFAULT_TRANSITION : {\n    type: false,\n    delay: 0\n  };\n  const {\n    pointerOut,\n    pointerOver\n  } = useHoverIntent({\n    onPointerOver: event => {\n      setInternalActive(true);\n      onMouseEnter == null ? void 0 : onMouseEnter(event);\n    },\n    onPointerOut: event => {\n      setInternalActive(false);\n      onMouseLeave == null ? void 0 : onMouseLeave(event);\n    }\n  });\n  const arcFill = gradient2 && !mask ? \"url(#gradient-\".concat(id, \")\") : mask ? \"url(#mask-pattern-\".concat(id, \")\") : fill;\n  const tooltipData = useMemo(() => ({\n    y: data.data.data,\n    x: data.data.key\n  }), [data]);\n  const ariaLabelData = useMemo(() => getAriaLabel(tooltipData), [tooltipData]);\n  return /* @__PURE__ */jsxs(Fragment, {\n    children: [/* @__PURE__ */jsx(motion.circle, {\n      id: \"\".concat(id, \"-bubble\"),\n      ref: bubbleRef,\n      fill: arcFill,\n      style: generateGlowStyles({\n        glow\n      }),\n      initial: {\n        r: data.r,\n        cx: data.x,\n        cy: data.y\n      },\n      animate: {\n        r: data.r,\n        cx: data.x,\n        cy: data.y\n      },\n      transition,\n      onClick: event => onClick && onClick(event, data),\n      onPointerOver: pointerOver,\n      onPointerOut: pointerOut,\n      tabIndex: 0,\n      \"aria-label\": ariaLabelData,\n      role: \"graphics-document\"\n    }), mask && /* @__PURE__ */jsxs(Fragment, {\n      children: [/* @__PURE__ */jsx(Mask, {\n        id: \"mask-\".concat(id),\n        fill: \"url(#gradient-\".concat(id, \")\")\n      }), /* @__PURE__ */jsx(CloneElement, {\n        element: mask,\n        id: \"mask-pattern-\".concat(id),\n        fill\n      })]\n    }), gradient2 && /* @__PURE__ */jsx(CloneElement, {\n      element: gradient2,\n      id: \"gradient-\".concat(id),\n      color: fill\n    }), tooltip2 && !tooltip2.props.disabled && /* @__PURE__ */jsx(CloneElement, {\n      element: tooltip2,\n      visible: !!internalActive,\n      reference: bubbleRef,\n      value: tooltipData\n    })]\n  });\n};\nconst BubbleLabel = _ref143 => {\n  let {\n    id,\n    data,\n    format,\n    wrap,\n    fill,\n    fontSize,\n    fontFamily,\n    animated\n  } = _ref143;\n  const transition = animated ? DEFAULT_TRANSITION : {\n    type: false,\n    delay: 0\n  };\n  let isElement = false;\n  let label2;\n  if (format) {\n    label2 = format(data);\n    isElement = isValidElement(label2);\n  }\n  if (!isElement) {\n    const text = wrap ? wrapText({\n      key: data.data.key,\n      fontFamily,\n      fontSize,\n      width: data.r\n    }) : data.data.key;\n    return /* @__PURE__ */jsx(motion.text, {\n      initial: {\n        x: data.x,\n        y: data.y\n      },\n      animate: {\n        x: data.x,\n        y: data.y\n      },\n      transition,\n      id: \"\".concat(id, \"-text\"),\n      style: {\n        pointerEvents: \"none\",\n        fontFamily,\n        fontSize\n      },\n      fill,\n      textAnchor: \"middle\",\n      children: text\n    });\n  }\n  return /* @__PURE__ */jsx(\"g\", {\n    style: {\n      transform: \"translate(\".concat(data.x, \"px, \").concat(data.y, \"px)\")\n    },\n    children: label2\n  });\n};\nBubbleLabel.defaultProps = {\n  wrap: true,\n  fontSize: 14,\n  fontFamily: \"sans-serif\"\n};\nconst BubbleSeries = _ref144 => {\n  let {\n    id,\n    data,\n    colorScheme,\n    animated,\n    bubble,\n    format,\n    label: label2\n  } = _ref144;\n  const transition = animated ? DEFAULT_TRANSITION : {\n    type: false,\n    delay: 0\n  };\n  const renderBubble = (item2, index) => {\n    const fill = getColor({\n      data,\n      colorScheme,\n      point: item2.data,\n      index\n    });\n    const textFill = fill ? invert(chroma(fill).darken(0.5).hex(), true) : \"white\";\n    return /* @__PURE__ */jsxs(motion.g, {\n      initial: {\n        scale: 0.5,\n        opacity: 0\n      },\n      animate: {\n        scale: 1,\n        opacity: 1\n      },\n      transition,\n      children: [/* @__PURE__ */jsx(CloneElement, {\n        element: format ? format(item2) : bubble,\n        id: identifier(\"\".concat(id, \"-\").concat(item2.data.key, \"-bubble\")),\n        animated,\n        data: item2,\n        fill\n      }), /* @__PURE__ */jsx(CloneElement, {\n        element: label2,\n        id: identifier(\"\".concat(id, \"-\").concat(item2.data.key, \"-label\")),\n        animated,\n        data: item2,\n        fill: textFill\n      })]\n    }, item2.data.key);\n  };\n  return /* @__PURE__ */jsx(Fragment, {\n    children: data.map(renderBubble)\n  });\n};\nBubbleSeries.defaultProps = {\n  colorScheme: \"cybertron\",\n  animated: true,\n  bubble: /* @__PURE__ */jsx(Bubble, {}),\n  label: /* @__PURE__ */jsx(BubbleLabel, {})\n};\nconst BubbleChart = _ref145 => {\n  let {\n    data,\n    id,\n    width,\n    height,\n    className,\n    containerClassName,\n    margins,\n    series\n  } = _ref145;\n  const getData = useCallback((cw, ch) => {\n    const bubble = pack().size([cw, ch]).padding(3);\n    const root = hierarchy({\n      children: data\n    }).sum(d => d.data).sort((a, b) => b.data - a.data);\n    return bubble(root).leaves();\n  }, [data]);\n  const renderChart = useCallback(_ref146 => {\n    let {\n      chartWidth,\n      chartHeight,\n      ...rest\n    } = _ref146;\n    const circles = getData(chartWidth, chartHeight);\n    return /* @__PURE__ */jsx(CloneElement, {\n      element: series,\n      id: \"\".concat(rest.id, \"-series\"),\n      data: circles\n    });\n  }, [series, getData]);\n  return /* @__PURE__ */jsx(ChartContainer, {\n    id,\n    width,\n    height,\n    containerClassName,\n    margins,\n    xAxisVisible: false,\n    yAxisVisible: false,\n    className,\n    children: renderChart\n  });\n};\nBubbleChart.defaultProps = {\n  data: [],\n  margins: 10,\n  series: /* @__PURE__ */jsx(BubbleSeries, {})\n};\nconst TreeMapLabel = _ref147 => {\n  let {\n    id,\n    data,\n    fill,\n    wrap,\n    placement,\n    fontSize,\n    fontFamily\n  } = _ref147;\n  const key = data.data.key;\n  const width = data.x1 - data.x0;\n  const text = wrapText({\n    key,\n    fontFamily,\n    fontSize,\n    paddingX: 10,\n    wrap,\n    paddingY: 10,\n    width,\n    height: data.y1 - data.y0\n  });\n  const size = calculateDimensions(typeof text === \"string\" ? text : key, fontFamily, fontSize);\n  const offsetX = placement === \"start\" ? 10 : placement === \"middle\" ? (width - size.width) / 2 : width - size.width - 10;\n  return /* @__PURE__ */jsx(\"g\", {\n    style: {\n      transform: \"translate(\".concat(offsetX, \"px, 15px)\")\n    },\n    children: /* @__PURE__ */jsx(\"text\", {\n      id: \"\".concat(id, \"-text\"),\n      style: {\n        pointerEvents: \"none\",\n        fontFamily,\n        fontSize\n      },\n      fill,\n      children: text\n    })\n  });\n};\nTreeMapLabel.defaultProps = {\n  fill: \"#FFF\",\n  wrap: true,\n  fontSize: 14,\n  fontFamily: \"sans-serif\",\n  placement: \"start\"\n};\nconst TreeMapRect = _ref148 => {\n  let {\n    data,\n    fill,\n    animated,\n    cursor,\n    tooltip: tooltip2,\n    onMouseEnter,\n    onMouseLeave,\n    onClick\n  } = _ref148;\n  const [internalActive, setInternalActive] = useState(false);\n  const rectRef = useRef(null);\n  const transition = animated ? DEFAULT_TRANSITION : {\n    type: false,\n    delay: 0\n  };\n  const currentFill = internalActive ? chroma(fill).darken(0.8).hex() : fill;\n  const {\n    pointerOut,\n    pointerOver\n  } = useHoverIntent({\n    onPointerOver: event => {\n      setInternalActive(true);\n      onMouseEnter == null ? void 0 : onMouseEnter(event, data);\n    },\n    onPointerOut: event => {\n      setInternalActive(false);\n      onMouseLeave == null ? void 0 : onMouseLeave(event, data);\n    }\n  });\n  const tooltipLabel2 = useMemo(() => {\n    const getKey = node2 => {\n      if (!node2.parent) {\n        return [];\n      }\n      return [...getKey(node2.parent), node2.data.key];\n    };\n    return getKey(data).join(\" → \");\n  }, [data]);\n  const tooltipData = useMemo(() => ({\n    y: data.value,\n    x: tooltipLabel2\n  }), [data, tooltipLabel2]);\n  const ariaLabelData = useMemo(() => getAriaLabel(tooltipData), [tooltipData]);\n  return /* @__PURE__ */jsxs(Fragment, {\n    children: [/* @__PURE__ */jsx(motion.rect, {\n      ref: rectRef,\n      initial: {\n        fill: currentFill,\n        width: data.x1 - data.x0,\n        height: data.y1 - data.y0\n      },\n      animate: {\n        fill: currentFill,\n        width: data.x1 - data.x0,\n        height: data.y1 - data.y0\n      },\n      style: {\n        cursor\n      },\n      transition,\n      onClick: event => {\n        onClick == null ? void 0 : onClick(event, data);\n      },\n      onPointerOver: pointerOver,\n      onPointerOut: pointerOut,\n      tabIndex: 0,\n      \"aria-label\": ariaLabelData,\n      role: \"graphics-document\"\n    }), tooltip2 && !tooltip2.props.disabled && /* @__PURE__ */jsx(CloneElement, {\n      element: tooltip2,\n      visible: !!internalActive,\n      reference: rectRef,\n      value: tooltipData\n    })]\n  });\n};\nTreeMapRect.defaultProps = {\n  cursor: \"pointer\",\n  tooltip: /* @__PURE__ */jsx(ChartTooltip, {})\n};\nconst TreeMapSeries = _ref149 => {\n  let {\n    id,\n    data,\n    colorScheme,\n    animated,\n    rect,\n    label: label2\n  } = _ref149;\n  const transition = animated ? DEFAULT_TRANSITION : {\n    type: false,\n    delay: 0\n  };\n  const renderItem = (item2, index) => {\n    const fill = getColor({\n      data,\n      colorScheme,\n      point: item2.data,\n      index\n    });\n    const textFill = fill ? invert(chroma(fill).darken(0.5).hex(), true) : \"white\";\n    return /* @__PURE__ */jsxs(motion.g, {\n      initial: {\n        scale: 0.5,\n        opacity: 0,\n        x: item2.x0,\n        y: item2.y0\n      },\n      animate: {\n        scale: 1,\n        opacity: 1,\n        x: item2.x0,\n        y: item2.y0\n      },\n      transition,\n      children: [/* @__PURE__ */jsx(CloneElement, {\n        element: rect,\n        id: \"\".concat(id, \"-\").concat(item2.data.key, \"-rect\"),\n        animated,\n        data: item2,\n        fill\n      }), /* @__PURE__ */jsx(CloneElement, {\n        element: label2,\n        id: \"\".concat(id, \"-\").concat(item2.data.key, \"-label\"),\n        data: item2,\n        fill: textFill\n      })]\n    }, item2.data.key);\n  };\n  return /* @__PURE__ */jsx(Fragment, {\n    children: data.map((d, index) => renderItem(d, index))\n  });\n};\nTreeMapSeries.defaultProps = {\n  colorScheme: \"cybertron\",\n  animated: true,\n  rect: /* @__PURE__ */jsx(TreeMapRect, {}),\n  label: /* @__PURE__ */jsx(TreeMapLabel, {})\n};\nconst TreeMap = _ref150 => {\n  let {\n    data,\n    id,\n    containerClassName,\n    paddingInner,\n    paddingTop,\n    paddingOuter,\n    width,\n    height,\n    className,\n    margins,\n    series\n  } = _ref150;\n  const getData = useCallback((cw, ch) => {\n    const root = hierarchy({\n      data\n    }, d => d.data).sum(d => d.data).sort((a, b) => b.data - a.data);\n    const t = treemap().size([cw, ch]).tile(treemapSquarify).round(true).paddingInner(paddingInner).paddingOuter(paddingOuter).paddingTop(paddingTop);\n    const tree = t(root);\n    const nodes = [];\n    const getAllNodes = node2 => {\n      if (node2 == null ? void 0 : node2.parent) {\n        nodes.push(node2);\n      }\n      for (let child of (node2 == null ? void 0 : node2.children) || []) {\n        getAllNodes(child);\n      }\n    };\n    getAllNodes(tree);\n    return nodes;\n  }, [data, paddingInner, paddingOuter, paddingTop]);\n  const renderChart = useCallback(_ref151 => {\n    let {\n      chartWidth,\n      chartHeight,\n      ...rest\n    } = _ref151;\n    const datas = getData(chartWidth, chartHeight);\n    return /* @__PURE__ */jsx(CloneElement, {\n      element: series,\n      ...rest,\n      id: \"\".concat(id || rest.id, \"-series\"),\n      data: datas\n    });\n  }, [series, getData, id]);\n  return /* @__PURE__ */jsx(ChartContainer, {\n    id,\n    width,\n    height,\n    containerClassName,\n    margins,\n    xAxisVisible: false,\n    yAxisVisible: false,\n    className,\n    children: renderChart\n  });\n};\nTreeMap.defaultProps = {\n  margins: 0,\n  paddingInner: 5,\n  paddingOuter: 5,\n  paddingTop: 30,\n  series: /* @__PURE__ */jsx(TreeMapSeries, {}),\n  data: []\n};\nconst item = \"_item_18e6r_1\";\nconst labelStart = \"_labelStart_18e6r_8\";\nconst valueEnd = \"_valueEnd_18e6r_9\";\nconst labelBottom = \"_labelBottom_18e6r_15\";\nconst labelNone = \"_labelNone_18e6r_24\";\nconst label = \"_label_18e6r_8\";\nconst labelEnd = \"_labelEnd_18e6r_35\";\nconst valueStart = \"_valueStart_18e6r_36\";\nconst labelTop = \"_labelTop_18e6r_42\";\nconst valueBottom = \"_valueBottom_18e6r_57\";\nconst valueNone = \"_valueNone_18e6r_65\";\nconst valueLabel = \"_valueLabel_18e6r_71\";\nconst clickable = \"_clickable_18e6r_77\";\nconst outerBar = \"_outerBar_18e6r_97\";\nconst bar = \"_bar_18e6r_105\";\nconst css$1 = {\n  item,\n  labelStart,\n  valueEnd,\n  labelBottom,\n  labelNone,\n  label,\n  labelEnd,\n  valueStart,\n  labelTop,\n  valueBottom,\n  valueNone,\n  valueLabel,\n  clickable,\n  outerBar,\n  bar\n};\nconst BarListSeries = _ref152 => {\n  let {\n    data,\n    colorScheme,\n    itemClassName,\n    labelClassName,\n    outerBarClassName,\n    valueClassName,\n    labelFormat,\n    barClassName,\n    labelPosition,\n    valuePosition,\n    valueFormat,\n    onItemClick,\n    onItemMouseEnter,\n    onItemMouseLeave\n  } = _ref152;\n  const renderBar = useCallback((item2, index) => {\n    const fill = getColor({\n      data,\n      colorScheme,\n      point: item2.data,\n      index\n    });\n    return /* @__PURE__ */jsx(\"div\", {\n      className: classNames(css$1.outerBar, outerBarClassName),\n      children: /* @__PURE__ */jsx(motion.div, {\n        transition: DEFAULT_TRANSITION,\n        className: classNames(css$1.bar, barClassName),\n        initial: {\n          width: \"0%\"\n        },\n        animate: {\n          width: \"\".concat(item2.data, \"%\")\n        },\n        style: {\n          background: fill\n        },\n        tabIndex: 0,\n        \"aria-label\": getAriaLabel(item2),\n        role: \"graphics-document\"\n      })\n    });\n  }, [barClassName, outerBarClassName, colorScheme, data]);\n  return /* @__PURE__ */jsx(Fragment$1, {\n    children: data.map((d, i) => {\n      const label2 = labelFormat ? labelFormat(d.key, i) : d.key;\n      const valueLabel2 = valueFormat ? valueFormat(d.metadata.value, i) : formatValue(d.metadata.value);\n      return /* @__PURE__ */jsxs(\"div\", {\n        role: \"listitem\",\n        className: classNames(css$1.item, itemClassName, {\n          [css$1.clickable]: onItemClick,\n          [css$1.valueBottom]: valuePosition === \"bottom\",\n          [css$1.valueStart]: valuePosition === \"start\",\n          [css$1.valueEnd]: valuePosition === \"end\",\n          [css$1.valueNone]: valuePosition === \"none\",\n          [css$1.labelBottom]: labelPosition === \"bottom\",\n          [css$1.labelTop]: labelPosition === \"top\",\n          [css$1.labelStart]: labelPosition === \"start\",\n          [css$1.labelEnd]: labelPosition === \"end\",\n          [css$1.labelNone]: labelPosition === \"none\"\n        }),\n        onMouseEnter: () => onItemMouseEnter == null ? void 0 : onItemMouseEnter(d),\n        onMouseLeave: () => onItemMouseLeave == null ? void 0 : onItemMouseLeave(d),\n        onClick: () => onItemClick == null ? void 0 : onItemClick(d),\n        children: [/* @__PURE__ */jsx(\"label\", {\n          title: label2,\n          className: classNames(css$1.label, labelClassName),\n          children: label2\n        }), renderBar(d, i), /* @__PURE__ */jsx(\"label\", {\n          title: valueLabel2,\n          className: classNames(css$1.valueLabel, valueClassName),\n          children: /* @__PURE__ */jsx(\"small\", {\n            children: valueLabel2\n          })\n        })]\n      }, d.key);\n    })\n  });\n};\nBarListSeries.defaultProps = {\n  colorScheme: \"cybertron\",\n  labelPosition: \"top\",\n  valuePosition: \"none\"\n};\nconst BarList = _ref153 => {\n  let {\n    data,\n    id,\n    className,\n    sortDirection,\n    style,\n    series,\n    type\n  } = _ref153;\n  const curId = useId(id);\n  const mashedData = useMemo(() => {\n    const maxVal = type === \"count\" ? max(data, d => d.data) : 100;\n    const domainVal = maxVal == 0 ? [0] : [0, maxVal];\n    const groupScale = scaleLinear().domain(domainVal).rangeRound([0, 100]);\n    const mashed = data.map(d => ({\n      ...d,\n      data: groupScale(d.data),\n      metadata: {\n        value: d.data,\n        percent: data.length * d.data / 100\n      }\n    }));\n    if (sortDirection === \"asc\") {\n      mashed.sort((a, b) => a.data - b.data);\n    } else if (sortDirection === \"desc\") {\n      mashed.sort((a, b) => b.data - a.data);\n    }\n    return mashed;\n  }, [data, sortDirection]);\n  return /* @__PURE__ */jsx(motion.section, {\n    role: \"list\",\n    variants: {\n      initial: {\n        transition: {\n          staggerChildren: 0.05,\n          staggerDirection: -1\n        }\n      },\n      animate: {\n        transition: {\n          staggerChildren: 0.07,\n          delayChildren: 0.2\n        }\n      }\n    },\n    id: curId,\n    className,\n    style,\n    children: /* @__PURE__ */jsx(CloneElement, {\n      element: series,\n      data: mashedData\n    })\n  });\n};\nBarList.defaultProps = {\n  data: [],\n  sortDirection: \"desc\",\n  series: /* @__PURE__ */jsx(BarListSeries, {}),\n  type: \"count\"\n};\nconst MeterColumn = _ref154 => {\n  let {\n    index,\n    scale: scale2,\n    value: value2,\n    count,\n    height,\n    className,\n    animated,\n    activeFill,\n    inActiveFill\n  } = _ref154;\n  const isActive = scale2(index) <= scale2(value2);\n  const fill = isActive ? activeFill : inActiveFill;\n  const transition = animated ? {\n    ...DEFAULT_TRANSITION,\n    delay: index / count * 0.5\n  } : {\n    type: false,\n    delay: 0\n  };\n  return /* @__PURE__ */jsx(motion.div, {\n    initial: {\n      background: inActiveFill,\n      height\n    },\n    animate: {\n      background: fill,\n      height\n    },\n    tranisition: transition,\n    className\n  }, index);\n};\nMeterColumn.defaultProps = {\n  activeFill: schemes.cybertron[0],\n  inActiveFill: \"#414242\",\n  height: 32,\n  animated: true\n};\nconst container = \"_container_13giw_1\";\nconst css = {\n  container\n};\nconst Meter = _ref155 => {\n  let {\n    min: min2,\n    max: max2,\n    className,\n    column,\n    gap,\n    style,\n    value: value2,\n    columns\n  } = _ref155;\n  const scale2 = scaleLinear().domain([min2, max2]).range([0, 100]);\n  const cols = scale2.ticks(columns);\n  return /* @__PURE__ */jsx(\"div\", {\n    className: classNames(css.container, className),\n    style: {\n      gap: \"\".concat(gap, \"px\"),\n      ...style\n    },\n    children: cols.map(index => /* @__PURE__ */jsx(CloneElement, {\n      element: column,\n      count: cols.length,\n      index,\n      scale: scale2,\n      value: value2\n    }, index))\n  });\n};\nMeter.defaultProps = {\n  min: 0,\n  max: 100,\n  columns: 10,\n  gap: 15,\n  style: {},\n  column: /* @__PURE__ */jsx(MeterColumn, {})\n};\nconst RadarChartSeries = props => /* @__PURE__ */jsx(RadialAreaSeries, {\n  ...props\n});\nRadarChartSeries.defaultProps = {\n  area: null,\n  type: \"grouped\",\n  symbols: /* @__PURE__ */jsx(RadialPointSeries, {\n    show: true\n  })\n};\nconst RadarChart = props => /* @__PURE__ */jsx(RadialAreaChart, {\n  ...props\n});\nRadarChart.defaultProps = {\n  series: /* @__PURE__ */jsx(RadarChartSeries, {}),\n  axis: /* @__PURE__ */jsx(RadialAxis, {\n    type: \"category\",\n    arcs: /* @__PURE__ */jsx(RadialAxisArcSeries, {\n      count: 5,\n      arc: null,\n      line: /* @__PURE__ */jsx(RadialAxisArcLine, {})\n    })\n  })\n};\nconst FunnelArc = _ref156 => {\n  let {\n    data,\n    id,\n    xScale,\n    opacity,\n    index,\n    variant,\n    yScale,\n    interpolation,\n    colorScheme,\n    gradient: gradient2,\n    glow,\n    tooltip: tooltip2\n  } = _ref156;\n  const internalData = [...data, data[data.length - 1]];\n  const areaGenerator = area().curve(interpolate(interpolation)).x((_d, i) => xScale(i)).y0(yScale(0)).y1(_ref157 => {\n    let {\n      data: data2\n    } = _ref157;\n    return yScale(data2);\n  });\n  const areaMirrorGenerator = area().curve(interpolate(interpolation)).x((_d, i) => xScale(i)).y0(yScale(0)).y1(_ref158 => {\n    let {\n      data: data2\n    } = _ref158;\n    return yScale(-data2);\n  });\n  const fillColor = getColor({\n    data,\n    domain: [0, 1, 2, 3],\n    colorScheme,\n    key: index\n  });\n  const fillTop = gradient2 ? \"url(#gradient-\".concat(id, \"-top)\") : fillColor;\n  const fillBottom = gradient2 ? \"url(#gradient-\".concat(id, \"-bottom)\") : fillColor;\n  const [height] = yScale.range();\n  const [_, width] = xScale.range();\n  const ariaLabelData = useMemo(() => getAriaLabel(data), [data]);\n  return /* @__PURE__ */jsx(CloneElement, {\n    element: tooltip2,\n    xScale,\n    yScale,\n    data,\n    height,\n    width,\n    tooltip: /* @__PURE__ */jsx(ChartTooltip, {\n      followCursor: true,\n      content: (data2, color) => {\n        const value2 = {\n          x: data2.key,\n          y: data2.data,\n          value: data2.data\n        };\n        return /* @__PURE__ */jsx(TooltipTemplate, {\n          value: value2,\n          color\n        });\n      }\n    }),\n    children: /* @__PURE__ */jsxs(\"g\", {\n      pointerEvents: tooltip2 ? \"none\" : \"auto\",\n      style: generateGlowStyles({\n        glow\n      }),\n      \"aria-label\": ariaLabelData,\n      role: \"graphics-document\",\n      children: [/* @__PURE__ */jsx(motion.path, {\n        d: areaGenerator(internalData),\n        fill: fillTop,\n        stroke: \"none\",\n        initial: {\n          opacity: 0\n        },\n        animate: {\n          opacity\n        }\n      }), /* @__PURE__ */jsx(motion.path, {\n        d: areaMirrorGenerator(internalData),\n        fill: fillBottom,\n        stroke: \"none\",\n        initial: {\n          opacity: 0\n        },\n        animate: {\n          opacity\n        }\n      }), gradient2 && /* @__PURE__ */jsxs(Fragment$1, {\n        children: [/* @__PURE__ */jsx(CloneElement, {\n          element: gradient2,\n          id: \"gradient-\".concat(id, \"-top\"),\n          color: fillColor\n        }), /* @__PURE__ */jsx(CloneElement, {\n          element: gradient2,\n          id: \"gradient-\".concat(id, \"-bottom\"),\n          color: fillColor\n        })]\n      })]\n    })\n  });\n};\nFunnelArc.defaultProps = {\n  gradient: /* @__PURE__ */jsx(Gradient, {\n    direction: \"horizontal\",\n    stops: [/* @__PURE__ */jsx(GradientStop, {\n      offset: \"0%\",\n      stopOpacity: 1\n    }, \"stop\"), /* @__PURE__ */jsx(GradientStop, {\n      offset: \"80%\",\n      stopOpacity: 0.5\n    }, \"start\")]\n  }),\n  interpolation: \"smooth\",\n  colorScheme: schemes.cybertron[0],\n  animated: true,\n  variant: \"default\",\n  opacity: 1,\n  tooltip: null\n};\nconst FunnelAxisLabel = _ref159 => {\n  let {\n    data,\n    index,\n    xScale,\n    yScale,\n    fontFamily,\n    padding,\n    fontSize,\n    fill,\n    className,\n    position,\n    showValue,\n    labelVisibility\n  } = _ref159;\n  const x = xScale(index) + padding;\n  const [height] = yScale.range();\n  const y = height / 2 + padding;\n  const label2 = data.key;\n  const nextOffset = xScale(index + 1);\n  const width = (nextOffset ? nextOffset - xScale(index) : 0) - padding;\n  const size = calculateDimensions(label2, fontFamily, fontSize);\n  const text = wrapText({\n    key: label2,\n    size,\n    paddingY: padding,\n    paddingX: padding,\n    width,\n    height,\n    fontFamily,\n    fontSize,\n    visibility: labelVisibility\n  });\n  const getTransformString = useCallback(() => {\n    let transform2;\n    switch (position) {\n      case \"top\":\n        transform2 = \"translate(\".concat(x, \", \").concat(fontSize * 3, \")\");\n        break;\n      case \"middle\":\n        transform2 = \"translate(\".concat(x, \", \").concat(y, \")\");\n        break;\n      case \"bottom\":\n        {\n          const textWrapHeight = Array.isArray(text) ? text.slice(1).reduce((acc, curr) => acc + curr.props.dy, 0) : 0;\n          transform2 = \"translate(\".concat(x, \", \").concat(height - padding - textWrapHeight, \")\");\n        }\n        break;\n    }\n    return transform2;\n  }, [position, x, fontSize, y, text, height, padding]);\n  if (labelVisibility !== \"always\" && size.width > width) {\n    return null;\n  }\n  return /* @__PURE__ */jsxs(motion.g, {\n    transform: getTransformString(),\n    initial: {\n      opacity: 0\n    },\n    animate: {\n      opacity: 1\n    },\n    children: [showValue && /* @__PURE__ */jsx(\"text\", {\n      pointerEvents: \"none\",\n      fill,\n      y: -(fontSize + padding),\n      className,\n      dominantBaseline: \"middle\",\n      fontFamily,\n      fontSize: fontSize * 2,\n      children: formatValue(data.data)\n    }), /* @__PURE__ */jsx(\"text\", {\n      pointerEvents: \"none\",\n      fill,\n      className,\n      dominantBaseline: \"middle\",\n      fontFamily,\n      fontSize,\n      children: text\n    })]\n  });\n};\nFunnelAxisLabel.defaultProps = {\n  fontSize: 13,\n  padding: 10,\n  fontFamily: \"sans-serif\",\n  fill: \"#fff\",\n  position: \"middle\",\n  showValue: true,\n  labelVisibility: \"auto\"\n};\nconst FunnelAxisLine = _ref160 => {\n  let {\n    strokeColor,\n    strokeWidth,\n    yScale,\n    xScale,\n    index\n  } = _ref160;\n  const [height] = yScale.range();\n  return /* @__PURE__ */jsx(\"line\", {\n    x1: xScale(index),\n    y1: 0,\n    x2: xScale(index),\n    y2: height,\n    stroke: strokeColor,\n    strokeWidth,\n    pointerEvents: \"none\"\n  });\n};\nFunnelAxisLine.defaultProps = {\n  strokeColor: \"#333\",\n  strokeWidth: 2\n};\nconst FunnelAxis = _ref161 => {\n  let {\n    data,\n    xScale,\n    yScale,\n    line: line2,\n    label: label2\n  } = _ref161;\n  const lines = range(0, data.length);\n  return /* @__PURE__ */jsx(Fragment$1, {\n    children: lines.map(index => /* @__PURE__ */jsxs(Fragment, {\n      children: [line2 && index !== 0 && /* @__PURE__ */jsx(CloneElement, {\n        element: line2,\n        index,\n        xScale,\n        yScale\n      }), label2 && /* @__PURE__ */jsx(CloneElement, {\n        element: label2,\n        index,\n        data: data[index],\n        xScale,\n        yScale\n      })]\n    }, index))\n  });\n};\nFunnelAxis.defaultProps = {\n  label: /* @__PURE__ */jsx(FunnelAxisLabel, {}),\n  line: /* @__PURE__ */jsx(FunnelAxisLine, {})\n};\nconst FunnelSeries = _ref162 => {\n  let {\n    data,\n    id,\n    arc: arc2,\n    axis,\n    height,\n    width,\n    onSegmentClick\n  } = _ref162;\n  const getScales = useCallback((height2, width2) => {\n    const yScale = scaleLinear().domain([-max(data, _ref163 => {\n      let {\n        data: data2\n      } = _ref163;\n      return data2;\n    }), max(data, _ref164 => {\n      let {\n        data: data2\n      } = _ref164;\n      return data2;\n    })]).nice().range([height2, 0]);\n    const xScale = scaleLinear().domain([0, data.length]).range([0, width2]);\n    const transformedData = data.map((d, i) => ({\n      ...d,\n      key: d.key,\n      x: xScale(i),\n      i\n    }));\n    return {\n      data: transformedData,\n      yScale,\n      xScale\n    };\n  }, [data]);\n  const {\n    datas,\n    halfOffset\n  } = useMemo(() => {\n    if (arc2.props.variant === \"layered\") {\n      const offset = height / 4;\n      const halfOffset2 = offset / 2;\n      return {\n        halfOffset: halfOffset2,\n        datas: [{\n          data,\n          ...getScales(height, width)\n        }, {\n          data,\n          ...getScales(height - offset, width)\n        }, {\n          data,\n          ...getScales(height - offset * 2, width)\n        }]\n      };\n    } else {\n      return {\n        halfOffset: 0,\n        datas: [{\n          data,\n          ...getScales(height, width)\n        }]\n      };\n    }\n  }, [data, arc2, height, width, getScales]);\n  const handleSegmentClick = useCallback(e => {\n    if (onSegmentClick) {\n      const {\n        xScale,\n        data: data2\n      } = datas[0];\n      const {\n        clientX,\n        clientY,\n        target\n      } = e;\n      const position = getPositionForTarget({\n        target,\n        clientX,\n        clientY\n      });\n      const value2 = getClosestContinousScalePoint({\n        pos: position.x,\n        scale: xScale,\n        data: data2,\n        attr: \"i\"\n      });\n      onSegmentClick({\n        value: {\n          key: value2.key,\n          data: value2.data\n        },\n        nativeEvent: e\n      });\n    }\n  }, [datas, onSegmentClick]);\n  return /* @__PURE__ */jsxs(Fragment$1, {\n    children: [datas.map((d, i) => /* @__PURE__ */jsx(\"g\", {\n      style: {\n        transform: \"translate(0, \".concat(i * halfOffset, \"px)\")\n      },\n      onClick: handleSegmentClick,\n      children: /* @__PURE__ */jsx(CloneElement, {\n        element: arc2,\n        ...d,\n        id: \"\".concat(id, \"-arc-\").concat(i),\n        index: i\n      })\n    }, i)), /* @__PURE__ */jsx(CloneElement, {\n      element: axis,\n      data,\n      xScale: datas[0].xScale,\n      yScale: datas[0].yScale\n    })]\n  });\n};\nFunnelSeries.defaultProps = {\n  arc: /* @__PURE__ */jsx(FunnelArc, {}),\n  axis: /* @__PURE__ */jsx(FunnelAxis, {})\n};\nconst FunnelChart = _ref165 => {\n  let {\n    data,\n    width,\n    margins,\n    height,\n    className,\n    containerClassName,\n    series,\n    ...rest\n  } = _ref165;\n  const id = useId(rest.id);\n  const renderChart = useCallback(_ref166 => {\n    let {\n      id: id2,\n      chartWidth,\n      chartHeight,\n      chartSized\n    } = _ref166;\n    if (!chartSized) {\n      return null;\n    }\n    return /* @__PURE__ */jsx(CloneElement, {\n      element: series,\n      id: \"funnel-series-\".concat(id2),\n      data,\n      height: chartHeight,\n      width: chartWidth\n    });\n  }, [data, series]);\n  return /* @__PURE__ */jsx(ChartContainer, {\n    id,\n    width,\n    height,\n    margins,\n    containerClassName,\n    className,\n    children: renderChart\n  });\n};\nFunnelChart.defaultProps = {\n  margins: 0,\n  series: /* @__PURE__ */jsx(FunnelSeries, {})\n};\nexport { Area, AreaChart, AreaSeries, AreaSparklineChart, Bar, BarChart, BarLabel, BarList, BarListSeries, BarSeries, BarSparklineChart, Brush, BrushHandle, BrushSlice, Bubble, BubbleChart, BubbleLabel, BubbleSeries, COUNT_DEFAULTS, CalendarHeatmap, ChartBrush, ChartConsumer, ChartContainer, ChartContext, ChartProvider, ChartTooltip, ChartZoomPan, Count, DEFAULT_TRANSITION, DiscreteLegend, DiscreteLegendEntry, DiscreteLegendSymbol, FunnelArc, FunnelAxis, FunnelAxisLabel, FunnelAxisLine, FunnelChart, FunnelSeries, Gradient, GradientStop, GridStripe, Gridline, GridlineSeries, GuideBar, Heatmap, HeatmapCell, HeatmapSeries, HistogramBarChart, HistogramBarSeries, Line, LineChart, LineSeries, LinearAxis, LinearAxisLine, LinearAxisTickLabel, LinearAxisTickLine, LinearAxisTickSeries, LinearGauge, LinearGaugeBar, LinearGaugeOuterBar, LinearGaugeSeries, LinearValueMarker, LinearXAxis, LinearXAxisTickLabel, LinearXAxisTickLine, LinearXAxisTickSeries, LinearYAxis, LinearYAxisTickLabel, LinearYAxisTickLine, LinearYAxisTickSeries, Map$1 as Map, MapMarker, MarimekkoBarSeries, MarimekkoChart, MarkLine, Mask, Meter, MeterColumn, MotionPath, Move, Pan, PieArc, PieArcLabel, PieArcSeries, PieChart, PointSeries, RadarChart, RadarChartSeries, RadialArea, RadialAreaChart, RadialAreaSeries, RadialAxis, RadialAxisArc, RadialAxisArcLine, RadialAxisArcSeries, RadialAxisTick, RadialAxisTickLabel, RadialAxisTickLine, RadialAxisTickSeries, RadialBar, RadialBarChart, RadialBarSeries, RadialGauge, RadialGaugeArc, RadialGaugeLabel, RadialGaugeOuterArc, RadialGaugeSeries, RadialGaugeStackedArc, RadialGaugeValueLabel, RadialGradient, RadialGuideBar, RadialLine, RadialPointSeries, RadialScatterPlot, RadialScatterPoint, RadialScatterSeries, RadialValueMarker, RangeLines, Sankey, SankeyLabel, SankeyLink, SankeyNode, ScatterPlot, ScatterPoint, ScatterSeries, SequentialLegend, SonarChart, SparklineChart, StackedAreaChart, StackedAreaSeries, StackedBarChart, StackedBarSeries, StackedNormalizedAreaChart, StackedNormalizedAreaSeries, StackedNormalizedBarChart, StackedNormalizedBarSeries, StackedRadialGaugeDescriptionLabel, StackedRadialGaugeSeries, StackedRadialGaugeValueLabel, Stripes, TooltipArea, TooltipTemplate, TreeMap, TreeMapLabel, TreeMapRect, TreeMapSeries, VennArc, VennDiagram, VennLabel, VennOuterLabel, VennSeries, Zoom, ZoomPan, addWeeksToDate, bigIntegerToLocaleString, buildBarStackData, buildBins, buildDataScales, buildMarimekkoData, buildNestedChartData, buildShallowChartData, buildStackData, buildWaterfall, calculateDimensions, calculateShowStroke, constrainMatrix, constructFunctionProps, createColorSchemeValueScales, extent, formatValue, functionProps, getAriaLabel, getClosestBandScalePoint, getClosestContinousScalePoint, getColor, getColorSchemeStyles, getDegrees, getDimension, getDurationTicks, getGroupScale, getInnerScale, getLimitMatrix, getMarimekkoGroupScale, getMarimekkoScale, getMaxBigIntegerForNested, getMaxBigIntegerForShallow, getMaxTicks, getParentSVG, getPointFromMatrix, getPositionForTarget, getRadialYScale, getTicks, getXDomain, getXScale, getYDomain, getYScale, humanFormatBigInteger, interpolate, isAxisVisible, isZoomLevelGoingOutOfBounds, normalizeValue, normalizeValueForFormatting, reduceTicks, schemes, toggleTextSelection, tooltipTheme, uniqueBy, useChart, useCount, weekDays, wrapText };","map":{"version":3,"names":["useDimensions","bigInt","chroma","isEqual","useMotionValue","useSpring","motion","animate","interpolate","interpolate$1","identifier","geoNaturalEarth1","geoMercator","geoPath","sankey","sankeyJustify","sankeyCenter","sankeyLeft","sankeyRight","sankeyLinkHorizontal","layout","invert","pack","hierarchy","treemap","treemapSquarify","LinearAxisLine","_ref","strokeColor","strokeWidth","strokeGradient","scale","scale2","orientation","className","id","useId","range0","range1","range","jsxs","Fragment","children","jsx","x1","x2","y1","y2","stroke","concat","CloneElement","element","defaultProps","LinearAxis","props","position","tickSeries","axisLine","height","width","visibility","onDimensionsChange","containerRef","createRef","dimensions","setDimensions","useState","updateDimensions","useCallback","shouldOffset","height2","width2","dims","current","getBoundingClientRect","Math","floor","useEffect","getPosition","translateY2","translateX2","translateX","translateY","transform","ref","line","label","axis","scaled","roundDomains","LinearAxisTickLabel","_ref2","text","fullText","angle","half","line2","textAnchor","fill","fontSize","fontFamily","rotation","padding","formatTooltip","align","getAlign","getTickLineSpacing","_line2$props$size","_line2$props$position","size","position2","getOffset","adjustedPadding","fromAxis","alongAxis","spacing","offset1","align2","offset2","horz","getTextPosition","transform2","newtextAnchor","alignmentBaseline","x","y","textPosition","titleHover","LinearAxisTickLine","_ref3","path2","useMemo","isVertical","tickSize","start2","end2","getNavigatorLanguage","window","navigator","languages","length","userLanguage","language","browserLanguage","locale","options","month","day","hour12","formatMatcher","formatValue","value2","Date","toLocaleDateString","toLocaleString","getAriaLabel","datapoint","isArray","Array","map","row","join","key","data","ONE_DAY","DURATION_TICK_STEPS","reduceTicks","ticks","maxTicks","reduced","modulus","i","push","getMaxTicks","dimension","tickWidth","max","getDurationTicks","domain","domainWidth","tickStep","s","numDayTicks","dayStep","ceil","getTicks","tickValues","type","arguments","undefined","interval","result","cache","calculateDimensions","document","parseInt","toString","dimensions2","createElement","style","left","whiteSpace","fontWeight","lineHeight","wordBreak","textContent","body","appendChild","offsetHeight","offsetWidth","removeChild","LinearAxisTickSeries","_ref4","label2","getAdjustedScale","bandwidth","offset","round","d","scaledTick","getDimension2","labelFormatFn","format","tickFormat","apply","v","ticks2","adjustedScale","midpoint","tick","ellipsize","labelProps","maxTicksLength","angle2","baseWidth","maxBaseWidth","cos","PI","LinearXAxisTickLabel","LinearXAxisTickLine","LinearXAxisTickSeries","LinearXAxis","LinearYAxisTickLabel","LinearYAxisTickLine","LinearYAxisTickSeries","LinearYAxis","isAxisVisible","RadialAxisTickLine","_ref5","innerRadius","outerRadius","pointerEvents","rad2deg","RadialAxisTickLabel","_ref6","point","point2","autoRotate","lineSize","index","rest","textAnchor2","transform22","shouldRotate","rotate","translate2","dy","startAngle","endAngle","RadialAxisTick","_ref7","RadialAxisTickSeries","_ref8","count","tickElement","RadialAxisArc","_ref9","strokeDasharray","_a","_b","_c","_d","r","strokeDash","isFullCircle","abs","arc","REGEX","matches","match","split","Fragment$1","cx","cy","getPointsForLevels","_ref10","arcs","levels","polyangle","level","hyp","points","vertex","theta","sin","RadialAxisArcSeries","_ref11","arc2","scaleLinear","RadialAxisArcLine","_ref12","lineGenerator","line$1","d2","humanFormatScale","humanFormat","Scale","k","M","B","humanFormatMillionScale","T","ONE_MILLION","ONE_BILLION","humanFormatBigInteger","bigInteger","greater","divide","toJSNumber","bigIntegerToLocaleString","formattedString","c","reverse","parseMargins","margins","top","right","bottom","calculateMarginOffsets","newHeight","newWidth","getDimension","_ref13","xOffset","yOffset","parsedMargins","marginDims","chartWidth","chartHeight","xMargin","yMargin","extent","attr","accessor","val","fn","vv","minVal","min","maxVal","getYDomain","_ref14","isDiverging","startY","endY","startY1","endY1","posStart","maxNum","getXDomain","_ref15","startX0","endX1","curveMonotoneX","curveStep","curveLinear","scaleBandInvert","paddingOuter","eachBand","step","band","getClosestContinousScalePoint","_ref16","pos","roundDown","bisect","bisector","minIndex","before","maxIndex2","after","beforeVal","afterVal","getClosestBandScalePoint","_ref17","roundClosest","prop","mariemkoInvert","idx","indexOf","getParentSVG","event","node2","target","ownerSVGElement","getPositionForTarget","_ref18","clientX","clientY","rect","clientLeft","clientTop","getPointFromMatrix","matrix","parent","applyToPoint","inverse","getLimitMatrix","applyToPoints","constrainMatrix","min2","max2","lessThanScaleFactorMin","scaleFactor","scaleFactorMin","moreThanScaleFactorMax","scaleFactorMax","isZoomLevelGoingOutOfBounds","a","b","toggleTextSelection","allowSelection","forEach","calculateShowStroke","showLine","prev","cur","next","getDegrees","radians","functionProps","classNames","constructFunctionProps","uniqueBy","_len","accessors","_key","ittr","arr","depth","acc","Error","includes","wrapText","_ref19","paddingY","wrap","paddingX","words","rows","maxWidth","maxHeight","curText","currWidth","nextText","nextWidth","word","dominantBaseline","baselineShift","RadialAxis","_ref20","xScale","Move","started","deltaX","deltaY","prevXPosition","prevYPosition","rqf","useRef","cancelAnimationFrame","disposeHandlers","removeEventListener","onMouseMove","onMouseUp","onTouchMove","onTouchEnd","setCursor","disableText","shouldDisable","set","cursor","checkThreshold","threshold","getTouchCoords","touches","onMouseDown","preventRightClick","disabled","shouldCancel","nativeEvent","which","preventDefault","stopPropagation","addEventListener","movementX","movementY","localDeltaX","localDeltaY","onMoveStart","requestAnimationFrame","onMove","onMoveEnd","onMoveCancel","onTouchStart","Children","child","cloneElement","e","handle","dragging","dot","css$s","BrushHandle","onHandleDrag","isDragging","setIsDragging","_ref21","slice","unsliced","css$r","BrushSlice","start","end","onBrushChange","sliceWidth","endSliceWidth","hasNoSlice","hasNoSlice2","_ref22","startUpdated","endUpdated","direction","opacity","Brush","startProp","endProp","isSlicing","setIsSlicing","initial","setInitial","range2","setRange","ensurePositionInBounds","newStart","newEnd","getPositionsForPanEvent","eventObj","getStartEnd","positions","start22","end22","onSliceChange","state","bind","ChartBrush","getBrushOffset","onBrushChangeHandler","domain2","context","useContext","ChartContext","container$3","svg","css$q","container","ChartContainer","_ref23","center","centerX","centerY","containerClassName","xAxisVisible","yAxisVisible","curId","xAxisSized","setXAxisSized","yAxisSized","setYAxisSized","setXOffset","setYOffset","observe","chartSized","onUpdateAxes","childProps","updateAxes","styleHeight","styleWidth","ChartProvider","value","tabIndex","normalizeValue","maxBigInt","isInstance","divideBy","normalizeValueForFormatting","getMaxBigIntegerForNested","series","maxBigInteger","one","group","maxBigIntegerForGroup","getMaxBigIntegerForShallow","buildNestedChartData","sort","nestedPoint","findIndex","getTime","metadata","x0","y0","aMax","median","bMax","addToChartType","add","valueOf","buildShallowChartData","binSize","isTuple","k1","k0","v0","v1","xProp","yProp","buildBins","thresholds","layout2","histogram","bins","bin","transformDataToStack$1","category","formattedValues","transformStackToData$1","stackData","categoryKey","buildBarStackData","keys","stackFn","stack","stackOffsetExpand","stackOffsetDiverging","buildMarimekkoData","sums","totalSum","sum","reduce","transformDataToStack","transformStackToData","buildStackData","normalized","buildWaterfall","cumulative","Pan","Component","constructor","childRef","globalPanning","classList","contains","onPanStart","pan","onPanEnd","onPanCancel","source","contrained","componentDidMount","passive","componentWillUnmount","onPanMove","constrain","newMatrix","smoothMatrix","translate","shouldConstrain","f","render","getMidpoint","pointA","pointB","getDistanceBetweenPoints","sqrt","pow","getTouchPoints","touch","distance","Zoom","onMouseWheel","disableMouseWheel","requireZoomModifier","onZoomEnd","hasModifier","metaKey","ctrlKey","getStep","clearTimeout","timeout","setTimeout","firstTouch","lastDistance","distanceFactor","outside","delta","minZoom","maxZoom","onZoom","container$2","horizontal$2","vertical$2","css$p","horizontal","vertical","DiscreteLegend","_ref24","entries","entry2","symbol","css$o","entry","vertical$1","label$3","horizontal$1","css$n","DiscreteLegendEntry","_ref26","symbol2","title","color","onMouseEnter","onMouseLeave","onClick","gradient","css$m","container$1","SequentialLegend","_ref27","gradientClassName","colorScheme","colors","extent$1","gradientDir","background","gridLine","css$l","Gridline","_ref28","coords","GridlineSeries","_ref29","stripe","yScale","yAxis","xAxis","shouldRenderY","shouldRenderX","yAxisGrid","xAxisGrid","renderGroup","grid","renderSeries","yAxisGrid2","xAxisGrid2","gridStripe","css$k","GridStripe","_ref30","stripeFill","dim","markLine","css$j","MarkLine","_ref31","pointX","vectorEffect","GradientStop","_ref32","stopOpacity","stopColor","Gradient","_ref33","stops","stop","spreadMethod","RadialGradient","_ref34","radius","gradientUnits","label$2","subValue","subValueColor","subValueName","css$i","TooltipTemplate","_ref37","renderValues","backgroundColor","renderMultiple","value22","excessCount","pagedValues","isMultiple","base","disablePointer","css$h","tooltipTheme","ChartTooltip","_ref38","content","Tooltip","theme","TooltipArea","forwardRef","_ref39","inverse2","tooltip","tooltip2","isRadial","isContinous","onValueEnter","isHorizontal","placement","placementProp","onValueLeave","visible","setVisible","setPlacement","setValue","offsetX","setOffsetX","offsetY","setOffsetY","prevX","setPrevX","prevY","setPrevY","fullCircleref","rotationFactor","getXCoord","outerRadiusNew","rad","atan2","transformData","seriesPoint","data2","shallowPoint","transformed","newPlacement","keyScale","valueScale","coord","newValue","pointY","marginX","marginY","isNaN","target2","offsetX2","offsetY2","outerRadius2","useImperativeHandle","triggerMouseMove","tooltipReference","renderRadial","innerRadiusNew","fullCircle","renderLinear","modifiers","reference","ZoomPan","_ref40","pannable","zoomable","zoomStep","onZoomPan","zoomRef","panRef","isZooming","setIsZooming","isPanning","setIsPanning","setMatrix","identity","fromDefinition","tx","ty","sx","sy","onPanStartHandler","onPanMoveHandler","onPanEndHandler","onZoomHandler","onZoomEndHandler","selection","matrixObj","fromObject","userSelect","getXScale","_ref41","isMultiSeries","scaleTime","rangeRound","scaleBand","nice","getYScale","_ref42","getMarimekkoScale","getMarimekkoGroupScale","_ref43","barCount","widthMinusPadding","xMultiplier","getXRange","arg","found","getGroupScale","_ref44","paddingInner","getInnerScale","_ref45","groupScale","getRadialYScale","Object","assign","ChartZoomPan","_ref46","axisType","onZoomPanHandler","can","newScale","copy","clamp","isZoomed","zoomOffset","zoomOffset2","endOffset","DEFAULT_TRANSITION","velocity","damping","restDelta","restSpeed","MotionPath","_ref47","custom","transition","exit","spring","interpolator","get","enter","prevSpring","on","enterD","enterRest","exitD","exitRest","path","schemes","cybertron","correctLightness","brewer","isColorSchemeStyleArray","rangeHelper","attribute","getColor","active","scaleOrdinal","maxIdx","maxIndex","getValueScale","emptyColor","selections","valueDomain","scaleQuantile","getColorSchemeStyles","valueScales","from","_ref48","getColorSchemeForProperty","colorSchemeProperty","schemeItem","createColorSchemeValueScales","Map","colorSchemeProperties","Set","flatMap","COUNT_DEFAULTS","duration","delay","decimalPlaces","useCount","_ref49","to","prefix","suffix","nodeRef","controls","onUpdate","formatted","Number","toFixed","Count","_ref50","localize","LinearValueMarker","_ref51","thickness","coordinates","RadialValueMarker","_ref52","inactive$1","hidden$1","css$g","inactive","hidden","generateGlowStyles","_ref53","glow","colorSchemeColor","blur","alpha","css","filter","ScatterPoint","_ref54","animated","rectRef","tooltipVisible","setTooltipVisible","extras","renderedSymbol","transitionProps","enterProps","exitProps","yStartDomain","ariaLabelData","isVisible","role","g","circle","PADDING$1","HALF_PADDING$1","ScatterSeries","_ref55","activeIds","valueMarkers","renderPoint","pointData","pointId","renderValueMarkers","marker2","clipPath","scatterPlot","css$f","ScatterPlot","_ref56","gridlines","brush","zoomPan","secondaryAxis","zoomControlled","hasOwnProperty","preventAnimation","setPreventAnimation","zoomDomain","setZoomDomain","setIsZoomed","aggregatedData","getScales","renderChart","_ref57","id2","disableBrush","css$e","PointSeries","_ref58","activeValues","show","getIsVisible","point22","isActive","Area","_ref59","gradient2","mask","total","interpolation","item2","getAreaPath","area","curve","areaPath","maxY","coords2","renderArea","maskPath","Mask","Line","_ref60","hasArea","showZeroStroke","pathLength","setPathLength","ghostPathRef","getTotalLength","getLinePath","defined","linePath","strokeDashoffset","newCoords","strokeFill","PADDING","HALF_PADDING","AreaSeries","_ref61","markLine2","symbols","area2","setActiveValues","setActivePoint","isMulti","getPointColor","renderSymbols","activeSymbols","isAnimated","renderMarkLine","activePoint","renderSingleSeries","renderMultiSeries","StackedNormalizedAreaSeries","_ref62","StackedAreaSeries","_ref63","areaChart","css$d","AreaChart","_ref64","zoom","timeoutRef","seriesType","zoom2","_ref65","StackedAreaChart","StackedNormalizedAreaChart","Bar","_ref66","activeBrightness","barIndex","groupIndex","minHeight","rangeLines","rx","ry","isCategorical","guide","xScale1","internalActive","setInternalActive","calculateLinearScalePadding","scale22","totalSize","sizeMinusPadding","multiplier","getExit","_ref67","newX","newY","getKeyCoords","sizeOverride","isCategorical2","padding2","calc","c0","c1","getValueCoords","minSize","getCoords","newYScale","newXScale","xCoords","yCoords","onMouseEnterInternal","onMouseLeaveInternal","onMouseClick","getFill","color2","tooltipData","xAttr","getTransition","index2","renderBar","currentColorShade2","initialExit","attrX","attrY","animate2","renderGuideBar","console","error","attrStart","endPoint","startPoint","currentColorShade","brighten","hex","rangeLineColor","rangeLineColorShade","barLabel","BarSeries","_ref68","bar","bar2","getTransform","xPos","yPos","getBarColor","barElements","renderBarGroup","barData","groupData","groupPadding","followCursor","RangeLines","_ref69","rangeLineHeight","isTop","minX","delay2","StackedBarSeries","StackedNormalizedBarSeries","MarimekkoBarSeries","BarLabel","_ref70","HistogramBarSeries","_ref71","GuideBar","_ref72","other","barChart","stackedNormalized","stacked","marimekko","css$c","BarChart","_ref73","keyAxis","getMarimekkoGroupScales","getMultiGroupScales","getKeyScale","getValueScale2","getScalesAndData","isMarimekko","isGrouped","isStacked","distroType","containerProps","MarimekkoChart","StackedBarChart","StackedNormalizedBarChart","HistogramBarChart","LineSeries","LineChart","Map$1","_ref74","markers","projection","getProjection","_ref75","fitSize","renderMarker","projection2","warn","renderCountry","geoProjection","features","marker","css$b","modifiers$1","MapMarker","_ref76","setActive","useInterpolate$1","_ref77","prevData","newData","useHoverIntent","_ref78","sensitivity","onPointerOver","onPointerOut","mouseOver","timer","px","py","comparePosition","cleanup","pointerOver","pointerOut","PieArc","_ref79","arcRef","internalFill","findBreakPoint","_ref80","_ref81","startX","endX","breakPoint","breakPointCondition","sign","minScale","maxScale","getTextAnchor","_ref82","PieArcLabel","_ref83","centroid","lineStroke","fontFill","posX","posY","minRadius","innerPoint","shapeRendering","factor","midAngle","labelVisible","shouldDisplayLabel","displayAllLabels","arcData","calculateOuterRadius","explode","calculateCentroid","newOuter","calculateRadius","arcWidth","doughnut","minDimension","labelWidth","outerArcRadius","calculateInnerArc","cornerRadius","padAngle","padRadius","calculateLabelPositions","minDistance","outerArc","aPosX","aPosY","j","bPosX","bPosY","overlap","PieArcSeries","_ref84","innerArc","renderItem","safeKey","PieChart","_ref85","newId","internalData","pieLayout","pie","_ref86","DEFAULT_COLOR","LABEL_PADDING_PERCENT","JUSTIFICATION","justify","Sankey","_ref87","links","justification","nodeWidth","nodePadding","labelPosition","nodeSort","nodes","activeNodes","setActiveNodes","activeLinks","setActiveLinks","getNodeColor","onNodeActive","activeNodes2","activeLinks2","sourceLinks","sourceLink","sourceLinkTarget","targetLinks","targetLink","targetLinkSource","onLinkActive","link2","onInactive","nodeMap","nodeMap2","renderNode","computedNode","some","node22","labelPadding","renderLink","computedLink","chartId","getNodesAndLinks","sankeyChart","nodeAlign","nodeId","nodesCopy","linksCopy","sankeyNodes","sankeyLinks","_ref88","nodePosition","label$1","css$a","LABEL_PADDING","LABEL_TRUNCATE_LENGTH","SankeyLabel","_ref89","node","ellipsis","paddedWidth","showRightSide","truncatedTitle","avaialableWidth","link","tooltip$1","tooltipLabel$1","tooltipValue$1","css$9","tooltipLabel","tooltipValue","SankeyLink","_ref90","linkSource","linkTarget","hovered","setHovered","linkRef","getLink","renderTooltipContent","strokeOpacity","css$8","SankeyNode","_ref91","nodeHeight","fillOpacity","SparklineChart","AreaSparklineChart","Stripes","BarSparklineChart","SonarChart","RadialArea","_ref92","isClosedCurve","getPath","curveCardinalClosed","curveCardinal","curveLinearClosed","radialFn","radialArea","dd","_","yStart","RadialLine","_ref93","preData","radialLine","RadialScatterPlot","_ref94","outer","inner","xDomain","yDomain","css$7","RadialScatterPoint","_ref95","getTranslate","parseFloat","sizeVal","exitTransform","RadialScatterSeries","_ref96","internalActiveIds","setInternalActiveIds","_ref97","dataId","pointVisible","RadialPointSeries","_ref98","RadialAreaSeries","_ref99","getColorForPoint","RadialAreaChart","_ref100","getXScale2","scalePoint","innerRadius2","pi","tau","epsilon","tauEpsilon","append","strings","n","appendRound","digits","Path","_x0","_y0","_x1","_y1","_append","moveTo","_templateObject","_taggedTemplateLiteral","closePath","_templateObject2","lineTo","_templateObject3","quadraticCurveTo","_templateObject4","bezierCurveTo","_templateObject5","arcTo","x21","y21","x01","y01","l01_2","_templateObject6","_templateObject7","x20","y20","l21_2","l20_2","l21","l01","l","tan","acos","t01","t21","_templateObject8","_templateObject9","a0","a1","ccw","dx","cw","da","_templateObject10","_templateObject11","_templateObject12","_templateObject13","w","h","_templateObject14","prototype","MotionBar","_ref101","currentYRef","timeoutId","unsubscribe","onChange","RadialGuideBar","_ref102","variants","RadialBar","_ref103","curved","innerBarCount","previousEnter","getArc","arcFn","xScaleDomain","xScaleRange","xScaleBandwidth","rotateMid","innerAngleDistance","arcLength","outerAngleDistance","halfAngleDistanceDelta","innerDiff","innerStart","innerEnd","outerDiff","halfAngleDiffDistanceDelta","pathFn","fill2","yEnd","guidePath","RadialBarSeries","_ref104","RadialBarChart","_ref105","_ref106","RadialGaugeArc","_ref107","arcGenerator","arcElement","valueLabel$2","css$6","valueLabel","RadialGaugeLabel","_ref108","valueLabel$1","css$5","RadialGaugeValueLabel","_ref109","RadialGaugeOuterArc","RadialGaugeSeries","_ref110","valueLabel2","minGaugeWidth","columns","columns2","xScale2","yScale2","renderGauge","dataEndAngle","labelOffset","RadialGaugeStackedArc","_ref111","restProps","stackedArcs","prevEndAngle","renderArc","startArcAngle","endArcAngle","stackedValueLabel","css$4","StackedRadialGaugeValueLabel","_ref112","isChartNestedData","StackedRadialGaugeSeries","_ref113","stackedInnerArc","descriptionLabel","fillFactor","arcPadding","rAxis","renderOuterArc","renderInnerArc","renderStackedArc","_ref114","_ref115","renderStackedGauges","_ref116","_ref117","call","stackedDescriptionLabel","css$3","StackedRadialGaugeDescriptionLabel","_ref118","RadialGauge","_ref119","minValue","maxValue","_ref120","_ref121","_ref122","_ref123","_ref124","cell","css$2","HeatmapCell","_ref125","cellIndex","cellCount","isTransparent","appliedStroke","HeatmapSeries","_ref126","cellElement","renderCell","_ref127","cell2","rowIndex","cellCount2","Heatmap","_ref128","getScalesData","nestedData","scalesData","getFirstOfMonth","date","getFullYear","getMonth","addWeeksToDate","weeks","setDate","getDate","getStartOfDay","setHours","getNewDayFromDay","num","weekDays","base2","UTC","name","weekday","buildDataScales","rawData","view","startDate","endDomain","xDomainRange","dates","firstDayOfStart","getDay","curDate","week","_ref129","dayValue","find","xAxisLabelFormat","CalendarHeatmap","_ref130","domainData","xTickValues","yAxisLabelFormat","LinearGaugeBar","LinearGaugeOuterBar","_ref131","LinearGaugeSeries","_ref132","outerBar","outerBar2","LinearGauge","_ref133","transformedData","minValue2","maxValue2","_ref134","useInterpolate","_ref135","stiffness","VennArc","_ref136","inactiveStyle","activeStyle","initialStyle","currentStyle","arcFill","sets","VennLabel","_ref137","labelType","showAll","_e","large","circles","VennOuterLabel","_ref138","isElement","isValidElement","showIcon","icon","verticalAlign","VennSeries","_ref139","actives","setActives","onActivate","textFill","darken","isSelected","isHovered","getStrokeColor","arcStroke","outerLabel","topArcs","xlinkHref","bb","venn5","intersections","shapes","venn0","venn1","venn2","venn3","venn4","upto","limit","isEllipse","combinations","array","_e1","_e2","lookup","combo","buildData","uniqueSets","uniqueSetKeys","u","sets2","filteredSets","diff","keyedData","sets22","uniqueCount","generateArcSlicePath","refs","rot","sweep","buildLayout","_ref140","box","shape","mx","my","shapeSets","intersections2","starEulerLayout","bb2","VennDiagram","_ref141","layoutData","distinct","Bubble","_ref142","bubbleRef","BubbleLabel","_ref143","BubbleSeries","_ref144","bubble","renderBubble","BubbleChart","_ref145","getData","ch","root","leaves","_ref146","TreeMapLabel","_ref147","TreeMapRect","_ref148","currentFill","tooltipLabel2","getKey","TreeMapSeries","_ref149","TreeMap","_ref150","paddingTop","t","tile","tree","getAllNodes","_ref151","datas","labelNone","labelEnd","valueStart","labelTop","valueBottom","valueNone","clickable","BarListSeries","_ref152","itemClassName","labelClassName","outerBarClassName","valueClassName","labelFormat","barClassName","valuePosition","valueFormat","onItemClick","onItemMouseEnter","onItemMouseLeave","css$1","div","item","valueEnd","labelBottom","labelStart","BarList","_ref153","sortDirection","mashedData","domainVal","mashed","percent","section","staggerChildren","staggerDirection","delayChildren","MeterColumn","_ref154","activeFill","inActiveFill","Meter","_ref155","column","gap","cols","RadarChartSeries","RadarChart","FunnelArc","_ref156","variant","areaGenerator","_ref157","areaMirrorGenerator","_ref158","fillColor","fillTop","fillBottom","FunnelAxisLabel","_ref159","showValue","labelVisibility","nextOffset","getTransformString","textWrapHeight","curr","FunnelAxisLine","_ref160","FunnelAxis","_ref161","lines","FunnelSeries","_ref162","onSegmentClick","_ref163","_ref164","halfOffset","halfOffset2","handleSegmentClick","FunnelChart","_ref165","_ref166"],"sources":["/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/common/Axis/LinearAxis/LinearAxisLine.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/common/Axis/LinearAxis/LinearAxis.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/common/Axis/LinearAxis/LinearAxisTickLabel.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/common/Axis/LinearAxis/LinearAxisTickLine.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/common/utils/formatting.ts","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/common/utils/ticks.ts","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/common/utils/size.ts","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/common/Axis/LinearAxis/LinearAxisTickSeries.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/common/Axis/LinearAxis/LinearXAxis.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/common/Axis/LinearAxis/LinearYAxis.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/common/Axis/LinearAxis/helpers.ts","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/common/Axis/RadialAxis/RadialAxisTickSeries/RadialAxisTickLine.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/common/Axis/RadialAxis/RadialAxisTickSeries/RadialAxisTickLabel.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/common/Axis/RadialAxis/RadialAxisTickSeries/RadialAxisTick.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/common/Axis/RadialAxis/RadialAxisTickSeries/RadialAxisTickSeries.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/common/Axis/RadialAxis/RadialAxisArcSeries/RadialAxisArc.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/common/Axis/RadialAxis/RadialAxisArcSeries/utils.ts","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/common/Axis/RadialAxis/RadialAxisArcSeries/RadialAxisArcSeries.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/common/Axis/RadialAxis/RadialAxisArcSeries/RadialAxisArcLine.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/common/utils/bigint.ts","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/common/utils/dimensions.ts","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/common/utils/domains.ts","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/common/utils/interpolation.ts","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/common/utils/position.ts","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/common/utils/selection.ts","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/common/utils/stroke.ts","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/common/utils/math.ts","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/common/utils/functions.ts","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/common/utils/array.ts","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/common/utils/wrapText.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/common/Axis/RadialAxis/RadialAxis.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/common/Gestures/Move.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/common/Brush/BrushHandle.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/common/Brush/BrushSlice.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/common/Brush/Brush.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/common/Brush/ChartBrush.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/common/containers/ChartContext.ts","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/common/containers/ChartContainer.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/common/data/bigInteger.ts","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/common/data/builder.ts","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/common/data/histogram.ts","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/common/data/barStack.ts","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/common/data/marimekko.ts","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/common/data/areaStack.ts","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/common/data/waterfall.ts","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/common/Gestures/Pan.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/common/Gestures/pinchUtils.ts","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/common/Gestures/Zoom.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/common/legends/DiscreteLegend/DiscreteLegend.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/common/legends/DiscreteLegend/DiscreteLegendSymbol.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/common/legends/DiscreteLegend/DiscreteLegendEntry.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/common/legends/SequentialLegend/SequentialLegend.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/common/Gridline/Gridline.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/common/Gridline/GridlineSeries.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/common/Gridline/GridStripe.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/common/MarkLine/MarkLine.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/common/Gradient/GradientStop.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/common/Gradient/Gradient.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/common/Gradient/RadialGradient.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/common/Mask/Mask.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/common/Mask/Stripes.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/common/Tooltip/TooltipTemplate.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/common/Tooltip/TooltipTheme.ts","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/common/Tooltip/ChartTooltip.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/common/Tooltip/TooltipArea.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/common/ZoomPan/ZoomPan.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/common/scales/basic.ts","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/common/scales/marimekko.ts","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/common/scales/multiSeries.ts","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/common/scales/radial.ts","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/common/ZoomPan/ChartZoomPan.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/common/Motion/config.ts","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/common/Motion/MotionPath.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/common/color/schemes.ts","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/common/color/helper.ts","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/common/Count/useCount.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/common/Count/Count.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/common/ValueMarker/LinearValueMarker.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/common/ValueMarker/RadialValueMarker.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/common/Glow/utils.ts","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/ScatterPlot/ScatterSeries/ScatterPoint.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/ScatterPlot/ScatterSeries/ScatterSeries.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/ScatterPlot/ScatterPlot.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/AreaChart/AreaSeries/PointSeries.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/AreaChart/AreaSeries/Area.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/AreaChart/AreaSeries/Line.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/AreaChart/AreaSeries/AreaSeries.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/AreaChart/AreaSeries/StackedNormalizedAreaSeries.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/AreaChart/AreaSeries/StackedAreaSeries.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/AreaChart/AreaChart.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/AreaChart/StackedAreaChart.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/AreaChart/StackedNormalizedAreaChart.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/BarChart/BarSeries/Bar.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/BarChart/BarSeries/BarSeries.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/BarChart/BarSeries/RangeLines.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/BarChart/BarSeries/StackedBarSeries.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/BarChart/BarSeries/StackedNormalizedBarSeries.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/BarChart/BarSeries/MarimekkoBarSeries.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/BarChart/BarSeries/BarLabel.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/BarChart/BarSeries/HistogramBarSeries.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/BarChart/BarSeries/GuideBar.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/BarChart/BarChart.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/BarChart/MarimekkoChart.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/BarChart/StackedBarChart.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/BarChart/StackedNormalizedBarChart.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/BarChart/HistogramBarChart.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/LineChart/LineSeries.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/LineChart/LineChart.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/Map/Map.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/Map/MapMarker.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/PieChart/PieArcSeries/useInterpolate.ts","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/common/utils/useHoverIntent.ts","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/PieChart/PieArcSeries/PieArc.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/PieChart/PieArcSeries/findBreakPoint.ts","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/PieChart/PieArcSeries/PieArcLabel.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/PieChart/PieArcSeries/radiusUtils.ts","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/PieChart/PieArcSeries/PieArcSeries.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/PieChart/PieChart.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/Sankey/utils.ts","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/Sankey/Sankey.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/Sankey/SankeyLabel/SankeyLabel.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/Sankey/SankeyLink/SankeyLink.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/Sankey/SankeyNode/SankeyNode.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/Sparkline/SparklineChart.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/Sparkline/AreaSparklineChart.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/Sparkline/BarSparklineChart.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/Sparkline/SonarChart.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/RadialAreaChart/RadialAreaSeries/RadialArea.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/RadialAreaChart/RadialAreaSeries/RadialLine.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/RadialScatterPlot/RadialScatterPlot.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/RadialScatterPlot/RadialScatterSeries/RadialScatterPoint.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/RadialScatterPlot/RadialScatterSeries/RadialScatterSeries.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/RadialAreaChart/RadialAreaSeries/RadialPointSeries.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/RadialAreaChart/RadialAreaSeries/RadialAreaSeries.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/RadialAreaChart/RadialAreaChart.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/node_modules/d3-path/src/path.js","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/RadialBarChart/RadialBarSeries/MotionBar.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/RadialBarChart/RadialBarSeries/RadialGuideBar.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/RadialBarChart/RadialBarSeries/RadialBar.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/RadialBarChart/RadialBarSeries/RadialBarSeries.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/RadialBarChart/RadialBarChart.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/RadialGauge/RadialGaugeSeries/RadialGaugeArc.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/RadialGauge/RadialGaugeSeries/RadialGaugeLabel/RadialGaugeLabel.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/RadialGauge/RadialGaugeSeries/RadialGaugeValueLabel/RadialGaugeValueLabel.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/RadialGauge/RadialGaugeSeries/RadialGaugeOuterArc.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/RadialGauge/RadialGaugeSeries/RadialGaugeSeries.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/RadialGauge/RadialGaugeSeries/RadialGaugeStackedArc.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/RadialGauge/RadialGaugeSeries/StackedRadialGaugeValueLabel/StackedRadialGaugeValueLabel.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/RadialGauge/RadialGaugeSeries/StackedRadialGaugeSeries.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/RadialGauge/RadialGaugeSeries/StackedRadialGaugeDescriptionLabel/StackedRadialGaugeDescriptionLabel.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/RadialGauge/RadialGauge.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/Heatmap/HeatmapSeries/HeatmapCell.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/Heatmap/HeatmapSeries/HeatmapSeries.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/Heatmap/Heatmap.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/Heatmap/calendarUtils.ts","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/Heatmap/CalendarHeatmap.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/LinearGauge/LinearGaugeBar.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/LinearGauge/LinearGaugeOuterBar.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/LinearGauge/LinearGaugeSeries.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/LinearGauge/LinearGauge.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/VennDiagram/useInterpolate.ts","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/VennDiagram/VennArc.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/VennDiagram/VennLabel.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/VennDiagram/VennOuterLabel.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/VennDiagram/VennSeries.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/VennDiagram/starEuler/starEuler.ts","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/VennDiagram/VennDiagram.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/BubbleChart/Bubble.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/BubbleChart/BubbleLabel.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/BubbleChart/BubbleSeries.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/BubbleChart/BubbleChart.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/TreeMap/TreeMapLabel.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/TreeMap/TreeMapRect.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/TreeMap/TreeMapSeries.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/TreeMap/TreeMap.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/BarList/BarListSeries.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/BarList/BarList.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/Meter/MeterColumn.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/Meter/Meter.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/RadarChart/RadarChartSeries.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/RadarChart/RadarChart.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/FunnelChart/FunnelSeries/FunnelArc.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/FunnelChart/FunnelSeries/FunnelAxis/FunnelAxisLabel.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/FunnelChart/FunnelSeries/FunnelAxis/FunnelAxisLine.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/FunnelChart/FunnelSeries/FunnelAxis/FunnelAxis.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/FunnelChart/FunnelSeries/FunnelSeries.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/FunnelChart/FunnelChart.tsx"],"sourcesContent":["import React, { Fragment, FC, ReactElement } from 'react';\nimport { GradientProps, Gradient } from '../../Gradient';\nimport { CloneElement, useId } from 'reablocks';\n\nexport interface LinearAxisLineProps {\n  height: number;\n  width: number;\n  strokeColor?: string;\n  strokeWidth: number;\n  strokeGradient: ReactElement<GradientProps, typeof Gradient> | null;\n  scale: any;\n  orientation: 'horizontal' | 'vertical';\n  className?: string;\n}\n\nexport const LinearAxisLine: FC<Partial<LinearAxisLineProps>> = ({\n  strokeColor,\n  strokeWidth,\n  strokeGradient,\n  scale,\n  orientation,\n  className\n}) => {\n  const id = useId();\n  const [range0, range1] = scale.range();\n\n  return (\n    <Fragment>\n      <line\n        className={className}\n        x1={orientation === 'vertical' ? 0 : range0}\n        // Workaround for a Chrome/Firefox bug where it won't render gradients for straight lines\n        x2={orientation === 'vertical' ? 0.00001 : range1}\n        y1={orientation === 'vertical' ? range0 : 0}\n        y2={orientation === 'vertical' ? range1 : 0.00001}\n        strokeWidth={strokeWidth}\n        stroke={strokeGradient ? `url(#axis-gradient-${id})` : strokeColor}\n      />\n      {strokeGradient && (\n        <CloneElement<GradientProps>\n          element={strokeGradient}\n          id={`axis-gradient-${id}`}\n        />\n      )}\n    </Fragment>\n  );\n};\n\nLinearAxisLine.defaultProps = {\n  strokeColor: '#8F979F',\n  strokeWidth: 1\n};\n","import { CloneElement } from 'reablocks';\nimport React, {\n  FC,\n  ReactElement,\n  createRef,\n  useCallback,\n  useEffect,\n  useState\n} from 'react';\nimport { ChartDataTypes } from '../../data';\nimport { LinearAxisLine, LinearAxisLineProps } from './LinearAxisLine';\nimport {\n  LinearAxisTickSeries,\n  LinearAxisTickSeriesProps\n} from './LinearAxisTickSeries';\n\nexport interface LinearAxisDimensionChanged {\n  height?: number;\n  width?: number;\n}\n\nexport interface LinearAxisProps {\n  height?: number;\n  width?: number;\n  domain?: ChartDataTypes[];\n  scaled?: boolean;\n  roundDomains?: boolean;\n  type?: 'value' | 'time' | 'category' | 'duration';\n  position?: 'start' | 'end' | 'center';\n  tickSeries?: ReactElement<\n    LinearAxisTickSeriesProps,\n    typeof LinearAxisTickSeries\n  >;\n  axisLine?: ReactElement<LinearAxisLineProps, typeof LinearAxisLine> | null;\n  scale?: any;\n  visibility?: 'visible' | 'hidden';\n  orientation?: 'horizontal' | 'vertical';\n  onDimensionsChange?: (event: LinearAxisDimensionChanged) => void;\n}\n\ninterface LinearAxisState {\n  height?: number;\n  width?: number;\n}\n\nexport const LinearAxis: FC<Partial<LinearAxisProps>> = (props) => {\n  const {\n    position,\n    tickSeries,\n    axisLine,\n    height,\n    width,\n    scale,\n    orientation,\n    visibility = 'visible',\n    onDimensionsChange\n  } = props;\n\n  const containerRef = createRef<SVGGElement>();\n  const [dimensions, setDimensions] = useState<LinearAxisState>({\n    height: height,\n    width: width\n  });\n\n  const updateDimensions = useCallback(() => {\n    const shouldOffset = position !== 'center';\n\n    let height;\n    let width;\n    if (shouldOffset) {\n      const dims = containerRef.current!.getBoundingClientRect();\n      width = Math.floor(dims.width);\n      height = Math.floor(dims.height);\n    }\n\n    if (orientation === 'vertical') {\n      if (dimensions.width !== width) {\n        setDimensions({ ...dimensions, width: width });\n        onDimensionsChange({ width });\n      }\n    } else {\n      if (dimensions.height !== height) {\n        setDimensions({ ...dimensions, height: height });\n        onDimensionsChange({ height });\n      }\n    }\n  }, [containerRef, dimensions, onDimensionsChange, orientation, position]);\n\n  useEffect(() => {\n    updateDimensions();\n  }, [updateDimensions, height, width, scale]);\n\n  function getPosition() {\n    let translateY = 0;\n    let translateX = 0;\n\n    if (position === 'end' && orientation === 'horizontal') {\n      translateY = height;\n    } else if (position === 'center' && orientation === 'horizontal') {\n      translateY = height / 2;\n    } else if (position === 'end' && orientation === 'vertical') {\n      translateX = width;\n    } else if (position === 'center' && orientation === 'vertical') {\n      translateX = width / 2;\n    }\n\n    return { translateX, translateY };\n  }\n\n  const { translateX, translateY } = getPosition();\n\n  return (\n    <g\n      transform={`translate(${translateX}, ${translateY})`}\n      ref={containerRef}\n      visibility={visibility}\n    >\n      {axisLine && (\n        <CloneElement<LinearAxisLineProps>\n          element={axisLine}\n          height={height}\n          width={width}\n          scale={scale}\n          orientation={orientation}\n        />\n      )}\n      {(tickSeries.props.line || tickSeries.props.label) && (\n        <CloneElement<LinearAxisTickSeriesProps>\n          element={tickSeries}\n          height={height}\n          width={width}\n          scale={scale}\n          orientation={orientation}\n          axis={props}\n        />\n      )}\n    </g>\n  );\n};\n\nLinearAxis.defaultProps = {\n  scaled: false,\n  roundDomains: false,\n  axisLine: <LinearAxisLine />,\n  onDimensionsChange: () => undefined\n};\n","import React, { FC, ReactElement } from 'react';\nimport {\n  LinearAxisTickLine,\n  LinearAxisTickLineProps\n} from './LinearAxisTickLine';\n\nexport interface LinearAxisTickLabelProps {\n  text: string;\n  fullText: string;\n  angle: number;\n  orientation: 'horizontal' | 'vertical';\n  half: 'start' | 'end' | 'center';\n  line: ReactElement<LinearAxisTickLineProps, typeof LinearAxisTickLine>;\n  format?: (v) => any;\n  /**\n   * Format tooltip title on hover label.\n   */\n  formatTooltip?: (value: any) => any | string;\n  fill: string;\n  fontSize: number;\n  fontFamily: string;\n  rotation: boolean | number;\n  padding: number | { fromAxis: number; alongAxis: number };\n  textAnchor?: 'start' | 'end' | 'middle';\n  position: 'start' | 'end' | 'center';\n  align: 'start' | 'end' | 'center' | 'inside' | 'outside';\n  className?: string;\n}\n\nexport const LinearAxisTickLabel: FC<Partial<LinearAxisTickLabelProps>> = ({\n  text,\n  fullText,\n  angle,\n  orientation,\n  half,\n  line,\n  textAnchor,\n  position,\n  className,\n  fill,\n  fontSize,\n  fontFamily,\n  rotation,\n  padding,\n  formatTooltip,\n  align\n}) => {\n  function getAlign() {\n    if ((align === 'inside' || align === 'outside') && half === 'center') {\n      return 'center';\n    }\n\n    if (align === 'inside') {\n      return half === 'start' ? 'end' : 'start';\n    }\n\n    if (align === 'outside') {\n      return half === 'start' ? 'start' : 'end';\n    }\n\n    return align;\n  }\n\n  // bug in this function - spacing is NA\n  function getTickLineSpacing() {\n    if (!line) {\n      return [0, 0];\n    }\n\n    const size = line.props.size ?? 3;\n    const position = line.props.position ?? 'center';\n\n    if (position === 'start') {\n      return [size * -1, 0];\n    } else if (position === 'end') {\n      return [0, size];\n    } else {\n      return [size * -0.5, size * 0.5];\n    }\n  }\n\n  function getOffset() {\n    const adjustedPadding =\n      typeof padding === 'number'\n        ? { fromAxis: padding, alongAxis: padding }\n        : padding;\n\n    const spacing = getTickLineSpacing();\n    const offset1 =\n      position === 'start'\n        ? spacing[0] - adjustedPadding.fromAxis\n        : position === 'end'\n          ? spacing[1] + adjustedPadding.fromAxis\n          : 0;\n\n    const align = getAlign();\n    let offset2 = 0;\n    offset2 +=\n      align === 'center'\n        ? 0\n        : align === 'start'\n          ? -adjustedPadding.alongAxis\n          : adjustedPadding.alongAxis;\n\n    const horz = orientation === 'horizontal';\n\n    return {\n      [horz ? 'x' : 'y']: offset2,\n      [horz ? 'y' : 'x']: offset1\n    };\n  }\n\n  function getTextPosition() {\n    let transform = '';\n    let newtextAnchor = '';\n    let alignmentBaseline = 'middle' as 'middle' | 'baseline' | 'hanging';\n\n    if (angle !== 0) {\n      transform = `rotate(${angle})`;\n      newtextAnchor = 'end';\n    } else {\n      const align = getAlign();\n      if (orientation === 'horizontal') {\n        newtextAnchor =\n          align === 'center' ? 'middle' : align === 'start' ? 'end' : 'start';\n        if (position === 'start') {\n          alignmentBaseline = 'baseline';\n        } else if (position === 'end') {\n          alignmentBaseline = 'hanging';\n        }\n      } else {\n        alignmentBaseline =\n          align === 'center'\n            ? 'middle'\n            : align === 'start'\n              ? 'baseline'\n              : 'hanging';\n        if (position === 'start') {\n          newtextAnchor = 'end';\n        } else if (position === 'end') {\n          newtextAnchor = 'start';\n        } else {\n          newtextAnchor = 'middle';\n        }\n      }\n    }\n\n    return {\n      transform,\n      textAnchor: textAnchor || newtextAnchor,\n      alignmentBaseline\n    };\n  }\n\n  const { x, y } = getOffset();\n  const textPosition = getTextPosition();\n  const titleHover =\n    typeof formatTooltip === 'function' ? formatTooltip(fullText) : fullText;\n\n  return (\n    <g\n      transform={`translate(${x}, ${y})`}\n      fontSize={fontSize}\n      fontFamily={fontFamily}\n    >\n      <title>{titleHover}</title>\n      <text {...textPosition} fill={fill} className={className}>\n        {text}\n      </text>\n    </g>\n  );\n};\n\nLinearAxisTickLabel.defaultProps = {\n  fill: '#8F979F',\n  fontSize: 11,\n  fontFamily: 'sans-serif',\n  rotation: true,\n  padding: 5,\n  align: 'center'\n};\n","import React, { FC, useMemo } from 'react';\n\nexport interface LinearAxisTickLineProps {\n  height: number;\n  width: number;\n  orientation: 'horizontal' | 'vertical';\n  size: number;\n  strokeColor?: string;\n  strokeWidth: number;\n  position: 'start' | 'end' | 'center';\n  className?: string;\n}\n\nexport const LinearAxisTickLine: FC<Partial<LinearAxisTickLineProps>> = ({\n  size,\n  position,\n  orientation,\n  strokeColor,\n  strokeWidth,\n  className\n}) => {\n  const path = useMemo(() => {\n    const isVertical = orientation === 'vertical';\n    const tickSize = size || 0;\n    const start =\n      position === 'start'\n        ? tickSize * -1\n        : position === 'center'\n          ? tickSize * -0.5\n          : 0;\n    const end = start + tickSize;\n\n    return {\n      x1: isVertical ? end : 0,\n      x2: isVertical ? start : 0,\n      y1: isVertical ? 0 : start,\n      y2: isVertical ? 0 : end\n    };\n  }, [orientation, position, size]);\n\n  return (\n    <line\n      className={className}\n      strokeWidth={strokeWidth}\n      stroke={strokeColor}\n      {...path}\n    />\n  );\n};\n\nLinearAxisTickLine.defaultProps = {\n  strokeColor: '#8F979F',\n  strokeWidth: 1,\n  size: 5\n};\n","import { ChartInternalDataTypes } from '../data';\n\n// https://stackoverflow.com/questions/673905/best-way-to-determine-users-locale-within-browser\nconst getNavigatorLanguage = () => {\n  if (typeof window === 'undefined') {\n    return 'en';\n  }\n\n  if (navigator.languages && navigator.languages.length) {\n    return navigator.languages[0];\n  }\n\n  if (\n    (navigator as any).userLanguage ||\n    navigator.language ||\n    (navigator as any).browserLanguage\n  ) {\n    return 'en';\n  }\n};\n\nconst locale = getNavigatorLanguage();\n\nconst options = {\n  year: 'numeric',\n  month: 'numeric',\n  day: 'numeric',\n  hour12: true,\n  formatMatcher: 'best fit'\n};\n\n/**\n * Format a value based on type.\n */\nexport function formatValue(value: ChartInternalDataTypes): string {\n  if (value !== undefined) {\n    if (value instanceof Date) {\n      return (value as Date).toLocaleDateString(locale, options as any);\n    } else if (typeof value === 'number') {\n      return value.toLocaleString();\n    }\n\n    return value as string;\n  }\n\n  return 'No value';\n}\n\n/**\n * Generate aria label text for the given data point(s)\n * @param datapoint \n * @returns Aria Label\n */\nexport function getAriaLabel(datapoint) {\n  const isArray = Array.isArray(datapoint);\n  if (isArray) {\n    return datapoint?.map(row => (getAriaLabel(row))).join(', ');\n  } else {\n    const key = datapoint?.key || datapoint?.x;\n    // 'data' or 'y' will not be an array as the label is unique for each element\n    const value = datapoint?.data || datapoint?.y;\n    return `${key}: ${formatValue(value)}`;\n  }\n}","import { TimeInterval } from 'd3-time';\n\nconst ONE_DAY = 60 * 60 * 24;\nconst DURATION_TICK_STEPS = [\n  0.001, // 1 ms\n  0.005, // 5 ms\n  0.01, // 10 ms\n  0.05, // 50 ms\n  0.1, // 100 ms\n  0.5, // 500 ms\n  1, // 1 s\n  5, // 5 s\n  10, // 10 s\n  15, // 15 s\n  60, // 1 m\n  60 * 15, // 15 m\n  60 * 30, // 30 m\n  60 * 60, // 1 h\n  60 * 60 * 2, // 2 h\n  60 * 60 * 4, // 4 h\n  60 * 60 * 6, // 6 h\n  60 * 60 * 8, // 8 h\n  60 * 60 * 12, // 12 h\n  ONE_DAY // 24 h\n];\n\n/**\n * Reduce the ticks to the max number of ticks.\n */\nexport function reduceTicks<T>(ticks: T[], maxTicks: number) {\n  if (ticks.length > maxTicks) {\n    const reduced: T[] = [];\n    const modulus = Math.floor(ticks.length / maxTicks);\n\n    for (let i = 0; i < ticks.length; i++) {\n      if (i % modulus === 0) {\n        reduced.push(ticks[i]);\n      }\n    }\n    ticks = reduced;\n  }\n\n  return ticks;\n}\n\n/**\n * Determine the max ticks for the available width.\n */\nexport function getMaxTicks(size: number, dimension: number) {\n  const tickWidth = Math.max(size, 0);\n  return Math.floor(dimension / tickWidth);\n}\n\n/**\n * Formats the ticks in a duration format.\n */\nexport function getDurationTicks(domain, maxTicks) {\n  const domainWidth = domain[1] - domain[0];\n  let tickStep: number | null = null;\n  for (const s of DURATION_TICK_STEPS) {\n    if (domainWidth / s < maxTicks) {\n      tickStep = s;\n      break;\n    }\n  }\n\n  if (tickStep === null) {\n    const numDayTicks = domainWidth / ONE_DAY;\n    const dayStep = Math.ceil(numDayTicks / maxTicks);\n    tickStep = ONE_DAY * dayStep;\n  }\n\n  const ticks = [domain[0]];\n  while (ticks[ticks.length - 1] + tickStep <= domain[1]) {\n    ticks.push(ticks[ticks.length - 1] + tickStep);\n  }\n\n  return ticks;\n}\n\n/**\n * Get the tick values from the scale.\n */\nexport function getTicks(\n  scale: any,\n  tickValues: any[],\n  type: 'value' | 'category' | 'time' | 'duration',\n  maxTicks = 100,\n  interval?: number | TimeInterval\n) {\n  let result;\n\n  if (tickValues) {\n    result = tickValues;\n  } else {\n    if (scale.ticks) {\n      if (type === 'duration') {\n        result = getDurationTicks(scale.domain(), maxTicks);\n      } else if (interval) {\n        result = scale.ticks(interval);\n      } else {\n        if (type === 'time') {\n          // If its time, we need to handle the time count\n          // manually because d3 does this odd rounding\n          result = scale.ticks();\n          result = reduceTicks(result, maxTicks);\n        } else {\n          result = scale.ticks(maxTicks);\n        }\n      }\n    } else {\n      tickValues = scale.domain();\n      result = reduceTicks(tickValues, maxTicks);\n    }\n  }\n\n  return result;\n}\n","export interface TextDimensions {\n  height: number;\n  width: number;\n}\n\nconst cache: { [key: string]: TextDimensions } = {};\n\nexport const calculateDimensions = (\n  text: string,\n  fontFamily: string,\n  fontSize: string | number\n): TextDimensions => {\n  const key = `${text}_${fontFamily}_${fontSize}`;\n\n  // Check if we have a cache hit\n  if (cache[key]) {\n    return cache[key];\n  }\n\n  // If we are in a Node.js environment\n  if (typeof window === 'undefined' || typeof document === 'undefined') {\n    const height = parseInt(typeof fontSize === 'string' ? fontSize : fontSize.toString(), 10);\n    const dimensions = {\n      height,\n      // 8 is an approximation of the width of a character\n      width: text.length * 8\n    };\n\n    cache[key] = dimensions;\n\n    return dimensions;\n  }\n\n  // Create a temporary div element\n  const element = document.createElement('div');\n\n  // Set up the style so the size can be measured\n  element.style.fontFamily = fontFamily;\n  element.style.fontSize = typeof fontSize === 'string' ? fontSize : `${fontSize}px`;\n  element.style.position = 'absolute';\n  element.style.left = '-9999px';\n  element.style.whiteSpace = 'nowrap';\n  element.style.height = 'auto';\n  element.style.fontWeight = 'normal';\n  element.style.lineHeight = 'normal';\n  element.style.width = 'auto';\n  element.style.wordBreak = 'normal';\n\n  // Add the text to the div\n  element.textContent = text;\n\n  // Add the div to the body\n  document.body.appendChild(element);\n\n  // Measure the div\n  const dimensions = {\n    height: element.offsetHeight,\n    width: element.offsetWidth\n  };\n\n  // Remove the div from the body\n  document.body.removeChild(element);\n\n  // Store the result in the cache for future calls\n  cache[key] = dimensions;\n\n  return dimensions;\n};\n","import React, { FC, Fragment, ReactElement, useCallback, useMemo } from 'react';\nimport {\n  LinearAxisTickLabel,\n  LinearAxisTickLabelProps\n} from './LinearAxisTickLabel';\nimport {\n  LinearAxisTickLine,\n  LinearAxisTickLineProps\n} from './LinearAxisTickLine';\nimport { formatValue } from '../../utils/formatting';\nimport { getTicks, getMaxTicks } from '../../utils/ticks';\nimport { TimeInterval } from 'd3-time';\nimport { CloneElement } from 'reablocks';\nimport { LinearAxisProps } from './LinearAxis';\nimport ellipsize from 'ellipsize';\nimport { max } from 'd3-array';\nimport { calculateDimensions } from '../../utils/size';\n\nexport interface LinearAxisTickSeriesProps {\n  height: number;\n  width: number;\n  scale: any;\n  interval?: number | TimeInterval;\n  tickSize: number;\n  tickValues: any[];\n  orientation: 'horizontal' | 'vertical';\n  label: ReactElement<\n    LinearAxisTickLabelProps,\n    typeof LinearAxisTickLabel\n  > | null;\n  line: ReactElement<LinearAxisTickLineProps, typeof LinearAxisTickLine> | null;\n  axis: LinearAxisProps;\n}\n\ninterface ProcessedTick {\n  text: string;\n  fullText: string;\n  x: number;\n  y: number;\n  height: number;\n  width: number;\n  half: 'start' | 'end' | 'center';\n}\n\nexport const LinearAxisTickSeries: FC<Partial<LinearAxisTickSeriesProps>> = ({\n  scale,\n  orientation,\n  height,\n  width,\n  label,\n  tickSize,\n  tickValues,\n  interval,\n  line,\n  axis\n}) => {\n  /**\n   * Gets the adjusted scale given offsets.\n   */\n  const getAdjustedScale = useCallback(() => {\n    if (scale.bandwidth) {\n      let offset = scale.bandwidth() / 2;\n      if (scale.round()) {\n        offset = Math.round(offset);\n      }\n\n      return (d) => +scale(d) + offset;\n    } else {\n      return (d) => +scale(d);\n    }\n  }, [scale]);\n\n  /**\n   * Gets the x/y position for a given tick.\n   */\n  const getPosition = useCallback(\n    (scaledTick: number) => {\n      if (orientation === 'horizontal') {\n        return { x: scaledTick, y: 0 };\n      } else {\n        return { x: 0, y: scaledTick };\n      }\n    },\n    [orientation]\n  );\n\n  /**\n   * Gets the dimension (height/width) this axis is calculating on.\n   */\n  const getDimension = useCallback(() => {\n    return orientation === 'vertical' ? height : width;\n  }, [height, orientation, width]);\n\n  /**\n   * Gets the formatted label of the tick.\n   */\n  const labelFormatFn = useMemo((): any => {\n    if (label && label.props.format) {\n      return label.props.format;\n    } else if (scale.tickFormat) {\n      return scale.tickFormat.apply(scale, [5]);\n    } else {\n      return (v) => formatValue(v);\n    }\n  }, [label, scale]);\n\n  /**\n   * Gets the ticks given the dimensions and scales and returns\n   * the text and position.\n   */\n  const ticks = useMemo((): ProcessedTick[] => {\n    const dimension = getDimension();\n    const maxTicks = getMaxTicks(tickSize, dimension);\n    const ticks = getTicks(scale, tickValues, axis.type, maxTicks, interval);\n    const adjustedScale = getAdjustedScale();\n    const format = labelFormatFn;\n    const midpoint = dimension / 2;\n\n    return ticks.map((tick) => {\n      const fullText = format(tick);\n      const scaledTick = adjustedScale(tick);\n      const position = getPosition(scaledTick);\n      const text = ellipsize(fullText, 18);\n      const size = label\n        ? calculateDimensions(\n          text,\n          label.props.fontFamily,\n          label.props.fontSize.toString()\n        )\n        : {};\n\n      return {\n        ...position,\n        ...size,\n        text,\n        fullText,\n        half:\n          scaledTick === midpoint\n            ? 'center'\n            : scaledTick < midpoint\n              ? 'start'\n              : 'end'\n      };\n    });\n  }, [\n    axis.type,\n    getAdjustedScale,\n    getDimension,\n    getPosition,\n    interval,\n    label,\n    labelFormatFn,\n    scale,\n    tickSize,\n    tickValues\n  ]);\n\n  /**\n   * Calculates the rotation angle that the ticks need to be shifted to.\n   * This equation will measure the length of the text in a external canvas\n   * object and determine what the longest label is and rotate until they fit.\n   */\n  const angle = useMemo((): number => {\n    if (!label) {\n      return 0;\n    }\n\n    const labelProps = label.props;\n    const dimension = getDimension();\n    const maxTicksLength = max(ticks, (tick) => tick.width);\n    let angle = 0;\n\n    if (labelProps.rotation) {\n      if (labelProps.rotation === true) {\n        let baseWidth = maxTicksLength;\n        const maxBaseWidth = Math.floor(dimension / ticks.length);\n\n        while (baseWidth > maxBaseWidth && angle > -90) {\n          angle -= 30;\n          baseWidth = Math.cos(angle * (Math.PI / 180)) * maxTicksLength;\n        }\n      } else {\n        angle = labelProps.rotation;\n      }\n    }\n\n    return angle;\n  }, [getDimension, label, ticks]);\n\n  return (\n    <Fragment>\n      {ticks.map((tick, i) => (\n        <g key={i} transform={`translate(${tick.x}, ${tick.y})`}>\n          {line && (\n            <CloneElement<LinearAxisTickLineProps>\n              element={line}\n              height={height}\n              width={width}\n              orientation={orientation}\n            />\n          )}\n          {label && (\n            <CloneElement<LinearAxisTickLabelProps>\n              element={label}\n              text={tick.text}\n              fullText={tick.fullText}\n              half={tick.half}\n              angle={angle}\n              orientation={orientation}\n              line={line!}\n            />\n          )}\n        </g>\n      ))}\n    </Fragment>\n  );\n};\n\nLinearAxisTickSeries.defaultProps = {\n  line: (\n    <LinearAxisTickLine\n      height={10}\n      width={10}\n      orientation=\"horizontal\"\n      position=\"center\"\n    />\n  ),\n  label: (\n    <LinearAxisTickLabel\n      line={\n        <LinearAxisTickLine\n          orientation=\"horizontal\"\n          position=\"center\"\n          height={5}\n          width={5}\n        />\n      }\n      text=\"\"\n      fullText=\"\"\n      angle={0}\n      orientation=\"horizontal\"\n      half=\"start\"\n      position=\"center\"\n    />\n  ),\n  tickSize: 30\n};\n","import React, { FC } from 'react';\nimport {\n  LinearAxisTickLabelProps,\n  LinearAxisTickLabel\n} from './LinearAxisTickLabel';\nimport {\n  LinearAxisTickLineProps,\n  LinearAxisTickLine\n} from './LinearAxisTickLine';\nimport {\n  LinearAxisTickSeriesProps,\n  LinearAxisTickSeries\n} from './LinearAxisTickSeries';\nimport { LinearAxisProps, LinearAxis } from './LinearAxis';\n\nexport const LinearXAxisTickLabel: FC<Partial<LinearAxisTickLabelProps>> = (\n  props\n) => <LinearAxisTickLabel {...props} />;\nLinearXAxisTickLabel.defaultProps = {\n  ...LinearAxisTickLabel.defaultProps,\n  rotation: true,\n  position: 'end',\n  align: 'center'\n};\n\nexport const LinearXAxisTickLine: FC<Partial<LinearAxisTickLineProps>> = (\n  props\n) => <LinearAxisTickLine {...props} />;\nLinearXAxisTickLine.defaultProps = {\n  ...LinearAxisTickLine.defaultProps,\n  position: 'end'\n};\n\nexport const LinearXAxisTickSeries: FC<Partial<LinearAxisTickSeriesProps>> = (\n  props\n) => <LinearAxisTickSeries {...props} />;\nLinearXAxisTickSeries.defaultProps = {\n  ...LinearAxisTickSeries.defaultProps,\n  tickSize: 75,\n  line: <LinearXAxisTickLine />,\n  label: <LinearXAxisTickLabel />\n};\n\nexport const LinearXAxis: FC<Partial<LinearAxisProps>> = (props) => (\n  <LinearAxis {...props} />\n);\nLinearXAxis.defaultProps = {\n  ...LinearAxis.defaultProps,\n  position: 'end',\n  roundDomains: false,\n  scaled: false,\n  type: 'value',\n  orientation: 'horizontal',\n  tickSeries: <LinearXAxisTickSeries />\n};\n","import React, { FC } from 'react';\nimport {\n  LinearAxisTickLabelProps,\n  LinearAxisTickLabel\n} from './LinearAxisTickLabel';\nimport {\n  LinearAxisTickLineProps,\n  LinearAxisTickLine\n} from './LinearAxisTickLine';\nimport {\n  LinearAxisTickSeriesProps,\n  LinearAxisTickSeries\n} from './LinearAxisTickSeries';\nimport { LinearAxisProps, LinearAxis } from './LinearAxis';\n\nexport const LinearYAxisTickLabel: FC<Partial<LinearAxisTickLabelProps>> = (\n  props\n) => <LinearAxisTickLabel {...props} />;\nLinearYAxisTickLabel.defaultProps = {\n  ...LinearAxisTickLabel.defaultProps,\n  rotation: false,\n  position: 'start',\n  align: 'center'\n};\n\nexport const LinearYAxisTickLine: FC<Partial<LinearAxisTickLineProps>> = (\n  props\n) => <LinearAxisTickLine {...props} />;\nLinearYAxisTickLine.defaultProps = {\n  ...LinearAxisTickLine.defaultProps,\n  position: 'start'\n};\n\nexport const LinearYAxisTickSeries: FC<Partial<LinearAxisTickSeriesProps>> = (\n  props\n) => <LinearAxisTickSeries {...props} />;\nLinearYAxisTickSeries.defaultProps = {\n  ...LinearAxisTickSeries.defaultProps,\n  tickSize: 30,\n  line: <LinearYAxisTickLine />,\n  label: <LinearYAxisTickLabel />\n};\n\nexport const LinearYAxis: FC<Partial<LinearAxisProps>> = (props) => (\n  <LinearAxis {...props} />\n);\nLinearYAxis.defaultProps = {\n  ...LinearAxis.defaultProps,\n  orientation: 'vertical',\n  scaled: false,\n  roundDomains: false,\n  type: 'value',\n  position: 'start',\n  tickSeries: <LinearYAxisTickSeries />\n};\n","import { LinearAxisProps } from './LinearAxis';\n\n/**\n * Returns whether the axis has a visual element or not.\n */\nexport const isAxisVisible = (axis: LinearAxisProps) =>\n  !!axis.tickSeries.props.label || !!axis.tickSeries.props.line;\n","import React, { FC } from 'react';\n\nexport interface RadialAxisTickLineProps {\n  /**\n   * Size of the tick line.\n   */\n  size?: number;\n\n  /**\n   * Stroke color of the tick line.\n   */\n  stroke: string;\n\n  /**\n   * Inner radius of the arc.\n   */\n  innerRadius: number;\n\n  /**\n   * Outer radius of the arc.\n   */\n  outerRadius: number;\n\n  /**\n   * Position of the tick line.\n   */\n  position: 'inside' | 'outside';\n}\n\nexport const RadialAxisTickLine: FC<Partial<RadialAxisTickLineProps>> = ({\n  stroke,\n  size,\n  position,\n  innerRadius,\n  outerRadius\n}) => {\n  const x1 = position === 'outside' ? size : -(outerRadius - innerRadius);\n\n  return (\n    <line x1={x1} x2={0} stroke={stroke} style={{ pointerEvents: 'none' }} />\n  );\n};\n\nRadialAxisTickLine.defaultProps = {\n  stroke: 'rgba(113, 128, 141, .5)',\n  size: 10,\n  position: 'inside'\n};\n","import React, { FC, SVGTextElementAttributes, useMemo } from 'react';\nimport { formatValue } from '../../../utils/formatting';\n\nconst rad2deg = (angle: number) => (angle * 180) / Math.PI;\n\nexport interface RadialAxisTickLabelProps\n  extends Omit<SVGTextElementAttributes<SVGTextElement>, 'format'> {\n  /**\n   * Data to render.\n   */\n  data: any;\n\n  /**\n   * Size of the line.\n   */\n  lineSize: number;\n\n  /**\n   * Color of the text.\n   */\n  fill: string;\n\n  /**\n   * Font size of the text.\n   */\n  fontSize: number;\n\n  /**\n   * Rotation of the text.\n   */\n  rotation: number;\n\n  /**\n   * Font family of the text.\n   */\n  fontFamily: string;\n\n  /**\n   * Index of the tick.\n   */\n  index: number;\n\n  /**\n   * Padding of the tick.\n   */\n  padding: number;\n\n  /**\n   * Point of the tick.\n   */\n  point: any;\n\n  /**\n   * Auto rotate the text.\n   */\n  autoRotate: boolean;\n\n  /**\n   * Format of the label.\n   */\n  format?: (value: any, index: number) => any | string;\n\n  /**\n   * Format tooltip title on hover label.\n   */\n  formatTooltip?: (value: any, index: number) => any | string;\n}\n\nexport const RadialAxisTickLabel: FC<Partial<RadialAxisTickLabelProps>> = ({\n  point,\n  autoRotate,\n  rotation,\n  padding,\n  data,\n  fill,\n  fontFamily,\n  fontSize,\n  format,\n  lineSize,\n  index,\n  formatTooltip,\n  ...rest\n}) => {\n  const { transform, textAnchor } = useMemo(() => {\n    let textAnchor;\n    let transform;\n\n    if (autoRotate) {\n      // TODO: This centers the text, determine better way later\n      if (\n        (rotation >= 85 && rotation <= 95) ||\n        (rotation <= -85 && rotation >= -95) ||\n        (rotation >= 265 && rotation <= 275) ||\n        (rotation <= -265 && rotation >= -275)\n      ) {\n        textAnchor = 'middle';\n      } else if (\n        (rotation < -85 && rotation > -265) ||\n        (rotation > 95 && rotation < 265)\n      ) {\n        textAnchor = 'end';\n      } else {\n        textAnchor = 'start';\n      }\n\n      transform = `rotate(${90 - rad2deg(point)}, ${padding}, 0)`;\n    } else {\n      const shouldRotate = rotation && (rotation > 100 || rotation < -100);\n      const rotate = shouldRotate ? 180 : 0;\n      const translate = shouldRotate ? -30 : 0;\n      textAnchor = shouldRotate ? 'end' : 'start';\n      transform = `rotate(${rotate}) translate(${translate})`;\n    }\n\n    return {\n      transform,\n      textAnchor\n    };\n  }, [autoRotate, padding, point, rotation]);\n\n  const text = format ? format(data, index) : formatValue(data);\n  const titleHover =\n    typeof formatTooltip === 'function' ? formatTooltip(data, index) : text;\n\n  return (\n    <g transform={transform}>\n      <title>{titleHover}</title>\n      <text\n        dy=\"0.35em\"\n        x={lineSize + 5}\n        textAnchor={textAnchor}\n        fill={fill}\n        fontFamily={fontFamily}\n        fontSize={fontSize}\n        {...rest}\n      >\n        {text}\n      </text>\n    </g>\n  );\n};\n\nRadialAxisTickLabel.defaultProps = {\n  fill: '#71808d',\n  fontSize: 11,\n  padding: 15,\n  fontFamily: 'sans-serif',\n  autoRotate: true,\n  startAngle: 0,\n  endAngle: 2 * Math.PI\n};\n","import React, { FC, ReactElement } from 'react';\nimport {\n  RadialAxisTickLineProps,\n  RadialAxisTickLine\n} from './RadialAxisTickLine';\nimport {\n  RadialAxisTickLabelProps,\n  RadialAxisTickLabel\n} from './RadialAxisTickLabel';\nimport { CloneElement } from 'reablocks';\n\nexport interface RadialAxisTickProps {\n  /**\n   * Scale to use for the tick.\n   */\n  scale: any;\n\n  /**\n   * Outer radius of the arc.\n   */\n  outerRadius: number;\n\n  /**\n   * Inner radius of the arc.\n   */\n  innerRadius: number;\n\n  /**\n   * Padding between the tick and the label.\n   */\n  padding: number;\n\n  /**\n   * Data to render.\n   */\n  data: any;\n\n  /**\n   * Index of the tick.\n   */\n  index: number;\n\n  /**\n   * Line element to render.\n   */\n  line: ReactElement<RadialAxisTickLineProps, typeof RadialAxisTickLine> | null;\n\n  /**\n   * Label element to render.\n   */\n  label: ReactElement<\n    RadialAxisTickLabelProps,\n    typeof RadialAxisTickLabel\n  > | null;\n\n  /**\n   * Start angle for the first value.\n   */\n  startAngle?: number;\n\n  /**\n   * End angle for the last value.\n   */\n  endAngle?: number;\n}\n\nexport const RadialAxisTick: FC<Partial<RadialAxisTickProps>> = ({\n  line,\n  label,\n  scale,\n  outerRadius,\n  data,\n  index,\n  padding,\n  innerRadius,\n  startAngle,\n  endAngle\n}) => {\n  const point = scale(data);\n\n  const rotation = (point * 180) / Math.PI - 90;\n  const transform = `rotate(${rotation}) translate(${outerRadius + padding},0)`;\n  const lineSize = line ? line.props.size : 0;\n\n  return (\n    <g transform={transform}>\n      {line && (\n        <CloneElement<RadialAxisTickLineProps>\n          element={line}\n          innerRadius={innerRadius}\n          outerRadius={outerRadius}\n        />\n      )}\n      {label && (\n        <CloneElement<RadialAxisTickLabelProps>\n          element={label}\n          index={index}\n          point={point}\n          rotation={rotation}\n          lineSize={lineSize}\n          data={data}\n          startAngle={startAngle}\n          endAngle={endAngle}\n        />\n      )}\n    </g>\n  );\n};\n\nRadialAxisTick.defaultProps = {\n  outerRadius: 0,\n  padding: 0,\n  line: <RadialAxisTickLine />,\n  label: <RadialAxisTickLabel />,\n  startAngle: 0,\n  endAngle: 2 * Math.PI\n};\n","import React, { FC, Fragment, ReactElement } from 'react';\nimport { RadialAxisTick, RadialAxisTickProps } from './RadialAxisTick';\nimport { CloneElement } from 'reablocks';\nimport { getTicks } from '../../../utils/ticks';\nimport { TimeInterval } from 'd3-time';\n\nexport interface TickCallback {\n  index?: number;\n}\n\nexport interface RadialAxisTickSeriesProps {\n  /**\n   * Scale to use for the tick.\n   */\n  scale: any;\n\n  /**\n   * Number of ticks to render.\n   */\n  count?: number;\n\n  /**\n   * Interval between ticks.\n   */\n  interval?: number | TimeInterval;\n\n  /**\n   * Tick values to render.\n   */\n  tickValues: any[];\n\n  /**\n   * Outer radius of the arc.\n   */\n  outerRadius: number;\n\n  /**\n   * Type of the axis.\n   */\n  type: 'value' | 'category' | 'time' | 'duration';\n\n  /**\n   * Inner radius of the arc.\n   */\n  innerRadius: number;\n\n  /**\n   * Tick element to render.\n   */\n  tick:\n    | ((\n        tick: TickCallback\n      ) => ReactElement<RadialAxisTickProps, typeof RadialAxisTick>)\n    | ReactElement<RadialAxisTickProps, typeof RadialAxisTick>;\n\n  /**\n   * Start angle for the first value.\n   */\n  startAngle?: number;\n\n  /**\n   * End angle for the last value.\n   */\n  endAngle?: number;\n}\n\nexport const RadialAxisTickSeries: FC<Partial<RadialAxisTickSeriesProps>> = ({\n  scale,\n  count,\n  outerRadius,\n  tick,\n  tickValues,\n  innerRadius,\n  interval,\n  type,\n  startAngle,\n  endAngle\n}) => {\n  const ticks = getTicks(scale, tickValues, type, count, interval || count);\n\n  return (\n    <Fragment>\n      {ticks.map((data, i) => {\n        const tickElement =\n          typeof tick === 'function' ? tick({ index: i }) : tick;\n        return (\n          <CloneElement<RadialAxisTickProps>\n            element={tickElement}\n            key={i}\n            index={i}\n            scale={scale}\n            data={data}\n            innerRadius={innerRadius}\n            outerRadius={outerRadius}\n            startAngle={startAngle}\n            endAngle={endAngle}\n          />\n        );\n      })}\n    </Fragment>\n  );\n};\n\nRadialAxisTickSeries.defaultProps = {\n  count: 12,\n  type: 'time',\n  tick: <RadialAxisTick />,\n  startAngle: 0,\n  endAngle: 2 * Math.PI\n};\n","import { arc } from 'd3-shape';\nimport React, { FC } from 'react';\n\nexport interface RadialAxisArcProps {\n  /**\n   * Index of the arc.\n   */\n  index: number;\n\n  /**\n   * Scale to use for the arc.\n   */\n  scale: any;\n\n  /**\n   * Stroke color of the arc.\n   */\n  stroke: ((index: number) => string) | string;\n\n  /**\n   * Stroke dash array of the arc.\n   */\n  strokeDasharray: ((index: number) => string) | string;\n\n  /**\n   * Start angle for the first value.\n   */\n  startAngle?: number;\n\n  /**\n   * End angle for the last value.\n   */\n  endAngle?: number;\n}\n\nexport const RadialAxisArc: FC<Partial<RadialAxisArcProps>> = ({\n  index,\n  stroke,\n  strokeDasharray,\n  scale,\n  startAngle,\n  endAngle\n}) => {\n  const r = scale(index);\n  const strokeColor = typeof stroke === 'string' ? stroke : stroke(index);\n  const strokeDash =\n    typeof strokeDasharray === 'string'\n      ? strokeDasharray\n      : strokeDasharray(index);\n\n  const isFullCircle = Math.abs(endAngle - startAngle) >= 2 * Math.PI;\n\n  const x = arc()({\n    innerRadius: r,\n    outerRadius: r,\n    startAngle: startAngle,\n    endAngle: endAngle\n  });\n\n  // Path calculation for intermediate angles\n  const REGEX = /(-?\\d+\\.?\\d*,-?\\d+\\.?\\d*A-?\\d+\\.?\\d*,-?\\d+\\.?\\d*)/gm;\n  const matches = x.match(REGEX);\n  const start = matches?.[0]?.split('A', 2)?.[0];\n  const end = matches?.[1]?.split('A', 2)?.[0];\n  const d = x + ` M ${start} L 0,0 M ${end} L 0,0`;\n\n  return (\n    <>\n      {isFullCircle ? \n        <circle\n          fill=\"none\"\n          strokeDasharray={strokeDash}\n          stroke={strokeColor}\n          style={{ pointerEvents: 'none' }}\n          cx=\"0\"\n          cy=\"0\"\n          r={r}\n        />\n        :\n        <path d={d} fill=\"none\"\n          strokeDasharray={strokeDash}\n          stroke={strokeColor}\n          style={{ pointerEvents: 'none' }}\n        />\n      }\n    </>\n  );\n};\n\nRadialAxisArc.defaultProps = {\n  stroke: '#71808d',\n  strokeDasharray: '1,4',\n  startAngle: 0,\n  endAngle: 2 * Math.PI\n};\n","/**\n * Given a set of arcs, return an array of points for each arc.\n */\nexport const getPointsForLevels = ({ count, outerRadius, ticks, arcs }) => {\n  const levels: Array<Array<{ x: number; y: number }>> = [];\n  const polyangle = (Math.PI * 2) / ticks;\n\n  for (const level of arcs) {\n    const hyp = (level / count) * outerRadius;\n\n    const points: Array<{ x: number; y: number }> = [];\n    for (let vertex = 0; vertex < ticks; vertex++) {\n      const theta = vertex * polyangle;\n      points.push({\n        x: hyp * Math.sin(Math.PI - theta),\n        y: hyp * Math.cos(Math.PI - theta)\n      });\n    }\n\n    levels.push([...points, points[0]]);\n  }\n\n  return levels;\n};\n","import React, { FC, ReactElement } from 'react';\nimport { RadialAxisArc, RadialAxisArcProps } from './RadialAxisArc';\nimport { CloneElement } from 'reablocks';\nimport { scaleLinear } from 'd3-scale';\nimport { getPointsForLevels } from './utils';\nimport { RadialAxisArcLine, RadialAxisArcLineProps } from './RadialAxisArcLine';\n\nexport interface RadialAxisArcSeriesProps {\n  /**\n   * Arc element to render.\n   */\n  arc: ReactElement<RadialAxisArcProps, typeof RadialAxisArc>;\n\n  /**\n   * Line element to render.\n   */\n  line: ReactElement<RadialAxisArcLineProps, typeof RadialAxisArcLine>;\n\n  /**\n   * Number of arcs to render.\n   */\n  count: number;\n\n  /**\n   * Inner radius of the arc.\n   */\n  innerRadius: number;\n\n  /**\n   * Outer radius of the arc.\n   */\n  outerRadius: number;\n\n  /**\n   * Calculated tick values by the Radial Axis.\n   */\n  tickValues?: any[];\n\n  /**\n   * Start angle for the first value.\n   */\n  startAngle?: number;\n\n  /**\n   * End angle for the last value.\n   */\n  endAngle?: number;\n}\n\nexport const RadialAxisArcSeries: FC<Partial<RadialAxisArcSeriesProps>> = ({\n  count,\n  innerRadius,\n  outerRadius,\n  line,\n  arc,\n  tickValues,\n  startAngle,\n  endAngle\n}) => {\n  const scale = scaleLinear()\n    .domain([0, count])\n    .range([innerRadius, outerRadius]);\n\n  const arcs = scale.ticks(count);\n\n  const points = getPointsForLevels({\n    count,\n    outerRadius,\n    ticks: tickValues.length,\n    arcs\n  });\n\n  return (\n    <>\n      {line && (\n        <>\n          {points.map((d, i) => (\n            <CloneElement<RadialAxisArcLineProps>\n              element={line}\n              key={i}\n              data={d}\n              index={i}\n            />\n          ))}\n        </>\n      )}\n      {arc && (\n        <>\n          {arcs.map((d) => (\n            <CloneElement<RadialAxisArcProps>\n              element={arc}\n              key={d}\n              index={d}\n              scale={scale}\n              startAngle={startAngle}\n              endAngle={endAngle}\n            />\n          ))}\n        </>\n      )}\n    </>\n  );\n};\n\nRadialAxisArcSeries.defaultProps = {\n  type: 'arc',\n  count: 12,\n  arc: <RadialAxisArc />,\n  startAngle: 0,\n  endAngle: 2 * Math.PI\n};\n","import { line } from 'd3-shape';\nimport React, { FC } from 'react';\n\nexport interface RadialAxisArcLineProps {\n  /**\n   * Stroke color of the arc.\n   */\n  stroke: ((index: number) => string) | string;\n\n  /**\n   * Data to render the line.\n   */\n  data: Array<{ x: number; y: number }>;\n\n  /**\n   * Index of the arc.\n   */\n  index: number;\n}\n\nexport const RadialAxisArcLine: FC<Partial<RadialAxisArcLineProps>> = ({\n  data,\n  stroke,\n  index\n}) => {\n  const lineGenerator = line<{ x: number; y: number }>()\n    .x((d: any) => d.x)\n    .y((d: any) => d.y);\n\n  const d = lineGenerator(data);\n  const strokeColor = typeof stroke === 'string' ? stroke : stroke(index);\n\n  return (\n    <path\n      d={d}\n      stroke={strokeColor}\n      fill=\"none\"\n      style={{ pointerEvents: 'none' }}\n    />\n  );\n};\n\nRadialAxisArcLine.defaultProps = {\n  stroke: '#71808d'\n};\n","import humanFormat from 'human-format';\n\nconst humanFormatScale = new humanFormat.Scale({\n  k: 1000,\n  M: 1000000,\n  B: 1000000000\n});\n\nconst humanFormatMillionScale = new humanFormat.Scale({\n  M: 1,\n  B: 1000,\n  T: 1000000\n});\n\nconst ONE_MILLION = 1000000;\nconst ONE_BILLION = 1000000000;\n\nexport const humanFormatBigInteger = (bigInteger) => {\n  if (bigInteger.greater(ONE_BILLION)) {\n    return humanFormat(bigInteger.divide(ONE_MILLION).toJSNumber(), {\n      scale: humanFormatMillionScale\n    });\n  }\n  return humanFormat(bigInteger.toJSNumber(), { scale: humanFormatScale });\n};\n\nexport const bigIntegerToLocaleString = (bigInteger) => {\n  let i = 0;\n  let formattedString = '';\n  for (const c of bigInteger.toString().split('').reverse()) {\n    if (i > 0 && i % 3 === 0) {\n      formattedString = ',' + formattedString;\n    }\n    formattedString = c + formattedString;\n    i++;\n  }\n  return formattedString;\n};\n","export interface Dimensions {\n  xOffset: number;\n  yOffset: number;\n  height: number;\n  width: number;\n  chartWidth: number;\n  chartHeight: number;\n  xMargin: number;\n  yMargin: number;\n}\n\nexport interface DimensionParameter {\n  xOffset: number;\n  yOffset: number;\n  yAxis: any;\n  xAxis: any;\n  height: number;\n  width: number;\n  margins: Margins;\n}\n\nexport type Margins =\n  | [number, number]\n  | [number, number, number, number]\n  | number;\n\n/**\n * Given a margins object, returns the top/left/right/bottom positions.\n */\nfunction parseMargins(margins?: Margins) {\n  let top = 0;\n  let right = 0;\n  let bottom = 0;\n  let left = 0;\n\n  if (Array.isArray(margins)) {\n    if (margins.length === 2) {\n      top = margins[0];\n      bottom = margins[0];\n      left = margins[1];\n      right = margins[1];\n    } else if (margins.length === 4) {\n      top = margins[0];\n      right = margins[1];\n      bottom = margins[2];\n      left = margins[3];\n    }\n  } else if (margins !== undefined) {\n    top = margins;\n    right = margins;\n    bottom = margins;\n    left = margins;\n  }\n\n  return {\n    top,\n    right,\n    bottom,\n    left\n  };\n}\n\n/**\n * Calculates the margins for the chart.\n */\nfunction calculateMarginOffsets(\n  height: number,\n  width: number,\n  margins: { left: number; right: number; bottom: number; top: number }\n) {\n  const { left, right, bottom, top } = margins;\n  const newHeight = height - top - bottom;\n  const newWidth = width - left - right;\n\n  return {\n    height: newHeight,\n    width: newWidth\n  };\n}\n\n/**\n * Calculates the dimensions for the chart.\n */\nexport function getDimension({\n  xOffset,\n  yOffset,\n  height,\n  width,\n  margins\n}: DimensionParameter | any): Dimensions {\n  const parsedMargins = parseMargins(margins);\n  const marginDims = calculateMarginOffsets(height, width, parsedMargins);\n  const chartWidth = marginDims.width - xOffset;\n  const chartHeight = marginDims.height - yOffset;\n\n  return {\n    xOffset,\n    yOffset,\n    height,\n    width,\n    chartWidth,\n    chartHeight,\n    xMargin: xOffset + parsedMargins.left,\n    yMargin: parsedMargins.top\n  };\n}\n","import { min, max } from 'd3-array';\n\n/**\n * Gets the min/max values handling nested arrays.\n */\nexport function extent(data: any[], attr: string): number[] {\n  const accessor = (val, fn) => {\n    if (Array.isArray(val.data)) {\n      return fn(val.data, (vv) => vv[attr]);\n    }\n    return val[attr];\n  };\n\n  const minVal = min(data, (d) => accessor(d, min));\n  const maxVal = max(data, (d) => accessor(d, max));\n\n  return [minVal, maxVal];\n}\n\n/**\n * Get the domain for the Y Axis.\n */\nexport function getYDomain({\n  data,\n  scaled = false,\n  isDiverging = false\n}): number[] {\n  const [startY, endY] = extent(data, 'y');\n  const [startY1, endY1] = extent(data, 'y1');\n\n  // If dealing w/ negative numbers, we should\n  // normalize the top and bottom values\n  if (startY < 0 || isDiverging) {\n    const posStart = -startY;\n    const maxNum = Math.max(posStart, endY);\n\n    return [-maxNum, maxNum];\n  }\n\n  // Scaled start scale at non-zero\n  if (scaled) {\n    return [startY1, endY1];\n  }\n\n  // Start at 0 based\n  return [0, endY1];\n}\n\n/**\n * Get the domain for the X Axis.\n */\nexport function getXDomain({\n  data,\n  scaled = false,\n  isDiverging = false\n}): number[] {\n  const startX0 = extent(data, 'x0')[0];\n  const endX1 = extent(data, 'x1')[1];\n\n  // Histograms use dates for start/end\n  if (typeof startX0 === 'number' && typeof endX1 === 'number') {\n    // If dealing w/ negative numbers, we should\n    // normalize the top and bottom values\n    if (startX0 < 0 || isDiverging) {\n      const posStart = -startX0;\n      const maxNum = Math.max(posStart, endX1);\n\n      return [-maxNum, maxNum];\n    }\n\n    // If not scaled, return 0/max domains\n    if (!scaled) {\n      return [0, endX1];\n    }\n  }\n\n  // Scaled start scale at non-zero\n  return [startX0, endX1];\n}\n","import { curveLinear, curveMonotoneX, curveStep } from 'd3-shape';\n\nexport type InterpolationTypes = 'linear' | 'smooth' | 'step';\nexport type RadialInterpolationTypes = 'linear' | 'smooth';\n\n/**\n * Helper function for interpolation.\n */\nexport function interpolate(\n  type: InterpolationTypes | RadialInterpolationTypes\n) {\n  if (type === 'smooth') {\n    return curveMonotoneX;\n  } else if (type === 'step') {\n    return curveStep;\n  } else {\n    return curveLinear;\n  }\n}\n","import { bisector } from 'd3-array';\nimport { applyToPoint, applyToPoints, inverse } from 'transformation-matrix';\n\ntype PointObjectNotation = { x: number; y: number };\n\n/**\n * Add ability to calculate scale band position.\n * Reference: https://stackoverflow.com/questions/38633082/d3-getting-invert-value-of-band-scales\n */\nconst scaleBandInvert = (scale, round = false) => {\n  const domain = scale.domain();\n  const paddingOuter = scale(domain[0]);\n  const eachBand = scale.step();\n  const [, end] = scale.range();\n\n  return (offset) => {\n    // Keep the band from going outside the domain length\n    let band = Math.min(\n      (offset - paddingOuter) / eachBand,\n      domain.length - 0.01\n    );\n\n    // Catch negative band values from horizontal charts exceeding domain length\n    if (band < 0 && Math.abs(band) > domain.length - 1) {\n      band = Math.floor(Math.abs(band)) * -1;\n    }\n\n    // Round to the closest index OR take the floor value\n    let index = round\n      ? Math.round(band) % domain.length\n      : Math.floor(band) % domain.length;\n\n    // Handle horizontal charts...\n    if (end === 0) {\n      index = index * -1;\n    }\n\n    return domain[Math.max(0, Math.min(index, domain.length - 1))];\n  };\n};\n\n/**\n * Get the data point closest to a given position on a continuous scale.\n *\n * @param {Object} params - The parameters for the function.\n * @param {number} params.pos - The position to find the closest point to.\n * @param {Object} params.scale - The scale object.\n * @param {Array} params.data - The data array.\n * @param {string} [params.attr='x'] - The attribute to use for comparison.\n * @param {boolean} [params.roundDown=false] - Whether to round down to the nearest point.\n *\n * @returns {Object} The closest point to the specified position.\n */\nexport const getClosestContinousScalePoint = ({\n  pos,\n  scale,\n  data,\n  attr = 'x',\n  roundDown = false\n}: {\n  pos: number;\n  scale: any;\n  data: any[];\n  attr?: string;\n  roundDown?: boolean;\n}) => {\n  const domain = scale.invert(pos);\n\n  // Select the index\n  const bisect = bisector((d: any) => {\n    // add 1 to an index so it's the upper limit of a domain\n    return attr === 'i' ? d[attr] + 1 : d[attr];\n  }).right;\n  const index = bisect(data, domain);\n\n  // Determine min index\n  const minIndex = Math.max(0, index - 1);\n  const before = data[minIndex];\n\n  if (roundDown) {\n    return before;\n  }\n\n  // Determine max index\n  const maxIndex = Math.min(data.length - 1, index);\n  const after = data[maxIndex];\n\n  // Determine which is closest to the point\n  let beforeVal = before[attr];\n  let afterVal = after[attr];\n  beforeVal = domain - beforeVal;\n  afterVal = afterVal - domain;\n\n  return beforeVal < afterVal ? before : after;\n};\n\n/**\n * Get the data point closest to a given position on a band scale. This rounds down by default.\n *\n * @param {Object} params - The parameters for the function.\n * @param {number} params.pos - The position to find the closest point to.\n * @param {Object} params.scale - The scale object.\n * @param {Array} params.data - The data array.\n * @param {boolean} [params.roundClosest=false] - Whether to round to the closest point instead of down.\n *\n * @returns {Object} The closest point to the specified position.\n */\nexport const getClosestBandScalePoint = ({\n  pos,\n  scale,\n  data,\n  roundClosest = false\n}: {\n  pos: number;\n  scale: any;\n  data: any[];\n  roundClosest?: boolean;\n}) => {\n  const domain = scale.domain();\n  let prop;\n\n  // Of course the Marimekko is a pain...\n  if (scale.mariemkoInvert) {\n    prop = scale.mariemkoInvert(pos);\n  } else {\n    prop = scaleBandInvert(scale, roundClosest)(pos);\n  }\n\n  const idx = domain.indexOf(prop);\n  return data[idx];\n};\n\n/**\n * Given an event, get the parent svg element;\n */\nexport const getParentSVG = (event) => {\n  // set node to targets owner svg\n  let node = event.target.ownerSVGElement;\n\n  // find the outermost svg\n  if (node) {\n    while (node.ownerSVGElement) {\n      node = node.ownerSVGElement;\n    }\n  }\n\n  return node;\n};\n\n/**\n * Given an event, get the relative X/Y position for a target.\n */\nexport const getPositionForTarget = ({ target, clientX, clientY }) => {\n  const rect = target.getBoundingClientRect();\n  return {\n    x: clientX - (rect?.left || 0) - target.clientLeft,\n    y: clientY - (rect?.top || 0) - target.clientTop\n  };\n};\n\n/**\n * Gets the point from q given matrix.\n */\nexport const getPointFromMatrix = (event, matrix): PointObjectNotation => {\n  const parent = getParentSVG(event);\n\n  if (!parent) {\n    return null;\n  }\n\n  // Determines client coordinates relative to the editor component\n  const { top, left } = parent.getBoundingClientRect();\n  const x = event.clientX - left;\n  const y = event.clientY - top;\n\n  // Transforms the coordinate to world coordinate (in the SVG/DIV world)\n  return applyToPoint(inverse(matrix), { x, y });\n};\n\n/**\n * Get the start/end matrix.\n */\nexport const getLimitMatrix = (\n  height: number,\n  width: number,\n  matrix\n): PointObjectNotation[] =>\n  applyToPoints(matrix, [\n    { x: 0, y: 0 },\n    { x: width, y: height }\n  ]);\n\n/**\n * Constrain the matrix.\n */\nexport const constrainMatrix = (height: number, width: number, matrix) => {\n  const [min, max] = getLimitMatrix(height, width, matrix) as {\n    x: number;\n    y: number;\n  }[];\n\n  if (max.x < width || max.y < height) {\n    return true;\n  }\n\n  if (min.x > 0 || min.y > 0) {\n    return true;\n  }\n\n  return false;\n};\n\n/**\n * Determine if scale factor is less than allowed.\n */\nconst lessThanScaleFactorMin = (value, scaleFactor: number) =>\n  value.scaleFactorMin && value.d * scaleFactor <= value.scaleFactorMin;\n\n/**\n * Determine if scale factor is larger than allowed.\n */\nconst moreThanScaleFactorMax = (value, scaleFactor: number) =>\n  value.scaleFactorMax && value.d * scaleFactor >= value.scaleFactorMax;\n\n/**\n * Determine if both min and max scale fctors are going out of bounds.\n */\nexport const isZoomLevelGoingOutOfBounds = (value, scaleFactor: number) => {\n  const a = lessThanScaleFactorMin(value, scaleFactor) && scaleFactor < 1;\n  const b = moreThanScaleFactorMax(value, scaleFactor) && scaleFactor > 1;\n  return a || b;\n};\n","/**\n * Toggle the text selection of the body.\n */\nexport function toggleTextSelection(allowSelection: boolean) {\n  const style = allowSelection ? '' : 'none';\n  [\n    '-webkit-touch-callout',\n    '-webkit-user-select',\n    '-khtml-user-select',\n    '-moz-user-select',\n    '-ms-user-select',\n    'user-select'\n  ].forEach((prop) => (document.body.style[prop] = style));\n}\n","import { ChartInternalShallowDataShape } from '../data';\n\n/**\n * Calculates whether the stroke should be shown.\n */\nexport function calculateShowStroke(\n  current: ChartInternalShallowDataShape,\n  data: ChartInternalShallowDataShape[]\n) {\n  const i = data.indexOf(current);\n  let showLine = false;\n\n  const prev = data[i - 1];\n  if (i > 0 && prev.y) {\n    showLine = true;\n  }\n\n  const cur = data[i];\n  if (cur.y) {\n    showLine = true;\n  }\n\n  const next = data[i + 1];\n  if (i < data.length - 1 && next.y) {\n    showLine = true;\n  }\n\n  return showLine;\n}\n","/**\n * Get the angle from a radian.\n */\nexport const getDegrees = (radians: number) => (radians / Math.PI) * 180 - 90;\n","import classNames from 'classnames';\n\nexport interface PropFunctionTypes {\n  /**\n   * Classnames to apply to the element.\n   */\n  className?: any;\n\n  /**\n   * CSS styles to apply to the element.\n   */\n  style?: any;\n}\n\nexport const functionProps = (prop: string, val: any, data: any) => {\n  if (typeof val === 'function') {\n    return val(data);\n  } else if (prop === 'className') {\n    return classNames(val);\n  } else if (val !== undefined || val !== null) {\n    return val;\n  }\n\n  return {};\n};\n\nexport const constructFunctionProps = (\n  props: PropFunctionTypes,\n  data: any\n) => ({\n  className: functionProps('className', props.className, data),\n  style: functionProps('style', props.style, data)\n});\n","type AccessorCallback = (data: any) => any;\n\n/**\n * Given a dataset and a list of accessors, returns a unique collection.\n */\nexport function uniqueBy<T = any>(data: T[], ...accessors: AccessorCallback[]) {\n  const result: any[] = [];\n\n  const ittr = (arr: T[], depth: number) => {\n    for (const a of arr) {\n      const acc = accessors[depth];\n      if (acc === undefined) {\n        throw new Error(`Accessor not found for depth: ${depth}`);\n      }\n\n      const val = acc(a);\n      if (Array.isArray(val)) {\n        ittr(val, depth + 1);\n      } else if (!result.includes(val)) {\n        result.push(val);\n      }\n    }\n  };\n\n  ittr(data, 0);\n\n  return result;\n}\n","import React, { ReactElement } from 'react';\nimport { calculateDimensions } from './size';\n\nexport interface WrapTextInputs {\n  key: string;\n  x?: any;\n  paddingY?: number;\n  paddingX?: number;\n  width: number;\n  height?: number;\n  fontFamily: string;\n  fontSize: number;\n  wrap?: boolean;\n  size?: {\n    width: number;\n    height: number;\n  };\n  visibility?: 'auto' | 'always';\n}\n\nexport function wrapText({\n  key,\n  x = 0,\n  size,\n  paddingY,\n  wrap = true,\n  paddingX,\n  width,\n  height,\n  fontFamily,\n  fontSize,\n  visibility = 'auto'\n}: WrapTextInputs): ReactElement | ReactElement[] | null {\n  size = size || calculateDimensions(key, fontFamily, fontSize);\n  const words = key.toString().split(/\\s+/);\n\n  if (words.length > 1 && size.width > width) {\n    let rows = [];\n    let maxWidth = 0;\n    let maxHeight = 0;\n    let curText = '';\n    let currWidth = 0;\n    let nextText = '';\n    let nextWidth = 0;\n\n    for (const word of words) {\n      nextText = curText === '' ? word : `${curText} ${word}`;\n      nextWidth = calculateDimensions(nextText, fontFamily, fontSize).width;\n\n      if (nextWidth <= width - (paddingX ? 2 * paddingX : 0)) {\n        curText = nextText;\n        currWidth = nextWidth;\n      } else {\n        rows.push(curText);\n        maxWidth = Math.max(maxWidth, currWidth);\n        curText = word;\n        currWidth = calculateDimensions(curText, fontFamily, fontSize).width;\n      }\n    }\n    rows.push(curText);\n    maxHeight = rows.length * size.height;\n\n    if (visibility !== 'always') {\n      if (height && maxHeight >= height - (paddingY ? 2 * paddingY : 0)) {\n        return null;\n      }\n\n      if (width && maxWidth >= width - (paddingX ? 2 * paddingX : 0)) {\n        return null;\n      }\n    }\n\n    if (!wrap && rows.length > 1) {\n      return rows[0];\n    }\n\n    return rows.map((r, i) => (\n      <tspan\n        key={i}\n        dominantBaseline=\"alphabetic\"\n        style={{ baselineShift: '0%' }}\n        dy={\n          i > 0\n            ? size.height\n            : height\n              ? size.height / 2 - 5\n              : -maxHeight / 2 + size.height\n        }\n        x={x}\n      >\n        {r}\n      </tspan>\n    ));\n  }\n\n  if (visibility !== 'always') {\n    if (height && size.height + paddingY >= height) {\n      return null;\n    }\n\n    if (width && size.width + paddingX >= width) {\n      return null;\n    }\n  }\n\n  // NOTE: 5px seems to magic number for making it center\n  return (\n    <tspan\n      dominantBaseline=\"alphabetic\"\n      style={{ baselineShift: '0%' }}\n      dy={size.height / 2 - 5}\n      x={x}\n    >\n      {key}\n    </tspan>\n  );\n}\n","import React, { FC, Fragment, ReactElement } from 'react';\nimport {\n  RadialAxisTickSeries,\n  RadialAxisTickSeriesProps\n} from './RadialAxisTickSeries';\nimport {\n  RadialAxisArcSeries,\n  RadialAxisArcSeriesProps\n} from './RadialAxisArcSeries';\nimport { CloneElement } from 'reablocks';\nimport { getTicks } from '../../utils';\n\nexport interface RadialAxisProps {\n  /**\n   * Height of the axis.\n   */\n  height: number;\n\n  /**\n   * Width of the axis.\n   */\n  width: number;\n\n  /**\n   * Scale to use for the axis.\n   */\n  xScale: any;\n\n  /**\n   * Inner radius of the axis.\n   */\n  innerRadius: number;\n\n  /**\n   * Type of the axis.\n   */\n  type: 'value' | 'time' | 'category';\n\n  /**\n   * Arc element to render.\n   */\n  arcs: ReactElement<\n    RadialAxisArcSeriesProps,\n    typeof RadialAxisArcSeries\n  > | null;\n\n  /**\n   * Tick element to render.\n   */\n  ticks: ReactElement<\n    RadialAxisTickSeriesProps,\n    typeof RadialAxisTickSeries\n  > | null;\n\n  /**\n   * Start angle for the first value.\n   */\n  startAngle?: number;\n\n  /**\n   * End angle for the last value.\n   */\n  endAngle?: number;\n}\n\nexport const RadialAxis: FC<Partial<RadialAxisProps>> = ({\n  arcs,\n  ticks,\n  xScale,\n  height,\n  width,\n  innerRadius,\n  type,\n  startAngle,\n  endAngle\n}) => {\n  const outerRadius = Math.min(height, width) / 2;\n\n  // TODO: This is a hack to get the ticks in the parent\n  // component. This is because the ticks are needed\n  // for the arcs's lines.\n  const tickValues = getTicks(\n    xScale,\n    ticks.props.tickValues,\n    type,\n    ticks.props.count,\n    ticks.props.interval || ticks.props.count\n  );\n\n  return (\n    <Fragment>\n      {arcs && (\n        <CloneElement<RadialAxisArcSeriesProps>\n          element={arcs}\n          outerRadius={outerRadius}\n          innerRadius={innerRadius}\n          tickValues={tickValues}\n          startAngle={startAngle}\n          endAngle={endAngle}\n        />\n      )}\n      {ticks && (\n        <CloneElement<RadialAxisTickSeriesProps>\n          element={ticks}\n          scale={xScale}\n          type={type}\n          innerRadius={innerRadius}\n          outerRadius={outerRadius}\n          startAngle={startAngle}\n          endAngle={endAngle}\n        />\n      )}\n    </Fragment>\n  );\n};\n\nRadialAxis.defaultProps = {\n  innerRadius: 10,\n  type: 'value',\n  arcs: <RadialAxisArcSeries />,\n  ticks: <RadialAxisTickSeries />,\n  startAngle: 0,\n  endAngle: 2 * Math.PI\n};\n","import React, {\n  Children,\n  cloneElement,\n  PropsWithChildren,\n  FC,\n  useEffect,\n  useRef\n} from 'react';\nimport { toggleTextSelection } from '../utils/selection';\n\ninterface MoveProps extends PropsWithChildren {\n  cursor?: string;\n  disabled?: boolean;\n  preventRightClick: boolean;\n  disableText: boolean;\n  threshold: number;\n  onMoveStart: (event) => void;\n  onMove: (event) => void;\n  onMoveCancel: (event) => void;\n  onMoveEnd: (event) => void;\n}\n\nexport const Move: FC<Partial<MoveProps>> = (props) => {\n  let started = false;\n  let deltaX = 0;\n  let deltaY = 0;\n  let prevXPosition = 0;\n  let prevYPosition = 0;\n  const rqf = useRef<number>();\n\n  useEffect(() => {\n    return () => {\n      cancelAnimationFrame(rqf.current);\n      disposeHandlers();\n    };\n  }, []);\n\n  const disposeHandlers = () => {\n    window.removeEventListener('mousemove', onMouseMove);\n    window.removeEventListener('mouseup', onMouseUp);\n    window.removeEventListener('touchmove', onTouchMove);\n    window.removeEventListener('touchend', onTouchEnd);\n\n    setCursor(false);\n    disableText(true);\n  };\n\n  const disableText = (shouldDisable: boolean) => {\n    if (props.disableText) {\n      toggleTextSelection(shouldDisable);\n    }\n  };\n\n  const setCursor = (set: boolean) => {\n    let { cursor } = props;\n\n    if (cursor) {\n      if (!set) {\n        cursor = 'inherit';\n      }\n\n      document.body.style['cursor'] = cursor;\n    }\n  };\n\n  const checkThreshold = () => {\n    const { threshold } = props;\n\n    return (\n      !started && (Math.abs(deltaX) > threshold || Math.abs(deltaY) > threshold)\n    );\n  };\n\n  const getTouchCoords = (event) => {\n    const { clientX, clientY } = event.touches[0];\n    return {\n      clientX,\n      clientY\n    };\n  };\n\n  const onMouseDown = (event: React.MouseEvent) => {\n    const { preventRightClick, disabled } = props;\n\n    const shouldCancel = event.nativeEvent.which === 3 && preventRightClick;\n    if (shouldCancel || disabled) {\n      return;\n    }\n\n    event.preventDefault();\n    event.stopPropagation();\n\n    started = false;\n\n    // Always bind event so we cancel movement even if no action was taken\n    window.addEventListener('mousemove', onMouseMove);\n    window.addEventListener('mouseup', onMouseUp);\n  };\n\n  const onMouseMove = (event) => {\n    event.preventDefault();\n    event.stopPropagation();\n\n    const { movementX, movementY } = event;\n    let localDeltaX = deltaX + movementX;\n    let localDeltaY = deltaY + movementY;\n\n    if (checkThreshold()) {\n      disableText(true);\n      setCursor(true);\n\n      localDeltaX = 0;\n      localDeltaY = 0;\n      started = true;\n\n      props.onMoveStart({\n        nativeEvent: event,\n        type: 'mouse'\n      });\n    } else {\n      rqf.current = requestAnimationFrame(() => {\n        props.onMove({\n          nativeEvent: event,\n          type: 'mouse',\n          x: localDeltaX,\n          y: localDeltaY\n        });\n      });\n    }\n\n    deltaX = localDeltaX;\n    deltaY = localDeltaY;\n  };\n\n  const onMouseUp = (event) => {\n    event.preventDefault();\n    event.stopPropagation();\n\n    disposeHandlers();\n\n    if (started) {\n      props.onMoveEnd({\n        nativeEvent: event,\n        type: 'mouse'\n      });\n    } else {\n      props.onMoveCancel({\n        nativeEvent: event,\n        type: 'mouse'\n      });\n    }\n  };\n\n  const onTouchStart = (event: React.TouchEvent) => {\n    const { disabled } = props;\n\n    if (disabled || event.touches.length !== 1) {\n      return;\n    }\n\n    event.preventDefault();\n    event.stopPropagation();\n\n    started = false;\n    prevXPosition = event.touches[0].clientX;\n    prevYPosition = event.touches[0].clientY;\n\n    // Always bind event so we cancel movement even if no action was taken\n    window.addEventListener('touchmove', onTouchMove);\n    window.addEventListener('touchend', onTouchEnd);\n  };\n\n  const onTouchMove = (event: TouchEvent) => {\n    event.preventDefault();\n    event.stopPropagation();\n\n    // Calculate delta from previous position and current\n    const { clientX, clientY } = getTouchCoords(event);\n    let localDeltaX = clientX - prevXPosition;\n    let localDeltaY = clientY - prevYPosition;\n\n    // Track the delta\n    localDeltaX = localDeltaX + localDeltaX;\n    localDeltaY = localDeltaY + localDeltaY;\n\n    if (checkThreshold()) {\n      disableText(true);\n      setCursor(true);\n\n      localDeltaX = 0;\n      localDeltaY = 0;\n      started = true;\n\n      props.onMoveStart({\n        // TODO: Come back and clean this up...\n        nativeEvent: {\n          ...event,\n          clientX,\n          clientY\n        },\n        type: 'touch'\n      });\n    } else {\n      rqf.current = requestAnimationFrame(() => {\n        props.onMove({\n          // TODO: Come back and clean this up...\n          nativeEvent: {\n            ...event,\n            clientX,\n            clientY\n          },\n          type: 'touch',\n          x: localDeltaX,\n          y: localDeltaY\n        });\n      });\n    }\n\n    prevXPosition = clientX;\n    prevYPosition = clientY;\n  };\n\n  const onTouchEnd = (event: TouchEvent) => {\n    event.preventDefault();\n    event.stopPropagation();\n    disposeHandlers();\n\n    if (started) {\n      props.onMoveEnd({\n        nativeEvent: event,\n        type: 'touch'\n      });\n    } else {\n      props.onMoveCancel({\n        nativeEvent: event,\n        type: 'touch'\n      });\n    }\n  };\n\n  return Children.map(props.children, (child: any) =>\n    cloneElement(child, {\n      ...child.props,\n      onMouseDown: (e) => {\n        onMouseDown(e);\n        if (child.props.onMouseDown) {\n          child.props.onMouseDown(e);\n        }\n      },\n      onTouchStart: (e) => {\n        onTouchStart(e);\n        if (child.props.onTouchStart) {\n          child.props.onTouchStart(e);\n        }\n      }\n    })\n  );\n};\n\nMove.defaultProps = {\n  preventRightClick: true,\n  disableText: true,\n  threshold: 0,\n  onMoveStart: () => undefined,\n  onMove: () => undefined,\n  onMoveEnd: () => undefined,\n  onMoveCancel: () => undefined\n};\n","import React, { FC, useState } from 'react';\nimport classNames from 'classnames';\nimport { range } from 'd3-array';\nimport { Move } from '../Gestures/Move';\nimport css from './BrushHandle.module.css';\n\nexport interface BrushHandleProps {\n  height: number;\n  onHandleDrag: (deltaX: number) => void;\n}\n\nexport const BrushHandle: FC<BrushHandleProps> = (props) => {\n  const { height, onHandleDrag } = props;\n  const [isDragging, setIsDragging] = useState(false);\n\n  return (\n    <Move\n      cursor=\"ew-resize\"\n      onMoveStart={() => setIsDragging(true)}\n      onMove={({x}) =>  onHandleDrag(x)}\n      onMoveEnd={() =>  setIsDragging(false)}\n    >\n      <g>\n        <line className={css.line} y1=\"0\" y2={height} x1=\"5\" x2=\"5\" />\n        <rect\n          className={classNames(css.handle, { [css.dragging]: isDragging })}\n          height={height - 10}\n          style={{ cursor: 'ew-resize' }}\n          width={8}\n          y=\"5\"\n          y1={height - 5}\n        />\n        <g\n          transform={`translate(-1, ${height / 2 - 10})`}\n          style={{ pointerEvents: 'none' }}\n        >\n          {range(5).map((i) => (\n            <circle cy={i * 5} cx=\"5\" r=\".5\" key={i} className={css.dot} />\n          ))}\n        </g>\n      </g>\n    </Move>\n  );\n};\n\nBrushHandle.defaultProps = {};\n\n","import React, { Fragment, useState, FC, useCallback } from 'react';\nimport { BrushHandle } from './BrushHandle';\nimport { Move } from '../Gestures/Move';\nimport css from './BrushSlice.module.css';\n\nexport interface BrushChangeEvent {\n  start?: number;\n  end?: number;\n}\n\ninterface BrushSliceProps {\n  height: number;\n  width: number;\n  start: number;\n  end: number;\n  onBrushChange: (event: BrushChangeEvent) => void;\n}\n\nexport const BrushSlice: FC<BrushSliceProps> = (props) => {\n  const { height, start, end, width, onBrushChange, } = props;\n  const [isDragging, setIsDragging] = useState(false);\n  const sliceWidth = Math.max(end - start, 0);\n  const endSliceWidth = Math.max(width - end, 0);\n  const hasNoSlice = start === 0 && end === width;\n\n  const onMoveStart = useCallback(() =>  {\n    const hasNoSlice = start === 0 && end === width;\n\n    if (!hasNoSlice) {\n      setIsDragging(true);\n    }\n  }, [end, start, width]);\n\n  const onMove = useCallback(({ x }) => {\n    const startUpdated = start + x;\n    const endUpdated = end + x;\n\n    if (startUpdated >= 0 && endUpdated <= width) {\n      onBrushChange({\n        start: startUpdated,\n        end: endUpdated\n      });\n    }\n  }, [start, end, width, onBrushChange]);\n\n  const onHandleDrag = useCallback((direction: 'start' | 'end', deltaX: number) => {\n    const startUpdated = direction === 'start' ? start + deltaX : start;\n    const endUpdated = direction !== 'start' ? end + deltaX : end;\n\n    onBrushChange({\n      start: startUpdated,\n      end: endUpdated\n    });\n  }, [end, onBrushChange, start]);\n\n  return (\n    <Fragment>\n      <rect className={css.unsliced} height={height} width={start} />\n      <rect\n        transform={`translate(${end}, 0)`}\n        className={css.unsliced}\n        height={height}\n        width={endSliceWidth}\n      />\n      <g transform={`translate(${start}, 0)`}>\n        <Move\n          cursor=\"grabbing\"\n          onMoveStart={onMoveStart}\n          onMove={onMove}\n          onMoveEnd={() => setIsDragging(false)}\n        >\n          <rect\n            className={css.slice}\n            height={height}\n            width={sliceWidth}\n            style={{\n              cursor: isDragging ? 'grabbing' : 'grab',\n              opacity: hasNoSlice ? 0 : 0.1,\n              pointerEvents: !hasNoSlice ? 'initial' : 'none'\n            }}\n          />\n        </Move>\n        <g transform={'translate(-4, 0)'}>\n          <BrushHandle\n            height={height}\n            onHandleDrag={(deltaX) => onHandleDrag('start', deltaX)}\n          />\n        </g>\n        <g transform={`translate(${sliceWidth - 5}, 0)`}>\n          <BrushHandle\n            height={height}\n            onHandleDrag={(deltaX) => onHandleDrag('end', deltaX)}\n          />\n        </g>\n      </g>\n    </Fragment>\n  );\n};\n\nBrushSlice.defaultProps = {};\n","import React, { useState, useEffect, useRef, FC, PropsWithChildren, useCallback } from 'react';\nimport bind from 'memoize-bind';\nimport { getPositionForTarget } from '../utils/position';\nimport { BrushSlice, BrushChangeEvent } from './BrushSlice';\nimport { ChartDataTypes } from '../data';\nimport { Move } from '../Gestures/Move';\n\nexport interface BrushConfiguration {\n  disabled?: boolean;\n  fill?: string;\n  domain?: [ChartDataTypes, ChartDataTypes];\n  onBrushChange?: (e) => void;\n}\n\ninterface BrushProps extends PropsWithChildren {\n  height: number;\n  width: number;\n  disabled?: boolean;\n  start?: number;\n  end?: number;\n  onBrushChange?: (e: BrushChangeEvent) => void;\n}\n\ninterface BrushState {\n  start?: number;\n  end?: number;\n}\n\nexport const Brush: FC<Partial<BrushProps>> = (props) => {\n  const { children, disabled, height, width, start: startProp, end: endProp, onBrushChange } = props;\n  const [isSlicing, setIsSlicing] = useState(false);\n  const [initial, setInitial] = useState<number>();\n  const [range, setRange] = useState<BrushState>({\n    start: props.start || 0,\n    end: props.end || props.width,\n  });\n  const { start, end } = range;\n\n  const ref = useRef<any>();\n\n  const ensurePositionInBounds = useCallback((\n    newStart?: number,\n    newEnd?: number,\n  ) => {\n    let startUpdated = newStart;\n    let endUpdated = newEnd;\n\n    if (startUpdated === undefined || startUpdated <= 0) {\n      startUpdated = 0;\n    }\n\n    if (end === undefined) {\n      endUpdated = width;\n    }\n\n    if (startUpdated > endUpdated) {\n      startUpdated = start;\n    }\n\n    if (endUpdated < startUpdated) {\n      endUpdated = end;\n    }\n\n    if (endUpdated >= width) {\n      endUpdated = width;\n    }\n\n    return { start: startUpdated, end: endUpdated };\n  }, [end, start, width]);\n\n  const getPositionsForPanEvent = useCallback((event: any) => {\n    const eventObj = {\n      target: ref.current,\n      clientX: event.clientX,\n      clientY: event.clientY,\n    };\n\n    return getPositionForTarget(eventObj);\n  }, []);\n\n  const getStartEnd = useCallback((event: any) => {\n    const { x } = getPositionsForPanEvent(event);\n\n    if (x < initial) {\n      return ensurePositionInBounds(x, initial);\n    } else {\n      return ensurePositionInBounds(initial, x);\n    }\n  }, [ensurePositionInBounds, getPositionsForPanEvent, initial]);\n\n  const onMoveStart = useCallback((event: any) => {\n    if (!disabled) {\n      const positions = getPositionsForPanEvent(event.nativeEvent);\n\n      setIsSlicing(true);\n      setInitial(positions.x);\n    }\n  }, [disabled, getPositionsForPanEvent]);\n\n  const onMove = useCallback((event: any) => {\n    if (!disabled) {\n      const { start, end } = getStartEnd(event.nativeEvent);\n\n      if (onBrushChange) {\n        onBrushChange({\n          start,\n          end,\n        });\n      }\n\n      setRange({start, end});\n    }\n  }, [disabled, getStartEnd, onBrushChange]);\n\n  const onMoveEnd = useCallback(() => {\n    setIsSlicing(false);\n  }, []);\n\n  const onMoveCancel = useCallback(() => {\n    const val = {\n      start: 0,\n      end: width,\n    };\n\n    setRange(val);\n\n    if (onBrushChange) {\n      onBrushChange(val);\n    }\n  }, [onBrushChange, width]);\n\n  const onSliceChange = useCallback((event: BrushChangeEvent) => {\n    const val = ensurePositionInBounds(event.start, event.end);\n\n    setRange((state) => ({...state, ...val}));\n\n    if (onBrushChange) {\n      onBrushChange(val);\n    }\n  }, [ensurePositionInBounds, onBrushChange]);\n\n  useEffect(() => {\n    if (end === width) {\n      setRange((prev) => ({\n        ...prev,\n        end: width,\n      }));\n    }\n  }, [end, width]);\n\n  useEffect(() => {\n    // Don't update if we are doing the slicing\n    if (!isSlicing) {\n      const startUpdated = startProp !== start;\n      const endUpdated = endProp !== end;\n\n      if (startUpdated || endUpdated) {\n        setRange(ensurePositionInBounds(start, end));\n      }\n    }\n  }, [end, endProp, ensurePositionInBounds, isSlicing, start, startProp]);\n\n  return (\n    <Move\n      cursor=\"crosshair\"\n      onMoveStart={bind(onMoveStart, this)}\n      onMove={bind(onMove, this)}\n      onMoveEnd={bind(onMoveEnd, this)}\n      onMoveCancel={bind(onMoveCancel, this)}\n    >\n      <g\n        style={{\n          pointerEvents: isSlicing ? 'none' : 'auto',\n          cursor: disabled ? '' : 'crosshair',\n        }}\n      >\n        {children}\n        {!disabled && (\n          <>\n            <rect\n              ref={ref}\n              height={height}\n              width={width}\n              opacity={0}\n            />\n            {start !== undefined && end !== undefined && (\n              <BrushSlice\n                start={start}\n                end={end}\n                height={height}\n                width={width}\n                onBrushChange={bind(onSliceChange, this)}\n              />\n            )}\n          </>\n        )}\n      </g>\n    </Move>\n  );\n};","import React, { FC, PropsWithChildren, useCallback } from 'react';\nimport { BrushConfiguration, Brush } from './Brush';\nimport { BrushChangeEvent } from './BrushSlice';\n\nexport interface ChartBrushProps extends BrushConfiguration, PropsWithChildren {\n  scale: any;\n  height: number;\n  width: number;\n  children: any;\n}\n\nexport const ChartBrush: FC<Partial<ChartBrushProps>> = (props) => {\n  const { disabled, domain, scale, onBrushChange, width, children } = props;\n\n  const getBrushOffset = useCallback(() => {\n    let start;\n    let end;\n\n    if (!disabled && domain) {\n      start = scale(domain[0]);\n      end = scale(domain[1]);\n    }\n\n    return { start, end };\n  }, [disabled, domain, scale]);\n\n  const onBrushChangeHandler = useCallback((event: BrushChangeEvent) => {\n    if (onBrushChange) {\n      let domain;\n\n      if (\n        event.start !== undefined &&\n        event.end !== undefined &&\n        (event.start !== 0 || event.end !== width)\n      ) {\n        if (scale.invert) {\n          const start = scale.invert(event.start);\n          const end = scale.invert(event.end);\n          domain = [start, end];\n        } else {\n          // invert scaleBend\n          const band = scale.step();\n          const start = Math.ceil((event.start - band / 2) / band);\n          const end = Math.ceil((event.end - band / 2) / band);\n\n          domain = [scale.domain()[start], scale.domain()[end]];\n        }\n      }\n\n      onBrushChange({\n        domain\n      });\n    }\n  }, [onBrushChange, scale, width]);\n\n  return (\n    <Brush\n      {...props}\n      {...getBrushOffset()}\n      onBrushChange={onBrushChangeHandler}\n    >\n      {children}\n    </Brush>\n  );\n};\n\n\nChartBrush.defaultProps = {};\n","import { createContext, useContext } from 'react';\nimport { Dimensions } from '../utils';\nimport { LinearAxisDimensionChanged } from '../Axis';\n\nexport interface ChartContextProps extends Dimensions {\n  id: string;\n  chartSized?: boolean;\n  yAxisSized?: boolean;\n  xAxisSized?: boolean;\n  updateAxes: (\n    orientation: 'horizontal' | 'vertical',\n    event: LinearAxisDimensionChanged\n  ) => void;\n}\n\nexport const ChartContext = createContext<Partial<ChartContextProps>>({});\n\nexport const { Provider: ChartProvider, Consumer: ChartConsumer } =\n  ChartContext;\n\nexport const useChart = () => {\n  const context = useContext(ChartContext);\n\n  if (context === undefined) {\n    throw new Error('`useChart` hook must be used within a `ChartProvider`');\n  }\n\n  return context;\n};\n","import React, { FC, useCallback, useState, useMemo } from 'react';\nimport { Margins, getDimension } from '../utils/dimensions';\nimport useDimensions from 'react-cool-dimensions';\nimport { useId } from 'reablocks';\nimport { LinearAxisDimensionChanged } from '../Axis';\nimport classNames from 'classnames';\nimport { ChartContextProps, ChartProvider } from './ChartContext';\nimport css from './ChartContainer.module.css';\n\nexport interface ChartProps {\n  /**\n   * Id of the chart.\n   */\n  id?: string;\n\n  /**\n   * Width of the chart. If not provided will autosize.\n   */\n  width?: number;\n\n  /**\n   * Height of the chart. If not provided will autosize.\n   */\n  height?: number;\n\n  /**\n   * Margins for the chart.\n   */\n  margins?: Margins;\n\n  /**\n   * Classnames for the chart.\n   */\n  className?: string;\n\n  /**\n   * Classnames for the chart.\n   */\n  containerClassName?: string;\n\n  /**\n   * Additional css styles.\n   */\n  style?: React.StyleHTMLAttributes<SVGSVGElement>;\n\n  /**\n   * Center the chart. Used mainly internally.\n   */\n  center?: boolean;\n\n  /**\n   * Center chart on X Axis only. Used mainly internally.\n   */\n  centerX?: boolean;\n\n  /**\n   * Center chart on Y Axis only. Used mainly internally.\n   */\n  centerY?: boolean;\n}\n\nexport interface ChartContainerProps extends ChartProps {\n  /**\n   * Internal property to identify if the xAxis is visible.\n   */\n  xAxisVisible?: boolean;\n\n  /**\n   * Internal property to identify if the xAxis is visible.\n   */\n  yAxisVisible?: boolean;\n\n  /**\n   * Children elements to recieve the calculated props.\n   */\n  children: (props: ChartContainerChildProps) => any;\n}\n\nexport type ChartContainerChildProps = ChartContextProps;\n\nexport const ChartContainer: FC<ChartContainerProps> = ({\n  className,\n  children,\n  center,\n  centerX,\n  centerY,\n  style,\n  margins,\n  containerClassName,\n  xAxisVisible,\n  yAxisVisible,\n  id,\n  ...rest\n}) => {\n  const curId = useId(id);\n  const [xAxisSized, setXAxisSized] = useState<boolean>(false);\n  const [yAxisSized, setYAxisSized] = useState<boolean>(false);\n  const [xOffset, setXOffset] = useState<number>(0);\n  const [yOffset, setYOffset] = useState<number>(0);\n  const { observe, width, height } = useDimensions<HTMLDivElement>();\n\n  const chartSized = useMemo(() => {\n    if (!height || !width) {\n      return false;\n    }\n\n    // TODO: @amcdnl refactor this to account for 0-2 axises on x/y\n    if (xAxisVisible && !xAxisSized) {\n      return false;\n    }\n\n    if (yAxisVisible && !yAxisSized) {\n      return false;\n    }\n\n    return true;\n  }, [height, width, xAxisSized, xAxisVisible, yAxisVisible, yAxisSized]);\n\n  const onUpdateAxes = useCallback(\n    (\n      orientation: 'horizontal' | 'vertical',\n      event: LinearAxisDimensionChanged\n    ) => {\n      if (orientation === 'horizontal') {\n        setXAxisSized(true);\n      } else {\n        setYAxisSized(true);\n      }\n\n      if (event.height) {\n        setYOffset(event.height);\n      }\n\n      if (event.width) {\n        setXOffset(event.width);\n      }\n    },\n    []\n  );\n\n  const childProps: ChartContainerChildProps = useMemo(\n    () => ({\n      chartSized,\n      id: curId,\n      updateAxes: onUpdateAxes,\n      yAxisSized,\n      xAxisSized,\n      ...getDimension({\n        margins,\n        height,\n        width,\n        yOffset,\n        xOffset\n      })\n    }),\n    [\n      chartSized,\n      curId,\n      onUpdateAxes,\n      yAxisSized,\n      xAxisSized,\n      margins,\n      height,\n      width,\n      yOffset,\n      xOffset\n    ]\n  );\n\n  const translateX = center || centerX ? width / 2 : childProps.xMargin;\n  const translateY = center || centerY ? height / 2 : childProps.yMargin;\n\n  const styleHeight =\n    rest.height !== undefined && rest.height !== null ? rest.height : '100%';\n  const styleWidth =\n    rest.width !== undefined && rest.width !== null ? rest.width : '100%';\n\n  return (\n    <div\n      ref={observe}\n      style={{ height: styleHeight, width: styleWidth }}\n      className={classNames(containerClassName, css.container)}\n      {...rest}\n    >\n      <ChartProvider value={childProps}>\n        {height > 0 && width > 0 && (\n          <svg\n            width={width}\n            height={height}\n            className={classNames(css.svg, className)}\n            style={style}\n            tabIndex={0}\n          >\n            <g transform={`translate(${translateX}, ${translateY})`}>\n              {children(childProps)}\n            </g>\n          </svg>\n        )}\n      </ChartProvider>\n    </div>\n  );\n};\n","import bigInt from 'big-integer';\nimport { bigIntegerToLocaleString } from '../../common/utils/bigint';\nimport {\n  ChartDataTypes,\n  ChartInternalDataTypes,\n  ChartNestedDataShape,\n  ChartShallowDataShape\n} from './types';\n\nexport function normalizeValue(\n  value: ChartDataTypes,\n  maxBigInt: bigInt.BigInteger\n): ChartInternalDataTypes {\n  if (bigInt.isInstance(value)) {\n    if (maxBigInt.greater(1000000)) {\n      const divideBy = maxBigInt.divide(1000000);\n      return (value as bigInt.BigInteger).divide(divideBy).toJSNumber();\n    } else {\n      return (value as bigInt.BigInteger).toJSNumber();\n    }\n  } else {\n    return value as ChartInternalDataTypes;\n  }\n}\n\nexport function normalizeValueForFormatting(\n  value: ChartDataTypes\n): ChartInternalDataTypes {\n  if (bigInt.isInstance(value)) {\n    return bigIntegerToLocaleString(value as bigInt.BigInteger);\n  }\n  return value as ChartInternalDataTypes;\n}\n\nexport function getMaxBigIntegerForNested(series: ChartNestedDataShape[]) {\n  let maxBigInteger = bigInt.one;\n  for (const group of series) {\n    const maxBigIntegerForGroup = getMaxBigIntegerForShallow(group.data);\n    if (maxBigIntegerForGroup.greater(maxBigInteger)) {\n      maxBigInteger = maxBigIntegerForGroup;\n    }\n  }\n  return maxBigInteger;\n}\n\nexport function getMaxBigIntegerForShallow(series: ChartShallowDataShape[]) {\n  let maxBigInteger = bigInt.one;\n  for (const point of series) {\n    if (bigInt.isInstance(point.data)) {\n      const bigInteger = point.data as bigInt.BigInteger;\n      if (bigInteger.greater(maxBigInteger)) {\n        maxBigInteger = bigInteger;\n      }\n    }\n  }\n  return maxBigInteger;\n}\n","import { median } from 'd3-array';\nimport {\n  ChartInternalNestedDataShape,\n  ChartShallowDataShape,\n  ChartNestedDataShape,\n  ChartInternalShallowDataShape,\n  ChartDataTypes\n} from './types';\nimport {\n  getMaxBigIntegerForNested,\n  getMaxBigIntegerForShallow,\n  normalizeValue,\n  normalizeValueForFormatting\n} from './bigInteger';\nimport bigInt from 'big-integer';\n\nexport type Direction = 'vertical' | 'horizontal';\n\n/**\n * Accepts a `ChartDataShape` and transforms it to a chart readable data shape.\n *\n * Example:\n *\n *   [{\n *    key: 'Threat Intel',\n *    data: [{ key:'2011', data: 25 }]\n *   }]\n *\n * will be transformed to:\n *\n *  [{\n *    key: 'Threat Intel',\n *    data: [\n *      key: 'Threat Intel',\n *      x: '2011',\n *      y: 25\n *    ]\n *  }]\n */\nexport function buildNestedChartData(\n  series: ChartNestedDataShape[],\n  sort = false,\n  direction: Direction = 'vertical'\n): ChartInternalNestedDataShape[] {\n  let result: ChartInternalNestedDataShape[] = [];\n  const maxBigInteger = getMaxBigIntegerForNested(series);\n  const isVertical = direction === 'vertical';\n\n  for (const point of series) {\n    for (const nestedPoint of point.data) {\n      const key = normalizeValueForFormatting(point.key);\n      let idx = result.findIndex((r) => {\n        const left = r.key;\n        if (left instanceof Date && key instanceof Date) {\n          return left.getTime() === key.getTime();\n        }\n        return left === key;\n      });\n\n      if (idx === -1) {\n        result.push({\n          key,\n          metadata: point.metadata,\n          data: []\n        });\n\n        idx = result.length - 1;\n      }\n\n      const x = normalizeValue(\n        isVertical ? nestedPoint.key : nestedPoint.data,\n        maxBigInteger\n      );\n\n      const y = normalizeValue(\n        isVertical ? nestedPoint.data : nestedPoint.key,\n        maxBigInteger\n      );\n\n      result[idx].data.push({\n        key,\n        value: normalizeValueForFormatting(nestedPoint.data),\n        metadata: nestedPoint.metadata,\n        id: point.id,\n        x,\n        x0: isVertical ? x : 0,\n        x1: x,\n        y,\n        y0: isVertical ? 0 : y,\n        y1: y\n      });\n    }\n  }\n\n  // Sort the series data based on the median value\n  if (sort) {\n    result = result.sort((a, b) => {\n      const aMax = median(a.data, (d: any) => d.y)!;\n      const bMax = median(b.data, (d: any) => d.y)!;\n      return aMax < bMax ? 1 : -1;\n    });\n  }\n\n  return result;\n}\n\nfunction addToChartType(\n  a: ChartDataTypes,\n  b: number | bigInt.BigInteger\n): ChartDataTypes {\n  if (bigInt.isInstance(a) && bigInt.isInstance(b)) {\n    return (a as bigInt.BigInteger).add(b as bigInt.BigInteger);\n  } else if (a instanceof Date && typeof b === 'number') {\n    return new Date(a.valueOf() + b);\n  } else if (typeof a === 'number' && typeof b === 'number') {\n    return a + b;\n  } else {\n    throw new Error('Invalid types to addToChartTypes');\n  }\n}\n\n/**\n * Accepts a shallow shape and normalizes it to a chart readable format.\n */\nexport function buildShallowChartData(\n  series: ChartShallowDataShape[],\n  direction: Direction = 'vertical',\n  binSize: number | undefined = undefined\n): ChartInternalShallowDataShape[] {\n  const result: ChartInternalShallowDataShape[] = [];\n  const maxBigInteger = getMaxBigIntegerForShallow(series);\n  const isVertical = direction === 'vertical';\n\n  for (const point of series) {\n    const isTuple = Array.isArray(point.data);\n    let k1 = point.key;\n    if (binSize) {\n      k1 = addToChartType(point.key, binSize);\n    }\n\n    const props = {\n      k0: normalizeValue(point.key, maxBigInteger),\n      k1: normalizeValue(k1, maxBigInteger),\n      v0: normalizeValue(isTuple ? point.data[0] : 0, maxBigInteger),\n      v1: normalizeValue(isTuple ? point.data[1] : point.data, maxBigInteger)\n    };\n\n    const xProp = isVertical ? 'k' : 'v';\n    const yProp = isVertical ? 'v' : 'k';\n\n    result.push({\n      key: normalizeValueForFormatting(props.k0),\n      value: normalizeValueForFormatting(props.v1),\n      metadata: point.metadata,\n      id: point.id,\n      x: props[`${xProp}1`],\n      x0: props[`${xProp}0`],\n      x1: props[`${xProp}1`],\n      y: props[`${yProp}1`],\n      y0: props[`${yProp}0`],\n      y1: props[`${yProp}1`]\n    });\n  }\n\n  return result;\n}\n","import { histogram } from 'd3-array';\nimport { ChartInternalShallowDataShape, ChartInternalDataTypes } from './types';\n\n/**\n * Build a histogram given data set.\n */\nexport function buildBins(\n  xScale,\n  thresholds,\n  data: any[]\n): ChartInternalShallowDataShape[] {\n  const layout = histogram()\n    .value((d: any) => d.x)\n    .domain(xScale.domain())\n    .thresholds(xScale.ticks(thresholds));\n\n  const bins = layout(data as any);\n\n  return bins.map((bin) => ({\n    x0: bin.x0 as ChartInternalDataTypes,\n    x1: bin.x1 as ChartInternalDataTypes,\n    y: bin.length,\n    y0: 0,\n    y1: bin.length\n  }));\n}\n","import { stack, stackOffsetExpand, stackOffsetDiverging } from 'd3-shape';\nimport { ChartNestedDataShape, ChartInternalNestedDataShape } from './types';\nimport {\n  getMaxBigIntegerForNested,\n  normalizeValue,\n  normalizeValueForFormatting\n} from './bigInteger';\nimport { uniqueBy } from '../../common/utils/array';\n\nexport type StackTypes = 'default' | 'expand' | 'diverging';\n\n/**\n * Given a dataset like:\n *\n *   [{\n *    key: 'Threat Intel',\n *    data: [{ key:'2011', data: 25 }]\n *   }]\n *\n * it will transform it to:\n *\n *  [\n *    { x: 'Theat Intel', '2011': 25 }\n *  ]\n */\nfunction transformDataToStack(data: ChartNestedDataShape[]) {\n  const result: any[] = [];\n  const maxBigInteger = getMaxBigIntegerForNested(data);\n\n  for (const category of data) {\n    for (const value of category.data) {\n      let idx = result.findIndex((r) => {\n        if (r.x instanceof Date && category.key instanceof Date) {\n          return r.x.getTime() === category.key.getTime();\n        }\n        return r.x === category.key;\n      });\n\n      if (idx === -1) {\n        result.push({\n          metadata: category.metadata,\n          x: category.key,\n          formattedValues: {}\n        });\n\n        idx = result.length - 1;\n      }\n\n      result[idx].metadata = value.metadata;\n\n      result[idx][value.key as string] = normalizeValue(\n        value.data,\n        maxBigInteger\n      );\n\n      result[idx].formattedValues[value.key as string] =\n        normalizeValueForFormatting(value.data);\n    }\n  }\n\n  return result;\n}\n\n/**\n * Translates the stack data to a chart standard dataset.\n */\nfunction transformStackToData(\n  stackData,\n  direction = 'vertical'\n): ChartInternalNestedDataShape[] {\n  const result: ChartInternalNestedDataShape[] = [];\n  const isVertical = direction === 'vertical';\n\n  // Transform the data from the d3 stack format to our internal format\n  for (const category of stackData) {\n    for (const point of category) {\n      const key = point.data.x;\n\n      let idx = result.findIndex((r) => {\n        if (r.key instanceof Date && key instanceof Date) {\n          return r.key.getTime() === key.getTime();\n        }\n        return r.key === key;\n      });\n\n      if (idx === -1) {\n        result.push({\n          key,\n          data: []\n        });\n\n        idx = result.length - 1;\n      }\n\n      const categoryKey = category.key;\n      const y = point.data[categoryKey];\n      const [y0, y1] = point;\n\n      result[idx].data.push({\n        metadata: point.data.metadata,\n        key,\n        x: isVertical ? categoryKey : y1,\n        x0: isVertical ? categoryKey : y0,\n        x1: isVertical ? categoryKey : y1,\n        y: isVertical ? y : categoryKey,\n        y0: isVertical ? y0 : categoryKey,\n        y1: isVertical ? y1 : categoryKey,\n        value: point.data.formattedValues[categoryKey]\n      });\n    }\n  }\n\n  return result;\n}\n\n/**\n * Builds a stack dataset from the standard data format.\n */\nexport function buildBarStackData(\n  data: ChartNestedDataShape[] = [],\n  offset: StackTypes = 'default',\n  direction = 'vertical'\n) {\n  const keys = uniqueBy<ChartNestedDataShape>(\n    data,\n    (d) => d.data,\n    (d) => d.key\n  );\n  const stackData = transformDataToStack(data);\n\n  let stackFn = stack();\n  if (offset === 'expand') {\n    stackFn = stackFn.offset(stackOffsetExpand);\n  } else if (offset === 'diverging') {\n    stackFn = stackFn.offset(stackOffsetDiverging);\n  }\n\n  const result = stackFn.keys(keys)(stackData);\n\n  return transformStackToData(result, direction);\n}\n","import { ChartNestedDataShape, ChartInternalNestedDataShape } from './types';\nimport { buildBarStackData } from './barStack';\n\n/**\n * Builds a stack dataset from the standard data format.\n */\nexport function buildMarimekkoData(\n  data: ChartNestedDataShape[] = []\n): ChartInternalNestedDataShape[] {\n  const result = buildBarStackData(data, 'expand');\n  const sums = {};\n\n  // Calculate the sum for each series and the total sum\n  let totalSum = 0;\n  for (const series of result) {\n    const sum = series.data.reduce((acc, cur) => acc + (cur.y as number), 0);\n\n    sums[series.key as string] = sum;\n    totalSum += sum;\n  }\n\n  // Calculate the x0/x1 for each series\n  let prev = 0;\n  for (const series of result) {\n    const x0 = prev;\n    const x1 = prev + sums[series.key as string] / totalSum;\n    prev = x1;\n\n    for (const point of series.data) {\n      point.x0 = x0;\n      point.x1 = x1;\n    }\n  }\n\n  return result;\n}\n","import { stack, stackOffsetExpand } from 'd3-shape';\nimport {\n  ChartNestedDataShape,\n  ChartInternalDataShape,\n  ChartInternalNestedDataShape,\n  ChartInternalShallowDataShape\n} from './types';\nimport {\n  getMaxBigIntegerForNested,\n  normalizeValue,\n  normalizeValueForFormatting\n} from './bigInteger';\nimport { uniqueBy } from '../../common/utils/array';\n\n/**\n * Given a dataset like:\n *\n *   [{\n *    key: 'Threat Intel',\n *    data: [{ key:'2011', data: 25 }]\n *   }]\n *\n * it will transform it to:\n *\n *  [\n *    { x: '2011', 'Theat Intel': 25 }\n *  ]\n */\nfunction transformDataToStack(data) {\n  const result: any[] = [];\n  const maxBigInteger = getMaxBigIntegerForNested(data);\n\n  for (const category of data) {\n    for (const value of category.data) {\n      let idx = result.findIndex((r) => {\n        if (r.x instanceof Date && value.key instanceof Date) {\n          return r.x.getTime() === value.key.getTime();\n        }\n        return r.x === value.key;\n      });\n\n      if (idx === -1) {\n        result.push({\n          x: value.key,\n          formattedValues: {}\n        });\n\n        idx = result.length - 1;\n      }\n\n      result[idx][category.key as string] = normalizeValue(\n        value.data,\n        maxBigInteger\n      );\n      result[idx].formattedValues[\n        category.key as string\n      ] = normalizeValueForFormatting(value.data);\n    }\n  }\n\n  return result;\n}\n\n/**\n * Translates the stack data to a chart standard dataset.\n */\nfunction transformStackToData(stackData): ChartInternalNestedDataShape[] {\n  const result: ChartInternalNestedDataShape[] = [];\n\n  for (const category of stackData) {\n    const series: ChartInternalShallowDataShape[] = [];\n\n    for (const point of category) {\n      const [y0, y1] = point;\n      const x = point.data.x;\n      series.push({\n        key: category.key,\n        x,\n        x0: x,\n        x1: x,\n        y: y1 - y0,\n        y0,\n        y1,\n        value: point.data.formattedValues[category.key]\n      });\n    }\n\n    result.push({\n      key: category.key,\n      data: series\n    });\n  }\n\n  return result;\n}\n\n/**\n * Builds a stack dataset from the standard data format.\n */\nexport function buildStackData(\n  data: ChartNestedDataShape[],\n  normalized = false\n): ChartInternalDataShape[] {\n  const keys = uniqueBy<ChartNestedDataShape>(data, (d) => d.key);\n  const stackData = transformDataToStack(data);\n  const stackFn = !normalized ? stack() : stack().offset(stackOffsetExpand);\n\n  const result = stackFn.keys(keys)(stackData);\n\n  return transformStackToData(result);\n}\n","import { ChartShallowDataShape } from './types';\nimport { Direction, buildShallowChartData } from './builder';\n\nexport const buildWaterfall = (\n  series: ChartShallowDataShape[],\n  direction: Direction = 'vertical',\n  binSize: number | undefined = undefined\n) => {\n  const data = buildShallowChartData(series, direction, binSize);\n  const isVertical = direction === 'vertical';\n  const v = isVertical ? 'y' : 'x';\n\n  let cumulative = 0;\n  for (const point of data) {\n    point[`${v}0`] = cumulative;\n    cumulative += point[v] as number;\n    point[`${v}1`] = cumulative;\n    point[v] = cumulative;\n  }\n\n  return data;\n};\n","import React, { Component, PropsWithChildren, createRef } from 'react';\nimport { toggleTextSelection } from '../utils/selection';\nimport { smoothMatrix, transform, translate } from 'transformation-matrix';\nimport { constrainMatrix } from '../utils/position';\n\ninterface PanProps extends PropsWithChildren {\n  disabled: boolean;\n  threshold: number;\n  cursor?: string;\n  x: number;\n  y: number;\n  scale: number;\n  matrix: any;\n  width: number;\n  height: number;\n  constrain: boolean;\n  globalPanning: boolean;\n  onPanStart: (event: PanStartEvent) => void;\n  onPanMove: (event: PanMoveEvent) => void;\n  onPanEnd: (event: PanEndEvent) => void;\n  onPanCancel: (event: PanCancelEvent) => void;\n}\n\nexport interface PanStartEvent {\n  source: 'mouse' | 'touch';\n  nativeEvent: MouseEvent | TouchEvent;\n}\n\nexport interface PanMoveEvent {\n  source: 'mouse' | 'touch';\n  x: number;\n  y: number;\n  nativeEvent: MouseEvent | TouchEvent;\n}\n\nexport interface PanEndEvent {\n  source: 'mouse' | 'touch';\n  nativeEvent: MouseEvent | TouchEvent;\n}\n\nexport interface PanCancelEvent {\n  source: 'mouse' | 'touch';\n  nativeEvent: MouseEvent | TouchEvent;\n}\n\nexport class Pan extends Component<PanProps> {\n  static defaultProps: Partial<PanProps> = {\n    x: 0,\n    y: 0,\n    disabled: false,\n    scale: 1,\n    threshold: 10,\n    globalPanning: true,\n    onPanStart: () => undefined,\n    onPanMove: () => undefined,\n    onPanEnd: () => undefined,\n    onPanCancel: () => undefined\n  };\n\n  prevXPosition: number = 0;\n  prevYPosition: number = 0;\n  started: boolean = false;\n  deltaX: number = 0;\n  deltaY: number = 0;\n  childRef = createRef<SVGGElement>();\n\n  componentDidMount() {\n    if (this.childRef.current) {\n      this.childRef.current.addEventListener('mousedown', this.onMouseDown, {\n        passive: false\n      });\n      this.childRef.current.addEventListener('touchstart', this.onTouchStart, {\n        passive: false\n      });\n    }\n  }\n\n  componentWillUnmount() {\n    this.disposeHandlers();\n\n    if (this.childRef.current) {\n      this.childRef.current.removeEventListener('mousedown', this.onMouseDown);\n      this.childRef.current.removeEventListener(\n        'touchstart',\n        this.onTouchStart\n      );\n    }\n  }\n\n  disposeHandlers() {\n    window.removeEventListener('mousemove', this.onMouseMove);\n    window.removeEventListener('mouseup', this.onMouseUp);\n    window.removeEventListener('touchmove', this.onTouchMove);\n    window.removeEventListener('touchend', this.onTouchEnd);\n\n    // Reset cursor on body back to original\n    document.body.style['cursor'] = 'inherit';\n    toggleTextSelection(true);\n  }\n\n  checkThreshold() {\n    const { threshold } = this.props;\n    return (\n      !this.started &&\n      (Math.abs(this.deltaX) > threshold || Math.abs(this.deltaY) > threshold)\n    );\n  }\n\n  onPanStart(nativeEvent, source: 'mouse' | 'touch') {\n    this.props.onPanStart({\n      nativeEvent,\n      source\n    });\n  }\n\n  onPanMove(x: number, y: number, source: 'mouse' | 'touch', nativeEvent) {\n    this.props.onPanMove({\n      source,\n      nativeEvent,\n      x,\n      y\n    });\n  }\n\n  onPanEnd(nativeEvent, source: 'mouse' | 'touch') {\n    const { onPanEnd } = this.props;\n\n    onPanEnd({\n      nativeEvent,\n      source\n    });\n  }\n\n  pan(x: number, y: number, nativeEvent, source: 'mouse' | 'touch') {\n    const { scale, constrain, width, height, matrix } = this.props;\n\n    const newMatrix = smoothMatrix(\n      transform(matrix, translate(x / scale, y / scale)),\n      100\n    );\n\n    const shouldConstrain =\n      constrain && constrainMatrix(height, width, newMatrix);\n    if (!shouldConstrain) {\n      this.onPanMove(newMatrix.e, newMatrix.f, source, nativeEvent);\n    }\n\n    return shouldConstrain;\n  }\n\n  onMouseDown = (event: MouseEvent) => {\n    // Stop at disabled\n    if (this.props.disabled) {\n      return;\n    }\n\n    // Ignore right click\n    if (event.which === 3) {\n      return;\n    }\n\n    // If global panning is turned off, it will only pan on the container\n    if (\n      !this.props.globalPanning &&\n      event.target &&\n      !(event.target as HTMLElement).classList.contains('pan-container')\n    ) {\n      return;\n    }\n\n    event.preventDefault();\n    event.stopPropagation();\n\n    toggleTextSelection(false);\n    this.started = false;\n\n    // Always bind event so we cancel movement even if no action was taken\n    window.addEventListener('mousemove', this.onMouseMove);\n    window.addEventListener('mouseup', this.onMouseUp);\n  };\n\n  onMouseMove = (event: MouseEvent) => {\n    event.preventDefault();\n    event.stopPropagation();\n\n    this.deltaX = this.deltaX + event.movementX;\n    this.deltaY = this.deltaY + event.movementY;\n\n    if (this.checkThreshold()) {\n      if (this.props.cursor) {\n        document.body.style['cursor'] = this.props.cursor;\n      }\n\n      this.deltaX = 0;\n      this.deltaY = 0;\n      this.started = true;\n\n      this.onPanStart(event, 'mouse');\n    } else {\n      this.pan(event.movementX, event.movementY, event, 'mouse');\n    }\n  };\n\n  onMouseUp = (event: MouseEvent) => {\n    event.preventDefault();\n    event.stopPropagation();\n\n    this.disposeHandlers();\n    toggleTextSelection(true);\n\n    if (this.started) {\n      this.onPanEnd(event, 'mouse');\n    } else {\n      this.props.onPanCancel({\n        nativeEvent: event,\n        source: 'mouse'\n      });\n    }\n  };\n\n  onTouchStart = (event: TouchEvent) => {\n    // Stop at disabled\n    if (this.props.disabled) {\n      return;\n    }\n\n    // Reqquire more than one touch\n    if (event.touches.length !== 1) {\n      return;\n    }\n\n    event.preventDefault();\n    event.stopPropagation();\n\n    toggleTextSelection(false);\n    this.started = false;\n\n    this.prevXPosition = event.touches[0].clientX;\n    this.prevYPosition = event.touches[0].clientY;\n\n    // Always bind event so we cancel movement even if no action was taken\n    window.addEventListener('touchmove', this.onTouchMove);\n    window.addEventListener('touchend', this.onTouchEnd);\n  };\n\n  onTouchMove = (event: TouchEvent) => {\n    event.preventDefault();\n    event.stopPropagation();\n\n    // Calculate delta from previous position and current\n    const x = event.touches[0].clientX;\n    const y = event.touches[0].clientY;\n\n    const deltaX = x - this.prevXPosition;\n    const deltaY = y - this.prevYPosition;\n\n    this.deltaX = this.deltaX + deltaX;\n    this.deltaY = this.deltaY + deltaY;\n\n    if (this.checkThreshold()) {\n      this.deltaX = 0;\n      this.deltaY = 0;\n      this.started = true;\n\n      this.onPanStart(event, 'touch');\n    } else {\n      const contrained = this.pan(deltaX, deltaY, event, 'touch');\n\n      if (!contrained) {\n        this.prevXPosition = x;\n        this.prevYPosition = y;\n      }\n    }\n  };\n\n  onTouchEnd = (event: TouchEvent) => {\n    event.preventDefault();\n    event.stopPropagation();\n\n    this.disposeHandlers();\n    toggleTextSelection(true);\n\n    if (this.started) {\n      this.onPanEnd(event, 'touch');\n    } else {\n      this.props.onPanCancel({\n        nativeEvent: event,\n        source: 'touch'\n      });\n    }\n  };\n\n  render() {\n    return <g ref={this.childRef}>{this.props.children}</g>;\n  }\n}\n","/**\n * Gets the position between a given set of points.\n */\nexport const getMidpoint = (pointA, pointB) => ({\n  x: (pointA.x + pointB.x) / 2,\n  y: (pointA.y + pointB.y) / 2\n});\n\n/**\n * Gets the distance between a given set of points.\n */\nexport const getDistanceBetweenPoints = (pointA, pointB) =>\n  Math.sqrt(\n    Math.pow(pointB.y - pointA.y, 2) + Math.pow(pointB.x - pointA.x, 2)\n  );\n\n/**\n * Get touch points.\n */\nexport function getTouchPoints(event, node) {\n  const { left, top } = node.getBoundingClientRect();\n\n  const [pointA, pointB] = [...event.touches].map((touch) => ({\n    x: touch.clientX - Math.round(left),\n    y: touch.clientY - Math.round(top)\n  }));\n\n  const distance = getDistanceBetweenPoints(pointA, pointB);\n  const midpoint = getMidpoint(pointA, pointB);\n\n  return {\n    pointA,\n    pointB,\n    distance,\n    midpoint\n  };\n}\n","import React, { Component, PropsWithChildren, createRef } from 'react';\nimport { toggleTextSelection } from '../utils/selection';\nimport {\n  getPointFromMatrix,\n  isZoomLevelGoingOutOfBounds\n} from '../utils/position';\nimport { getTouchPoints } from './pinchUtils';\nimport {\n  scale,\n  smoothMatrix,\n  transform,\n  translate,\n  applyToPoint,\n  inverse\n} from 'transformation-matrix';\n\ninterface ZoomGestureProps extends PropsWithChildren {\n  disabled?: boolean;\n  maxZoom: number;\n  minZoom: number;\n  scaleFactor: number;\n  scale: number;\n  matrix: any;\n  x: number;\n  y: number;\n  style?: any;\n  disableMouseWheel?: boolean;\n  requireZoomModifier?: boolean;\n  onZoom: (event: ZoomEvent) => void;\n  onZoomEnd: () => void;\n}\n\nexport interface ZoomEvent {\n  scale: number;\n  x: number;\n  y: number;\n  nativeEvent: any;\n}\n\nexport class Zoom extends Component<ZoomGestureProps> {\n  static defaultProps: Partial<ZoomGestureProps> = {\n    x: 0,\n    y: 0,\n    scale: 1,\n    scaleFactor: 0.1,\n    minZoom: 1,\n    maxZoom: 10\n  };\n\n  firstTouch: any;\n  lastDistance: any;\n  timeout: any;\n  childRef = createRef<SVGGElement>();\n  rqf: any;\n\n  componentDidMount() {\n    const { disabled, disableMouseWheel } = this.props;\n\n    const ref = this.childRef.current;\n    if (!disabled && ref) {\n      if (!disableMouseWheel) {\n        ref.addEventListener('mousewheel', this.onMouseWheel, {\n          passive: false\n        });\n      }\n\n      ref.addEventListener('touchstart', this.onTouchStart, { passive: false });\n    }\n  }\n\n  componentWillUnmount() {\n    window.removeEventListener('touchmove', this.onTouchMove);\n    window.removeEventListener('touchend', this.onTouchEnd);\n    cancelAnimationFrame(this.rqf);\n    clearTimeout(this.timeout);\n\n    const ref = this.childRef.current;\n    if (ref) {\n      ref.removeEventListener('mousewheel', this.onMouseWheel);\n      ref.removeEventListener('touchstart', this.onTouchStart);\n    }\n\n    toggleTextSelection(true);\n  }\n\n  getStep(delta: number) {\n    const { scaleFactor } = this.props;\n    return -delta > 0 ? scaleFactor + 1 : 1 - scaleFactor;\n  }\n\n  scale(x: number, y: number, step: number, nativeEvent) {\n    const { minZoom, maxZoom, onZoom, matrix } = this.props;\n\n    const outside = isZoomLevelGoingOutOfBounds(\n      {\n        d: matrix.a,\n        scaleFactorMin: minZoom,\n        scaleFactorMax: maxZoom\n      },\n      step\n    );\n\n    if (!outside) {\n      const newMatrix = smoothMatrix(\n        transform(\n          matrix,\n          translate(x, y),\n          scale(step, step),\n          translate(-x, -y)\n        ),\n        100\n      );\n\n      this.rqf = requestAnimationFrame(() => {\n        onZoom({\n          scale: newMatrix.a,\n          x: newMatrix.e,\n          y: newMatrix.f,\n          nativeEvent\n        });\n      });\n    }\n\n    return outside;\n  }\n\n  onMouseWheel = (event) => {\n    const {\n      disableMouseWheel,\n      requireZoomModifier,\n      matrix,\n      onZoomEnd\n    } = this.props;\n\n    if (disableMouseWheel) {\n      return false;\n    }\n\n    const hasModifier = event.metaKey || event.ctrlKey;\n    if (requireZoomModifier && !hasModifier) {\n      return false;\n    }\n\n    event.preventDefault();\n    event.stopPropagation();\n\n    const point = getPointFromMatrix(event, matrix);\n    if (point) {\n      const { x, y } = point as { x: number; y: number };\n      const step = this.getStep(event.deltaY);\n\n      this.scale(x, y, step, event);\n\n      // Do small timeout to 'guess' when its done zooming\n      clearTimeout(this.timeout);\n      this.timeout = setTimeout(() => onZoomEnd(), 500);\n    }\n  };\n\n  onTouchStart = (event: TouchEvent) => {\n    if (event.touches.length === 2) {\n      event.preventDefault();\n      event.stopPropagation();\n      toggleTextSelection(false);\n\n      this.firstTouch = getTouchPoints(event, this.childRef.current);\n      this.lastDistance = this.firstTouch.distance;\n\n      window.addEventListener('touchmove', this.onTouchMove);\n      window.addEventListener('touchend', this.onTouchEnd);\n    }\n  };\n\n  onTouchMove = (event: TouchEvent) => {\n    if (event.touches.length === 2) {\n      event.preventDefault();\n      event.stopPropagation();\n\n      const { distance } = getTouchPoints(event, this.childRef.current);\n      const distanceFactor = distance / this.lastDistance;\n\n      const point = applyToPoint(inverse(this.props.matrix), {\n        x: this.firstTouch.midpoint.x,\n        y: this.firstTouch.midpoint.y\n      }) as { x: number; y: number };\n\n      if (point.x && point.y) {\n        const outside = this.scale(point.x, point.y, distanceFactor, event);\n\n        if (!outside) {\n          this.lastDistance = distance;\n        }\n      }\n    }\n  };\n\n  onTouchEnd = (event: TouchEvent) => {\n    event.preventDefault();\n    event.stopPropagation();\n\n    window.removeEventListener('touchmove', this.onTouchMove);\n    window.removeEventListener('touchend', this.onTouchEnd);\n\n    toggleTextSelection(true);\n    this.props.onZoomEnd();\n  };\n\n  render() {\n    const { style, children } = this.props;\n    return (\n      <g ref={this.childRef} style={style}>\n        {children}\n      </g>\n    );\n  }\n}\n","import React, { FC, ReactElement } from 'react';\nimport classNames from 'classnames';\nimport { CloneElement } from 'reablocks';\nimport {\n  DiscreteLegendEntryProps,\n  DiscreteLegendEntry\n} from './DiscreteLegendEntry';\nimport css from './DiscreteLegend.module.css';\n\nexport interface DiscreteLegendProps {\n  /**\n   * CSS Class name.\n   */\n  className?: string;\n\n  /**\n   * CSS Styles.\n   */\n  style?: React.CSSProperties;\n\n  /**\n   * Orientation of the legend.\n   */\n  orientation?: 'horizontal' | 'vertical';\n\n  /**\n   * Entry components to show in the legend.\n   */\n  entries: ReactElement<DiscreteLegendEntryProps, typeof DiscreteLegendEntry>[];\n}\n\nexport const DiscreteLegend: FC<Partial<DiscreteLegendProps>> = ({\n  entries,\n  orientation,\n  style,\n  className\n}) => (\n  <div\n    className={classNames(css.container, className, {\n      [css.horizontal]: orientation === 'horizontal',\n      [css.vertical]: orientation === 'vertical'\n    })}\n    style={style}\n  >\n    {entries.map((entry, index) => (\n      <CloneElement<DiscreteLegendEntryProps>\n        element={entry}\n        key={`dle-${index}`}\n        orientation={orientation}\n      />\n    ))}\n  </div>\n);\n\nDiscreteLegend.defaultProps = {\n  orientation: 'vertical'\n};\n","import React, { FC } from 'react';\nimport classNames from 'classnames';\nimport css from './DiscreteLegendSymbol.module.css';\n\nexport interface DiscreteLegendSymbolProps {\n  /**\n   * Color for the symbol set by the `DiscreteLegendEntry`.\n   */\n  color: string;\n\n  /**\n   * CSS Class names.\n   */\n  className?: string;\n}\n\nexport const DiscreteLegendSymbol: FC<Partial<DiscreteLegendSymbolProps>> = ({\n  className,\n  color\n}) => (\n  <div\n    className={classNames(css.symbol, className)}\n    style={{ background: color }}\n  />\n);\n","import React, { ReactNode, ReactElement, FC } from 'react';\nimport classNames from 'classnames';\nimport {\n  DiscreteLegendSymbol,\n  DiscreteLegendSymbolProps\n} from './DiscreteLegendSymbol';\nimport { CloneElement } from 'reablocks';\nimport css from './DiscreteLegendEntry.module.css';\n\nexport interface DiscreteLegendEntryProps {\n  /**\n   * Label for the entry.\n   */\n  label: string;\n\n  /**\n   * Color for the entry.\n   */\n  color: string;\n\n  /**\n   * Symbol for the entry.\n   */\n  symbol:\n    | ReactElement<DiscreteLegendSymbolProps, typeof DiscreteLegendSymbol>\n    | ReactNode;\n\n  /**\n   * CSS Styles.\n   */\n  style?: React.CSSProperties;\n\n  /**\n   * CSS Class names.\n   */\n  className?: string;\n\n  /**\n   * HTML Title Attribute.\n   */\n  title?: string;\n\n  /**\n   * Orientation of the entry set internally by `DiscreteLegend`.\n   */\n  orientation: 'horizontal' | 'vertical';\n\n  /**\n   * Mouse enter event.\n   */\n  onMouseEnter: (event: React.MouseEvent<HTMLDivElement>) => void;\n\n  /**\n   * Mouse leave event.\n   */\n  onMouseLeave: (event: React.MouseEvent<HTMLDivElement>) => void;\n\n  /**\n   * On click event.\n   */\n  onClick: (event: React.MouseEvent<HTMLDivElement>) => void;\n}\n\nexport const DiscreteLegendEntry: FC<Partial<DiscreteLegendEntryProps>> = ({\n  label,\n  symbol,\n  title,\n  className,\n  color,\n  style,\n  orientation,\n  onMouseEnter,\n  onMouseLeave,\n  onClick\n}) => (\n  <div\n    title={title}\n    className={classNames(css.entry, className, {\n      [css.vertical]: orientation === 'vertical',\n      [css.horizontal]: orientation === 'horizontal'\n    })}\n    onClick={onClick}\n    onMouseEnter={onMouseEnter}\n    onMouseLeave={onMouseLeave}\n    style={style}\n  >\n    <CloneElement<DiscreteLegendSymbolProps> element={symbol} color={color} />\n    <span className={css.label}>{label}</span>\n  </div>\n);\n\nDiscreteLegendEntry.defaultProps = {\n  symbol: <DiscreteLegendSymbol />,\n  orientation: 'horizontal'\n};\n","import React, { FC, useMemo } from 'react';\nimport classNames from 'classnames';\nimport { ChartDataShape } from '../../../common/data';\nimport chroma from 'chroma-js';\nimport { uniqueBy } from '../../../common/utils/array';\nimport { extent } from 'd3-array';\nimport { formatValue } from '../../utils/formatting';\n\nimport css from './SequentialLegend.module.css';\n\nexport interface SequentialLegendProps {\n  /**\n   * CSS Class name.\n   */\n  className?: any;\n\n  /**\n   * CSS Class name for the gradient element.\n   */\n  gradientClassName?: string;\n\n  /**\n   * CSS Styles.\n   */\n  style?: any;\n\n  /**\n   * Orientation of the legend.\n   */\n  orientation?: 'horizontal' | 'vertical';\n\n  /**\n   * Data to use to render the scale.\n   */\n  data: ChartDataShape[];\n\n  /**\n   * Color scheme for the scale.\n   */\n  colorScheme?: string[];\n}\n\nexport const SequentialLegend: FC<SequentialLegendProps> = ({\n  className,\n  gradientClassName,\n  style,\n  data,\n  colorScheme = ['rgba(28, 107, 86, 0.5)', '#2da283'],\n  orientation = 'orientation'\n}) => {\n  // Generate the color gradient\n  const color = chroma\n    .scale(colorScheme)\n    .colors(10)\n    .reverse()\n    .map((c, i) => `${c} ${i * 10}%`)\n    .join(',');\n\n  // Get the extent from the data passed\n  const [end, start] = useMemo(\n    () =>\n      extent(\n        uniqueBy(\n          data,\n          (d) => d.data,\n          (d) => d.data\n        )\n      ),\n    [data]\n  );\n\n  // Get direction\n  const gradientDir = orientation === 'vertical' ? '' : 'to left,';\n\n  return (\n    <div\n      style={style}\n      className={classNames(css.container, className, {\n        [css.vertical]: orientation === 'vertical',\n        [css.horizontal]: orientation === 'horizontal'\n      })}\n    >\n      <div className={css.start}>{formatValue(start)}</div>\n      <div\n        className={classNames(css.gradient, gradientClassName)}\n        style={{\n          background: `linear-gradient(${gradientDir}${color})`\n        }}\n      />\n      <div className={css.end}>{formatValue(end)}</div>\n    </div>\n  );\n};\n\nSequentialLegend.defaultProps = {\n  colorScheme: ['rgba(28, 107, 86, 0.5)', '#2da283'],\n  orientation: 'vertical'\n};\n","import classNames from 'classnames';\nimport React, { FC, useMemo } from 'react';\nimport css from './Gridline.module.css';\n\nexport interface GridlineProps {\n  /**\n   * Height of the line set by the `GridlineSeries`.\n   */\n  height: number;\n\n  /**\n   * Width of the line set by the `GridlineSeries`.\n   */\n  width: number;\n\n  /**\n   * CSS Classname to apply.\n   */\n  className?: string;\n\n  /**\n   * Direction set by the `GridlineSeries`.\n   */\n  direction: 'all' | 'x' | 'y';\n\n  /**\n   * D3 Scale set by `GridlineSeries`.\n   */\n  scale: any;\n\n  /**\n   * SVG Stroke Width Property.\n   */\n  strokeWidth: number;\n\n  /**\n   * SVG Stroke Color Property.\n   */\n  strokeColor: string;\n\n  /**\n   * Data point for the position set by the `GridlineSeries`.\n   */\n  data: number;\n\n  /**\n   * Index set by the `GridlineSeries`.\n   */\n  index: number;\n\n  /**\n   * SVG Stroke Dash Array Property.\n   */\n  strokeDasharray: string;\n}\n\nexport const Gridline: FC<Partial<GridlineProps>> = ({\n  strokeWidth,\n  direction,\n  className,\n  strokeColor,\n  data,\n  height,\n  width,\n  scale,\n  strokeDasharray\n}) => {\n  const coords = useMemo(() => {\n    const pos = scale(data);\n\n    if (direction === 'x') {\n      return {\n        x1: pos,\n        x2: pos,\n        y1: 0,\n        y2: height\n      };\n    } else {\n      return {\n        y1: pos,\n        y2: pos,\n        x1: 0,\n        x2: width\n      };\n    }\n  }, [direction, data, height, width, scale]);\n\n  return (\n    <line\n      {...coords}\n      className={classNames(css.gridLine, className)}\n      strokeDasharray={strokeDasharray}\n      strokeWidth={strokeWidth}\n      stroke={strokeColor}\n      fill=\"none\"\n    />\n  );\n};\n\nGridline.defaultProps = {\n  strokeWidth: 1,\n  strokeDasharray: '2 5',\n  direction: 'all',\n  strokeColor: 'rgba(153, 153, 153, 0.5)'\n};\n","import React, { Fragment, ReactElement, FC, useMemo, useCallback } from 'react';\nimport { Gridline, GridlineProps } from './Gridline';\nimport { getTicks, getMaxTicks } from '../utils/ticks';\nimport { CloneElement } from 'reablocks';\nimport { LinearAxisProps } from '../Axis';\nimport { GridStripeProps, GridStripe } from './GridStripe';\n\ntype GridLineElement = ReactElement<GridlineProps, typeof Gridline>;\ntype GridStripeElement = ReactElement<GridStripeProps, typeof GridStripe>;\ntype GridElement = GridLineElement | GridStripeElement;\n\nexport interface GridlineSeriesProps {\n  /**\n   * D3 scale for Y Axis.\n   */\n  yScale: any;\n\n  /**\n   * D3 scale for X Axis.\n   */\n  xScale: any;\n\n  /**\n   * The linear axis component for the Y Axis of the chart.\n   */\n  yAxis: LinearAxisProps;\n\n  /**\n   * The linear axis component for the X Axis of the chart.\n   */\n  xAxis: LinearAxisProps;\n\n  /**\n   * Height of the chart.\n   */\n  height: number;\n\n  /**\n   * Width of the chart.\n   */\n  width: number;\n\n  /**\n   * Gridline that is rendered.\n   */\n  line: GridLineElement | null;\n\n  /**\n   * GridStripe that is rendered.\n   */\n  stripe: GridStripeElement | null;\n}\n\nexport const GridlineSeries: FC<Partial<GridlineSeriesProps>> = ({\n  line,\n  stripe,\n  yScale,\n  xScale,\n  yAxis,\n  xAxis,\n  height,\n  width\n}) => {\n  const shouldRenderY = (direction: 'all' | 'x' | 'y') =>\n    direction === 'all' || direction === 'y';\n  const shouldRenderX = (direction: 'all' | 'x' | 'y') =>\n    direction === 'all' || direction === 'x';\n\n  const { yAxisGrid, xAxisGrid } = useMemo(() => {\n    return {\n      yAxisGrid: getTicks(\n        yScale,\n        yAxis.tickSeries.props.tickValues,\n        yAxis.type,\n        getMaxTicks(yAxis.tickSeries.props.tickSize, height),\n        yAxis.tickSeries.props.interval\n      ),\n      xAxisGrid: getTicks(\n        xScale,\n        xAxis.tickSeries.props.tickValues,\n        xAxis.type,\n        getMaxTicks(xAxis.tickSeries.props.tickSize, width),\n        xAxis.tickSeries.props.interval\n      )\n    };\n  }, [height, width, xAxis, yAxis, yScale, xScale]);\n\n  const renderGroup = useCallback(\n    (\n      element: GridElement,\n      grid,\n      scale,\n      direction: 'x' | 'y',\n      type: 'line' | 'stripe'\n    ) => {\n      return grid.map((point, index) => (\n        <Fragment key={`${type}-${direction}-${index}`}>\n          <CloneElement<GridlineProps | GridStripeProps>\n            element={element}\n            index={index}\n            scale={scale}\n            data={point}\n            height={height}\n            width={width}\n            direction={direction}\n          />\n        </Fragment>\n      ));\n    },\n    [height, width]\n  );\n\n  const renderSeries = useCallback(\n    (yAxisGrid, xAxisGrid, element: GridElement, type: 'line' | 'stripe') => {\n      return (\n        <Fragment>\n          {shouldRenderY(element.props.direction) &&\n            renderGroup(element, yAxisGrid, yScale, 'y', type)}\n          {shouldRenderX(element.props.direction) &&\n            renderGroup(element, xAxisGrid, xScale, 'x', type)}\n        </Fragment>\n      );\n    },\n    [renderGroup, xScale, yScale]\n  );\n\n  return (\n    <g style={{ pointerEvents: 'none' }}>\n      {line && renderSeries(yAxisGrid, xAxisGrid, line, 'line')}\n      {stripe && renderSeries(yAxisGrid, xAxisGrid, stripe, 'stripe')}\n    </g>\n  );\n};\n\nGridlineSeries.defaultProps = {\n  line: <Gridline direction=\"all\" />,\n  stripe: null\n};\n","import classNames from 'classnames';\nimport React, { FC, useMemo } from 'react';\nimport css from './GridStripe.module.css';\n\nexport interface GridStripeProps {\n  /**\n   * Position set by the `GridlineSeries`.\n   */\n  position: 'horizontal' | 'vertical';\n\n  /**\n   * CSS Classname to apply.\n   */\n  className?: string;\n\n  /**\n   * Stripe fill color.\n   */\n  fill: string;\n\n  /**\n   * Height of the line set by the `GridlineSeries`.\n   */\n  height: number;\n\n  /**\n   * Width of the line set by the `GridlineSeries`.\n   */\n  width: number;\n\n  /**\n   * Direction set by the `GridlineSeries`.\n   */\n  direction: 'all' | 'x' | 'y';\n\n  /**\n   * D3 Scale set by `GridlineSeries`.\n   */\n  scale: any;\n\n  /**\n   * Data point for the position set by the `GridlineSeries`.\n   */\n  data: number;\n\n  /**\n   * Index set by the `GridlineSeries`.\n   */\n  index: number;\n}\n\nexport const GridStripe: FC<Partial<GridStripeProps>> = ({\n  fill,\n  className,\n  position,\n  data,\n  height,\n  width,\n  scale,\n  index\n}) => {\n  const coords = useMemo(() => {\n    const pos = scale(data);\n    const stripeFill = index % 2 ? 'none' : fill;\n    const dim = scale.bandwidth();\n\n    if (position === 'vertical') {\n      return {\n        y: 0,\n        x: pos,\n        height: height,\n        width: dim,\n        fill: stripeFill\n      };\n    } else {\n      return {\n        y: pos,\n        x: 0,\n        height: dim,\n        width,\n        fill: stripeFill\n      };\n    }\n  }, [scale, data, index, height, width, fill, position]);\n\n  return <rect className={classNames(css.gridStripe, className)} {...coords} />;\n};\n\nGridStripe.defaultProps = {\n  fill: '#393c3e'\n};\n","import React, { FC } from 'react';\nimport css from './MarkLine.module.css';\n\nexport interface MarkLineProps {\n  height: number;\n  pointX?: number;\n  strokeColor: string;\n  strokeWidth: number;\n}\n\nexport const MarkLine: FC<Partial<MarkLineProps>> = ({\n  pointX,\n  height,\n  strokeWidth = 1,\n  strokeColor = '#eee'\n}) => (\n  <line\n    stroke={strokeColor}\n    strokeWidth={strokeWidth}\n    y1=\"0\"\n    vectorEffect=\"non-scaling-stroke\"\n    y2={height}\n    x1={pointX}\n    x2={pointX}\n    className={css.markLine}\n  />\n);\n","import React, { FC } from 'react';\n\nexport interface GradientStopProps {\n  offset: number | string;\n  stopOpacity: number | string;\n  color?: string;\n}\n\nexport const GradientStop: FC<Partial<GradientStopProps>> = ({\n  color,\n  offset,\n  stopOpacity = 1\n}) => <stop offset={offset} stopOpacity={stopOpacity} stopColor={color} />;\n","import React, { FC, ReactElement } from 'react';\nimport { GradientStop, GradientStopProps } from './GradientStop';\nimport { CloneElement } from 'reablocks';\n\nexport interface GradientProps {\n  id: string;\n  stops: ReactElement<GradientStopProps, typeof GradientStop>[];\n  color?: string;\n  direction: 'vertical' | 'horizontal' | 'radial';\n}\n\nexport const Gradient: FC<Partial<GradientProps>> = ({\n  id,\n  color,\n  direction,\n  stops\n}) => {\n  if (direction === 'radial') {\n    return (\n      <radialGradient id={id}>\n        {stops.map((stop, index) => (\n          <CloneElement<GradientStopProps>\n            element={stop}\n            key={`gradient-${index}`}\n            color={stop.props.color || color}\n          />\n        ))}\n      </radialGradient>\n    );\n  }\n\n  const pos =\n    direction === 'vertical'\n      ? {\n        x1: '10%',\n        x2: '10%',\n        y1: '100%',\n        y2: '0%'\n      }\n      : {\n        y1: '0%',\n        y2: '0%',\n        x1: '0%',\n        x2: '100%'\n      };\n\n  return (\n    <linearGradient spreadMethod=\"pad\" id={id} {...pos}>\n      {stops.map((stop, index) => (\n        <CloneElement<GradientStopProps>\n          element={stop}\n          key={`gradient-${index}`}\n          color={stop.props.color || color}\n        />\n      ))}\n    </linearGradient>\n  );\n};\n\nGradient.defaultProps = {\n  direction: 'vertical',\n  stops: [\n    <GradientStop offset=\"0%\" stopOpacity={0.3} key=\"start\" />,\n    <GradientStop offset=\"80%\" stopOpacity={1} key=\"stop\" />\n  ]\n};\n","import React, { FC, ReactElement } from 'react';\nimport { GradientStop, GradientStopProps } from './GradientStop';\nimport { CloneElement } from 'reablocks';\n\nexport interface RadialGradientProps {\n  id: string;\n  stops: ReactElement<GradientStopProps, typeof GradientStop>[];\n  color?: string;\n  radius: number | string;\n}\n\nexport const RadialGradient: FC<Partial<RadialGradientProps>> = ({\n  id,\n  color,\n  radius = '30%',\n  stops = [\n    <GradientStop offset=\"0%\" stopOpacity={0.2} key=\"start\" />,\n    <GradientStop offset=\"80%\" stopOpacity={0.7} key=\"stop\" />\n  ]\n}) => (\n  <radialGradient\n    id={id}\n    cx={0}\n    cy={0}\n    r={radius}\n    gradientUnits=\"userSpaceOnUse\"\n  >\n    {stops.map((stop, index) => (\n      <CloneElement<GradientStopProps>\n        element={stop}\n        key={`gradient-${index}`}\n        color={color}\n      />\n    ))}\n  </radialGradient>\n);\n","import React, { FC } from 'react';\n\nexport interface MaskProps {\n  id?: string;\n  fill?: string;\n}\n\nexport const Mask: FC<MaskProps> = ({ id, fill }) => (\n  <mask id={id}>\n    <rect x=\"0\" y=\"0\" width=\"100%\" height=\"100%\" fill={fill} />\n  </mask>\n);\n","import React, { FC } from 'react';\nimport { MaskProps } from './Mask';\n\nexport interface StripesProps extends MaskProps {\n  id?: string;\n  fill?: string;\n}\n\nexport const Stripes: FC<StripesProps> = ({ id, fill }) => (\n  <pattern\n    id={id}\n    width=\"4\"\n    height=\"4\"\n    patternUnits=\"userSpaceOnUse\"\n    patternTransform=\"rotate(45)\"\n  >\n    <rect className=\"area-stripe\" width=\"1\" height=\"4\" fill={fill} />\n  </pattern>\n);\n","import React, { Fragment, FC } from 'react';\nimport { formatValue } from '../utils/formatting';\nimport { ChartInternalDataTypes } from '../data';\nimport css from './TooltipTemplate.module.css';\n\ninterface SingleTooltipValue {\n  key?: ChartInternalDataTypes;\n  value?: ChartInternalDataTypes;\n  x: ChartInternalDataTypes;\n  y: ChartInternalDataTypes;\n}\n\ninterface MultipleTooltipValues {\n  x: ChartInternalDataTypes;\n  data: SingleTooltipValue[];\n}\n\ninterface TooltipTemplateProps {\n  /**\n   * Tooltip data value.\n   */\n  value?: SingleTooltipValue | MultipleTooltipValues;\n\n  /**\n   * Color scheme to apply.\n   */\n  color?: any;\n\n  /**\n   * Additional CSS classes to apply.\n   */\n  className?: any;\n}\n\nexport const TooltipTemplate: FC<TooltipTemplateProps> = ({\n  value,\n  color,\n  className\n}) => {\n  if (!value) {\n    return null;\n  }\n\n  const renderValues = (data: SingleTooltipValue, index: number) => {\n    const fill = color(data, index);\n\n    return (\n      <span className={css.subValue}>\n        <span className={css.subValueColor} style={{ backgroundColor: fill }} />\n        <span className={css.subValueName}>\n          {formatValue(data.key || data.x)}:\n        </span>\n        <span>{formatValue(data.value || data.y)}</span>\n      </span>\n    );\n  };\n\n  const renderMultiple = (value: MultipleTooltipValues) => {\n    const excessCount = value.data.length - 15;\n    const pagedValues = value.data.slice(0, 15);\n\n    return (\n      <Fragment>\n        {pagedValues.map((point, i) => (\n          <Fragment key={i}>{renderValues(point, i)}</Fragment>\n        ))}\n        {excessCount > 0 && <div>...{excessCount} more...</div>}\n      </Fragment>\n    );\n  };\n\n  const isMultiple = Array.isArray((value as any).data);\n\n  return (\n    <div className={className} role=\"tooltip\">\n      <div className={css.label}>{formatValue(value!.x)}</div>\n      <div className={css.value}>\n        {isMultiple && renderMultiple(value as MultipleTooltipValues)}\n        {!isMultiple && (\n          <Fragment>\n            {formatValue(\n              (value as SingleTooltipValue).value ||\n                (value as SingleTooltipValue).y\n            )}\n          </Fragment>\n        )}\n      </div>\n    </div>\n  );\n};\n","import { TooltipTheme } from 'reablocks';\n\nimport css from './Tooltip.module.css';\n\nexport const tooltipTheme: TooltipTheme = {\n  base: css.base,\n  disablePointer: css.disablePointer\n};\n","import React, { cloneElement, FC } from 'react';\nimport { Tooltip, TooltipProps } from 'reablocks';\nimport { TooltipTemplate } from './TooltipTemplate';\nimport { tooltipTheme } from './TooltipTheme';\n\nexport interface ChartTooltipProps extends TooltipProps {\n  /**\n   * Content for the tooltip.\n   */\n  content: any;\n\n  /**\n   * Tooltip data value.\n   */\n  value?: any;\n\n  /**\n   * Color scheme to apply.\n   */\n  color?: any;\n\n  /**\n   * Complete dataset.\n   */\n  data: any;\n\n  /**\n   * Whether the tooltip should move with the cursor or not.\n   */\n  followCursor?: boolean;\n}\n\nexport const ChartTooltip: FC<Partial<ChartTooltipProps>> = ({\n  content,\n  value,\n  data,\n  color,\n  ...rest\n}) => (\n  <Tooltip\n    theme={tooltipTheme}\n    {...rest}\n    content={() => {\n      if (!value && !data) {\n        return null;\n      }\n\n      return typeof content === 'function'\n        ? content(data || value, color)\n        : cloneElement(content, {\n          ...content.props,\n          value,\n          color\n        });\n    }}\n  />\n);\n\nChartTooltip.defaultProps = {\n  content: <TooltipTemplate />\n};\n","import React, {\n  Fragment,\n  ReactElement,\n  useState,\n  useRef,\n  useCallback,\n  useMemo,\n  forwardRef,\n  useImperativeHandle\n} from 'react';\nimport { TooltipAreaEvent } from './TooltipAreaEvent';\nimport {\n  ChartDataTypes,\n  ChartInternalDataShape,\n  ChartInternalShallowDataShape,\n  ChartInternalNestedDataShape\n} from '../data';\nimport {\n  getPositionForTarget,\n  getClosestContinousScalePoint,\n  getClosestBandScalePoint\n} from '../utils/position';\nimport { CloneElement, Placement } from 'reablocks';\nimport { ChartTooltip, ChartTooltipProps } from './ChartTooltip';\nimport { arc } from 'd3-shape';\nimport isEqual from 'react-fast-compare';\nimport { scaleLinear } from 'd3-scale';\n\nexport interface TooltipAreaProps {\n  /**\n   * Popperjs placement.\n   */\n  placement: Placement;\n\n  /**\n   * Chart height. Set internally.\n   */\n  height: number;\n\n  /**\n   * Chart width. Set internally.\n   */\n  width: number;\n\n  /**\n   * Chart D3 XScale. Set internally.\n   */\n  xScale: any;\n\n  /**\n   * Chart D3 YScale. Set internally.\n   */\n  yScale: any;\n\n  /**\n   * Whether the tooltip is disabled or not.\n   */\n  disabled: boolean;\n\n  /**\n   * Color setter.\n   */\n  color: any;\n\n  /**\n   * Chart internal data type.\n   */\n  data: ChartInternalDataShape[];\n\n  /**\n   * Child elements to be contained by.\n   */\n  children?: any;\n\n  /**\n   * Whether the area is radial or not.\n   */\n  isRadial?: boolean;\n\n  /**\n   * Whether the area is continous or not (e.g. line and area charts are continous, bar charts are not).\n   */\n  isContinous?: boolean;\n\n  /**\n   * Inner-radius to set the positioning by. Set internally.\n   */\n  innerRadius?: number;\n\n  /**\n   * Outer-radius to set the positioning by. Set internally.\n   */\n  outerRadius?: number;\n\n  /**\n   * Tooltip element.\n   */\n  tooltip: ReactElement<ChartTooltipProps, typeof ChartTooltip>;\n\n  /**\n   * Whether to inverse the data or not.\n   */\n  inverse: boolean;\n\n  /**\n   * When pointer entered mouse area.\n   */\n  onValueEnter: (event: TooltipAreaEvent) => void;\n\n  /**\n   * When pointer left mouse area.\n   */\n  onValueLeave: () => void;\n\n  /**\n   * Whether the layout is horizontal or not.\n   */\n  isHorizontal: boolean;\n\n  /**\n   * Start angle for the first value.\n   */\n  startAngle?: number;\n\n  /**\n   * End angle for the last value.\n   */\n  endAngle?: number;\n}\n\ninterface TooltipDataShape {\n  x?: ChartDataTypes;\n  y?: ChartDataTypes;\n  data?: ChartDataTypes | Array<ChartDataTypes | ChartInternalShallowDataShape>;\n  i?: number;\n}\n\n// eslint-disable-next-line react/display-name\nexport const TooltipArea = forwardRef<any, Partial<TooltipAreaProps>>(\n  (\n    {\n      children,\n      inverse,\n      tooltip,\n      disabled,\n      color,\n      isRadial,\n      isContinous,\n      width,\n      height,\n      xScale,\n      yScale,\n      onValueEnter,\n      data,\n      isHorizontal,\n      innerRadius,\n      outerRadius,\n      placement: placementProp,\n      onValueLeave,\n      startAngle,\n      endAngle\n    },\n    childRef\n  ) => {\n    const [visible, setVisible] = useState<boolean>();\n    const [placement, setPlacement] = useState<Placement>();\n    const [value, setValue] = useState<any>();\n    const [offsetX, setOffsetX] = useState<any>();\n    const [offsetY, setOffsetY] = useState<any>();\n    const [prevX, setPrevX] = useState<number>();\n    const [prevY, setPrevY] = useState<number>();\n    const ref = useRef<SVGRectElement | SVGPathElement | any>();\n    const fullCircleref = useRef<SVGRectElement | SVGPathElement | any>(null);\n    const isFullCircle = Math.abs(endAngle - startAngle) >= 2 * Math.PI;\n\n    const range = Math.abs(endAngle - startAngle);\n\n    const rotationFactor = 0.5;\n\n    const getXCoord = useCallback(\n      (x: number, y: number) => {\n        // If the shape is radial, we need to convert the X coords to a radial format.\n        if (isRadial) {\n          const outerRadiusNew = outerRadius || Math.min(width, height) / 2;\n          let rad =\n            Math.atan2(y - outerRadiusNew, x - outerRadiusNew) +\n            rotationFactor * Math.PI;\n\n          // Align it with the expected start angle\n          rad = (rad - startAngle) % (2 * Math.PI);\n\n          // TODO: Figure out what the 'correct' way to do this is...\n          if (rad < 0) {\n            rad += Math.PI * 2;\n          }\n\n          // convert to given range\n          const scale = scaleLinear()\n            .domain([0, range])\n            .range([startAngle, endAngle]);\n          rad = scale(rad);\n\n          return rad;\n        }\n\n        return x;\n      },\n      [endAngle, height, isRadial, outerRadius, range, startAngle, width]\n    );\n\n    const transformData = useCallback(\n      (series: ChartInternalDataShape[]) => {\n        const result: TooltipDataShape[] = [];\n\n        if (inverse) {\n          for (const point of series) {\n            const seriesPoint = point as ChartInternalNestedDataShape;\n            if (Array.isArray(seriesPoint.data)) {\n              for (const nestedPoint of seriesPoint.data) {\n                const right = nestedPoint.x;\n                let idx = result.findIndex((r) => {\n                  const left = r.x;\n                  if (left instanceof Date && right instanceof Date) {\n                    return left.getTime() === right.getTime();\n                  }\n                  return left === right;\n                });\n\n                if (idx === -1) {\n                  result.push({\n                    x: nestedPoint.x,\n                    data: []\n                  });\n\n                  idx = result.length - 1;\n                }\n\n                const data = result[idx].data;\n\n                if (Array.isArray(data)) {\n                  data.push(nestedPoint);\n                }\n              }\n            } else {\n              result.push(point);\n            }\n          }\n        } else {\n          for (const point of series) {\n            const nestedPoint = point as ChartInternalNestedDataShape;\n            if (Array.isArray(nestedPoint.data)) {\n              result.push({\n                ...nestedPoint,\n                x: nestedPoint.key,\n                data: nestedPoint.data.map((d) => ({\n                  ...d,\n                  key: !isHorizontal ? d.x : d.y,\n                  value: !isHorizontal ? d.y : d.x\n                }))\n              });\n            } else {\n              const shallowPoint = point as ChartInternalShallowDataShape;\n              result.push({\n                ...shallowPoint,\n                // Histograms special logic...\n                x: shallowPoint.key === undefined ? shallowPoint.x0 : point.key,\n                y:\n                  shallowPoint.value === undefined\n                    ? shallowPoint.y\n                    : shallowPoint.value\n              });\n            }\n          }\n        }\n\n        return result;\n      },\n      [inverse, isHorizontal]\n    );\n\n    const onMouseMove = useCallback(\n      (event: React.MouseEvent) => {\n        const transformed = transformData(data);\n\n        // Get our default placement\n        let newPlacement = placementProp;\n        if (!placementProp) {\n          if (isHorizontal) {\n            newPlacement = 'right';\n          } else {\n            newPlacement = 'top';\n          }\n        }\n\n        // Get the path container element\n        // Note that we are using the dummy 'full' circle for alignment\n        let target = fullCircleref.current || ref.current;\n\n        const { y, x } = getPositionForTarget({\n          target: target,\n          // Manually pass the x/y from the event\n          clientX: event.clientX,\n          clientY: event.clientY\n        });\n\n        // Need to flip scales/coords if we are a horz layout\n        let keyScale;\n        let valueScale;\n        let coord;\n        let attr = 'x';\n        if (isHorizontal) {\n          keyScale = yScale;\n          valueScale = xScale;\n          coord = y;\n        } else {\n          coord = getXCoord(x, y);\n          keyScale = xScale;\n          valueScale = yScale;\n        }\n\n        // If an index value exists in the data, use that to grab closest point\n        if (typeof transformed[0].i === 'number') {\n          attr = 'i';\n        }\n\n        // Get the closest point to the mouse\n        // Consider invertable scales to be continous\n        // Round non-continous charts with a continous scale down\n        // Round band scales to the closest point for radial charts\n        const newValue = keyScale.invert\n          ? getClosestContinousScalePoint({\n            pos: coord,\n            scale: keyScale,\n            data: transformed,\n            attr,\n            roundDown: !isContinous\n          })\n          : getClosestBandScalePoint({\n            pos: coord,\n            scale: keyScale,\n            data: transformed,\n            attr,\n            roundClosest: isRadial\n          });\n\n        if (!isEqual(newValue, value) && newValue) {\n          const pointX = keyScale(newValue.x);\n          let pointY = valueScale(newValue.y);\n          let marginX = 0;\n          let marginY = 0;\n\n          if (isNaN(pointY)) {\n            pointY = height / 2;\n            marginX = 10;\n            if (!placement) {\n              newPlacement = 'right';\n            }\n          } else {\n            marginY = -10;\n          }\n\n          // If the points didn't change, don't trigger an update\n          if (pointX === prevX && pointY === prevY) {\n            return;\n          }\n\n          setPrevX(pointX);\n          setPrevY(pointY);\n\n          const target = event.target as SVGRectElement;\n          const { top, left } = target.getBoundingClientRect();\n\n          let offsetX = 0;\n          let offsetY = 0;\n\n          if (isRadial) {\n            // If its radial, we need to convert the coords to radial format\n            const outerRadius = Math.min(width, height) / 2;\n            offsetX =\n              pointY * Math.cos(pointX - rotationFactor * Math.PI) +\n              outerRadius;\n            offsetY =\n              pointY * Math.sin(pointX - rotationFactor * Math.PI) +\n              outerRadius;\n          } else {\n            offsetX = pointX;\n            offsetY = pointY;\n          }\n\n          offsetX += left + marginX;\n          offsetY += top + marginY;\n\n          setPlacement(newPlacement);\n          setVisible(true);\n          setValue(newValue);\n          setOffsetX(offsetX);\n          setOffsetY(offsetY);\n\n          onValueEnter({\n            visible: true,\n            value: newValue,\n            pointY,\n            pointX,\n            offsetX,\n            offsetY,\n            nativeEvent: event\n          });\n        }\n      },\n      [\n        data,\n        getXCoord,\n        height,\n        isContinous,\n        isHorizontal,\n        isRadial,\n        onValueEnter,\n        placement,\n        placementProp,\n        prevX,\n        prevY,\n        transformData,\n        value,\n        width,\n        xScale,\n        yScale\n      ]\n    );\n\n    const onMouseLeave = useCallback(() => {\n      setPrevX(undefined);\n      setPrevY(undefined);\n\n      setValue(undefined);\n      setVisible(false);\n\n      onValueLeave();\n    }, [onValueLeave]);\n\n    useImperativeHandle(childRef, () => ({\n      triggerMouseMove(e: React.MouseEvent) {\n        onMouseMove(e);\n      }\n    }));\n\n    const tooltipReference = useMemo(\n      () => ({\n        width: 4,\n        height: 4,\n        top: offsetY,\n        left: offsetX\n      }),\n      [offsetX, offsetY]\n    );\n\n    const renderRadial = useCallback(() => {\n      const innerRadiusNew = innerRadius || 0;\n      const outerRadiusNew = outerRadius || Math.min(width, height) / 2;\n\n      const d = arc()({\n        innerRadius: innerRadiusNew,\n        outerRadius: outerRadiusNew,\n        startAngle: isFullCircle ? 0 : startAngle,\n        endAngle: isFullCircle ? 2 * Math.PI : endAngle\n      });\n\n      // This is a dummuy full circle in the background as we need the\n      // full circle to get the coordinates right from getBoundingClientRect().\n      // If we don't use a full circle, then the bounding rectangle could be of any dimension and\n      // the logic in getPositionForTarget() wouldn't work\n      const fullCircle = arc()({\n        innerRadius: innerRadiusNew,\n        outerRadius: outerRadiusNew,\n        startAngle: 0,\n        endAngle: 2 * Math.PI\n      });\n\n      return (\n        <>\n          <path d={fullCircle!} opacity=\"0\" cursor=\"auto\" ref={fullCircleref} />\n          <path\n            d={d!}\n            opacity=\"0\"\n            cursor=\"auto\"\n            ref={ref}\n            onMouseMove={onMouseMove}\n          />\n        </>\n      );\n    }, [\n      endAngle,\n      height,\n      innerRadius,\n      isFullCircle,\n      onMouseMove,\n      outerRadius,\n      startAngle,\n      width\n    ]);\n\n    const renderLinear = useCallback(() => {\n      return (\n        <rect\n          height={height}\n          ref={ref}\n          width={width}\n          opacity={0}\n          cursor=\"auto\"\n          onMouseMove={onMouseMove}\n        />\n      );\n    }, [height, onMouseMove, width]);\n\n    return (\n      <Fragment>\n        {disabled && children}\n        {!disabled && (\n          <g onMouseLeave={onMouseLeave} ref={childRef}>\n            {isRadial && renderRadial()}\n            {!isRadial && renderLinear()}\n            <CloneElement<ChartTooltipProps>\n              element={tooltip}\n              visible={visible}\n              placement={placement}\n              modifiers={{\n                offset: {\n                  offset: '0, 15px'\n                }\n              }}\n              reference={tooltipReference}\n              color={color}\n              value={value}\n            />\n            {children}\n          </g>\n        )}\n      </Fragment>\n    );\n  }\n);\n\nTooltipArea.defaultProps = {\n  isRadial: false,\n  isContinous: true,\n  tooltip: <ChartTooltip />,\n  inverse: true,\n  onValueEnter: () => undefined,\n  onValueLeave: () => undefined,\n  startAngle: 0,\n  endAngle: 2 * Math.PI\n};\n","import React, { PropsWithChildren, FC, useRef, useState, useEffect, useCallback } from 'react';\nimport bind from 'memoize-bind';\nimport {\n  Pan,\n  PanMoveEvent,\n  PanStartEvent,\n  PanEndEvent,\n  PanCancelEvent\n} from '../Gestures/Pan';\nimport { Zoom, ZoomEvent } from '../Gestures/Zoom';\nimport {\n  identity,\n  fromObject,\n  fromDefinition,\n  transform\n} from 'transformation-matrix';\nimport isEqual from 'react-fast-compare';\n\nexport interface ZoomPanEvent {\n  scale: number;\n  x: number;\n  y: number;\n  type: 'zoom' | 'pan';\n  nativeEvent: any;\n}\n\nexport interface ZoomPanProps extends PropsWithChildren {\n  height: number;\n  width: number;\n  scale: number;\n  x: number;\n  y: number;\n  pannable: boolean;\n  zoomable: boolean;\n  disabled?: boolean;\n  maxZoom: number;\n  minZoom: number;\n  zoomStep: number;\n  constrain: boolean;\n  globalPanning: boolean;\n  disableMouseWheel?: boolean;\n  requireZoomModifier?: boolean;\n  onZoomPan: (event: ZoomPanEvent) => void;\n  onZoom: (event: ZoomEvent) => void;\n  onZoomEnd: () => void;\n  onPanStart: (event: PanStartEvent) => void;\n  onPanMove: (event: PanMoveEvent) => void;\n  onPanEnd: (event: PanEndEvent) => void;\n  onPanCancel: (event: PanCancelEvent) => void;\n}\n\nexport const ZoomPan: FC<Partial<ZoomPanProps>> = ({\n  height,\n  width,\n  children,\n  disabled,\n  pannable,\n  maxZoom,\n  minZoom,\n  zoomable,\n  scale,\n  x,\n  y,\n  disableMouseWheel,\n  constrain,\n  zoomStep,\n  onPanCancel,\n  requireZoomModifier,\n  globalPanning,\n  onPanStart,\n  onZoomPan,\n  onPanMove,\n  onPanEnd,\n  onZoom,\n  onZoomEnd\n}) =>  {\n  const zoomRef = useRef<Zoom>();\n  const panRef = useRef<Pan>();\n  const [isZooming, setIsZooming] = useState<boolean>();\n  const [isPanning, setIsPanning] = useState<boolean>();\n  const [matrix, setMatrix] = useState<any>(identity());\n\n  useEffect(() => {\n    const newMatrix = transform(\n      fromDefinition([\n        { type: 'translate', tx: x, ty: y },\n        { type: 'scale', sx: scale, sy: scale },\n      ])\n    );\n\n    if (!isEqual(newMatrix, matrix)) {\n      setMatrix(newMatrix);\n    }\n  }, [x, y, scale, matrix]);\n\n\n  const onPanStartHandler = useCallback((event: PanStartEvent) => {\n    setIsPanning(true);\n    onPanStart(event);\n  }, [onPanStart]);\n\n  const onPanMoveHandler =  useCallback((event: PanMoveEvent) => {\n    onZoomPan({\n      scale: scale,\n      x: event.x,\n      y: event.y,\n      type: 'pan',\n      nativeEvent: event.nativeEvent\n    });\n\n    onPanMove(event);\n  }, [onPanMove, onZoomPan, scale]);\n\n  const onPanEndHandler =  useCallback((event: PanEndEvent) => {\n    setIsPanning(false);\n    onPanEnd(event);\n  }, [onPanEnd]);\n\n  const onZoomHandler =  useCallback((event: ZoomEvent) => {\n    onZoomPan({\n      x: event.x,\n      y: event.y,\n      scale: event.scale,\n      nativeEvent: event.nativeEvent,\n      type: 'zoom'\n    });\n    onZoom(event);\n  }, [onZoom, onZoomPan]);\n\n  const onZoomEndHandler =  useCallback(() => {\n    setIsZooming(false);\n    onZoomEnd();\n  }, [onZoomEnd]);\n\n  const cursor = pannable ? 'move' : 'auto';\n  const selection = isZooming || isPanning ? 'none' : 'auto';\n  const matrixObj = fromObject(matrix);\n\n  return (\n    <Pan\n      x={x}\n      y={y}\n      scale={scale}\n      matrix={matrixObj}\n      constrain={constrain}\n      height={height}\n      width={width}\n      disabled={!pannable || disabled}\n      ref={panRef}\n      globalPanning={globalPanning}\n      onPanStart={bind(onPanStartHandler)}\n      onPanMove={bind(onPanMoveHandler)}\n      onPanEnd={bind(onPanEndHandler)}\n      onPanCancel={onPanCancel}\n    >\n      <Zoom\n        ref={zoomRef}\n        disabled={!zoomable || disabled}\n        scaleFactor={zoomStep}\n        disableMouseWheel={disableMouseWheel}\n        maxZoom={maxZoom}\n        minZoom={minZoom}\n        scale={scale}\n        x={x}\n        y={y}\n        style={{ cursor }}\n        requireZoomModifier={requireZoomModifier}\n        matrix={matrix}\n        onZoom={bind(onZoomHandler)}\n        onZoomEnd={bind(onZoomEndHandler)}\n      >\n        {!disabled && (\n          <rect\n            height={height}\n            width={width}\n            opacity={0}\n            className=\"pan-container\"\n          />\n        )}\n        <g\n          style={{\n            pointerEvents: selection,\n            userSelect: selection\n          }}\n        >\n          {children}\n        </g>\n      </Zoom>\n    </Pan>\n  );\n};\n\nZoomPan.defaultProps = {\n  maxZoom: 10,\n  minZoom: 0,\n  zoomStep: 0.1,\n  pannable: true,\n  zoomable: true,\n  constrain: true,\n  height: 0,\n  width: 0,\n  x: 0,\n  y: 0,\n  scale: 1,\n  globalPanning: true,\n  onPanStart: () => undefined,\n  onPanMove: () => undefined,\n  onPanEnd: () => undefined,\n  onPanCancel: () => undefined,\n  onZoom: () => undefined,\n  onZoomEnd: () => undefined\n};\n","import { scaleLinear, scaleTime, scaleBand } from 'd3-scale';\nimport { getXDomain, getYDomain } from '../utils/domains';\nimport {\n  ChartInternalShallowDataShape,\n  ChartInternalNestedDataShape\n} from '../data';\nimport { uniqueBy } from '../utils/array';\n\ninterface ScaleConfig {\n  type: 'category' | 'value' | 'time' | 'duration';\n  roundDomains?: boolean;\n  data: any[];\n  domain?: any[];\n  padding?: number;\n  scaled?: boolean;\n  width?: number;\n  height?: number;\n  isMultiSeries?: boolean;\n  isDiverging?: boolean;\n}\n\n/**\n * Gets the X Scale function.\n */\nexport function getXScale({\n  type,\n  roundDomains,\n  data,\n  width,\n  domain,\n  padding,\n  scaled,\n  isMultiSeries = false,\n  isDiverging = false\n}: ScaleConfig) {\n  let scale;\n\n  if (type === 'time' || type === 'duration' || type === 'value') {\n    if (type === 'time') {\n      scale = scaleTime().rangeRound([0, width!]);\n    } else {\n      scale = scaleLinear().rangeRound([0, width!]);\n    }\n\n    scale = scale.domain(domain || getXDomain({ data, scaled, isDiverging }));\n  } else {\n    if (!domain) {\n      if (isMultiSeries) {\n        domain = uniqueBy<ChartInternalShallowDataShape>(data, (d) => d.key);\n      } else {\n        domain = uniqueBy<ChartInternalShallowDataShape>(data, (d) => d.x);\n      }\n    }\n\n    scale = scaleBand()\n      .rangeRound([0, width!])\n      .padding(padding || 0)\n      .domain(domain as ReadonlyArray<any>);\n  }\n\n  return roundDomains ? scale.nice() : scale;\n}\n\n/**\n * Gets the Y Scale function.\n */\nexport function getYScale({\n  type,\n  height,\n  data,\n  domain,\n  roundDomains = false,\n  scaled = false,\n  padding = 0,\n  isMultiSeries = false,\n  isDiverging = false\n}: ScaleConfig) {\n  let scale;\n\n  if (type === 'time' || type === 'value' || type === 'duration') {\n    scale = scaleLinear()\n      .range([height!, 0])\n      .domain(domain || getYDomain({ data, scaled, isDiverging }));\n  } else {\n    if (!domain) {\n      if (isMultiSeries) {\n        domain = uniqueBy<ChartInternalNestedDataShape>(\n          data as [],\n          (d) => d.key\n        );\n      } else {\n        domain = uniqueBy<ChartInternalShallowDataShape>(data, (d) => d.y);\n      }\n    }\n\n    scale = scaleBand()\n      .rangeRound([height!, 0])\n      .padding(padding)\n      .domain(domain as ReadonlyArray<any>);\n  }\n\n  return roundDomains ? scale.nice() : scale;\n}\n","import { scaleLinear } from 'd3-scale';\nimport { ChartInternalNestedDataShape } from '../data';\nimport { uniqueBy } from '../utils/array';\n\ninterface MariemkoScaleData {\n  data: ChartInternalNestedDataShape[];\n  width: number;\n  valueScale: any;\n  padding: number;\n}\n\n/**\n * Get a linear scale for the mariemko chart.\n */\nexport const getMarimekkoScale = (width: number, roundDomains: boolean) => {\n  const scale = scaleLinear().rangeRound([0, width]);\n  return roundDomains ? scale.nice() : scale;\n};\n\n/**\n * Builds a fake scale function to get a group scale for a marimekko value scale.\n */\nexport const getMarimekkoGroupScale = ({\n  data,\n  width,\n  valueScale,\n  padding\n}: MariemkoScaleData) => {\n  const domain = uniqueBy<ChartInternalNestedDataShape>(data, (d) => d.key);\n  const barCount = data.length;\n  const widthMinusPadding = width - padding * (barCount - 1);\n  const xMultiplier = widthMinusPadding / width;\n\n  // Given a data series, find the x0/x1 for it.\n  const getXRange = (series) => {\n    const [val] = series.data;\n    const x0 = valueScale(val.x0);\n    const x1 = valueScale(val.x1);\n    return { x0, x1 };\n  };\n\n  const scale: any = (arg) => {\n    let result = 0;\n    const index = data.findIndex((d) => d.key === arg);\n    const series = data[index];\n\n    if (series && series.data && series.data.length) {\n      const { x1, x0 } = getXRange(series);\n      result = (x1 - x0) / 2 + x0;\n\n      if (padding) {\n        result = result * xMultiplier + index * padding;\n      }\n    }\n\n    return result;\n  };\n\n  scale.range = () => [0, width];\n  scale.domain = () => domain;\n\n  // Special invert function for marimekko\n  scale.mariemkoInvert = (offset: number) => {\n    let found;\n\n    for (let i = 0; i < domain.length; i++) {\n      const attr = domain[i];\n      const series = data[i];\n      const { x1, x0 } = getXRange(series);\n\n      if (offset >= x0 - padding / 2 && offset <= x1 - padding / 2) {\n        found = attr;\n        break;\n      }\n    }\n\n    return found;\n  };\n\n  return scale;\n};\n","import { scaleBand } from 'd3-scale';\nimport { uniqueBy } from '../utils/array';\n\n/**\n * Get the group scale aka x0.\n */\nexport function getGroupScale({\n  dimension,\n  padding,\n  data,\n  direction = 'vertical'\n}) {\n  const domain = uniqueBy(data, (d) => d.key);\n  const spacing = domain.length / (dimension / padding + 1);\n  const range = direction === 'vertical' ? [0, dimension] : [dimension, 0];\n\n  return scaleBand()\n    .rangeRound(range as any)\n    .paddingInner(spacing)\n    .paddingOuter(spacing / 2)\n    .domain(domain as string[]);\n}\n\n/**\n * Get the inner scale aka x1.\n */\nexport function getInnerScale({ groupScale, padding, data, prop = 'x' }) {\n  const dimension = groupScale.bandwidth();\n  const domain = uniqueBy(\n    data,\n    (d) => d.data,\n    (d) => d[prop]\n  );\n  const spacing = domain.length / (dimension / padding + 1);\n\n  return scaleBand()\n    .rangeRound([0, dimension])\n    .paddingInner(spacing)\n    .domain(domain as string[]);\n}\n","import { scaleLinear } from 'd3-scale';\n\n/**\n * Get the Y Scale for a given set of radiuses.\n * Reference: https://github.com/d3/d3-scale/issues/90\n */\nexport const getRadialYScale = (\n  innerRadius: number,\n  outerRadius: number,\n  domain: any[]\n) => {\n  if (domain[0] === 0 && domain[1] === 0) {\n    // If all values are 0, set the domain to [0, 1], so the zero values are\n    // all at the bottom of the chart, not the middle.\n    domain = [0, 1];\n  }\n  const y = scaleLinear()\n    .range([innerRadius * innerRadius, outerRadius * outerRadius])\n    .domain(domain);\n\n  const yScale = Object.assign((d) => Math.sqrt(y(d)), y);\n\n  return yScale;\n};\n","import React, { FC, PropsWithChildren, useCallback, useMemo } from 'react';\nimport { ZoomPan, ZoomPanEvent } from './ZoomPan';\nimport { ChartInternalDataShape, ChartDataTypes } from '../data';\nimport { getXScale } from '../scales';\n\nexport interface ZoomPanChangeEvent {\n  domain: [ChartDataTypes, ChartDataTypes];\n  isZoomed: boolean;\n}\n\nexport interface ChartZoomPanProps extends PropsWithChildren {\n  data: ChartInternalDataShape[];\n  domain?: [ChartDataTypes, ChartDataTypes];\n  axisType: 'value' | 'time' | 'category' | 'duration';\n  roundDomains: boolean;\n  height: number;\n  width: number;\n  scale: number;\n  offset: number;\n  pannable: boolean;\n  zoomable: boolean;\n  disabled?: boolean;\n  maxZoom: number;\n  zoomStep: number;\n  disableMouseWheel?: boolean;\n  requireZoomModifier?: boolean;\n  onZoomPan?: (event: ZoomPanChangeEvent) => void;\n}\n\nexport const ChartZoomPan: FC<Partial<ChartZoomPanProps>> = ({\n  data,\n  height,\n  children,\n  disabled,\n  domain,\n  width,\n  axisType,\n  roundDomains,\n  onZoomPan,\n  ...rest\n}) => {\n  const onZoomPanHandler = useCallback((event: ZoomPanEvent) => {\n    const can =\n      event.type === 'zoom' || (event.type === 'pan' && event.scale > 1);\n\n    if (can) {\n      const scale: any = getXScale({\n        width: width,\n        type: axisType,\n        roundDomains,\n        data\n      });\n\n      const newScale = scale.copy().domain(\n        scale\n          .range()\n          .map((x) => (x - event.x) / event.scale)\n          .map(scale.clamp(true).invert, event.x)\n      );\n\n      onZoomPan!({\n        domain: newScale.domain(),\n        isZoomed: event.scale !== 1\n      });\n    }\n  }, [axisType, data, onZoomPan, roundDomains, width]);\n\n  const zoomOffset = useMemo(() => {\n    let zoomOffset = {\n      scale: undefined,\n      x: undefined\n    } as any;\n\n    if (!disabled && domain) {\n      const xScale: any = getXScale({\n        width,\n        type: axisType,\n        roundDomains,\n        data\n      });\n\n      let offset = xScale(domain[0]);\n      const endOffset = xScale(domain[1]);\n      const scale = width / (endOffset - offset);\n\n      // Apply the new scale to the offset so its scaled correctly\n      offset = offset * scale;\n\n      zoomOffset = {\n        scale: scale,\n        x: -offset\n      };\n    }\n\n    return zoomOffset;\n  }, [axisType, data, disabled, domain, roundDomains, width]);\n\n  return (\n    <ZoomPan\n      {...rest}\n      scale={zoomOffset.scale}\n      x={zoomOffset.x}\n      height={height}\n      width={width}\n      pannable={zoomOffset.scale > 1}\n      onZoomPan={onZoomPanHandler}\n    >\n      {children}\n    </ZoomPan>\n  );\n};\n\nChartZoomPan.defaultProps = {\n  onZoomPan: () => undefined,\n};\n","export const DEFAULT_TRANSITION = {\n  type: 'spring',\n  velocity: 5,\n  damping: 20,\n  // https://github.com/framer/motion/issues/1513#issuecomment-1121133717\n  restDelta: 0.01,\n  restSpeed: 0.01\n};\n","import React, { useEffect } from 'react';\nimport { motion, useMotionValue, useSpring } from 'framer-motion';\nimport { interpolate } from 'd3-interpolate';\nimport { DEFAULT_TRANSITION } from './config';\n\nexport const MotionPath = ({ custom, transition, ...rest }) => {\n  const d = useMotionValue(custom.exit.d);\n  const spring = useSpring(0, DEFAULT_TRANSITION);\n\n  useEffect(() => {\n    const interpolator = interpolate(d.get(), custom.enter.d);\n    const prevSpring = spring.get();\n    spring.set(prevSpring + 1);\n\n    return spring.on('change', (v) => d.set(interpolator(v - prevSpring)));\n  }, [custom.enter.d, custom.exit.d, d, spring]);\n\n  const { d: enterD, ...enterRest } = custom.enter;\n  const { d: exitD, ...exitRest } = custom.exit;\n\n  return (\n    <motion.path\n      {...rest}\n      initial={exitRest}\n      exit={exitRest}\n      animate={enterRest}\n      transition={transition}\n      d={transition.type !== false ? d : enterD}\n    />\n  );\n};\n","import chroma from 'chroma-js';\n\n/**\n * Color Schemes\n * Credits: https://gka.github.io/chroma.js/#chroma-brewer\n */\nexport const schemes = {\n  cybertron: chroma.scale(['#2d60e8', '#26efb5']).correctLightness().colors(8),\n  ...chroma.brewer\n};\n","import { scaleOrdinal, scaleQuantile } from 'd3-scale';\nimport { maxIndex, extent } from 'd3-array';\nimport { schemes } from './schemes';\nimport { uniqueBy } from '../utils';\n\nexport type ColorSchemeType =\n  | ((data, index: number, active?: any[]) => string)\n  | string[]\n  | string;\n\nexport type ColorSchemeStyleArray = Partial<CSSStyleDeclaration>[];\n\ntype ColorHelperProps = {\n  colorScheme: ColorSchemeType;\n  point: any;\n  data: any[];\n  index: number;\n  active: any[];\n  scale?: any;\n  domain?: any[];\n  key?: any;\n  attribute?: string;\n  isMultiSeries?: boolean;\n};\n\ntype ColorSchemeValueScale = (point: any) => string;\n\nfunction isColorSchemeStyleArray(\n  colorScheme: any\n): colorScheme is ColorSchemeStyleArray {\n  return Array.isArray(colorScheme) && typeof colorScheme[0] === 'object';\n}\n\n/**\n * Given a point, get the key attributes for it.\n */\nconst rangeHelper = (point: any, attribute: string) =>\n  point.map((r, i) => {\n    if (r) {\n      if (r[attribute] !== undefined) {\n        return r[attribute];\n      } else if (r.data && r.data[attribute] !== undefined) {\n        return r.data[attribute];\n      }\n    }\n\n    return i;\n  });\n\n/**\n * Get a color given a range.\n */\nexport const getColor = (props: Partial<ColorHelperProps>) => {\n  let {\n    point,\n    colorScheme,\n    attribute,\n    index,\n    data,\n    active,\n    isMultiSeries,\n    domain,\n    key,\n    scale\n  } = {\n    attribute: 'key',\n    isMultiSeries: false,\n    scale: scaleOrdinal,\n    ...props\n  };\n\n  if (typeof colorScheme === 'string' && schemes[colorScheme]) {\n    colorScheme = schemes[colorScheme];\n  }\n\n  if (Array.isArray(colorScheme)) {\n    if (!domain) {\n      if (isMultiSeries && Array.isArray(data)) {\n        const maxIdx = maxIndex(data, (d) => d.data.length);\n        const maxVal = data[maxIdx];\n        data = maxVal.data;\n      }\n\n      domain = rangeHelper(data, attribute);\n    }\n\n    key = key !== undefined ? key : point[attribute];\n\n    return scale(colorScheme).domain(domain)(key);\n  } else if (typeof colorScheme === 'function') {\n    return colorScheme(point, index!, active);\n  } else {\n    return colorScheme;\n  }\n};\n\n/**\n * This function creates a value scale that maps data points to colors or CSS styles.\n *\n * @param {Array} data - The data used to create the scale.\n * @param {ColorSchemeType} colorScheme - The color scheme used to generate the scale.\n * @param {string} emptyColor - The color used for data points with no value.\n * @param {any} selections - Selected values in active state\n *\n * @returns {ColorSchemeValueScale} A function that takes a data point and returns a color or CSS style based on the data point's value.\n */\nconst getValueScale = (\n  data,\n  colorScheme: ColorSchemeType,\n  emptyColor: string,\n  selections: any\n): ColorSchemeValueScale => {\n  const valueDomain = extent(\n    uniqueBy(\n      data,\n      (d) => d.data,\n      (d) => d.value\n    )\n  );\n\n  return (point) => {\n    // For 0 values, lets show a placeholder fill\n    if (point?.value === undefined || point?.value === null) {\n      return emptyColor;\n    }\n\n    // Note: this can return css style values, not just colors\n    return getColor({\n      scale: scaleQuantile,\n      domain: valueDomain,\n      key: point.value,\n      colorScheme,\n      point,\n      active: selections\n    });\n  };\n};\n\n/**\n * This function generates a style object for a given data point based on a map of value scales.\n *\n * @param {any} point - The data point for which to generate the style object.\n * @param {Map<string, ColorSchemeValueScale>} valueScales - A map where each key is a property name and each value is a function that takes a data point and returns a CSS style.\n *\n * @returns {Partial<CSSStyleDeclaration>} A style object where each key is a property name and each value is a color or CSS style based on the value of the data point for that property.\n */\nexport const getColorSchemeStyles = (\n  point,\n  valueScales: Map<string, ColorSchemeValueScale>\n): Partial<CSSStyleDeclaration> =>\n  Array.from(valueScales).reduce((acc, [key, valueScale]) => {\n    return { ...acc, [key]: valueScale(point) };\n  }, {});\n\n/**\n * This function retrieves a color scheme for a specific property from a given color scheme.\n *\n * @param {ColorSchemeStyleArray} colorScheme - The color scheme used to generate the scale.\n * @param {string} colorSchemeProperty - The property for which to retrieve the new color scheme.\n *\n * @returns {ColorSchemeType} A color scheme for the specified property.\n */\nconst getColorSchemeForProperty = (\n  colorScheme: ColorSchemeStyleArray,\n  colorSchemeProperty: string\n): ColorSchemeType =>\n  colorScheme.map(\n    (schemeItem: Partial<CSSStyleDeclaration>) =>\n      schemeItem?.[colorSchemeProperty]\n  );\n\n/**\n * This function creates a map of value scales for different properties based on a provided color scheme.\n * Each value scale is a function that takes a data point and returns a css style value based on that point.\n *\n * @param {Array} data - The data used to create the scales.\n * @param {ColorSchemeType | ColorSchemeStyleArray} colorScheme - The color scheme used to generate the scales. This can be an array of colors or an array of objects where each object contains a set of css styles.\n * @param {string} emptyColor - The color used for data points with no value.\n * @param {any} selections - Selected values in active state\n *\n * @returns {Map<string, ColorSchemeValueScale>} A map where each key is a property name and each value is a function that takes a data point and returns a value for the property.\n *\n * If the color scheme is an array of strings, they will be treated as fill values.\n */\nexport const createColorSchemeValueScales = (\n  data,\n  colorScheme: ColorSchemeType | ColorSchemeStyleArray,\n  emptyColor: string,\n  selections: any\n): Map<string, ColorSchemeValueScale> => {\n  const valueScales = new Map<string, ColorSchemeValueScale>();\n\n  if (isColorSchemeStyleArray(colorScheme)) {\n    const colorSchemeProperties = [\n      ...new Set(colorScheme.flatMap(Object.keys))\n    ];\n\n    colorSchemeProperties.forEach((key) => {\n      const valueScale = getValueScale(\n        data,\n        getColorSchemeForProperty(colorScheme, key),\n        emptyColor,\n        selections\n      );\n      valueScales.set(key, valueScale);\n    });\n  } else {\n    valueScales.set('fill', getValueScale(data, colorScheme, emptyColor, selections));\n  }\n\n  return valueScales;\n};\n","import { animate } from 'framer-motion';\nimport { useEffect, useRef } from 'react';\n\nexport interface CountInputs {\n  /**\n   * Number to animate to\n   */\n  to: number;\n\n  /**\n   * Number to animate from. Defaults 0.\n   */\n  from?: number;\n\n  /**\n   * Duration of the animation in seconds. Defaults 1.\n   */\n  duration?: number;\n\n  /**\n   * Delay of the animation. Defaults 0.\n   */\n  delay?: number;\n\n  /**\n   * Localize the number. Defaults true.\n   */\n  format?: boolean;\n\n  /**\n   * Number of decimal places. Defaults 0.\n   */\n  decimalPlaces?: number;\n\n  /**\n   * Prefix the number with a string or number.\n   */\n  prefix?: string | number;\n\n  /**\n   * Suffix the number with a string or number.\n   */\n  suffix?: string | number;\n}\n\nexport const COUNT_DEFAULTS = {\n  from: 0,\n  duration: 1,\n  delay: 0,\n  format: true,\n  decimalPlaces: 0\n};\n\nexport const useCount = ({\n  from,\n  to,\n  duration,\n  delay,\n  prefix,\n  suffix,\n  decimalPlaces,\n  format\n}: CountInputs) => {\n  const nodeRef = useRef<any | null>(null);\n\n  from = from || COUNT_DEFAULTS.from;\n  duration = duration || COUNT_DEFAULTS.duration;\n  delay = delay || COUNT_DEFAULTS.delay;\n  format = format || COUNT_DEFAULTS.format;\n  decimalPlaces = decimalPlaces || COUNT_DEFAULTS.decimalPlaces;\n\n  useEffect(() => {\n    const node = nodeRef.current;\n\n    const controls = animate(from, to, {\n      duration,\n      delay,\n      onUpdate(value) {\n        let formatted: number | string = value;\n        if (decimalPlaces) {\n          formatted = Number(value.toFixed(decimalPlaces));\n        } else {\n          formatted = Number(value.toFixed(0));\n        }\n\n        if (format) {\n          formatted = formatted.toLocaleString();\n        }\n\n        if (node) {\n          if (prefix) {\n            formatted = `${prefix}${formatted}`;\n          }\n          if (suffix) {\n            formatted = `${formatted}${suffix}`;\n          }\n\n          node.textContent = formatted as string;\n        }\n      }\n    });\n\n    return () => controls.stop();\n  }, [from, to, duration, delay, decimalPlaces, format, prefix, suffix]);\n\n  return nodeRef;\n};\n","import React, { FC } from 'react';\nimport { CountInputs, useCount } from './useCount';\n\nexport interface CountProps extends CountInputs {\n  className?: string;\n}\n\nexport const Count: FC<CountProps> = ({ className, ...rest }) => {\n  const ref = useCount(rest);\n  return <span ref={ref} className={className} />;\n};\n\nCount.defaultProps = {\n  from: 0,\n  duration: 1,\n  delay: 0,\n  localize: true,\n  decimalPlaces: 0\n};\n","import React, { FC } from 'react';\n\nexport interface LinearValueMarkerProps {\n  color: string;\n  value: any;\n  className?: string;\n  thickness?: number;\n  size?: number;\n  direction?: 'horizontal' | 'vertical';\n}\nexport const LinearValueMarker: FC<LinearValueMarkerProps> = ({\n  color,\n  value,\n  className,\n  thickness = 1,\n  size,\n  direction = 'horizontal'\n}) => {\n  const coordinates =\n    direction === 'horizontal'\n      ? { x1: 0, y1: value, x2: size, y2: value }\n      : { x1: value, y1: 0, x2: value, y2: size };\n\n  return (\n    <line\n      className={className}\n      stroke={color}\n      strokeWidth={thickness}\n      {...coordinates}\n    />\n  );\n};\n","import React, { FC } from 'react';\n\nexport interface RadialValueMarkerProps {\n  color: string;\n  value: number;\n  className?: string;\n  thickness?: number;\n}\nexport const RadialValueMarker: FC<RadialValueMarkerProps> = ({\n  color,\n  value,\n  className,\n  thickness = 1\n}) => (\n  <circle\n    className={className}\n    cx={0}\n    cy={0}\n    r={value}\n    fill=\"none\"\n    stroke={color}\n    strokeWidth={thickness}\n  />\n);\n","import { Glow } from './Glow';\nimport chroma from 'chroma-js';\n\nexport interface generateGlowStylesInput {\n  glow?: Glow;\n  colorSchemeColor?: string;\n}\n\nexport const generateGlowStyles = ({\n  glow,\n  colorSchemeColor\n}: generateGlowStylesInput) => {\n  if (!glow) return {};\n\n  let {\n    x = 0,\n    y = 0,\n    blur = 5,\n    color = colorSchemeColor || 'rgb(255, 255, 255, 0.25)',\n    opacity = 1\n  } = glow;\n\n  color = chroma(color).alpha(opacity).css();\n\n  return blur\n    ? { filter: `drop-shadow(${x}px ${y}px ${blur}px ${color})` }\n    : {};\n};\n","import React, {\n  Fragment,\n  ReactNode,\n  ReactElement,\n  useState,\n  FC,\n  useRef,\n  useMemo\n} from 'react';\nimport { ChartInternalShallowDataShape } from '../../common/data';\nimport { ChartTooltip, ChartTooltipProps } from '../../common/Tooltip';\nimport classNames from 'classnames';\nimport { CloneElement } from 'reablocks';\nimport {\n  constructFunctionProps,\n  PropFunctionTypes\n} from '../../common/utils/functions';\nimport { motion } from 'framer-motion';\nimport { DEFAULT_TRANSITION } from '../../common/Motion';\nimport { schemes, getColor, ColorSchemeType } from '../../common/color';\nimport { identifier } from 'safe-identifier';\nimport css from './ScatterPoint.module.css';\nimport { Glow } from '../../common/Glow';\nimport { generateGlowStyles } from '../../common/Glow/utils';\nimport { getAriaLabel } from '../../common';\n\nexport type ScatterPointProps = {\n  /**\n   * Whether the element is active or not. Set internally by `ScatterSeries`.\n   */\n  active?: boolean;\n\n  /**\n   * Size of the circle element.\n   */\n  size?: ((data: ChartInternalShallowDataShape) => number) | number;\n\n  /**\n   * Color of the circle.\n   */\n  color?: ColorSchemeType;\n\n  /**\n   * Cursor for the element.\n   */\n  cursor?: string;\n\n  /**\n   * D3 scale for X Axis. Set internally by `ScatterPlot`.\n   */\n  xScale: any;\n\n  /**\n   * D3 scale for Y Axis. Set internally by `ScatterPlot`.\n   */\n  yScale: any;\n\n  /**\n   * Height of the chart. Set internally by `ScatterPlot`.\n   */\n  height: number;\n\n  /**\n   * Whether to animate the enter/update/exit. Set internally by `ScatterSeries`.\n   */\n  animated?: boolean;\n\n  /**\n   * Index of the element in the series. Set internally by `ScatterSeries`.\n   */\n  index: number;\n\n  /**\n   * Tooltip element.\n   */\n  tooltip: ReactElement<ChartTooltipProps, typeof ChartTooltip> | null;\n\n  /**\n   * Parsed data shape. Set internally by `ScatterPlot`.\n   */\n  data: ChartInternalShallowDataShape;\n\n  /**\n   * Id set internally by `ScatterPlot`.\n   */\n  id: string;\n\n  /**\n   * Glow styling for the point.\n   */\n  glow?: Glow;\n\n  /**\n   * Symbol element to render.\n   */\n  symbol?: (data: ChartInternalShallowDataShape) => ReactNode;\n\n  /**\n   * Whether the elment is visiblbe or not.\n   */\n  visible?: (data: ChartInternalShallowDataShape, index: number) => boolean;\n\n  /**\n   * Event for when a symbol is clicked.\n   */\n  onClick?: (data: ChartInternalShallowDataShape) => void;\n\n  /**\n   * Event for when the symbol has mouse enter.\n   */\n  onMouseEnter?: (data: ChartInternalShallowDataShape) => void;\n\n  /**\n   * Event for when the symbol has mouse leave.\n   */\n  onMouseLeave?: (data: ChartInternalShallowDataShape) => void;\n} & PropFunctionTypes;\n\nexport const ScatterPoint: FC<Partial<ScatterPointProps>> = ({\n  symbol,\n  index,\n  id,\n  data,\n  xScale,\n  yScale,\n  active,\n  tooltip,\n  cursor,\n  size,\n  glow,\n  color,\n  animated,\n  onClick,\n  onMouseEnter,\n  onMouseLeave,\n  visible,\n  ...rest\n}) => {\n  const rectRef = useRef<any | null>(null);\n  const [tooltipVisible, setTooltipVisible] = useState<boolean>(false);\n  const extras = useMemo(\n    () => constructFunctionProps(rest, data),\n    [rest, data]\n  );\n  const r = useMemo(\n    () => (typeof size === 'function' ? size(data!) : size),\n    [size, data]\n  );\n  const renderedSymbol = useMemo(\n    () => (symbol ? symbol(data!) : null),\n    [data, symbol]\n  );\n\n  const transitionProps = useMemo(\n    () =>\n      animated\n        ? {\n          ...DEFAULT_TRANSITION,\n          delay: index! * 0.005\n        }\n        : {\n          type: false,\n          delay: 0\n        },\n    [index, animated]\n  );\n\n  const enterProps = useMemo(() => {\n    let cy = yScale(data!.y1);\n    if (yScale.bandwidth) {\n      const width = yScale.bandwidth();\n      cy = cy + width / 2;\n    }\n\n    return {\n      x: xScale(data!.x),\n      y: cy\n    };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [data, yScale]);\n\n  const exitProps = useMemo(() => {\n    const [yStartDomain] = yScale.domain();\n    return {\n      y: yScale(yStartDomain),\n      x: xScale(data!.x)\n    };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [data, yScale]);\n\n  const fill = useMemo(\n    () =>\n      getColor({\n        colorScheme: color,\n        index,\n        point: data\n      }),\n    [data, color, index]\n  );\n\n  const key = `symbol-${id}-${identifier(`${data!.id}`)}`;\n  const ariaLabelData = useMemo(() => getAriaLabel(data), [data]);\n\n  const isVisible = visible ? visible?.(data, index) : active;\n\n  return (\n    <Fragment>\n      <g\n        ref={rectRef}\n        className={classNames({\n          [css.inactive]: !active,\n          [css.hidden]: !isVisible\n        })}\n        onMouseEnter={() => {\n          setTooltipVisible(true);\n          onMouseEnter(data!);\n        }}\n        onMouseLeave={() => {\n          setTooltipVisible(false);\n          onMouseLeave(data!);\n        }}\n        onClick={() => onClick(data!)}\n        tabIndex={0}\n        aria-label={ariaLabelData}\n        role=\"graphics-document\"\n      >\n        {symbol ? (\n          <motion.g\n            key={key}\n            {...extras}\n            initial={{\n              translateX: exitProps.x,\n              translateY: exitProps.y,\n              opacity: 0\n            }}\n            animate={{\n              translateX: enterProps.x,\n              translateY: enterProps.y,\n              opacity: 1\n            }}\n            exit={{\n              translateX: exitProps.x,\n              translateY: exitProps.y,\n              opacity: 0\n            }}\n            transition={transitionProps}\n          >\n            {renderedSymbol}\n          </motion.g>\n        ) : (\n          <motion.circle\n            key={key}\n            className={extras.className}\n            style={{\n              ...extras.style,\n              ...generateGlowStyles({ glow }),\n              cursor\n            }}\n            fill={fill}\n            initial={{\n              cx: exitProps.x,\n              cy: exitProps.y,\n              r,\n              opacity: 0\n            }}\n            animate={{\n              cx: enterProps.x,\n              cy: enterProps.y,\n              opacity: 1,\n              r\n            }}\n            exit={{\n              cx: exitProps.x,\n              cy: exitProps.y,\n              r,\n              opacity: 0\n            }}\n            transition={transitionProps}\n          />\n        )}\n      </g>\n      {tooltip && !tooltip.props.disabled && (\n        <CloneElement<ChartTooltipProps>\n          element={tooltip}\n          visible={tooltipVisible}\n          reference={rectRef}\n          value={data}\n        />\n      )}\n    </Fragment>\n  );\n};\n\nScatterPoint.defaultProps = {\n  active: true,\n  tooltip: <ChartTooltip />,\n  cursor: 'pointer',\n  size: 4,\n  color: schemes.cybertron[0],\n  animated: true,\n  onClick: () => undefined,\n  onMouseEnter: () => undefined,\n  onMouseLeave: () => undefined\n};\n","import React, { useCallback, Fragment, ReactElement, FC } from 'react';\nimport { ChartInternalShallowDataShape } from '../../common/data';\nimport { CloneElement } from 'reablocks';\nimport { ScatterPoint, ScatterPointProps } from './ScatterPoint';\nimport { identifier } from 'safe-identifier';\nimport { LinearValueMarker, LinearValueMarkerProps } from '../../common';\n\nexport interface ScatterSeriesProps {\n  /**\n   * Point that is rendered.\n   */\n  point: ReactElement<ScatterPointProps, typeof ScatterPoint>;\n\n  /**\n   * D3 scale for X Axis. Set internally by `ScatterPlot`.\n   */\n  xScale: any;\n\n  /**\n   * D3 scale for Y Axis. Set internally by `ScatterPlot`.\n   */\n  yScale: any;\n\n  /**\n   * Parsed data shape. Set internally by `ScatterPlot`.\n   */\n  data: ChartInternalShallowDataShape[];\n\n  /**\n   * Id set internally by `ScatterPlot`.\n   */\n  id: string;\n\n  /**\n   * Height of the chart. Set internally by `ScatterPlot`.\n   */\n  height: number;\n\n  /**\n   * Width of the chart. Set internally by `ScatterPlot`.\n   */\n  width: number;\n\n  /**\n   * Whether the chart has been zoomed or not. Set internally by `ScatterPlot`.\n   */\n  isZoomed: boolean;\n\n  /**\n   * Whether to animate the enter/update/exit.\n   */\n  animated: boolean;\n\n  /**\n   * Active element ids to highlight.\n   */\n  activeIds?: string[];\n\n  /**\n   * Value markers line for the chart.\n   */\n  valueMarkers:\n    | ReactElement<LinearValueMarkerProps, typeof LinearValueMarker>[]\n    | null;\n}\n\n// For bubble charts, often symbols exceed the area\n// and we want to add a little bit of padding to prevent clipping\nconst PADDING = 25;\nconst HALF_PADDING = PADDING / 2;\n\nexport const ScatterSeries: FC<Partial<ScatterSeriesProps>> = ({\n  data,\n  height,\n  width,\n  id,\n  isZoomed,\n  activeIds,\n  point,\n  valueMarkers,\n  xScale,\n  yScale,\n  ...rest\n}) => {\n  const renderPoint = useCallback(\n    (pointData: ChartInternalShallowDataShape, index: number) => {\n      let pointId;\n      if (pointData.id) {\n        pointId = pointData.id;\n      }\n\n      const key = identifier(`${pointId || index}`);\n      const active =\n        !(activeIds && activeIds.length) || activeIds.includes(pointId);\n\n      return (\n        <CloneElement<ScatterPointProps>\n          element={point}\n          key={key}\n          xScale={xScale}\n          yScale={yScale}\n          {...rest}\n          id={id}\n          data={pointData}\n          index={index}\n          active={active}\n        />\n      );\n    },\n    [activeIds, point, yScale, rest, id]\n  );\n\n  const renderValueMarkers = useCallback(\n    () => (\n      <>\n        {valueMarkers?.length &&\n          valueMarkers.map((marker) => {\n            const isVertical = marker?.props?.direction === 'vertical';\n            const size = isVertical ? height : width;\n            const value = isVertical\n              ? xScale(marker.props.value)\n              : yScale(marker.props.value);\n            return (\n              <CloneElement<LinearValueMarkerProps>\n                key={marker.key}\n                element={marker}\n                size={size}\n                value={value}\n              />\n            );\n          })}\n      </>\n    ),\n    [valueMarkers, width, yScale]\n  );\n\n  return (\n    <Fragment>\n      <defs>\n        <clipPath id={`${id}-path`}>\n          <rect\n            width={isZoomed ? width : width! + PADDING}\n            height={height! + PADDING}\n            x={isZoomed ? 0 : -HALF_PADDING}\n            y={-HALF_PADDING}\n          />\n        </clipPath>\n      </defs>\n      {renderValueMarkers()}\n      <g clipPath={`url(#${id}-path)`}>{data!.map(renderPoint)}</g>\n    </Fragment>\n  );\n};\n\nScatterSeries.defaultProps = {\n  point: <ScatterPoint />\n};\n","import React, {\n  FC,\n  Fragment,\n  ReactElement,\n  useState,\n  useRef,\n  useCallback,\n  useMemo\n} from 'react';\nimport classNames from 'classnames';\nimport {\n  ChartShallowDataShape,\n  buildShallowChartData,\n  ChartDataTypes\n} from '../common/data';\nimport {\n  isAxisVisible,\n  LinearAxisProps,\n  LinearXAxis,\n  LinearYAxis,\n  LinearAxis\n} from '../common/Axis';\nimport { getYScale, getXScale } from '../common/scales';\nimport { ScatterSeries, ScatterSeriesProps } from './ScatterSeries';\nimport { GridlineSeries, GridlineSeriesProps } from '../common/Gridline';\nimport {\n  ZoomPanChangeEvent,\n  ChartZoomPanProps,\n  ChartZoomPan\n} from '../common/ZoomPan';\nimport { ChartBrushProps, ChartBrush } from '../common/Brush';\nimport {\n  ChartProps,\n  ChartContainer,\n  ChartContainerChildProps\n} from '../common/containers/ChartContainer';\nimport { CloneElement } from 'reablocks';\nimport css from './ScatterPlot.module.css';\n\nexport interface ScatterPlotProps extends ChartProps {\n  /**\n   * Data the chart will receive to render.\n   */\n  data: ChartShallowDataShape[];\n\n  /**\n   * The series component that renders the scatter components.\n   */\n  series: ReactElement<ScatterSeriesProps, typeof ScatterSeries>;\n\n  /**\n   * The linear axis component for the Y Axis of the chart.\n   */\n  yAxis: ReactElement<LinearAxisProps, typeof LinearAxis>;\n\n  /**\n   * The linear axis component for the X Axis of the chart.\n   */\n  xAxis: ReactElement<LinearAxisProps, typeof LinearAxis>;\n\n  /**\n   * The chart's background gridlines component.\n   */\n  gridlines: ReactElement<GridlineSeriesProps, typeof GridlineSeries> | null;\n\n  /**\n   * The chart's brush component.\n   */\n  brush: ReactElement<ChartBrushProps, typeof ChartBrush> | null;\n\n  /**\n   * The chart's zoom pan component.\n   */\n  zoomPan: ReactElement<ChartZoomPanProps, typeof ChartZoomPan> | null;\n\n  /**\n   * Any secondary axis components. Useful for multi-axis charts.\n   */\n  secondaryAxis?: ReactElement<LinearAxisProps, typeof LinearAxis>[];\n}\n\nexport const ScatterPlot: FC<Partial<ScatterPlotProps>> = ({\n  id,\n  width,\n  height,\n  margins,\n  className,\n  series,\n  xAxis,\n  yAxis,\n  data,\n  gridlines,\n  containerClassName,\n  brush,\n  zoomPan,\n  secondaryAxis\n}) => {\n  const zoomControlled = useMemo(\n    () =>\n      // eslint-disable-next-line\n      !zoomPan?.props?.domain?.hasOwnProperty('domain'),\n    [zoomPan]\n  );\n\n  const timeout = useRef<any | null>(null);\n  const [preventAnimation, setPreventAnimation] = useState<boolean>(false);\n  const [zoomDomain, setZoomDomain] = useState<\n    [ChartDataTypes, ChartDataTypes] | null\n  >(null);\n  const [isZoomed, setIsZoomed] = useState<boolean>(false);\n  const aggregatedData = useMemo(() => buildShallowChartData(data), [data]);\n\n  const getScales = useCallback(\n    (chartHeight: number, chartWidth: number) => {\n      const yScale = getYScale({\n        roundDomains: yAxis.props.roundDomains,\n        type: yAxis.props.type,\n        height: chartHeight,\n        data: aggregatedData,\n        domain: yAxis.props.domain\n      });\n\n      const xScale = getXScale({\n        width: chartWidth,\n        type: xAxis.props.type,\n        roundDomains: xAxis.props.roundDomains,\n        data: aggregatedData,\n        domain: zoomDomain || xAxis.props.domain\n      });\n\n      return {\n        yScale,\n        xScale\n      };\n    },\n    [yAxis, xAxis, aggregatedData, zoomDomain]\n  );\n\n  const onZoomPan = useCallback(\n    (event: ZoomPanChangeEvent) => {\n      if (zoomControlled) {\n        setPreventAnimation(true);\n        setZoomDomain(event.domain);\n        setIsZoomed(event.isZoomed);\n\n        clearTimeout(timeout.current);\n        timeout.current = setTimeout(() => setPreventAnimation(true), 500);\n      }\n    },\n    [zoomControlled]\n  );\n\n  const renderChart = useCallback(\n    ({\n      chartHeight,\n      chartWidth,\n      id,\n      updateAxes,\n      chartSized\n    }: ChartContainerChildProps) => {\n      const { yScale, xScale } = getScales(chartHeight, chartWidth);\n      const animated =\n        preventAnimation === true ? false : series.props.animated;\n      const disableBrush = aggregatedData.length <= 1;\n\n      return (\n        <Fragment>\n          {chartSized && gridlines && (\n            <CloneElement<GridlineSeriesProps>\n              element={gridlines}\n              height={chartHeight}\n              width={chartWidth}\n              yScale={yScale}\n              xScale={xScale}\n              yAxis={yAxis.props}\n              xAxis={xAxis.props}\n            />\n          )}\n          <CloneElement<LinearAxisProps>\n            element={xAxis}\n            height={chartHeight}\n            width={chartWidth}\n            scale={xScale}\n            visibility={chartSized ? 'visible' : 'hidden'}\n            onDimensionsChange={(e) => updateAxes('horizontal', e)}\n          />\n          <CloneElement<LinearAxisProps>\n            element={yAxis}\n            height={chartHeight}\n            width={chartWidth}\n            scale={yScale}\n            visibility={chartSized ? 'visible' : 'hidden'}\n            onDimensionsChange={(e) => updateAxes('vertical', e)}\n          />\n          {secondaryAxis &&\n            secondaryAxis.map((axis, i) => (\n              <CloneElement<LinearAxisProps>\n                key={i}\n                element={axis}\n                height={chartHeight}\n                width={chartWidth}\n                visibility={chartSized ? 'visible' : 'hidden'}\n                onDimensionsChange={(e) => updateAxes('horizontal', e)}\n              />\n            ))}\n          {chartSized && (\n            <CloneElement<ChartBrushProps>\n              disabled={disableBrush}\n              element={brush}\n              height={chartHeight}\n              width={chartWidth}\n              scale={xScale}\n            >\n              <CloneElement<ChartZoomPanProps>\n                element={zoomPan}\n                onZoomPan={onZoomPan}\n                height={chartHeight}\n                width={chartWidth}\n                axisType={xAxis.props.type}\n                roundDomains={xAxis.props.roundDomains}\n                data={aggregatedData}\n                domain={zoomDomain}\n              >\n                <CloneElement<ScatterSeriesProps>\n                  element={series}\n                  id={`area-series-${id}`}\n                  data={aggregatedData}\n                  height={chartHeight}\n                  width={chartWidth}\n                  yScale={yScale}\n                  xScale={xScale}\n                  isZoomed={isZoomed}\n                  animated={animated}\n                />\n              </CloneElement>\n            </CloneElement>\n          )}\n        </Fragment>\n      );\n    },\n    [\n      getScales,\n      preventAnimation,\n      series,\n      gridlines,\n      yAxis,\n      xAxis,\n      secondaryAxis,\n      brush,\n      zoomPan,\n      onZoomPan,\n      aggregatedData,\n      zoomDomain,\n      isZoomed\n    ]\n  );\n\n  return (\n    <ChartContainer\n      id={id}\n      width={width}\n      height={height}\n      containerClassName={containerClassName}\n      margins={margins}\n      xAxisVisible={isAxisVisible(xAxis.props)}\n      yAxisVisible={isAxisVisible(yAxis.props)}\n      className={classNames(css.scatterPlot, className)}\n    >\n      {renderChart}\n    </ChartContainer>\n  );\n};\n\nScatterPlot.defaultProps = {\n  data: [],\n  xAxis: <LinearXAxis type=\"time\" />,\n  yAxis: <LinearYAxis type=\"value\" />,\n  series: <ScatterSeries />,\n  gridlines: <GridlineSeries />,\n  brush: null,\n  zoomPan: null\n};\n","import React, { FC, ReactElement, useCallback } from 'react';\nimport { ChartInternalShallowDataShape } from '../../common/data';\nimport { CloneElement } from 'reablocks';\nimport {\n  ScatterPoint,\n  ScatterSeries,\n  ScatterPointProps\n} from '../../ScatterPlot';\nimport css from './PointSeries.module.css';\nimport isEqual from 'react-fast-compare';\n\nexport interface PointSeriesProps {\n  /**\n   * Determines if the points should be animated or not.\n   */\n  animated: boolean;\n\n  /**\n   * The color of the points.\n   */\n  color: any;\n\n  /**\n   * The active values for the points.\n   */\n  activeValues?: any;\n\n  /**\n   * The data for the points.\n   */\n  data: ChartInternalShallowDataShape[];\n\n  /**\n   * The y-scale for the points.\n   */\n  yScale: any;\n\n  /**\n   * The x-scale for the points.\n   */\n  xScale: any;\n\n  /**\n   * The unique identifier for the points.\n   */\n  id: string;\n\n  /**\n   * The height of the points.\n   */\n  height: number;\n\n  /**\n   * The width of the points.\n   */\n  width: number;\n\n  /**\n   * Determines when the points should be shown. Can be a boolean or one of the following strings: 'hover', 'first', 'last'.\n   */\n  show: boolean | 'hover' | 'first' | 'last';\n\n  /**\n   * The point element.\n   */\n  point: ReactElement<ScatterPointProps, typeof ScatterPoint>;\n\n  /**\n   * The index of the points.\n   */\n  index: number;\n}\n\nexport const PointSeries: FC<Partial<PointSeriesProps>> = ({\n  data,\n  xScale,\n  yScale,\n  animated,\n  point,\n  color,\n  height,\n  width,\n  id,\n  activeValues,\n  show\n}) => {\n  const getIsVisible = useCallback(\n    (point: ChartInternalShallowDataShape, index: number) => {\n      const isActive =\n        activeValues && point && isEqual(activeValues.x, point.x);\n\n      if (show === 'hover') {\n        return isActive;\n      } else if (show === 'first') {\n        if (activeValues) {\n          return isActive;\n        } else {\n          return index === 0;\n        }\n      } else if (show === 'last') {\n        if (activeValues) {\n          return isActive;\n        } else {\n          return index === data.length - 1;\n        }\n      }\n\n      return show;\n    },\n    [activeValues, data.length, show]\n  );\n\n  return (\n    <ScatterSeries\n      height={height}\n      width={width}\n      id={id}\n      animated={animated}\n      data={data}\n      xScale={xScale}\n      yScale={yScale}\n      point={\n        <CloneElement<ScatterPointProps>\n          element={point}\n          color={color}\n          className={css.point}\n          size={4}\n          tooltip={null}\n          visible={getIsVisible}\n        />\n      }\n    />\n  );\n};\n\nPointSeries.defaultProps = {\n  show: 'hover',\n  point: <ScatterPoint />\n};\n","import React, { Fragment, useMemo, ReactElement, FC, useCallback } from 'react';\nimport { area } from 'd3-shape';\nimport { Gradient, GradientProps } from '../../common/Gradient';\nimport { Mask, MaskProps } from '../../common/Mask';\nimport {\n  interpolate,\n  InterpolationTypes\n} from '../../common/utils/interpolation';\nimport {\n  ChartInternalDataShape,\n  ChartInternalShallowDataShape\n} from '../../common/data';\nimport { CloneElement } from 'reablocks';\nimport {\n  constructFunctionProps,\n  PropFunctionTypes\n} from '../../common/utils/functions';\nimport { MotionPath, DEFAULT_TRANSITION } from '../../common/Motion';\nimport { generateGlowStyles } from '../../common/Glow/utils';\nimport { Glow } from '../../common';\n\nexport interface AreaProps extends PropFunctionTypes {\n  /**\n   * Id set internally by `AreaSeries`.\n   */\n  id: string;\n\n  /**\n   * Parsed data shape. Set internally by `AreaChart`.\n   */\n  data: ChartInternalDataShape[];\n\n  /**\n   * Interpolation for the area. Set internally by `AreaSeries`.\n   */\n  interpolation: InterpolationTypes;\n\n  /**\n   * Color for the area. Set internally by `AreaSeries`.\n   */\n  color: any;\n\n  /**\n   * D3 scale for X Axis. Set internally by `AreaChart`.\n   */\n  xScale: any;\n\n  /**\n   * D3 scale for Y Axis. Set internally by `AreaChart`.\n   */\n  yScale: any;\n\n  /**\n   * Index of the area in the series. Set internally by `AreaSeries`.\n   */\n  index: number;\n\n  /**\n   * Total number of areas in the series. Set internally by `AreaSeries`.\n   */\n  total: number;\n\n  /**\n   * Whether to animate the enter/update/exit. Set internally by `AreaSeries`.\n   */\n  animated: boolean;\n\n  /**\n   * Mask to apply to the area.\n   */\n  mask: ReactElement<MaskProps, typeof Mask> | null;\n\n  /**\n   * Gradient to apply to the area.\n   */\n  gradient: ReactElement<GradientProps, typeof Gradient> | null;\n\n  /**\n   * Glow to apply to the area.\n   */\n  glow?: Glow;\n}\n\nexport const Area: FC<Partial<AreaProps>> = ({\n  id,\n  gradient,\n  glow,\n  mask,\n  data,\n  color,\n  index,\n  total,\n  xScale,\n  yScale,\n  animated,\n  interpolation,\n  ...rest\n}) => {\n  const stroke = color(data, index);\n\n  const coords = useMemo(() => {\n    return data.map((item: any) => ({\n      x: xScale(item.x),\n      x1: xScale(item.x) - xScale(item.x1),\n      y: yScale(item.y),\n      y0: yScale(item.y0),\n      y1: yScale(item.y1)\n    })) as ChartInternalShallowDataShape[];\n  }, [data, xScale, yScale]);\n\n  const getAreaPath = useCallback(\n    (d: ChartInternalShallowDataShape[]) => {\n      // If the input data is a single value and this is the only\n      // area in a series, fill the available space with an area:\n      if (d.length === 1 && total === 1) {\n        const [point] = d;\n        // Assume the single data point's `x` value\n        // is the middle of the graph:\n        const midpoint = point.x as number;\n        d = [{ ...point }, { ...point }];\n        const [start, end] = d;\n        start.x = 0;\n        end.x = midpoint * 2;\n      }\n\n      const fn = area()\n        .x((d: any) => d.x)\n        .y0((d: any) => d.y0)\n        .y1((d: any) => d.y1)\n        .curve(interpolate(interpolation));\n\n      return fn(d as any);\n    },\n    [interpolation, total]\n  );\n\n  const enter = useMemo(() => {\n    const areaPath = getAreaPath(coords);\n\n    return {\n      d: areaPath === null ? undefined : areaPath\n    };\n  }, [coords, getAreaPath]);\n\n  const exit = useMemo(() => {\n    const maxY = Math.max(...yScale.range());\n    const coords = data.map((item: any) => ({\n      x: xScale(item.x),\n      x1: 0,\n      y: 0,\n      y1: maxY,\n      y0: maxY\n    })) as ChartInternalShallowDataShape[];\n\n    const areaPath = getAreaPath(coords);\n\n    return {\n      d: areaPath === null ? undefined : areaPath\n    };\n  }, [data, getAreaPath, xScale, yScale]);\n\n  const fill = useMemo(() => {\n    if (mask) {\n      return `url(#mask-pattern-${id})`;\n    } else {\n      if (gradient) {\n        return `url(#gradient-${id})`;\n      }\n\n      return '';\n    }\n  }, [gradient, id, mask]);\n\n  const transition = useMemo(() => {\n    if (animated) {\n      return {\n        ...DEFAULT_TRANSITION,\n        delay: index * 0.05\n      };\n    } else {\n      return {\n        type: false,\n        delay: 0\n      };\n    }\n  }, [animated, index]);\n\n  const renderArea = useCallback(() => {\n    const maskPath = mask ? `url(#mask-${id})` : '';\n    const extras = constructFunctionProps(rest, data);\n\n    return (\n      <MotionPath\n        {...extras}\n        pointerEvents=\"none\"\n        mask={maskPath}\n        fill={fill}\n        transition={transition}\n        custom={{\n          enter,\n          exit\n        }}\n        style={{\n          ...extras.style,\n          ...generateGlowStyles({ glow, colorSchemeColor: stroke })\n        }}\n      />\n    );\n  }, [data, enter, exit, fill, glow, id, mask, rest, stroke, transition]);\n\n  return (\n    <Fragment>\n      {renderArea()}\n      {mask && (\n        <Fragment>\n          <Mask id={`mask-${id}`} fill={`url(#gradient-${id})`} />\n          <CloneElement<MaskProps>\n            element={mask}\n            id={`mask-pattern-${id}`}\n            fill={stroke}\n          />\n        </Fragment>\n      )}\n      {gradient && (\n        <CloneElement<GradientProps>\n          element={gradient}\n          id={`gradient-${id}`}\n          color={stroke}\n        />\n      )}\n    </Fragment>\n  );\n};\n\nArea.defaultProps = {\n  gradient: <Gradient />,\n  interpolation: 'linear'\n};\n","import React, {\n  FC,\n  Fragment,\n  ReactElement,\n  useCallback,\n  useEffect,\n  useMemo,\n  useRef,\n  useState\n} from 'react';\nimport { line } from 'd3-shape';\nimport {\n  interpolate,\n  InterpolationTypes\n} from '../../common/utils/interpolation';\nimport {\n  ChartInternalDataShape,\n  ChartInternalShallowDataShape\n} from '../../common/data';\nimport { calculateShowStroke } from '../../common/utils/stroke';\nimport {\n  constructFunctionProps,\n  PropFunctionTypes\n} from '../../common/utils/functions';\nimport { MotionPath, DEFAULT_TRANSITION } from '../../common/Motion';\nimport { Glow, Gradient, GradientProps } from '../../common';\nimport { generateGlowStyles } from '../../common/Glow/utils';\nimport { CloneElement } from 'reablocks';\n\nexport interface LineProps extends PropFunctionTypes {\n  /**\n   * Id set internally by `AreaChart`.\n   */\n  id: string;\n\n  /**\n   * Parsed data shape. Set internally by `AreaChart`.\n   */\n  data: ChartInternalDataShape[];\n\n  /**\n   * Width of the chart. Set internally by `AreaChart`.\n   */\n  width: number;\n\n  /**\n   * Interpolation for the area. Set internally by `AreaSeries`.\n   */\n  interpolation: InterpolationTypes;\n\n  /**\n   * Color for the area. Set internally by `AreaSeries`.\n   */\n  color: any;\n\n  /**\n   * D3 scale for X Axis. Set internally by `AreaChart`.\n   */\n  xScale: any;\n\n  /**\n   * D3 scale for Y Axis. Set internally by `AreaChart`.\n   */\n  yScale: any;\n\n  /**\n   * Index of the area in the series. Set internally by `AreaSeries`.\n   */\n  index: number;\n\n  /**\n   * Whether to animate the enter/update/exit. Set internally by `AreaSeries`.\n   */\n  animated: boolean;\n\n  /**\n   * Stroke width of the line.\n   */\n  strokeWidth: number;\n\n  /**\n   * Show the stroke if there is no value.\n   */\n  showZeroStroke: boolean;\n\n  /**\n   * Internal property to identify if there is a area or not.\n   */\n  hasArea: boolean;\n\n  /**\n   * Gradient to apply to the line.\n   */\n  gradient: ReactElement<GradientProps, typeof Gradient> | null;\n\n  /**\n   * Glow to apply to the line.\n   */\n  glow?: Glow;\n}\n\nexport const Line: FC<Partial<LineProps>> = ({\n  id,\n  width,\n  data,\n  color,\n  index,\n  strokeWidth,\n  hasArea,\n  animated,\n  yScale,\n  xScale,\n  showZeroStroke,\n  interpolation,\n  gradient,\n  glow,\n  ...rest\n}) => {\n  const [pathLength, setPathLength] = useState<number | null>(null);\n  const ghostPathRef = useRef<SVGPathElement | null>(null);\n\n  useEffect(() => {\n    if (ghostPathRef.current) {\n      setPathLength(ghostPathRef.current.getTotalLength());\n    }\n  }, [data, xScale, yScale, width]);\n\n  const getLinePath = useCallback(\n    (point: ChartInternalShallowDataShape[]) => {\n      const fn = line()\n        .x((d: any) => d.x)\n        .y((d: any) => d.y1)\n        .defined((d: any) => showZeroStroke || calculateShowStroke(d, point))\n        .curve(interpolate(interpolation));\n\n      return fn(point as any);\n    },\n    [interpolation, showZeroStroke]\n  );\n\n  const transition = useMemo(() => {\n    if (animated) {\n      return {\n        ...DEFAULT_TRANSITION,\n        delay: hasArea ? 0 : index * 0.05\n      };\n    } else {\n      return {\n        type: false,\n        delay: 0\n      };\n    }\n  }, [animated, hasArea, index]);\n\n  const coords = useMemo(() => {\n    return data.map((item: any) => ({\n      x: xScale(item.x),\n      x1: xScale(item.x) - xScale(item.x1),\n      y: yScale(item.y),\n      y0: yScale(item.y0),\n      y1: yScale(item.y1)\n    })) as ChartInternalShallowDataShape[];\n  }, [data, xScale, yScale]);\n\n  const enter = useMemo(() => {\n    const linePath = getLinePath(coords);\n\n    let strokeDasharray = '';\n    if (!hasArea && pathLength !== null) {\n      strokeDasharray = `${pathLength} ${pathLength}`;\n    }\n\n    return {\n      d: linePath === null ? undefined : linePath,\n      strokeDashoffset: 0,\n      strokeDasharray: strokeDasharray\n    };\n  }, [coords, getLinePath, hasArea, pathLength]);\n\n  const exit = useMemo(() => {\n    let newCoords = coords;\n    if (hasArea) {\n      const maxY = Math.max(...yScale.range());\n      newCoords = data.map((item: any) => ({\n        x: xScale(item.x),\n        x1: 0,\n        y: maxY,\n        y1: maxY,\n        y0: maxY\n      })) as ChartInternalShallowDataShape[];\n    }\n\n    const linePath = getLinePath(newCoords);\n\n    let strokeDasharray = '';\n    let strokeDashoffset = 0;\n    if (!hasArea && pathLength !== null) {\n      strokeDasharray = `${pathLength} ${pathLength}`;\n      strokeDashoffset = pathLength;\n    }\n\n    return {\n      d: linePath === null ? undefined : linePath,\n      strokeDasharray,\n      strokeDashoffset\n    };\n  }, [coords, data, getLinePath, hasArea, pathLength, xScale, yScale]);\n\n  const stroke = color(data, index);\n  const extras = constructFunctionProps(rest, data);\n  const showLine = hasArea || pathLength !== null;\n\n  const strokeFill = useMemo(() => {\n    if (gradient) {\n      return `url(#gradient-${id})`;\n    }\n    return stroke;\n  }, [gradient, id]);\n\n  // framer-motion freaks out when these are added for area\n  if (hasArea) {\n    delete enter.strokeDashoffset;\n    delete exit.strokeDashoffset;\n  }\n\n  return (\n    <Fragment>\n      {showLine && (\n        <MotionPath\n          {...extras}\n          pointerEvents=\"none\"\n          stroke={strokeFill}\n          strokeWidth={strokeWidth}\n          fill=\"none\"\n          transition={transition}\n          custom={{\n            enter,\n            exit\n          }}\n          style={{\n            ...extras.style,\n            ...generateGlowStyles({ glow, colorSchemeColor: strokeFill })\n          }}\n        />\n      )}\n      {!hasArea && (\n        <path opacity=\"0\" d={enter.d} ref={ghostPathRef} pointerEvents=\"none\" />\n      )}\n      {gradient && (\n        <CloneElement<GradientProps>\n          element={gradient}\n          id={`gradient-${id}`}\n          color={stroke}\n        />\n      )}\n    </Fragment>\n  );\n};\n\nLine.defaultProps = {\n  showZeroStroke: true,\n  strokeWidth: 3\n};\n","import React, {\n  Fragment,\n  ReactElement,\n  FC,\n  useCallback,\n  useState\n} from 'react';\nimport { PointSeries, PointSeriesProps } from './PointSeries';\nimport { Area, AreaProps } from './Area';\nimport { MarkLine, MarkLineProps } from '../../common/MarkLine';\nimport {\n  ChartInternalDataShape,\n  ChartInternalNestedDataShape,\n  ChartInternalShallowDataShape\n} from '../../common/data';\nimport { CloneElement } from 'reablocks';\nimport {\n  TooltipArea,\n  TooltipAreaProps,\n  TooltipAreaEvent\n} from '../../common/Tooltip';\nimport { Line, LineProps } from './Line';\nimport { InterpolationTypes } from '../../common/utils/interpolation';\nimport { getColor, ColorSchemeType } from '../../common/color';\nimport { identifier } from 'safe-identifier';\nimport { LinearValueMarker, LinearValueMarkerProps } from '../../common';\n\nexport type AreaChartTypes =\n  | 'standard'\n  | 'grouped'\n  | 'stacked'\n  | 'stackedNormalized';\n\nexport interface AreaSeriesProps {\n  /**\n   * Id set internally by `AreaChart`.\n   */\n  id: string;\n\n  /**\n   * D3 scale for X Axis. Set internally by `AreaChart`.\n   */\n  xScale: any;\n\n  /**\n   * D3 scale for Y Axis. Set internally by `AreaChart`.\n   */\n  yScale: any;\n\n  /**\n   * Parsed data shape. Set internally by `AreaChart`.\n   */\n  data: ChartInternalDataShape[];\n\n  /**\n   * Height of the chart. Set internally by `AreaChart`.\n   */\n  height: number;\n\n  /**\n   * Width of the chart. Set internally by `AreaChart`.\n   */\n  width: number;\n\n  /**\n   * Whether to animate the enter/update/exit.\n   */\n  animated: boolean;\n\n  /**\n   * Type of area chart to render.\n   */\n  type: AreaChartTypes;\n\n  /**\n   * Interpolation type for the area/line.\n   */\n  interpolation: InterpolationTypes;\n\n  /**\n   * Tooltip for the chart area.\n   */\n  tooltip: ReactElement<TooltipAreaProps, typeof TooltipArea>;\n\n  /**\n   * Markline for the chart.\n   */\n  markLine: ReactElement<MarkLineProps, typeof MarkLine> | null;\n\n  /**\n   * Symbols used to show points.\n   */\n  symbols: ReactElement<PointSeriesProps, typeof PointSeries> | null;\n\n  /**\n   * Line that is rendered.\n   */\n  line: ReactElement<LineProps, typeof Line> | null;\n\n  /**\n   * Area that is rendered.\n   */\n  area: ReactElement<AreaProps, typeof Area> | null;\n\n  /**\n   * Color scheme for the series.\n   */\n  colorScheme: ColorSchemeType;\n\n  /**\n   * Whether the chart has been zoomed or not. Set internally by `AreaChart`.\n   */\n  isZoomed: boolean;\n\n  /**\n   * Value markers line for the chart.\n   */\n  valueMarkers:\n    | ReactElement<LinearValueMarkerProps, typeof LinearValueMarker>[]\n    | null;\n}\n\n// For area charts, often symbols exceed the area\n// and we want to add a little bit of padding to prevent clipping\nconst PADDING = 25;\nconst HALF_PADDING = PADDING / 2;\n\nexport const AreaSeries: FC<Partial<AreaSeriesProps>> = ({\n  data,\n  height,\n  id,\n  width,\n  isZoomed,\n  tooltip,\n  xScale,\n  yScale,\n  type,\n  markLine,\n  symbols,\n  animated,\n  area,\n  interpolation,\n  line,\n  colorScheme,\n  valueMarkers\n}) => {\n  const [activeValues, setActiveValues] = useState<any | null>(null);\n  const [activePoint, setActivePoint] = useState<any | null>(null);\n\n  const onValueEnter = useCallback((event: TooltipAreaEvent) => {\n    setActivePoint(event.pointX);\n    setActiveValues(event.value);\n  }, []);\n\n  const onValueLeave = useCallback(() => {\n    setActivePoint(undefined);\n    setActiveValues(undefined);\n  }, []);\n\n  const isMulti =\n    type === 'grouped' || type === 'stacked' || type === 'stackedNormalized';\n\n  const getPointColor = useCallback(\n    (point, index: number) => {\n      const key = Array.isArray(point) ? point?.[0]?.key : point?.key;\n\n      return getColor({\n        data,\n        colorScheme,\n        active: activeValues,\n        point,\n        index,\n        key\n      });\n    },\n    [activeValues, colorScheme, data]\n  );\n\n  const renderArea = useCallback(\n    (data: ChartInternalShallowDataShape[], index = 0, total = 1) => (\n      <Fragment>\n        {line && (\n          <CloneElement<LineProps>\n            element={line}\n            xScale={xScale}\n            yScale={yScale}\n            data={data}\n            width={width}\n            index={index}\n            hasArea={area !== null}\n            animated={animated}\n            interpolation={interpolation}\n            color={getPointColor}\n          />\n        )}\n        {area && (\n          <CloneElement<AreaProps>\n            element={area}\n            id={`${id}-area-${index}`}\n            xScale={xScale}\n            yScale={yScale}\n            data={data}\n            index={index}\n            total={total}\n            animated={animated}\n            interpolation={interpolation}\n            color={getPointColor}\n          />\n        )}\n      </Fragment>\n    ),\n    [\n      animated,\n      area,\n      getPointColor,\n      id,\n      interpolation,\n      line,\n      width,\n      xScale,\n      yScale\n    ]\n  );\n\n  const renderSymbols = useCallback(\n    (data: ChartInternalShallowDataShape[], index = 0) => {\n      const visible = symbols !== null;\n      const activeSymbols =\n        (symbols && symbols.props.activeValues) || activeValues;\n\n      // Animations are only valid for Area\n      const isAnimated = area !== undefined && animated && !activeSymbols;\n\n      return (\n        <Fragment>\n          {visible && (\n            <CloneElement<PointSeriesProps>\n              element={symbols}\n              key={`point-series-${id}`}\n              id={id}\n              height={height}\n              width={width}\n              activeValues={activeSymbols}\n              xScale={xScale}\n              yScale={yScale}\n              index={index}\n              data={data}\n              animated={isAnimated}\n              color={() => getPointColor(data, index)}\n            />\n          )}\n        </Fragment>\n      );\n    },\n    [\n      activeValues,\n      animated,\n      area,\n      getPointColor,\n      height,\n      id,\n      symbols,\n      width,\n      xScale,\n      yScale\n    ]\n  );\n\n  const renderMarkLine = useCallback(\n    () => (\n      <>\n        {activeValues && markLine && (\n          <CloneElement<MarkLineProps>\n            element={markLine}\n            height={height}\n            pointX={activePoint}\n          />\n        )}\n      </>\n    ),\n    [activePoint, activeValues, height, markLine]\n  );\n\n  const renderSingleSeries = useCallback(\n    (data: ChartInternalShallowDataShape[]) => (\n      <Fragment>\n        {renderArea(data)}\n        {renderMarkLine()}\n        {renderSymbols(data)}\n      </Fragment>\n    ),\n    [renderArea, renderMarkLine, renderSymbols]\n  );\n\n  const renderMultiSeries = useCallback(\n    (data: ChartInternalNestedDataShape[]) => (\n      <Fragment>\n        {data\n          .map((point, index) => (\n            <Fragment key={identifier(`${point.key}`)}>\n              {renderArea(point.data, index, data.length)}\n            </Fragment>\n          ))\n          .reverse()}\n        {renderMarkLine()}\n        {data\n          .map((point, index) => (\n            <Fragment key={identifier(`${point.key}`)}>\n              {renderSymbols(point.data, index)}\n            </Fragment>\n          ))\n          .reverse()}\n      </Fragment>\n    ),\n    [renderArea, renderMarkLine, renderSymbols]\n  );\n\n  const renderValueMarkers = useCallback(\n    () => (\n      <>\n        {valueMarkers?.length &&\n          valueMarkers.map((marker) => {\n            const isVertical = marker?.props?.direction === 'vertical';\n            const size = isVertical ? height : width;\n            const value = isVertical\n              ? xScale(marker.props.value)\n              : yScale(marker.props.value);\n            return (\n              <CloneElement<LinearValueMarkerProps>\n                key={marker.key}\n                element={marker}\n                size={size}\n                value={value}\n              />\n            );\n          })}\n      </>\n    ),\n    [valueMarkers, width, yScale]\n  );\n\n  return (\n    <Fragment>\n      <defs>\n        <clipPath id={`${id}-path`}>\n          <rect\n            width={isZoomed ? width : width + PADDING}\n            height={height + PADDING}\n            x={isZoomed ? 0 : -HALF_PADDING}\n            y={-HALF_PADDING}\n          />\n        </clipPath>\n      </defs>\n      <CloneElement<TooltipAreaProps>\n        element={tooltip}\n        xScale={xScale}\n        yScale={yScale}\n        data={data}\n        height={height}\n        width={width}\n        color={getPointColor}\n        onValueEnter={onValueEnter}\n        onValueLeave={onValueLeave}\n      >\n        <g clipPath={`url(#${id}-path)`}>\n          {isMulti && renderMultiSeries(data as ChartInternalNestedDataShape[])}\n          {!isMulti &&\n            renderSingleSeries(data as ChartInternalShallowDataShape[])}\n          {renderValueMarkers()}\n        </g>\n      </CloneElement>\n    </Fragment>\n  );\n};\n\nAreaSeries.defaultProps = {\n  colorScheme: 'cybertron',\n  animated: true,\n  interpolation: 'linear',\n  type: 'standard',\n  line: <Line />,\n  area: <Area />,\n  markLine: <MarkLine />,\n  tooltip: <TooltipArea />,\n  symbols: <PointSeries />\n};\n","import React, { FC } from 'react';\nimport { AreaSeriesProps, AreaSeries } from './AreaSeries';\nimport { formatValue } from '../../common/utils/formatting';\nimport {\n  TooltipTemplate,\n  TooltipArea,\n  ChartTooltip\n} from '../../common/Tooltip';\nimport { CloneElement } from 'reablocks';\nimport { PointSeriesProps } from './PointSeries';\nimport { ScatterPointProps } from '../../ScatterPlot';\n\nexport const StackedNormalizedAreaSeries: FC<Partial<AreaSeriesProps>> = ({\n  type,\n  symbols,\n  ...rest\n}) => (\n  <AreaSeries\n    {...rest}\n    type=\"stackedNormalized\"\n    symbols={\n      symbols && (\n        <CloneElement<PointSeriesProps>\n          element={symbols}\n          {...symbols.props}\n          point={\n            <CloneElement<ScatterPointProps>\n              element={symbols.props.point}\n              {...symbols.props.point.props}\n              tooltip={null}\n            />\n          }\n        />\n      )\n    }\n  />\n);\n\nStackedNormalizedAreaSeries.defaultProps = {\n  ...AreaSeries.defaultProps,\n  type: 'stackedNormalized',\n  tooltip: (\n    <TooltipArea\n      tooltip={\n        <ChartTooltip\n          content={(series, color) => {\n            if (!series) {\n              return null;\n            }\n\n            const value = {\n              ...series,\n              data: series.data.map((d) => ({\n                ...d,\n                value: `${formatValue(d.value)} ∙ ${formatValue(\n                  Math.floor((d.y1 - d.y0) * 100)\n                )}%`\n              }))\n            };\n\n            return <TooltipTemplate color={color} value={value} />;\n          }}\n        />\n      }\n    />\n  )\n};\n","import React, { FC } from 'react';\nimport { AreaSeriesProps, AreaSeries } from './AreaSeries';\nimport { CloneElement } from 'reablocks';\nimport { PointSeriesProps } from './PointSeries';\nimport { ScatterPointProps } from '../../ScatterPlot';\n\nexport const StackedAreaSeries: FC<Partial<AreaSeriesProps>> = ({\n  type,\n  symbols,\n  ...rest\n}) => (\n  <AreaSeries\n    {...rest}\n    type=\"stacked\"\n    symbols={\n      symbols && (\n        <CloneElement<PointSeriesProps>\n          element={symbols}\n          {...symbols.props}\n          point={\n            <CloneElement<ScatterPointProps>\n              element={symbols.props.point}\n              {...symbols.props.point.props}\n              tooltip={null}\n            />\n          }\n        />\n      )\n    }\n  />\n);\n\nStackedAreaSeries.defaultProps = {\n  ...AreaSeries.defaultProps,\n  type: 'stacked'\n};\n","import React, {\n  Fragment,\n  useEffect,\n  ReactElement,\n  FC,\n  useCallback,\n  useMemo,\n  useState,\n  useRef\n} from 'react';\nimport classNames from 'classnames';\nimport { AreaSeries, AreaSeriesProps } from './AreaSeries';\nimport {\n  isAxisVisible,\n  LinearAxisProps,\n  LinearXAxis,\n  LinearYAxis,\n  LinearAxis\n} from '../common/Axis/LinearAxis';\nimport { getXScale, getYScale } from '../common/scales';\nimport { GridlineSeries, GridlineSeriesProps } from '../common/Gridline';\nimport {\n  ChartDataShape,\n  ChartNestedDataShape,\n  buildStackData,\n  buildShallowChartData,\n  ChartShallowDataShape,\n  buildNestedChartData\n} from '../common/data';\nimport css from './AreaChart.module.css';\nimport { ChartBrushProps, ChartBrush } from '../common/Brush';\nimport {\n  ZoomPanChangeEvent,\n  ChartZoomPanProps,\n  ChartZoomPan\n} from '../common/ZoomPan';\nimport {\n  ChartContainerChildProps,\n  ChartContainer,\n  ChartProps\n} from '../common/containers/ChartContainer';\nimport { CloneElement } from 'reablocks';\n\nexport interface AreaChartProps extends ChartProps {\n  /**\n   * Data the chart will receive to render.\n   */\n  data: ChartDataShape[];\n\n  /**\n   * The series component that renders the area/line/circles components.\n   */\n  series: ReactElement<AreaSeriesProps, typeof AreaSeries>;\n\n  /**\n   * The linear axis component for the Y Axis of the chart.\n   */\n  yAxis: ReactElement<LinearAxisProps, typeof LinearAxis>;\n\n  /**\n   * The linear axis component for the X Axis of the chart.\n   */\n  xAxis: ReactElement<LinearAxisProps, typeof LinearAxis>;\n\n  /**\n   * The chart's background gridlines component.\n   */\n  gridlines: ReactElement<GridlineSeriesProps, typeof GridlineSeries> | null;\n\n  /**\n   * The chart's brush component.\n   */\n  brush: ReactElement<ChartBrushProps, typeof ChartBrush> | null;\n\n  /**\n   * The chart's zoom pan component.\n   */\n  zoomPan: ReactElement<ChartZoomPanProps, typeof ChartZoomPan> | null;\n\n  /**\n   * Any secondary axis components. Useful for multi-axis charts.\n   */\n  secondaryAxis?: ReactElement<LinearAxisProps, typeof LinearAxis>[];\n}\n\nexport const AreaChart: FC<Partial<AreaChartProps>> = ({\n  xAxis,\n  yAxis,\n  id,\n  data,\n  width,\n  height,\n  margins,\n  className,\n  containerClassName,\n  series,\n  gridlines,\n  brush,\n  zoomPan,\n  secondaryAxis\n}) => {\n  const zoom: any = zoomPan ? zoomPan.props : {};\n  const [zoomDomain, setZoomDomain] = useState<any>(zoom.domain);\n  const [preventAnimation, setPreventAnimation] = useState<boolean>(false);\n  const [isZoomed, setIsZoomed] = useState<boolean>(!!zoom.domain);\n  // eslint-disable-next-line\n  const [zoomControlled] = useState<boolean>(!zoom.hasOwnProperty('domain'));\n\n  const timeoutRef = useRef<any | null>(null);\n\n  const seriesType = series.props.type;\n  const isMultiSeries =\n    seriesType === 'stacked' ||\n    seriesType === 'stackedNormalized' ||\n    seriesType === 'grouped';\n\n  const animated = preventAnimation === true ? false : series.props.animated;\n\n  useEffect(() => {\n    if (zoomPan) {\n      const zoom = zoomPan.props;\n      if (!zoomControlled && zoom.domain !== zoomDomain) {\n        setZoomDomain(zoom.domain);\n        setIsZoomed(!!zoom.domain);\n      }\n    }\n  }, [zoomControlled, zoomDomain, zoomPan]);\n\n  const aggregatedData = useMemo(() => {\n    if (seriesType === 'stacked' || seriesType === 'stackedNormalized') {\n      return buildStackData(\n        data as ChartNestedDataShape[],\n        seriesType === 'stackedNormalized'\n      );\n    } else if (seriesType === 'grouped') {\n      return buildNestedChartData(data as ChartNestedDataShape[], true);\n    } else {\n      return buildShallowChartData(data as ChartShallowDataShape[]);\n    }\n  }, [data, seriesType]);\n\n  const getScales = useCallback(\n    (chartWidth: number, chartHeight: number) => {\n      const xScale = getXScale({\n        width: chartWidth,\n        type: xAxis.props.type,\n        roundDomains: xAxis.props.roundDomains,\n        data: aggregatedData,\n        domain: zoomDomain || xAxis.props.domain,\n        isMultiSeries\n      });\n\n      const yScale = getYScale({\n        roundDomains: yAxis.props.roundDomains,\n        type: yAxis.props.type,\n        height: chartHeight,\n        data: aggregatedData,\n        domain: yAxis.props.domain,\n        isMultiSeries\n      });\n\n      return { xScale, yScale };\n    },\n    [\n      aggregatedData,\n      isMultiSeries,\n      xAxis.props.domain,\n      xAxis.props.roundDomains,\n      xAxis.props.type,\n      yAxis.props.domain,\n      yAxis.props.roundDomains,\n      yAxis.props.type,\n      zoomDomain\n    ]\n  );\n\n  const onZoomPan = useCallback(\n    (event: ZoomPanChangeEvent) => {\n      if (zoomControlled) {\n        setZoomDomain(event.domain);\n        setIsZoomed(event.isZoomed);\n        setPreventAnimation(true);\n\n        clearTimeout(timeoutRef.current);\n        timeoutRef.current = setTimeout(() => setPreventAnimation(false));\n      }\n    },\n    [zoomControlled]\n  );\n\n  const renderChart = useCallback(\n    ({\n      chartHeight,\n      chartWidth,\n      id,\n      updateAxes,\n      chartSized\n    }: ChartContainerChildProps) => {\n      const { xScale, yScale } = getScales(chartWidth, chartHeight);\n      const disableBrush = aggregatedData.length <= 1;\n\n      return (\n        <Fragment>\n          {chartSized && gridlines && (\n            <CloneElement<GridlineSeriesProps>\n              element={gridlines}\n              height={chartHeight}\n              width={chartWidth}\n              yScale={yScale}\n              xScale={xScale}\n              yAxis={yAxis.props}\n              xAxis={xAxis.props}\n            />\n          )}\n          <CloneElement<LinearAxisProps>\n            element={xAxis}\n            height={chartHeight}\n            width={chartWidth}\n            scale={xScale}\n            visibility={chartSized ? 'visible' : 'hidden'}\n            onDimensionsChange={(event) => updateAxes('horizontal', event)}\n          />\n          <CloneElement<LinearAxisProps>\n            element={yAxis}\n            height={chartHeight}\n            width={chartWidth}\n            scale={yScale}\n            visibility={chartSized ? 'visible' : 'hidden'}\n            onDimensionsChange={(event) => updateAxes('vertical', event)}\n          />\n          {secondaryAxis &&\n            secondaryAxis.map((axis, i) => (\n              <CloneElement<LinearAxisProps>\n                key={i}\n                element={axis}\n                height={chartHeight}\n                width={chartWidth}\n                visibility={chartSized ? 'visible' : 'hidden'}\n                onDimensionsChange={(event) => updateAxes('horizontal', event)}\n              />\n            ))}\n          {chartSized && (\n            <CloneElement<ChartBrushProps>\n              disabled={disableBrush}\n              element={brush}\n              height={chartHeight}\n              width={chartWidth}\n              scale={xScale}\n            >\n              <CloneElement<ChartZoomPanProps>\n                element={zoomPan}\n                onZoomPan={onZoomPan}\n                height={chartHeight}\n                width={chartWidth}\n                axisType={xAxis.props.type}\n                roundDomains={xAxis.props.roundDomains}\n                data={aggregatedData}\n                domain={zoomDomain}\n              >\n                <CloneElement<AreaSeriesProps>\n                  element={series}\n                  id={`area-series-${id}`}\n                  data={aggregatedData}\n                  height={chartHeight}\n                  width={chartWidth}\n                  yScale={yScale}\n                  xScale={xScale}\n                  isZoomed={isZoomed}\n                  animated={animated}\n                />\n              </CloneElement>\n            </CloneElement>\n          )}\n        </Fragment>\n      );\n    },\n    [\n      aggregatedData,\n      animated,\n      brush,\n      getScales,\n      gridlines,\n      isZoomed,\n      onZoomPan,\n      secondaryAxis,\n      series,\n      xAxis,\n      yAxis,\n      zoomDomain,\n      zoomPan\n    ]\n  );\n\n  return (\n    <ChartContainer\n      id={id}\n      width={width}\n      height={height}\n      margins={margins}\n      containerClassName={containerClassName}\n      xAxisVisible={isAxisVisible(xAxis.props)}\n      yAxisVisible={isAxisVisible(yAxis.props)}\n      className={classNames(\n        css.areaChart,\n        className,\n        series.type as unknown as string\n      )}\n    >\n      {renderChart}\n    </ChartContainer>\n  );\n};\n\nAreaChart.defaultProps = {\n  data: [],\n  xAxis: <LinearXAxis type=\"time\" />,\n  yAxis: <LinearYAxis type=\"value\" />,\n  series: <AreaSeries />,\n  gridlines: <GridlineSeries />,\n  brush: null,\n  zoomPan: null\n};\n","import React, { FC } from 'react';\nimport { AreaChart, AreaChartProps } from './AreaChart';\nimport { ChartNestedDataShape } from '../common/data';\nimport { StackedAreaSeries } from './AreaSeries';\n\nexport interface StackedAreaChartProps extends AreaChartProps {\n  data: ChartNestedDataShape[];\n}\n\nexport const StackedAreaChart: FC<Partial<StackedAreaChartProps>> = (props) => (\n  <AreaChart {...props} />\n);\n\nStackedAreaChart.defaultProps = {\n  series: <StackedAreaSeries />\n};\n","import React, { FC } from 'react';\nimport { AreaChart, AreaChartProps } from './AreaChart';\nimport { ChartNestedDataShape } from '../common/data';\nimport { StackedNormalizedAreaSeries } from './AreaSeries';\nimport {\n  LinearYAxis,\n  LinearYAxisTickSeries,\n  LinearYAxisTickLabel\n} from '../common/Axis/LinearAxis';\n\nexport interface StackedNormalizedAreaChartProps extends AreaChartProps {\n  data: ChartNestedDataShape[];\n}\n\nexport const StackedNormalizedAreaChart: FC<\n  Partial<StackedNormalizedAreaChartProps>\n> = (props) => <AreaChart {...props} />;\n\nStackedNormalizedAreaChart.defaultProps = {\n  series: <StackedNormalizedAreaSeries />,\n  yAxis: (\n    <LinearYAxis\n      type=\"value\"\n      tickSeries={\n        <LinearYAxisTickSeries\n          label={\n            <LinearYAxisTickLabel\n              rotation={false}\n              format={(data) => `${data * 100}%`}\n            />\n          }\n        />\n      }\n    />\n  )\n};\n","import React, {\n  Fragment,\n  ReactElement,\n  useCallback,\n  FC,\n  useRef,\n  useMemo,\n  useState\n} from 'react';\nimport chroma from 'chroma-js';\nimport { Gradient, GradientProps } from '../../common/Gradient';\nimport classNames from 'classnames';\nimport { ChartInternalShallowDataShape, Direction } from '../../common/data';\nimport { RangeLinesProps, RangeLines } from './RangeLines';\nimport { CloneElement } from 'reablocks';\nimport { Mask, MaskProps } from '../../common/Mask';\nimport {\n  constructFunctionProps,\n  PropFunctionTypes\n} from '../../common/utils/functions';\nimport { motion } from 'framer-motion';\nimport { DEFAULT_TRANSITION } from '../../common/Motion';\nimport { BarLabelProps, BarLabel } from './BarLabel';\nimport { formatValue, getAriaLabel } from '../../common/utils/formatting';\nimport { GuideBarProps, GuideBar } from './GuideBar';\nimport { ChartTooltipProps, ChartTooltip } from '../../common/Tooltip';\nimport { Glow } from '../../common/Glow';\nimport { ClickEvent } from '../../common/types';\nimport { generateGlowStyles } from '../../common/Glow/utils';\n\nexport type BarType =\n  | 'standard'\n  | 'grouped'\n  | 'stacked'\n  | 'stackedNormalized'\n  | 'stackedDiverging'\n  | 'marimekko'\n  | 'waterfall';\n\nexport type BarProps = {\n  /**\n   * Whether the bar is active or not.\n   */\n  active: boolean;\n\n  /**\n   * Chroma brightness factor to brighten the active bar. See\n   * https://gka.github.io/chroma.js/#color-brighten for more info.\n   */\n  activeBrightness?: number;\n\n  /**\n   * D3 scale for X Axis. Set internally by `BarChart`.\n   */\n  xScale: any;\n\n  /**\n   * D3 scale for Y Axis. Set internally by `BarChart`.\n   */\n  yScale: any;\n\n  /**\n   * D3 scale for X Multi-Group Axis. Set internally by `BarChart`.\n   */\n  xScale1: any;\n\n  /**\n   * Parsed data shape. Set internally by `BarChart`.\n   */\n  data: ChartInternalShallowDataShape;\n\n  /**\n   * Id set internally by `BarChart`.\n   */\n  id: string;\n\n  /**\n   * Gradient shades for the bar.\n   */\n  gradient: ReactElement<GradientProps, typeof Gradient> | null;\n\n  /**\n   * SVG rx attribute for the bar.\n   */\n  rx: number;\n\n  /**\n   * SVG ry attribute for the bar.\n   */\n  ry: number;\n\n  /**\n   * Width of the bar. Set internally by `BarSeries`.\n   */\n  width: number;\n\n  /**\n   * Padding for the bar groups.\n   */\n  padding: number;\n\n  /**\n   * Total number of bars used for animation. Set internally by `BarSeries`.\n   */\n  barCount: number;\n\n  /**\n   * Color callback for the bar.\n   */\n  color: any;\n\n  /**\n   * Cursor for the bar element.\n   */\n  cursor: string;\n\n  /**\n   * Index of the bar. Set internally by `BarSeries`.\n   */\n  barIndex: number;\n\n  /**\n   * Index of the group. Set internally by `BarSeries`.\n   */\n  groupIndex?: number;\n\n  /**\n   * Whether to animate the enter/update/exit. Set internally by `BarSeries`.\n   */\n  animated: boolean;\n\n  /**\n   * Whether this is categorical chart or not. Set internally by `BarSeries`.\n   */\n  isCategorical: boolean;\n\n  /**\n   * Rangelines element. for the bar.\n   */\n  rangeLines: ReactElement<RangeLinesProps, typeof RangeLines> | null;\n\n  /**\n   * Mask element for the bar.\n   */\n  mask: ReactElement<MaskProps, typeof Mask> | null;\n\n  /**\n   * Tooltip element.\n   */\n  tooltip: ReactElement<ChartTooltipProps, typeof ChartTooltip> | null;\n\n  /**\n   * Direction of the chart. Set internally by `BarSeries`.\n   */\n  layout: Direction;\n\n  /**\n   * Type of bar chart. Set internally by `BarSeries`.\n   */\n  type: BarType;\n\n  /**\n   * Label element.\n   */\n  label: ReactElement<BarLabelProps, typeof BarLabel> | null;\n\n  /**\n   * Guide bar component.\n   */\n  guide: ReactElement<GuideBarProps, typeof GuideBar> | null;\n\n  /**\n   * Force a min height on the bar.\n   */\n  minHeight?: number;\n\n  /**\n   * Glow styling for the bar.\n   */\n  glow?: Glow;\n\n  /**\n   * Event for when the bar is clicked.\n   */\n  onClick?: (event: ClickEvent) => void;\n\n  /**\n   * Event for when the bar has mouse enter.\n   */\n  onMouseEnter?: (event) => void;\n\n  /**\n   * Event for when the bar has mouse leave.\n   */\n  onMouseLeave?: (event) => void;\n\n  /**\n   * Event for when a bar has mouse move.\n   */\n  onMouseMove?: (event) => void;\n} & PropFunctionTypes;\n\ninterface BarCoordinates {\n  width: number;\n  height: number;\n  x: number;\n  y: number;\n}\n\nexport const Bar: FC<Partial<BarProps>> = ({\n  activeBrightness,\n  id,\n  gradient,\n  data,\n  barIndex,\n  color,\n  yScale,\n  barCount,\n  glow,\n  xScale,\n  groupIndex,\n  minHeight,\n  rangeLines,\n  animated,\n  active,\n  type,\n  tooltip,\n  layout,\n  mask,\n  label,\n  cursor,\n  rx,\n  ry,\n  isCategorical,\n  className,\n  style,\n  width,\n  padding,\n  guide,\n  xScale1,\n  onMouseEnter,\n  onClick,\n  onMouseMove,\n  onMouseLeave\n}) => {\n  const isVertical = useMemo(() => layout === 'vertical', [layout]);\n  const rect = useRef<SVGGElement | null>(null);\n  const [internalActive, setInternalActive] = useState<boolean>(active);\n\n  const calculateLinearScalePadding = useCallback(\n    (scale, offset: number, size: number) => {\n      // This function calculates the padding on a linear scale used by the marimekko chart.\n      const totalSize = scale.range()[1];\n      const sizeMinusPadding = totalSize - padding * (barCount - 1);\n      const multiplier = sizeMinusPadding / totalSize;\n      offset = offset * multiplier + groupIndex! * padding;\n      size = size * multiplier;\n\n      return { size, offset };\n    },\n    [barCount, groupIndex, padding]\n  );\n\n  const getExit = useCallback(\n    ({ x, y, width, height }: BarCoordinates) => {\n      let newX = isVertical ? x : Math.min(...xScale.range());\n      let newY = isVertical ? Math.max(...yScale.range()) : y;\n      const newHeight = isVertical ? 0 : height;\n      const newWidth = isVertical ? width : 0;\n\n      if (type === 'stackedDiverging') {\n        if (isVertical) {\n          newY = newY / 2;\n        } else {\n          newX = newX / 2;\n        }\n      }\n\n      return {\n        x: newX,\n        y: newY,\n        height: newHeight,\n        width: newWidth\n      };\n    },\n    [isVertical, type, xScale, yScale]\n  );\n\n  const getKeyCoords = useCallback(\n    (\n      v,\n      v0,\n      v1,\n      scale,\n      sizeOverride: number,\n      isCategorical: boolean,\n      padding: number\n    ) => {\n      let offset;\n      let size;\n\n      if (isCategorical) {\n        if (scale.bandwidth) {\n          offset = scale(v);\n          size = scale.bandwidth();\n\n          if (sizeOverride) {\n            if (offset) {\n              offset = offset + size / 2 - sizeOverride / 2;\n            } else {\n              // Stacked bar charts don't have offsets...\n              offset = size / 2 - sizeOverride / 2;\n            }\n\n            size = sizeOverride;\n          }\n        } else {\n          if (sizeOverride) {\n            throw new Error('Not a valid option for this scale type');\n          }\n\n          offset = scale(v0);\n          size = scale((v1 as any) - (v0 as any));\n\n          if (padding) {\n            const calc = calculateLinearScalePadding(scale, offset, size);\n            offset = calc.offset;\n            size = calc.size;\n          }\n        }\n      } else {\n        if (sizeOverride) {\n          throw new Error('Not a valid option for this scale type');\n        }\n\n        const c0 = scale(v0);\n        const c1 = scale(v1);\n        const delta = c1 - c0;\n        offset = c0;\n        size = Math.max(delta - 1, 0);\n      }\n\n      return {\n        offset: isNaN(offset) ? 0 : offset,\n        size: isNaN(size) ? 0 : size\n      };\n    },\n    [calculateLinearScalePadding]\n  );\n\n  const getValueCoords = useCallback(\n    (v0, v1, scale) => {\n      const c0 = scale(v0);\n      const c1 = scale(v1);\n      const size = Math.abs(c0 - c1);\n      const minSize = Math.max(minHeight || 0, size);\n      const offset = Math.min(c0, c1);\n\n      return {\n        offset: isNaN(offset) ? 0 : offset,\n        size: isNaN(minSize) ? 0 : minSize\n      };\n    },\n    [minHeight]\n  );\n\n  const getCoords = useCallback(\n    (data: ChartInternalShallowDataShape) => {\n      let newYScale = yScale;\n      let newXScale = xScale;\n\n      if (xScale1) {\n        if (isVertical) {\n          newXScale = xScale1;\n        } else {\n          newYScale = xScale1;\n        }\n      }\n\n      if (isVertical) {\n        const xCoords = getKeyCoords(\n          data.x,\n          data.x0,\n          data.x1,\n          newXScale,\n          width,\n          isCategorical,\n          padding\n        );\n        const yCoords = getValueCoords(data.y0, data.y1, newYScale);\n\n        return {\n          x: xCoords.offset,\n          width: xCoords.size,\n          y: yCoords.offset,\n          height: yCoords.size\n        } as BarCoordinates;\n      } else {\n        const yCoords = getKeyCoords(\n          data.y,\n          data.y0,\n          data.y1,\n          newYScale,\n          width,\n          isCategorical,\n          padding\n        );\n        const xCoords = getValueCoords(data.x0, data.x1, newXScale);\n\n        return {\n          x: xCoords.offset,\n          width: xCoords.size,\n          y: yCoords.offset,\n          height: yCoords.size\n        } as BarCoordinates;\n      }\n    },\n    [\n      getKeyCoords,\n      getValueCoords,\n      isCategorical,\n      isVertical,\n      padding,\n      width,\n      xScale,\n      xScale1,\n      yScale\n    ]\n  );\n\n  const onMouseEnterInternal = useCallback(\n    (event) => {\n      // Only tooltip bars rely on this...\n      if (tooltip) {\n        setInternalActive(true);\n      }\n\n      onMouseEnter?.({\n        value: data,\n        nativeEvent: event\n      });\n    },\n    [data, onMouseEnter, tooltip]\n  );\n\n  const onMouseLeaveInternal = useCallback(\n    (event) => {\n      // Only tooltip bars rely on this...\n      if (tooltip) {\n        setInternalActive(false);\n      }\n\n      onMouseLeave?.({\n        value: data,\n        nativeEvent: event\n      });\n    },\n    [data, onMouseLeave, tooltip]\n  );\n\n  const onMouseClick = useCallback(\n    (event) => {\n      onClick?.({\n        value: data,\n        nativeEvent: event\n      });\n    },\n    [data, onClick]\n  );\n\n  const getFill = useCallback(\n    (color: string) => {\n      if (mask) {\n        return `url(#mask-pattern-${id})`;\n      } else {\n        if (gradient) {\n          return `url(#gradient-${id})`;\n        }\n\n        return color;\n      }\n    },\n    [gradient, id, mask]\n  );\n\n  const tooltipData = useMemo(() => {\n    const xAttr = isCategorical ? 'x' : 'x0';\n    let x = data[xAttr]!;\n\n    // Stacked diverging negative numbers\n    // in horizontal layouts need to pull x0\n    if ((data.x0 as number) < 0) {\n      x = data.x0;\n    }\n\n    const matches = isVertical\n      ? data.key && data.key !== x\n      : data.key && data.key !== data.y;\n\n    if (matches) {\n      x = `${data.key} ∙ ${x}`;\n    }\n\n    return {\n      y: data.y,\n      x\n    };\n  }, [data, isCategorical, isVertical]);\n\n  const ariaLabelData = useMemo(() => getAriaLabel(tooltipData), [tooltipData]);\n\n  const getTransition = useCallback(\n    (index: number) => {\n      if (animated) {\n        let delay = 0;\n        if (layout === 'vertical') {\n          delay = (index / barCount) * 0.5;\n        } else {\n          delay = ((barCount - index) / barCount) * 0.5;\n        }\n\n        return {\n          ...DEFAULT_TRANSITION,\n          delay: delay\n        };\n      } else {\n        return {\n          type: false,\n          delay: 0\n        };\n      }\n    },\n    [animated, barCount, layout]\n  );\n\n  const renderBar = useCallback(\n    (currentColorShade: string, coords: BarCoordinates, index: number) => {\n      const maskPath = mask ? `url(#mask-${id})` : '';\n      const fill = getFill(currentColorShade);\n      const initialExit = getExit(coords);\n      const extras = constructFunctionProps({ className, style }, data);\n      const transition = getTransition(index);\n\n      // UGH: https://github.com/framer/motion/issues/384\n      const initial = {\n        ...initialExit,\n        attrX: initialExit.x,\n        attrY: initialExit.y,\n        fill\n      };\n\n      delete initial.x;\n      delete initial.y;\n\n      const animate = {\n        ...coords,\n        attrX: coords.x,\n        attrY: coords.y,\n        fill\n      };\n\n      delete animate.x;\n      delete animate.y;\n\n      return (\n        <g ref={rect}>\n          <motion.rect\n            className={classNames(extras.className)}\n            style={{\n              ...extras.style,\n              ...generateGlowStyles({\n                glow,\n                colorSchemeColor: currentColorShade\n              }),\n              cursor\n            }}\n            mask={maskPath}\n            rx={rx}\n            ry={ry}\n            initial={initial}\n            animate={animate}\n            exit={initial}\n            transition={transition}\n            onMouseEnter={onMouseEnterInternal}\n            onMouseLeave={onMouseLeaveInternal}\n            onClick={onMouseClick}\n            onMouseMove={onMouseMove}\n            tabIndex={0}\n            aria-label={ariaLabelData}\n            role=\"graphics-document\"\n          />\n        </g>\n      );\n    },\n    [\n      className,\n      cursor,\n      data,\n      getExit,\n      getFill,\n      getTransition,\n      glow,\n      id,\n      mask,\n      onMouseClick,\n      onMouseEnterInternal,\n      onMouseLeaveInternal,\n      onMouseMove,\n      rx,\n      ry,\n      style,\n      tooltipData\n    ]\n  );\n\n  const renderGuideBar = useCallback(() => {\n    if (!guide) {\n      return null;\n    }\n\n    // If we are stacked, only render the first bar\n    if (type === 'stacked' && barIndex !== 0) {\n      return null;\n    }\n\n    // No reason to show them since they are always 100% tall\n    if (type === 'stackedNormalized' || type === 'marimekko') {\n      console.error('Guide bars are not supported for these chart types');\n      return null;\n    }\n\n    const valueScale = isVertical ? yScale : xScale;\n    const [start, end] = valueScale.domain();\n    const attr = isVertical ? 'y' : 'x';\n\n    // For stacked diverging we need to flip the points for positive / negative bars\n    const attrStart = type === 'stackedDiverging' ? '0' : '1';\n    const endPoint = type === 'stackedDiverging' ? start : end;\n    const startPoint =\n      type === 'stackedDiverging' && (data[attr]! as number) > 0\n        ? end\n        : endPoint;\n\n    const coords = getCoords({\n      ...data,\n      [attr]: endPoint,\n      [`${attr}${attrStart}`]: startPoint\n    });\n\n    return (\n      <CloneElement<GuideBarProps>\n        element={guide}\n        {...coords}\n        active={active}\n      />\n    );\n  }, [\n    active,\n    barIndex,\n    data,\n    getCoords,\n    guide,\n    isVertical,\n    type,\n    xScale,\n    yScale\n  ]);\n\n  const isActive = tooltip ? internalActive : active;\n  const stroke = color(data, barIndex);\n  const coords = getCoords(data);\n  const currentColorShade = active\n    ? chroma(stroke).brighten(activeBrightness).hex()\n    : stroke;\n  const rangeLineColor = (rangeLines && rangeLines.props.color) || stroke;\n  const rangeLineColorShade = active\n    ? chroma(rangeLineColor).brighten(activeBrightness)\n    : rangeLineColor;\n  const index = groupIndex !== undefined ? groupIndex : barIndex;\n  const scale = isVertical ? yScale : xScale;\n  const barLabel = isVertical ? tooltipData.y : tooltipData.x;\n  const placement = layout === 'vertical' ? 'top' : 'right';\n\n  return (\n    <Fragment>\n      {renderGuideBar()}\n      {renderBar(currentColorShade, coords, index)}\n      {rangeLines && (\n        <CloneElement<RangeLinesProps>\n          element={rangeLines}\n          {...coords}\n          index={index}\n          data={data}\n          scale={scale}\n          color={rangeLineColorShade}\n          barCount={barCount}\n          animated={animated}\n          layout={layout}\n          type={type}\n        />\n      )}\n      {mask && (\n        <Fragment>\n          <Mask id={`mask-${id}`} fill={`url(#gradient-${id})`} />\n          <CloneElement<MaskProps>\n            element={mask}\n            id={`mask-pattern-${id}`}\n            fill={stroke}\n          />\n        </Fragment>\n      )}\n      {gradient && (\n        <CloneElement<GradientProps>\n          element={gradient}\n          id={`gradient-${id}`}\n          direction={layout}\n          color={currentColorShade}\n        />\n      )}\n      {label && (\n        <CloneElement<BarLabelProps>\n          element={label}\n          {...coords}\n          text={formatValue(barLabel)}\n          index={index}\n          data={data}\n          scale={scale}\n          fill={label.props.fill || currentColorShade}\n          barCount={barCount}\n          animated={animated}\n          layout={layout}\n          type={type}\n        />\n      )}\n      {tooltip && (\n        <CloneElement<ChartTooltipProps>\n          element={tooltip}\n          visible={!!isActive}\n          reference={rect}\n          color={color}\n          value={tooltipData}\n          placement={(tooltip.props as any).placement || placement}\n          data={data}\n        />\n      )}\n    </Fragment>\n  );\n};\n\nBar.defaultProps = {\n  activeBrightness: 0.5,\n  rx: 0,\n  ry: 0,\n  cursor: 'auto',\n  rangeLines: null,\n  label: null,\n  tooltip: null,\n  layout: 'vertical',\n  guide: null,\n  gradient: <Gradient />\n};\n","import React, {\n  Fragment,\n  ReactElement,\n  useMemo,\n  useRef,\n  FC,\n  useState,\n  useCallback\n} from 'react';\nimport { Bar, BarProps, BarType } from './Bar';\nimport {\n  ChartInternalDataShape,\n  ChartInternalNestedDataShape,\n  ChartInternalShallowDataShape,\n  Direction\n} from '../../common/data';\nimport { getColor, ColorSchemeType } from '../../common/color';\nimport { CloneElement } from 'reablocks';\nimport {\n  TooltipAreaProps,\n  TooltipArea,\n  ChartTooltip,\n  TooltipAreaEvent\n} from '../../common/Tooltip';\nimport { LinearValueMarker, LinearValueMarkerProps } from '../../common';\n\ntype BarElement = ReactElement<BarProps, typeof Bar>;\n\nexport interface BarSeriesProps {\n  /**\n   * Parsed data shape. Set internally by `BarChart`.\n   */\n  data: ChartInternalDataShape[];\n\n  /**\n   * Id of the bar chart. Set internally by `BarChart`.\n   */\n  id: string;\n\n  /**\n   * D3 scale for X Axis. Set internally by `BarChart`.\n   */\n  xScale: any;\n\n  /**\n   * D3 scale for Y Axis. Set internally by `BarChart`.\n   */\n  yScale: any;\n\n  /**\n   * D3 scale for X Multi-Group Axis. Set internally by `BarChart`.\n   */\n  xScale1: any;\n\n  /**\n   * Bar element.\n   */\n  bar: BarElement | BarElement[];\n\n  /**\n   * Type of the chart.\n   */\n  type: BarType;\n\n  /**\n   * Color scheme for the chart.\n   */\n  colorScheme: ColorSchemeType;\n\n  /**\n   * Whether the chart is animated or not.\n   */\n  animated: boolean;\n\n  /**\n   * Amount of padding between each bar.\n   */\n  padding: number;\n\n  /**\n   * Amount of padding between each group.\n   */\n  groupPadding: number;\n\n  /**\n   * Whether the chart is categorical or not. Set internally by `BarChart`.\n   */\n  isCategorical: boolean;\n\n  /**\n   * Direction of the chart\n   */\n  layout: Direction;\n\n  /**\n   * The size of each bin/bucket in the bar chart.\n   */\n  binSize?: number;\n\n  /**\n   * Height of the chart. Set internally by `BarChart`.\n   */\n  height: number;\n\n  /**\n   * Width of the chart. Set internally by `BarChart`.\n   */\n  width: number;\n\n  /**\n   * Tooltip for the chart area.\n   */\n  tooltip: ReactElement<TooltipAreaProps, typeof TooltipArea> | null;\n\n  /**\n   * Value markers line for the chart.\n   */\n  valueMarkers:\n    | ReactElement<LinearValueMarkerProps, typeof LinearValueMarker>[]\n    | null;\n}\n\nexport const BarSeries: FC<Partial<BarSeriesProps>> = ({\n  data,\n  tooltip,\n  xScale,\n  yScale,\n  height,\n  width,\n  colorScheme,\n  xScale1,\n  bar,\n  padding,\n  animated,\n  isCategorical,\n  layout,\n  type,\n  id,\n  valueMarkers\n}) => {\n  const ref = useRef<any | null>(null);\n  const [activeValues, setActiveValues] = useState<any | null>(null);\n  const isVertical = useMemo(() => layout === 'vertical', [layout]);\n\n  const isMultiSeries = useMemo(() => {\n    return (\n      type === 'grouped' ||\n      type === 'stacked' ||\n      type === 'marimekko' ||\n      type === 'stackedNormalized' ||\n      type === 'stackedDiverging'\n    );\n  }, [type]);\n\n  const getTransform = useCallback(\n    (data: ChartInternalNestedDataShape) => {\n      let xPos = 0;\n      let yPos = 0;\n      if (type !== 'marimekko') {\n        if (layout === 'vertical') {\n          const val = xScale(data.key);\n          xPos = val;\n        } else {\n          const val = yScale(data.key);\n          yPos = val;\n        }\n      }\n\n      return `translate(${xPos}, ${yPos})`;\n    },\n    [layout, type, xScale, yScale]\n  );\n\n  const getBarColor = useCallback(\n    (point, index: number) => {\n      let key = 'key';\n      if (isMultiSeries) {\n        if (layout === 'vertical') {\n          key = 'x';\n        } else {\n          key = 'y';\n        }\n      }\n\n      // histograms...\n      if (point[key] === undefined) {\n        key = 'x0';\n      }\n\n      return getColor({\n        colorScheme,\n        point,\n        index,\n        data,\n        isMultiSeries,\n        attribute: key\n      });\n    },\n    [colorScheme, data, isMultiSeries, layout]\n  );\n\n  const onMouseMove = useCallback((event) => {\n    // Manuallly call mouse move so we don't have to kill bar pointer events\n    ref.current?.triggerMouseMove(event);\n  }, []);\n\n  const onValueEnter = useCallback((event: TooltipAreaEvent) => {\n    setActiveValues(event.value);\n  }, []);\n\n  const onValueLeave = useCallback(() => {\n    setActiveValues(null);\n  }, []);\n\n  const renderBar = useCallback(\n    (\n      data: ChartInternalShallowDataShape,\n      barIndex: number,\n      barCount: number,\n      groupIndex?: number\n    ) => {\n      const active = activeValues && activeValues.x === data.key;\n\n      let newYScale = yScale;\n      let newXScale = xScale;\n\n      if (xScale1) {\n        if (isVertical) {\n          newXScale = xScale1;\n        } else {\n          newYScale = xScale1;\n        }\n      }\n\n      // Histograms dont have keys\n      let key = barIndex.toString();\n      if (data.key) {\n        key = `${data.key!.toString()}-${groupIndex}-${data.x}`;\n      }\n\n      let barElements = Array.isArray(bar) ? bar[barIndex] : bar;\n      if (!bar) {\n        barElements = <Bar />;\n      }\n\n      return (\n        <Fragment key={key}>\n          <CloneElement<BarProps>\n            element={barElements}\n            id={`${id}-bar-${groupIndex}-${barIndex}`}\n            animated={animated}\n            active={active}\n            xScale={newXScale}\n            xScale1={xScale1}\n            yScale={newYScale}\n            padding={padding}\n            barCount={barCount}\n            groupIndex={groupIndex}\n            barIndex={barIndex}\n            data={data}\n            isCategorical={isCategorical}\n            color={getBarColor}\n            layout={layout}\n            type={type}\n            onMouseMove={onMouseMove}\n          />\n        </Fragment>\n      );\n    },\n    [\n      activeValues,\n      animated,\n      bar,\n      getBarColor,\n      id,\n      isCategorical,\n      isVertical,\n      layout,\n      onMouseMove,\n      padding,\n      type,\n      xScale,\n      xScale1,\n      yScale\n    ]\n  );\n\n  const renderBarGroup = useCallback(\n    (\n      data: ChartInternalShallowDataShape[],\n      barCount: number,\n      groupIndex?: number\n    ) => {\n      return (\n        <Fragment>\n          {data.map((barData, barIndex) =>\n            renderBar(barData, barIndex, barCount, groupIndex)\n          )}\n        </Fragment>\n      );\n    },\n    [renderBar]\n  );\n\n  const renderValueMarkers = useCallback(\n    () => (\n      <>\n        {valueMarkers?.length &&\n          valueMarkers.map((marker) => (\n            <CloneElement<LinearValueMarkerProps>\n              key={marker.key}\n              element={marker}\n              size={layout === 'vertical' ? width : height}\n              value={\n                layout === 'vertical'\n                  ? yScale(marker.props.value)\n                  : xScale(marker.props.value)\n              }\n              isHorizontal={layout === 'vertical'}\n            />\n          ))}\n      </>\n    ),\n    [height, layout, valueMarkers, width, xScale, yScale]\n  );\n\n  return (\n    <CloneElement<TooltipAreaProps>\n      element={tooltip}\n      childRef={ref}\n      xScale={xScale}\n      yScale={yScale}\n      data={data}\n      height={height}\n      width={width}\n      inverse={false}\n      isHorizontal={layout === 'horizontal'}\n      color={getBarColor}\n      onValueEnter={onValueEnter}\n      onValueLeave={onValueLeave}\n      isContinous={false}\n    >\n      {isMultiSeries &&\n        (data as ChartInternalNestedDataShape[]).map((groupData, index) => (\n          <g transform={getTransform(groupData)} key={`bar-group-${index}`}>\n            {renderBarGroup(\n              groupData.data as ChartInternalShallowDataShape[],\n              data.length,\n              index\n            )}\n          </g>\n        ))}\n      {!isMultiSeries &&\n        renderBarGroup(data as ChartInternalShallowDataShape[], data.length)}\n      {renderValueMarkers()}\n    </CloneElement>\n  );\n};\n\nBarSeries.defaultProps = {\n  type: 'standard',\n  padding: 0.1,\n  groupPadding: 16,\n  animated: true,\n  tooltip: (\n    <TooltipArea\n      tooltip={\n        <ChartTooltip\n          followCursor={true}\n          modifiers={{\n            offset: '5px, 5px'\n          }}\n        />\n      }\n    />\n  ),\n  colorScheme: 'cybertron',\n  bar: <Bar />,\n  layout: 'vertical'\n};\n","import React, { FC, useMemo } from 'react';\nimport { ChartInternalShallowDataShape, Direction } from '../../common/data';\nimport { motion } from 'framer-motion';\nimport { DEFAULT_TRANSITION } from '../../common/Motion';\nimport { BarType } from './Bar';\n\nexport interface RangeLinesProps {\n  /**\n   * Height of the bar.\n   */\n  height: number;\n\n  /**\n   * Width of the bar.\n   */\n  width: number;\n\n  /**\n   * SVG x attribute for the bar.\n   */\n  x: number;\n\n  /**\n   * SVG y attribute for the bar.\n   */\n  y: number;\n\n  /**\n   * Group index or index of the bar. Set internally by `BarSeries`.\n   */\n  index: number;\n\n  /**\n   * Stroke width of the range line.\n   */\n  strokeWidth: number;\n\n  /**\n   * D3 scale for Axis. Set internally by `BarChart`.\n   */\n  scale: any;\n\n  /**\n   * Position of the range line.\n   */\n  position: 'top' | 'bottom';\n\n  /**\n   * Parsed data shape. Set internally by `BarChart`.\n   */\n  data: ChartInternalShallowDataShape;\n\n  /**\n   * Color for the range line.\n   */\n  color: string;\n\n  /**\n   * Total number of bars used for animation. Set internally by `BarSeries`.\n   */\n  barCount: number;\n\n  /**\n   * Direction of the chart. Set internally by `BarSeries`.\n   */\n  layout: Direction;\n\n  /**\n   * Whether to animate the enter/update/exit. Set internally by `BarSeries`.\n   */\n  animated: boolean;\n\n  /**\n   * Type of bar chart. Set internally by `BarSeries`.\n   */\n  type: BarType;\n}\n\nexport const RangeLines: FC<Partial<RangeLinesProps>> = ({\n  layout,\n  color,\n  x,\n  y,\n  scale,\n  type,\n  height,\n  position,\n  strokeWidth,\n  width,\n  animated,\n  index,\n  barCount,\n  data\n}) => {\n  const isVertical = useMemo(() => layout === 'vertical', [layout]);\n  const rangeLineHeight = useMemo(\n    () => Math.min(strokeWidth, isVertical ? height : width),\n    [height, isVertical, strokeWidth, width]\n  );\n\n  const [newWidth, newHeight] = useMemo(\n    () => [\n      isVertical ? width : rangeLineHeight,\n      isVertical ? rangeLineHeight : height\n    ],\n    [height, isVertical, rangeLineHeight, width]\n  );\n\n  const enterProps = useMemo(() => {\n    let newY = y;\n    let newX = x;\n\n    // If its diverging and the value is negative, we\n    // need to reverse the type...\n    const isTop = position === 'top';\n    const direction = isVertical\n      ? (data.y as number) < 0 && isTop\n        ? 'bottom'\n        : position\n      : (data.x0 as number) < 0 && isTop\n        ? 'bottom'\n        : position;\n\n    if (isVertical) {\n      if (direction === 'top') {\n        newY = y;\n      } else {\n        newY = y + height - rangeLineHeight;\n      }\n    } else {\n      if (direction === 'top') {\n        newX = x + width - rangeLineHeight;\n      } else {\n        newX = x;\n      }\n    }\n\n    return {\n      x: newX,\n      y: newY,\n      opacity: 1\n    };\n  }, [\n    data.x0,\n    data.y,\n    height,\n    isVertical,\n    position,\n    rangeLineHeight,\n    width,\n    x,\n    y\n  ]);\n\n  const exitProps = useMemo(() => {\n    let newY = y;\n    let newX = x;\n\n    if (isVertical) {\n      const maxY = Math.max(...scale.range());\n      if (position === 'top') {\n        newY = maxY;\n      } else {\n        newY = maxY + height - rangeLineHeight;\n      }\n    } else {\n      const minX = Math.min(...scale.range());\n      if (position === 'top') {\n        newX = minX;\n      } else {\n        newX = minX + width - rangeLineHeight;\n      }\n    }\n\n    if (type === 'stackedDiverging') {\n      if (isVertical) {\n        newY = newY / 2;\n      } else {\n        newX = newX / 2;\n      }\n    }\n\n    return {\n      y: newY,\n      x: newX,\n      opacity: 0\n    };\n  }, [height, isVertical, position, rangeLineHeight, scale, type, width, x, y]);\n\n  const delay = useMemo(() => {\n    let delay = 0;\n    if (animated) {\n      if (layout === 'vertical') {\n        return (index / barCount) * 0.5;\n      } else {\n        return ((barCount - index) / barCount) * 0.5;\n      }\n    }\n\n    return delay;\n  }, [animated, barCount, index, layout]);\n\n  // UGH: https://github.com/framer/motion/issues/384\n  const initial = useMemo(() => {\n    const r = {\n      ...exitProps,\n      attrX: exitProps.x,\n      attrY: exitProps.y\n    };\n\n    delete r.x;\n    delete r.y;\n\n    return r;\n  }, [exitProps]);\n\n  const animate = useMemo(() => {\n    const r = {\n      ...enterProps,\n      attrX: enterProps.x,\n      attrY: enterProps.y\n    };\n\n    delete r.x;\n    delete r.y;\n\n    return r;\n  }, [enterProps]);\n\n  return (\n    <motion.rect\n      pointerEvents=\"none\"\n      fill={color}\n      width={newWidth}\n      height={newHeight}\n      initial={initial}\n      animate={animate}\n      exit={initial}\n      transition={{\n        ...DEFAULT_TRANSITION,\n        delay\n      }}\n    />\n  );\n};\n\nRangeLines.defaultProps = {\n  position: 'top',\n  strokeWidth: 1,\n  layout: 'vertical'\n};\n","import React, { FC } from 'react';\nimport { BarSeriesProps, BarSeries } from './BarSeries';\nimport { Bar } from './Bar';\nimport { RangeLines } from './RangeLines';\nimport { Gradient, GradientStop } from '../../common';\n\nexport const StackedBarSeries: FC<Partial<BarSeriesProps>> = (props) => (\n  <BarSeries type=\"stackedNormalized\" {...props} />\n);\n\nStackedBarSeries.defaultProps = {\n  ...BarSeries.defaultProps,\n  type: 'stacked',\n  bar: (\n    <Bar\n      gradient={\n        <Gradient\n          stops={[\n            <GradientStop offset=\"5%\" stopOpacity={0.1} key=\"start\" />,\n            <GradientStop offset=\"90%\" stopOpacity={0.7} key=\"stop\" />\n          ]}\n        />\n      }\n      rangeLines={<RangeLines position=\"top\" strokeWidth={3} />}\n    />\n  )\n};\n","import React, { FC } from 'react';\nimport { BarSeriesProps, BarSeries } from './BarSeries';\nimport { Bar } from './Bar';\nimport { RangeLines } from './RangeLines';\nimport {\n  ChartTooltip,\n  TooltipTemplate,\n  TooltipArea\n} from '../../common/Tooltip';\nimport { formatValue } from '../../common/utils/formatting';\nimport { Gradient, GradientStop } from '../../common/Gradient';\n\nexport const StackedNormalizedBarSeries: FC<Partial<BarSeriesProps>> = (\n  props\n) => <BarSeries type=\"stackedNormalized\" {...props} />;\n\nStackedNormalizedBarSeries.defaultProps = {\n  ...BarSeries.defaultProps,\n  type: 'stackedNormalized',\n  tooltip: (\n    <TooltipArea\n      tooltip={\n        <ChartTooltip\n          followCursor={true}\n          modifiers={{\n            offset: '5px, 5px'\n          }}\n          content={(point, color) => {\n            point.data = point.data.map((d) => {\n              // Handle horz case\n              const start = isNaN(d.y0) ? d.x0 : d.y0;\n              const end = isNaN(d.y1) ? d.x1 : d.y1;\n\n              return {\n                ...d,\n                value: `${formatValue(Math.floor((end - start) * 100))}%`\n              };\n            });\n\n            return <TooltipTemplate value={point} color={color} />;\n          }}\n        />\n      }\n    />\n  ),\n  bar: (\n    <Bar\n      gradient={\n        <Gradient\n          stops={[\n            <GradientStop offset=\"5%\" stopOpacity={0.1} key=\"start\" />,\n            <GradientStop offset=\"90%\" stopOpacity={0.7} key=\"stop\" />\n          ]}\n        />\n      }\n      rangeLines={<RangeLines position=\"top\" strokeWidth={3} />}\n    />\n  )\n};\n","import React, { FC } from 'react';\nimport { BarSeriesProps, BarSeries } from './BarSeries';\nimport { Bar } from './Bar';\nimport { RangeLines } from './RangeLines';\nimport {\n  ChartTooltip,\n  TooltipTemplate,\n  TooltipArea\n} from '../../common/Tooltip';\nimport { formatValue } from '../../common/utils/formatting';\nimport { Gradient, GradientStop } from '../../common/Gradient';\n\nexport const MarimekkoBarSeries: FC<Partial<BarSeriesProps>> = (props) => (\n  <BarSeries type=\"marimekko\" {...props} />\n);\n\nMarimekkoBarSeries.defaultProps = {\n  ...BarSeries.defaultProps,\n  type: 'marimekko',\n  padding: 10,\n  tooltip: (\n    <TooltipArea\n      tooltip={\n        <ChartTooltip\n          followCursor={true}\n          modifiers={{\n            offset: '5px, 5px'\n          }}\n          content={(point, color) => {\n            const data = {\n              ...point,\n              data: point.data.map((d) => ({\n                ...d,\n                value: `${formatValue(d.value)} ∙ ${formatValue(\n                  Math.floor((d.y1 - d.y0) * 100)\n                )}%`\n              }))\n            };\n\n            return <TooltipTemplate value={data} color={color} />;\n          }}\n        />\n      }\n    />\n  ),\n  bar: (\n    <Bar\n      padding={10}\n      gradient={\n        <Gradient\n          stops={[\n            <GradientStop offset=\"5%\" stopOpacity={0.1} key=\"start\" />,\n            <GradientStop offset=\"90%\" stopOpacity={0.7} key=\"stop\" />\n          ]}\n        />\n      }\n      rangeLines={<RangeLines position=\"top\" strokeWidth={3} />}\n    />\n  )\n};\n","import React, { FC, useMemo } from 'react';\nimport { ChartInternalShallowDataShape, Direction } from '../../common/data';\nimport { BarType } from './Bar';\nimport { motion } from 'framer-motion';\nimport { DEFAULT_TRANSITION } from '../../common/Motion';\n\nexport interface BarLabelProps {\n  /**\n   * Text of the label. Set internally by `Bar`.\n   */\n  text: string;\n\n  /**\n   * Height of the bar.\n   */\n  height: number;\n\n  /**\n   * Width of the bar.\n   */\n  width: number;\n\n  /**\n   * SVG x attribute for the bar.\n   */\n  x: number;\n\n  /**\n   * SVG y attribute for the bar.\n   */\n  y: number;\n\n  /**\n   * Group index or index of the bar. Set internally by `BarSeries`.\n   */\n  index: number;\n\n  /**\n   * D3 scale for Axis. Set internally by `BarChart`.\n   */\n  scale: any;\n\n  /**\n   * Position of the label.\n   */\n  position: 'top' | 'center' | 'bottom';\n\n  /**\n   * Parsed data shape. Set internally by `BarChart`.\n   */\n  data: ChartInternalShallowDataShape;\n\n  /**\n   * Color of the text.\n   */\n  fill: string;\n\n  /**\n   * Number of the bars in the bar group. Set internally by `BarSeries`.\n   */\n  barCount: number;\n\n  /**\n   * Layout of bar chart to render. Set internally by `BarSeries`.\n   */\n  layout: Direction;\n\n  /**\n   * Whether to animate the enter/update/exit. Set internally by `BarSeries`.\n   */\n  animated: boolean;\n\n  /**\n   * Type of bar chart to render. Set internally by `BarSeries`.\n   */\n  type: BarType;\n\n  /**\n   * Font size of the text.\n   */\n  fontSize: number;\n\n  /**\n   * Font family of the text.\n   */\n  fontFamily: string;\n\n  /**\n   * Padding of the label.\n   */\n  padding: number;\n\n  /**\n   * Class name to apply to the text.\n   */\n  className?: any;\n}\n\nexport const BarLabel: FC<Partial<BarLabelProps>> = ({\n  fontSize,\n  fontFamily,\n  fill,\n  layout,\n  className,\n  text,\n  x,\n  y,\n  height,\n  position,\n  width,\n  data,\n  padding,\n  scale,\n  type,\n  animated,\n  index,\n  barCount\n}) => {\n  const isVertical = useMemo(() => layout === 'vertical', [layout]);\n  const textAnchor = isVertical ? 'middle' : 'start';\n\n  const enterProps = useMemo(() => {\n    let newY = y;\n    let newX = x;\n\n    // If its diverging and the value is negative, we\n    // need to reverse the type...\n    const isTop = position === 'top';\n    const direction = isVertical\n      ? (data.y as number) < 0 && isTop\n        ? 'bottom'\n        : position\n      : (data.x0 as number) < 0 && isTop\n        ? 'bottom'\n        : position;\n\n    if (isVertical) {\n      if (direction === 'top') {\n        newY = y - padding;\n      } else if (direction === 'center') {\n        newY = y + height / 2;\n      } else if (direction === 'bottom') {\n        newY = y + height - padding;\n      }\n      newX = newX + width / 2;\n    } else {\n      if (direction === 'top') {\n        newX = x + width + padding;\n      } else if (direction === 'center') {\n        newX = x + width / 2;\n      } else if (direction === 'bottom') {\n        newX = x + padding;\n      }\n      newY = newY + height / 2;\n    }\n\n    return {\n      translateX: newX,\n      translateY: newY,\n      opacity: 1\n    };\n  }, [data.x0, data.y, height, isVertical, padding, position, width, x, y]);\n\n  const exitProps = useMemo(() => {\n    let newY = y;\n    let newX = x;\n\n    if (isVertical) {\n      const maxY = Math.max(...scale.range());\n      if (position === 'top') {\n        newY = maxY;\n      } else {\n        newY = maxY + height + padding;\n      }\n\n      newX = newX + width / 2;\n    } else {\n      const minX = Math.min(...scale.range());\n      if (position === 'top') {\n        newX = minX;\n      } else {\n        newX = minX + width + padding;\n      }\n\n      newY = newY + height / 2;\n    }\n\n    if (type === 'stackedDiverging') {\n      if (isVertical) {\n        newY = newY / 2;\n      } else {\n        newX = newX / 2;\n      }\n    }\n\n    return {\n      translateY: newY,\n      translateX: newX,\n      opacity: 0\n    };\n  }, [height, isVertical, padding, position, scale, type, width, x, y]);\n\n  const delay = useMemo(() => {\n    let delay = 0;\n    if (animated) {\n      if (layout === 'vertical') {\n        return (index / barCount) * 0.5;\n      } else {\n        return ((barCount - index) / barCount) * 0.5;\n      }\n    }\n\n    return delay;\n  }, [animated, barCount, index, layout]);\n\n  return (\n    <motion.g\n      initial={exitProps}\n      animate={enterProps}\n      exit={exitProps}\n      transition={{\n        ...DEFAULT_TRANSITION,\n        delay\n      }}\n      fontSize={fontSize}\n      fontFamily={fontFamily}\n    >\n      <text fill={fill} className={className} textAnchor={textAnchor}>\n        {text}\n      </text>\n    </motion.g>\n  );\n};\n\nBarLabel.defaultProps = {\n  position: 'top',\n  layout: 'vertical',\n  fontSize: 13,\n  padding: 5,\n  fontFamily: 'sans-serif',\n  fill: '#000'\n};\n","import React, { FC } from 'react';\nimport { BarSeriesProps, BarSeries } from './BarSeries';\nimport {\n  ChartTooltip,\n  TooltipTemplate,\n  TooltipArea\n} from '../../common/Tooltip';\nimport { formatValue } from '../../common/utils/formatting';\nimport { schemes } from '../../common/color';\n\nexport const HistogramBarSeries: FC<Partial<BarSeriesProps>> = ({\n  type,\n  ...rest\n}) => <BarSeries {...rest} />;\n\nHistogramBarSeries.defaultProps = {\n  ...BarSeries.defaultProps,\n  colorScheme: schemes.cybertron[0],\n  tooltip: (\n    <TooltipArea\n      tooltip={\n        <ChartTooltip\n          followCursor={true}\n          modifiers={{\n            offset: '5px, 5px'\n          }}\n          content={(point, color) => {\n            const data = {\n              ...point,\n              x: `${formatValue(point.x0)} - ${formatValue(point.x1)}`,\n              value: point.y\n            };\n\n            return <TooltipTemplate value={data} color={color} />;\n          }}\n        />\n      }\n    />\n  )\n};\n","import React, { FC } from 'react';\nimport { motion } from 'framer-motion';\n\nexport interface GuideBarProps extends SVGRect {\n  active: boolean;\n  fill?: string;\n  opacity?: number;\n}\n\nexport const GuideBar: FC<Partial<GuideBarProps>> = ({\n  active,\n  opacity = 0.15,\n  ...rest\n}) => {\n  const { x, y, ...other } = rest;\n\n  return (\n    <motion.rect\n      {...other}\n      pointerEvents=\"none\"\n      initial=\"hidden\"\n      animate={active ? 'visible' : 'hidden'}\n      variants={{\n        hidden: { opacity: 0, attrX: x, attrY: y },\n        visible: { opacity, attrX: x, attrY: y }\n      }}\n    />\n  );\n};\n\nGuideBar.defaultProps = {\n  fill: '#eee',\n  opacity: 0.15\n};\n","import React, { Fragment, ReactElement, FC, useMemo, useCallback } from 'react';\nimport classNames from 'classnames';\nimport {\n  isAxisVisible,\n  LinearAxisProps,\n  LinearXAxisTickSeries,\n  LinearXAxis,\n  LinearYAxis,\n  LinearAxis\n} from '../common/Axis';\nimport { BarSeries, BarSeriesProps } from './BarSeries';\nimport {\n  ChartDataShape,\n  ChartNestedDataShape,\n  buildBarStackData,\n  buildMarimekkoData,\n  buildWaterfall,\n  ChartShallowDataShape,\n  buildNestedChartData,\n  buildShallowChartData,\n  StackTypes\n} from '../common/data';\nimport { GridlineSeries, GridlineSeriesProps } from '../common/Gridline';\nimport {\n  getXScale,\n  getYScale,\n  getGroupScale,\n  getInnerScale,\n  getMarimekkoScale,\n  getMarimekkoGroupScale\n} from '../common/scales';\nimport { ChartBrushProps, ChartBrush } from '../common/Brush';\nimport css from './BarChart.module.css';\nimport {\n  ChartContainer,\n  ChartContainerChildProps,\n  ChartProps\n} from '../common/containers/ChartContainer';\nimport { CloneElement } from 'reablocks';\n\nexport interface BarChartProps extends ChartProps {\n  /**\n   * Data the chart will receive to render.\n   */\n  data: ChartDataShape[];\n\n  /**\n   * The series component that renders the bar components.\n   */\n  series: ReactElement<BarSeriesProps, typeof BarSeries>;\n\n  /**\n   * The linear axis component for the Y Axis of the chart.\n   */\n  yAxis: ReactElement<LinearAxisProps, typeof LinearAxis>;\n\n  /**\n   * The linear axis component for the X Axis of the chart.\n   */\n  xAxis: ReactElement<LinearAxisProps, typeof LinearAxis>;\n\n  /**\n   * The chart's background gridlines component.\n   */\n  gridlines: ReactElement<GridlineSeriesProps, typeof GridlineSeries> | null;\n\n  /**\n   * The chart's brush component.\n   */\n  brush: ReactElement<ChartBrushProps, typeof ChartBrush> | null;\n\n  /**\n   * Any secondary axis components. Useful for multi-axis charts.\n   */\n  secondaryAxis?: ReactElement<LinearAxisProps, typeof LinearAxis>[];\n}\n\nexport const BarChart: FC<Partial<BarChartProps>> = ({\n  id,\n  width,\n  height,\n  margins,\n  className,\n  data,\n  xAxis,\n  yAxis,\n  series,\n  brush,\n  gridlines,\n  secondaryAxis,\n  containerClassName\n}) => {\n  const isVertical = useMemo(\n    () => series.props.layout === 'vertical',\n    [series]\n  );\n  const keyAxis = useMemo(\n    () => (isVertical ? xAxis : yAxis),\n    [yAxis, xAxis, isVertical]\n  );\n  const isDiverging = useMemo(\n    () => series.props.type === 'stackedDiverging',\n    [series.props.type]\n  );\n\n  const getMarimekkoGroupScales = useCallback(\n    (aggregatedData, axis, width: number) => {\n      const keyScale = getMarimekkoScale(width, axis.props.roundDomains);\n\n      const groupScale = getMarimekkoGroupScale({\n        width,\n        padding: series.props.padding,\n        data: aggregatedData,\n        valueScale: keyScale\n      });\n\n      return {\n        keyScale,\n        groupScale\n      };\n    },\n    [series.props.padding]\n  );\n\n  const getMultiGroupScales = useCallback(\n    (aggregatedData, height: number, width: number) => {\n      const { groupPadding, layout } = series.props;\n\n      const groupScale = getGroupScale({\n        dimension: isVertical ? width : height,\n        direction: layout,\n        padding: groupPadding,\n        data: aggregatedData\n      });\n\n      const keyScale = getInnerScale({\n        groupScale: groupScale,\n        padding: series.props.padding,\n        data: aggregatedData,\n        prop: isVertical ? 'x' : 'y'\n      });\n\n      return {\n        groupScale,\n        keyScale\n      };\n    },\n    [isVertical, series.props]\n  );\n\n  const getKeyScale = useCallback(\n    (aggregatedData, axis, isMultiSeries: boolean, width: number) => {\n      return getXScale({\n        width,\n        type: axis.props.type,\n        roundDomains: axis.props.roundDomains,\n        data: aggregatedData,\n        padding: series.props.padding,\n        domain: axis.props.domain,\n        isMultiSeries,\n        isDiverging\n      });\n    },\n    [isDiverging, series]\n  );\n\n  const getValueScale = useCallback(\n    (aggregatedData, axis, isMultiSeries: boolean, height: number) => {\n      return getYScale({\n        roundDomains: axis.props.roundDomains,\n        padding: series.props.padding,\n        type: axis.props.type,\n        height,\n        data: aggregatedData,\n        domain: axis.props.domain,\n        isMultiSeries,\n        isDiverging\n      });\n    },\n    [isDiverging, series]\n  );\n\n  const getScalesAndData = useCallback(\n    (chartHeight: number, chartWidth: number) => {\n      const { type, layout } = series.props;\n      const isMarimekko = type === 'marimekko';\n      const isGrouped = type === 'grouped';\n      const isStacked =\n        type === 'stacked' ||\n        type === 'stackedNormalized' ||\n        type === 'stackedDiverging';\n      const isMultiSeries = isGrouped || isStacked;\n\n      let aggregatedData;\n      if (isStacked) {\n        let distroType: StackTypes = 'default';\n        if (type === 'stackedNormalized') {\n          distroType = 'expand';\n        } else if (type === 'stackedDiverging') {\n          distroType = 'diverging';\n        }\n\n        aggregatedData = buildBarStackData(\n          data as ChartNestedDataShape[],\n          distroType,\n          layout\n        );\n      } else if (type === 'waterfall') {\n        aggregatedData = buildWaterfall(\n          data as ChartShallowDataShape[],\n          layout,\n          series.props.binSize\n        );\n      } else if (isMarimekko) {\n        aggregatedData = buildMarimekkoData(data as ChartNestedDataShape[]);\n      } else if (isGrouped) {\n        aggregatedData = buildNestedChartData(\n          data as ChartNestedDataShape[],\n          false,\n          layout\n        );\n      } else {\n        aggregatedData = buildShallowChartData(\n          data as ChartShallowDataShape[],\n          layout,\n          series.props.binSize\n        );\n      }\n\n      let yScale;\n      let xScale;\n      let xScale1;\n\n      if (isVertical) {\n        if (isGrouped) {\n          const { keyScale, groupScale } = getMultiGroupScales(\n            aggregatedData,\n            chartHeight,\n            chartWidth\n          );\n          xScale = groupScale;\n          xScale1 = keyScale;\n        } else if (isMarimekko) {\n          const { keyScale, groupScale } = getMarimekkoGroupScales(\n            aggregatedData,\n            xAxis,\n            chartWidth\n          );\n          xScale = groupScale;\n          xScale1 = keyScale;\n        } else {\n          xScale = getKeyScale(\n            aggregatedData,\n            xAxis,\n            isMultiSeries,\n            chartWidth\n          );\n        }\n\n        yScale = getValueScale(\n          aggregatedData,\n          yAxis,\n          isMultiSeries,\n          chartHeight\n        );\n      } else {\n        if (isGrouped) {\n          const { keyScale, groupScale } = getMultiGroupScales(\n            aggregatedData,\n            chartHeight,\n            chartWidth\n          );\n          yScale = groupScale;\n          xScale1 = keyScale;\n          xScale = getKeyScale(\n            aggregatedData,\n            xAxis,\n            isMultiSeries,\n            chartWidth\n          );\n        } else if (isMarimekko) {\n          throw new Error(\n            'Marimekko is currently not supported for horizontal layouts'\n          );\n        } else {\n          xScale = getKeyScale(\n            aggregatedData,\n            xAxis,\n            isMultiSeries,\n            chartWidth\n          );\n          yScale = getValueScale(\n            aggregatedData,\n            yAxis,\n            isMultiSeries,\n            chartHeight\n          );\n        }\n      }\n\n      return { xScale, xScale1, yScale, aggregatedData };\n    },\n    [\n      getKeyScale,\n      data,\n      getMarimekkoGroupScales,\n      getMultiGroupScales,\n      getValueScale,\n      isVertical,\n      series.props,\n      xAxis,\n      yAxis\n    ]\n  );\n\n  const renderChart = useCallback(\n    (containerProps: ChartContainerChildProps) => {\n      const { chartHeight, chartWidth, id, updateAxes, chartSized } =\n        containerProps;\n      const { xScale, xScale1, yScale, aggregatedData } = getScalesAndData(\n        chartHeight,\n        chartWidth\n      );\n\n      const isCategorical = keyAxis.props.type === 'category';\n      const disableBrush = aggregatedData.length <= 1;\n\n      return (\n        <Fragment>\n          {chartSized && gridlines && (\n            <CloneElement<GridlineSeriesProps>\n              element={gridlines}\n              height={chartHeight}\n              width={chartWidth}\n              yScale={yScale}\n              xScale={xScale}\n              yAxis={yAxis.props}\n              xAxis={xAxis.props}\n            />\n          )}\n          <CloneElement<LinearAxisProps>\n            element={xAxis}\n            height={chartHeight}\n            width={chartWidth}\n            scale={xScale}\n            visibility={chartSized ? 'visible' : 'hidden'}\n            onDimensionsChange={(event) =>\n              updateAxes(isVertical ? 'horizontal' : 'vertical', event)\n            }\n          />\n          <CloneElement<LinearAxisProps>\n            element={yAxis}\n            height={chartHeight}\n            width={chartWidth}\n            scale={yScale}\n            visibility={chartSized ? 'visible' : 'hidden'}\n            onDimensionsChange={(event) =>\n              updateAxes(isVertical ? 'vertical' : 'horizontal', event)\n            }\n          />\n          {secondaryAxis &&\n            secondaryAxis.map((axis, i) => (\n              <CloneElement<LinearAxisProps>\n                key={i}\n                element={axis}\n                height={chartHeight}\n                width={chartWidth}\n                visibility={chartSized ? 'visible' : 'hidden'}\n                onDimensionsChange={(event) => updateAxes('horizontal', event)}\n              />\n            ))}\n          {chartSized && (\n            <CloneElement<ChartBrushProps>\n              disabled={disableBrush}\n              element={brush}\n              height={chartHeight}\n              width={chartWidth}\n              scale={xScale}\n            >\n              <CloneElement<BarSeriesProps>\n                element={series}\n                id={`bar-series-${id}`}\n                data={aggregatedData}\n                height={chartHeight}\n                width={chartWidth}\n                isCategorical={isCategorical}\n                xScale={xScale}\n                xScale1={xScale1}\n                yScale={yScale}\n              />\n            </CloneElement>\n          )}\n        </Fragment>\n      );\n    },\n    [\n      brush,\n      getScalesAndData,\n      gridlines,\n      isVertical,\n      keyAxis,\n      secondaryAxis,\n      series,\n      xAxis,\n      yAxis\n    ]\n  );\n\n  return (\n    <ChartContainer\n      id={id}\n      width={width}\n      height={height}\n      margins={margins}\n      containerClassName={containerClassName}\n      xAxisVisible={isAxisVisible(xAxis.props)}\n      yAxisVisible={isAxisVisible(yAxis.props)}\n      className={classNames(css.barChart, className, css[series.props.type])}\n    >\n      {renderChart}\n    </ChartContainer>\n  );\n};\n\nBarChart.defaultProps = {\n  data: [],\n  xAxis: (\n    <LinearXAxis\n      type=\"category\"\n      tickSeries={<LinearXAxisTickSeries tickSize={20} />}\n    />\n  ),\n  yAxis: <LinearYAxis type=\"value\" />,\n  series: <BarSeries />,\n  gridlines: <GridlineSeries />,\n  brush: null\n};\n","import React, { FC } from 'react';\nimport { BarChart, BarChartProps } from './BarChart';\nimport { ChartNestedDataShape } from '../common/data';\nimport { MarimekkoBarSeries } from './BarSeries';\nimport {\n  LinearXAxis,\n  LinearXAxisTickSeries,\n  LinearYAxis,\n  LinearYAxisTickSeries,\n  LinearYAxisTickLabel\n} from '../common/Axis/LinearAxis';\n\nexport interface MarimekkoChartProps extends BarChartProps {\n  data: ChartNestedDataShape[];\n}\n\nexport const MarimekkoChart: FC<Partial<MarimekkoChartProps>> = (props) => (\n  <BarChart {...props} />\n);\n\nMarimekkoChart.defaultProps = {\n  series: <MarimekkoBarSeries />,\n  xAxis: (\n    <LinearXAxis\n      type=\"category\"\n      tickSeries={<LinearXAxisTickSeries tickSize={15} />}\n    />\n  ),\n  yAxis: (\n    <LinearYAxis\n      type=\"value\"\n      tickSeries={\n        <LinearYAxisTickSeries\n          label={\n            <LinearYAxisTickLabel\n              rotation={false}\n              format={(data) => `${data * 100}%`}\n            />\n          }\n        />\n      }\n    />\n  )\n};\n","import React, { FC } from 'react';\nimport { BarChart, BarChartProps } from './BarChart';\nimport { ChartNestedDataShape } from '../common/data';\nimport { StackedBarSeries } from './BarSeries';\n\nexport interface StackedBarChartProps extends BarChartProps {\n  data: ChartNestedDataShape[];\n}\n\nexport const StackedBarChart: FC<Partial<StackedBarChartProps>> = (props) => (\n  <BarChart {...props} />\n);\n\nStackedBarChart.defaultProps = {\n  series: <StackedBarSeries />\n};\n","import React, { FC } from 'react';\nimport { ChartNestedDataShape } from '../common/data';\nimport { BarChartProps, BarChart } from './BarChart';\nimport { StackedNormalizedBarSeries } from './BarSeries';\nimport {\n  LinearYAxis,\n  LinearYAxisTickSeries,\n  LinearYAxisTickLabel\n} from '../common/Axis/LinearAxis';\n\nexport interface StackedNormalizedBarChartProps extends BarChartProps {\n  data: ChartNestedDataShape[];\n}\n\nexport const StackedNormalizedBarChart: FC<\n  Partial<StackedNormalizedBarChartProps>\n> = (props) => <BarChart {...props} />;\n\nStackedNormalizedBarChart.defaultProps = {\n  series: <StackedNormalizedBarSeries />,\n  yAxis: (\n    <LinearYAxis\n      type=\"value\"\n      tickSeries={\n        <LinearYAxisTickSeries\n          label={\n            <LinearYAxisTickLabel\n              rotation={false}\n              format={(data) => `${data * 100}%`}\n            />\n          }\n        />\n      }\n    />\n  )\n};\n","import React, { FC } from 'react';\nimport { ChartShallowDataShape } from '../common/data';\nimport { BarChartProps, BarChart } from './BarChart';\nimport { HistogramBarSeries } from './BarSeries';\n\nexport interface HistogramBarChartProps extends BarChartProps {\n  data: ChartShallowDataShape[];\n}\n\nexport const HistogramBarChart: FC<Partial<HistogramBarChartProps>> = (\n  props\n) => <BarChart {...props} />;\n\nHistogramBarChart.defaultProps = {\n  series: <HistogramBarSeries />\n};\n","import React, { FC } from 'react';\nimport { AreaSeries, Line, AreaSeriesProps } from '../AreaChart';\n\nexport type LineSeriesProps = AreaSeriesProps;\n\nexport const LineSeries: FC<Partial<LineSeriesProps>> = (props) => (\n  <AreaSeries {...props} />\n);\n\nLineSeries.defaultProps = {\n  ...AreaSeries.defaultProps,\n  area: null,\n  line: <Line strokeWidth={3} />\n};\n","import React, { FC } from 'react';\nimport { AreaChart, AreaChartProps } from '../AreaChart';\nimport { LineSeries } from './LineSeries';\n\nexport type LineChartProps = AreaChartProps;\n\nexport const LineChart: FC<Partial<LineChartProps>> = (props) => (\n  <AreaChart {...props} />\n);\n\nLineChart.defaultProps = {\n  ...AreaChart.defaultProps,\n  series: <LineSeries />\n};\n","import React, { Fragment, ReactElement, FC, useCallback } from 'react';\nimport {\n  geoNaturalEarth1,\n  geoPath,\n  GeoProjection,\n  GeoPath,\n  geoMercator\n} from 'd3-geo';\nimport {\n  ChartProps,\n  ChartContainer,\n  ChartContainerChildProps\n} from '../common/containers/ChartContainer';\nimport { CloneElement } from 'reablocks';\nimport { MapMarkerProps, MapMarker } from './MapMarker';\nimport { motion } from 'framer-motion';\n\ntype MarkerElement = ReactElement<MapMarkerProps, typeof MapMarker>;\n\nexport interface MapProps extends ChartProps {\n  markers?: MarkerElement[];\n  data: any;\n  fill?: string;\n  /**\n   * Determines how the map transforms spherical geometry to planar geometry\n   */\n  projection?: 'mercator' | 'natural-earth';\n}\n\nexport const Map: FC<MapProps> = ({\n  id,\n  width,\n  height,\n  margins,\n  className,\n  containerClassName,\n  markers,\n  data,\n  fill,\n  projection = 'mercator'\n}) => {\n  const getProjection = useCallback(\n    ({ chartWidth, chartHeight }: ChartContainerChildProps) => {\n      if (projection === 'natural-earth') {\n        return geoNaturalEarth1()\n          .fitSize([chartWidth, chartHeight], data)\n          .center([0, 0]);\n      }\n      return geoMercator()\n        .fitSize([chartWidth, chartHeight], data)\n        .center([0, 35]);\n    },\n    [data, projection]\n  );\n\n  const renderMarker = useCallback(\n    (marker: MarkerElement, index: number, projection: GeoProjection) => {\n      const position = projection(marker.props.coordinates);\n\n      if (!position) {\n        console.warn(\n          `Position for ${marker.props.coordinates.toString()} not found.`\n        );\n        return null;\n      }\n\n      return (\n        <CloneElement<MapMarkerProps>\n          element={marker}\n          cx={position[0]}\n          cy={position[1]}\n          index={index}\n        />\n      );\n    },\n    []\n  );\n\n  const renderCountry = useCallback(\n    (point, index: number, path: GeoPath) => {\n      // Exclude ATA\n      if (point.id === '010') {\n        return null;\n      }\n\n      return <path key={`path-${index}`} d={path(point)!} fill={fill} />;\n    },\n    [fill]\n  );\n\n  const renderChart = useCallback(\n    (containerProps: ChartContainerChildProps) => {\n      if (!data) {\n        return null;\n      }\n\n      const geoProjection = getProjection(containerProps);\n      const path = geoPath().projection(geoProjection);\n\n      return (\n        <motion.g\n          initial={{\n            opacity: 0\n          }}\n          animate={{\n            opacity: 1\n          }}\n        >\n          {data.features.map((point, index) =>\n            renderCountry(point, index, path)\n          )}\n          {markers &&\n            markers.map((marker, index) => (\n              <Fragment key={`marker-${index}`}>\n                {renderMarker(marker, index, geoProjection)}\n              </Fragment>\n            ))}\n        </motion.g>\n      );\n    },\n    [data, getProjection, markers, renderCountry, renderMarker]\n  );\n\n  return (\n    <ChartContainer\n      id={id}\n      width={width}\n      height={height}\n      margins={margins}\n      containerClassName={containerClassName}\n      xAxisVisible={false}\n      yAxisVisible={false}\n      className={className}\n    >\n      {(props) => renderChart(props)}\n    </ChartContainer>\n  );\n};\n\nMap.defaultProps = {\n  fill: 'rgba(255, 255, 255, 0.3)'\n};\n","import React, { Fragment, useRef, useState, FC, useMemo } from 'react';\nimport { Tooltip } from 'reablocks';\nimport { motion } from 'framer-motion';\nimport css from './MapMarker.module.css';\nimport { tooltipTheme } from '../common';\n\nexport interface MapMarkerProps {\n  coordinates: [number, number];\n  index: number;\n  cy?: number;\n  cx?: number;\n  size?: number;\n  tooltip?: any;\n  onClick?: () => void;\n}\n\n// Set padding modifier for the tooltips\nconst modifiers = {\n  offset: {\n    offset: '0, 3px'\n  }\n};\n\nexport const MapMarker: FC<Partial<MapMarkerProps>> = ({\n  size = 3,\n  index,\n  tooltip,\n  cx,\n  cy,\n  onClick = () => undefined\n}) => {\n  const ref = useRef<SVGCircleElement | null>(null);\n  const [active, setActive] = useState<boolean>(false);\n\n  const ariaLabelData = useMemo(\n    () => (typeof tooltip === 'string' ? tooltip : 'map marker'),\n    [tooltip]\n  );\n\n  return (\n    <Fragment>\n      <motion.circle\n        initial={{\n          opacity: 0,\n          scale: 0.02\n        }}\n        animate={{\n          opacity: 1,\n          scale: 1\n        }}\n        transition={{\n          delay: index! * 0.3\n        }}\n        ref={ref}\n        className={css.marker}\n        cx={cx}\n        cy={cy}\n        r={size}\n        onMouseEnter={() => setActive(true)}\n        onMouseLeave={() => setActive(false)}\n        onClick={onClick}\n        tabIndex={0}\n        aria-label={ariaLabelData}\n        role=\"graphics-document\"\n      />\n      {tooltip && (\n        <Tooltip\n          theme={tooltipTheme}\n          visible={active}\n          reference={ref}\n          modifiers={modifiers}\n          content={tooltip}\n        />\n      )}\n    </Fragment>\n  );\n};\n","import { useEffect, useMemo, useRef } from 'react';\nimport { DEFAULT_TRANSITION } from '../../common/Motion';\nimport { useMotionValue, useSpring } from 'framer-motion';\nimport { interpolate } from 'd3-interpolate';\n\nexport const useInterpolate = ({ data, animated, arc }) => {\n  const exit = useMemo(() => {\n    const startAngle = data.startAngle;\n    const endAngle = animated ? startAngle : data.endAngle;\n\n    return {\n      ...data,\n      startAngle,\n      endAngle\n    };\n  }, [data, animated]);\n\n  const prevData = useRef(exit);\n  const d = useMotionValue(exit);\n  const spring = useSpring(0, DEFAULT_TRANSITION);\n\n  useEffect(() => {\n    const interpolator = interpolate(prevData.current, data);\n    const prevSpring = spring.get();\n\n    spring.set(prevSpring + 1);\n\n    return spring.on('change', (v) => {\n      const newData = interpolator(v - prevSpring);\n      prevData.current = newData;\n\n      d.set(arc(newData));\n    });\n  }, [arc, d, data, exit, spring]);\n\n  return d;\n};\n","import { PointerEvent, useCallback, useRef } from 'react';\n\nexport interface HoverIntentOptions {\n  interval?: number;\n  sensitivity?: number;\n  timeout?: number;\n  disabled?: boolean;\n  onPointerOver: (event: PointerEvent<SVGElement>) => void;\n  onPointerOut: (event: PointerEvent<SVGElement>) => void;\n}\n\nexport interface HoverIntentResult {\n  pointerOut: (event: PointerEvent<SVGElement>) => void;\n  pointerOver: (event: PointerEvent<SVGElement>) => void;\n}\n\n/**\n * Hover intent identifies if the user actually is\n * intending to over by measuring the position of the mouse\n * once a pointer enters and determining if in a duration if\n * the mouse moved inside a certain threshold and fires the events.\n */\nexport const useHoverIntent = ({\n  sensitivity = 7,\n  interval = 50,\n  timeout = 10,\n  disabled,\n  onPointerOver,\n  onPointerOut\n}: HoverIntentOptions | undefined): HoverIntentResult => {\n  const mouseOver = useRef<boolean>(false);\n  const timer = useRef<any | null>(null);\n  const state = useRef<number>(0);\n  const coords = useRef({\n    x: null,\n    y: null,\n    px: null,\n    py: null\n  });\n\n  const onMouseMove = useCallback((event: MouseEvent) => {\n    coords.current.x = event.clientX;\n    coords.current.y = event.clientY;\n  }, []);\n\n  const comparePosition = useCallback(\n    (event: PointerEvent<SVGElement>) => {\n      timer.current = clearTimeout(timer.current);\n      const { px, x, py, y } = coords.current;\n\n      if (Math.abs(px - x) + Math.abs(py - y) < sensitivity) {\n        state.current = 1;\n        onPointerOver(event);\n      } else {\n        coords.current.px = x;\n        coords.current.py = y;\n        timer.current = setTimeout(() => comparePosition(event), interval);\n      }\n    },\n    [interval, onPointerOver, sensitivity]\n  );\n\n  const cleanup = useCallback(() => {\n    clearTimeout(timer.current);\n    document.removeEventListener('mousemove', onMouseMove, false);\n  }, [onMouseMove]);\n\n  const pointerOver = useCallback(\n    (event: PointerEvent<SVGElement>) => {\n      if (!disabled) {\n        mouseOver.current = true;\n        cleanup();\n\n        if (state.current !== 1) {\n          coords.current.px = event.nativeEvent.x;\n          coords.current.py = event.nativeEvent.y;\n          document.addEventListener('mousemove', onMouseMove, false);\n          timer.current = setTimeout(() => comparePosition(event), timeout);\n        }\n      }\n    },\n    [cleanup, comparePosition, disabled, onMouseMove, timeout]\n  );\n\n  const delay = useCallback(\n    (event: PointerEvent<SVGElement>) => {\n      timer.current = clearTimeout(timer.current);\n      state.current = 0;\n      onPointerOut(event);\n    },\n    [onPointerOut]\n  );\n\n  const pointerOut = useCallback(\n    (event: PointerEvent<SVGElement>) => {\n      mouseOver.current = false;\n      cleanup();\n\n      if (state.current === 1) {\n        timer.current = setTimeout(() => delay(event), timeout);\n      }\n    },\n    [cleanup, delay, timeout]\n  );\n\n  return {\n    pointerOver,\n    pointerOut\n  };\n};\n","import React, { ReactElement, useState, FC, useRef, useMemo } from 'react';\nimport chroma from 'chroma-js';\nimport { motion } from 'framer-motion';\nimport { CloneElement } from 'reablocks';\nimport { ArcData } from '../PieChart';\nimport { ChartTooltip, ChartTooltipProps } from '../../common/Tooltip';\nimport { useInterpolate } from './useInterpolate';\nimport { useHoverIntent } from '../../common/utils/useHoverIntent';\nimport { Gradient, GradientProps } from '../../common/Gradient';\nimport { getAriaLabel } from '../../common';\n\nexport interface PieArcMouseEvent {\n  value: ArcData['data'];\n  nativeEvent: React.MouseEvent<SVGPathElement>;\n}\n\nexport interface PieArcProps {\n  /**\n   * Unique id for arc\n   */\n  id?: string;\n\n  /**\n   * The arc generator function returning an arc path\n   * @param data\n   */\n  arc?: (data: ArcData) => string | null;\n\n  /**\n   * Data is the datum passed to the arc generator function\n   */\n  data?: ArcData;\n\n  /**\n   * Color\n   */\n  color?: string;\n\n  /**\n   * Animate\n   */\n  animated?: boolean;\n\n  /**\n   * Tooltip component\n   */\n  tooltip?: ReactElement<ChartTooltipProps, typeof ChartTooltip> | null;\n\n  /**\n   * The cursor type used when hovering\n   */\n  cursor?: string;\n\n  /**\n   * Disable the arc\n   */\n  disabled?: boolean;\n\n  /**\n   * Gradient shades for the bar.\n   */\n  gradient?: ReactElement<GradientProps, typeof Gradient> | null;\n\n  /**\n   * OnClick event handler\n   * @param e Click event\n   */\n  onClick?: (e: PieArcMouseEvent) => void;\n\n  /**\n   * MouseEnter event handler\n   * @param e MouseEnter event\n   */\n  onMouseEnter?: (e: PieArcMouseEvent) => void;\n\n  /**\n   * MouseLeave event handler\n   * @param e MouseLeave event\n   */\n  onMouseLeave?: (e: PieArcMouseEvent) => void;\n}\n\nexport const PieArc: FC<PieArcProps> = ({\n  id,\n  color,\n  data,\n  arc,\n  cursor,\n  animated,\n  gradient,\n  disabled,\n  onClick,\n  onMouseEnter,\n  onMouseLeave,\n  tooltip\n}) => {\n  const arcRef = useRef<SVGPathElement | null>(null);\n  const d = useInterpolate({ animated, arc, data });\n  const [active, setActive] = useState<boolean>(false);\n  const fill = useMemo(\n    () => (active ? chroma(color).brighten(0.5) : color),\n    [color, active]\n  );\n\n  const { pointerOut, pointerOver } = useHoverIntent({\n    onPointerOver: (event) => {\n      if (!disabled) {\n        setActive(true);\n        onMouseEnter?.({\n          value: data.data,\n          nativeEvent: event as any\n        });\n      }\n    },\n    onPointerOut: (event) => {\n      if (!disabled) {\n        setActive(false);\n        onMouseLeave?.({\n          value: data.data,\n          nativeEvent: event as any\n        });\n      }\n    }\n  });\n\n  const internalFill = useMemo(() => {\n    if (gradient) {\n      return `url(#gradient-${id})`;\n    }\n\n    return color;\n  }, [gradient, id, color]);\n\n  const tooltipData = useMemo(\n    () => ({ y: data.data.data, x: data.data.key }),\n    [data]\n  );\n  const ariaLabelData = useMemo(() => getAriaLabel(tooltipData), [tooltipData]);\n\n  return (\n    <g\n      ref={arcRef}\n      tabIndex={0}\n      aria-label={ariaLabelData}\n      role=\"graphics-document\"\n    >\n      <motion.path\n        role=\"graphics-symbol\"\n        d={d}\n        style={{ cursor }}\n        fill={internalFill}\n        onPointerOver={pointerOver}\n        onPointerOut={pointerOut}\n        onClick={(event) => {\n          if (!disabled) {\n            onClick?.({\n              value: data.data,\n              nativeEvent: event\n            });\n          }\n        }}\n      />\n      {gradient && (\n        <CloneElement<GradientProps>\n          element={gradient}\n          id={`gradient-${id}`}\n          direction=\"horizontal\"\n          color={fill}\n        />\n      )}\n      {!tooltip?.props?.disabled && (\n        <CloneElement<ChartTooltipProps>\n          element={tooltip}\n          visible={!!active}\n          reference={arcRef}\n          value={tooltipData}\n        />\n      )}\n    </g>\n  );\n};\n\nPieArc.defaultProps = {\n  cursor: 'initial',\n  animated: true,\n  disabled: false,\n  tooltip: <ChartTooltip />\n};\n","type Coordinate = [number, number];\n\n/**\n * Finds intermediate point between two points so that this three points\n * can be nicely connected by two lines. One of this lines must be horizontal\n */\nexport function findBreakPoint(\n  [startX, startY]: Coordinate,\n  [endX, endY]: Coordinate\n): Coordinate {\n  let breakPoint: Coordinate = [0, 0];\n\n  // whether we should create breakpoint near pie or near label\n  const breakPointCondition = (endY - startY) * Math.sign(startY) >= 0;\n\n  if (breakPointCondition) {\n    // extend the line starting from startY till the endY\n    let scale = Math.abs(endY / startY) || 1;\n    const minScale = 1;\n    const maxScale = Math.abs(endX / startX) || 1;\n\n    scale = Math.max(Math.min(maxScale, scale), minScale);\n\n    breakPoint = [startX * scale, endY];\n  } else {\n    // some arbitrary scale to ensure that break point will be placed\n    // at some horizontal distance from the end point\n    let scale = 0.85;\n    const minScale = Math.abs(startX / endX) || 1;\n    const maxScale = 1;\n\n    scale = Math.max(Math.min(maxScale, scale), minScale);\n\n    breakPoint = [endX * scale, startY];\n  }\n\n  return breakPoint;\n}\n","import React, { FC } from 'react';\nimport { motion } from 'framer-motion';\nimport { arc } from 'd3-shape';\nimport { ArcData } from '../PieChart';\nimport { ChartInternalDataTypes } from '../../common/data/types';\nimport { formatValue } from '../../common/utils/formatting';\nimport { findBreakPoint } from './findBreakPoint';\n\nexport interface PieArcLabelProps {\n  /**\n   * Data set by the parent component\n   */\n  data: ArcData;\n\n  /**\n   * A function returning the centroid of the corresponding `PieArc`\n   * @param d PieArcDatum\n   */\n  centroid: (d: ArcData) => [number, number];\n\n  /**\n   * A Formatting function for the label value\n   * @param v The label value\n   */\n  format?: (\n    // have added any because not sure whether this change won't be breaking\n    v: any & ArcData['data'] & { textAnchor: 'start' | 'end' }\n  ) => React.ReactNode;\n\n  /**\n   * FontFill color\n   */\n  fontFill: string;\n\n  /**\n   * FontSize\n   */\n  fontSize: number;\n\n  /**\n   * FontFamily\n   */\n  fontFamily: string;\n\n  /**\n   * Line stroke of the label connector\n   */\n  lineStroke: string;\n\n  /**\n   * Outer radius of the corresponding `PieArc`\n   */\n  outerRadius: number;\n\n  /**\n   * y Padding of the label\n   */\n  padding: string;\n\n  /**\n   * The label position set by the parent component\n   */\n  position: [number, number];\n\n  /**\n   * Width of the label\n   */\n  width?: number;\n\n  /**\n   * Height of the label\n   */\n  height?: number;\n}\n\nconst getTextAnchor = ({ startAngle, endAngle }: ArcData) =>\n  // we could also use the sign of position[0]\n  startAngle + (endAngle - startAngle) / 2 < Math.PI ? 'start' : 'end';\n\nexport const PieArcLabel: FC<Partial<PieArcLabelProps>> = ({\n  centroid,\n  data,\n  lineStroke,\n  padding,\n  fontSize,\n  fontFill,\n  format,\n  fontFamily,\n  position,\n  outerRadius,\n  width,\n  height\n}) => {\n  const textAnchor = getTextAnchor(data);\n  const text: React.ReactNode = format\n    ? format({ ...data.data, textAnchor })\n    : formatValue(data.data.key as ChartInternalDataTypes);\n  const [posX, posY] = position;\n  // we want to have at least some pixels of straight line (margin)\n  // from pie section till we start to change line direction\n  const minRadius = outerRadius + 4;\n\n  const startPoint = centroid(data);\n  const innerPoint = arc<ArcData>()\n    .innerRadius(minRadius)\n    .outerRadius(minRadius)\n    .centroid(data);\n  const breakPoint = findBreakPoint(innerPoint, position);\n\n  return (\n    <motion.g\n      initial={{ opacity: 0 }}\n      animate={{ opacity: 1 }}\n      exit={{ opacity: 0 }}\n      transition={{\n        duration: 0.1\n      }}\n    >\n      {typeof text === 'string' ? (\n        <>\n          <title>{text}</title>\n          <text\n            dy={padding}\n            fill={fontFill}\n            fontSize={fontSize}\n            fontFamily={fontFamily}\n            textAnchor={textAnchor}\n            style={{\n              shapeRendering: 'crispEdges',\n              transform: `translate3d(${posX}px,${posY}px, 0)`\n            }}\n          >\n            {text}\n          </text>\n        </>\n      ) : (\n        <foreignObject\n          width={width}\n          height={height}\n          style={{\n            transform: `translate3d(${\n              textAnchor === 'start' ? posX : posX - width\n            }px,${posY - height / 2}px, 0)`,\n            color: fontFill,\n            fontFamily,\n            fontSize\n          }}\n        >\n          {text}\n        </foreignObject>\n      )}\n      <polyline\n        fill=\"none\"\n        stroke={lineStroke}\n        points={`${startPoint},${innerPoint},${breakPoint},${position}`}\n      />\n    </motion.g>\n  );\n};\n\nPieArcLabel.defaultProps = {\n  format: undefined,\n  lineStroke: 'rgba(127,127,127,0.5)',\n  fontFill: '#8F979F',\n  fontSize: 11,\n  fontFamily: 'sans-serif',\n  padding: '.35em',\n  height: 11\n};\n","import { max } from 'd3-array';\nimport { arc } from 'd3-shape';\nimport { ArcData } from '../PieChart';\n\nconst factor = 1.2;\nconst midAngle = (d: ArcData) => d.startAngle + (d.endAngle - d.startAngle) / 2;\nconst labelVisible = (arc: ArcData) =>\n  arc.endAngle - arc.startAngle > Math.PI / 30;\n\nfunction shouldDisplayLabel(displayAllLabels: boolean, arcData: ArcData) {\n  return displayAllLabels || labelVisible(arcData);\n}\n\nexport function calculateOuterRadius(\n  outerRadius: number,\n  data: ArcData[],\n  point: ArcData,\n  explode: boolean,\n) {\n  if (!explode || data === undefined) {\n    return outerRadius;\n  }\n\n  const maxVal = max(data, (d: ArcData) => d.value);\n\n  return (outerRadius * point.value) / maxVal;\n}\n\nexport function calculateCentroid(\n  data: ArcData[],\n  innerRadius: number,\n  outerRadius: number,\n  explode: boolean\n) {\n  return (point: ArcData) => {\n    const newOuter = calculateOuterRadius(outerRadius, data, point, explode);\n\n    return arc<any, ArcData>()\n      .innerRadius(innerRadius)\n      .outerRadius(newOuter)\n      .centroid(point);\n  };\n}\n\nexport function calculateRadius(\n  height,\n  width,\n  label,\n  arcWidth,\n  doughnut\n) {\n  const minDimension = Math.min(width, height);\n\n  let outerRadius = minDimension / 2;\n  let labelWidth = 0;\n\n  if (label) {\n    labelWidth = label.props.width;\n\n    if (labelWidth) {\n      const outerArcRadius = width / 2 - labelWidth;\n\n      outerRadius = Math.min(outerArcRadius / factor, height / 2);\n    } else {\n      outerRadius = minDimension / 3;\n      labelWidth = width / 2 - outerRadius * factor;\n    }\n  }\n\n  const innerRadius = doughnut ? outerRadius * (1 - arcWidth) : 0;\n\n  return {\n    outerRadius,\n    innerRadius,\n    labelWidth\n  };\n}\n\nexport function calculateInnerArc(\n  data: ArcData[],\n  innerRadius: number,\n  outerRadius: number,\n  cornerRadius: number,\n  padAngle: number,\n  padRadius: number,\n  explode: boolean\n) {\n  return (point: ArcData) => {\n    const newOuter = calculateOuterRadius(outerRadius, data, point, explode);\n\n    return arc<any, ArcData>()\n      .innerRadius(innerRadius)\n      .outerRadius(newOuter)\n      .cornerRadius(cornerRadius)\n      .padRadius(padRadius)\n      .padAngle(padAngle)(point);\n  };\n}\n\nexport function calculateLabelPositions(\n  data: ArcData[],\n  outerRadius: number,\n  minDistance: number,\n  cornerRadius: number,\n  padAngle: number,\n  padRadius: number,\n  displayAllLabels: boolean\n): Array<[number, number] | null> {\n  const outerArcRadius = outerRadius * factor;\n  const outerArc = arc<any, ArcData>()\n    .innerRadius(outerArcRadius)\n    .outerRadius(outerArcRadius)\n    .cornerRadius(cornerRadius)\n    .padAngle(padAngle)\n    .padRadius(padRadius);\n\n  const positions: Array<[number, number] | null> = data.map((d) => {\n    if (!shouldDisplayLabel(displayAllLabels, d)) {\n      return null;\n    }\n\n    const pos = outerArc.centroid(d);\n\n    // reposition the labels to the left/right from outerArc centroid\n    // so that all labels won't collide with pie\n    // when we will vertically reposition them\n    pos[0] = outerArcRadius * (midAngle(d) < Math.PI ? 1 : -1);\n\n    return pos;\n  });\n\n  for (let i = 0; i < data.length - 1; i++) {\n    if (!positions[i]) {\n      continue;\n    }\n\n    const [aPosX, aPosY] = positions[i];\n\n    for (let j = i + 1; j < data.length; j++) {\n      if (!positions[j]) {\n        continue;\n      }\n\n      const [bPosX, bPosY] = positions[j];\n\n      // if they're on the same side (both with - or + sign)\n      if (bPosX * aPosX > 0) {\n        // if they're overlapping\n        const overlap = minDistance - Math.abs(bPosY - aPosY);\n\n        if (overlap > 0) {\n          // push the second up or down\n          positions[j][1] += Math.sign(bPosX) * overlap;\n        }\n      }\n    }\n  }\n\n  return positions;\n}\n","import React, { FC, Fragment, ReactElement } from 'react';\nimport { CloneElement } from 'reablocks';\nimport { ArcData } from '../PieChart';\nimport { PieArc, PieArcProps } from './PieArc';\nimport { PieArcLabel, PieArcLabelProps } from './PieArcLabel';\nimport { getColor, ColorSchemeType } from '../../common/color';\nimport {\n  calculateCentroid,\n  calculateInnerArc,\n  calculateLabelPositions,\n  calculateRadius\n} from './radiusUtils';\nimport { identifier } from 'safe-identifier';\n\nexport interface PieArcSeriesProps {\n  /**\n   * Unique id for the series.\n   */\n  id?: string;\n\n  /**\n   * Animated set by the `PieArc` components.\n   */\n  animated: boolean;\n\n  /**\n   * Outer radius set by the parent component.\n   */\n  outerRadius: number;\n\n  /**\n   * Inner radius set by the parent component.\n   */\n  innerRadius: number;\n\n  /**\n   * Pad Angle between adjacent arcs, see https://github.com/d3/d3-shape#arc_padAngle\n   */\n  padAngle: number;\n\n  /**\n   * Pad Radius between adjacent arcs, see https://github.com/d3/d3-shape#arc_padRadius\n   */\n  padRadius: number;\n\n  /**\n   * Corner Radius of the arcs, see https://github.com/d3/d3-shape#arc_cornerRadius\n   */\n  cornerRadius: number;\n\n  /**\n   * Data set by the parent component.\n   */\n  data: ArcData[];\n\n  /**\n   * Width of the arc\n   */\n  arcWidth: number;\n\n  /**\n   * Doughnut, render as a donut shape\n   */\n  doughnut: boolean;\n\n  /**\n   * Explode: OuterRadius will be adjusted by the data property\n   */\n  explode: boolean;\n\n  /**\n   * Display all labels shows labels even if there is little space\n   */\n  displayAllLabels: boolean;\n\n  /**\n   * Label component\n   */\n  label?: ReactElement<PieArcLabelProps, typeof PieArcLabel> | null;\n\n  /**\n   * Arc Component\n   */\n  arc: ReactElement<PieArcProps, typeof PieArc>;\n\n  /**\n   * Color scheme\n   */\n  colorScheme: ColorSchemeType;\n\n  /**\n   * Height set by the parent component\n   */\n  height: number;\n\n  /**\n   * Width set by the parent component\n   */\n  width: number;\n}\n\nexport const PieArcSeries: FC<Partial<PieArcSeriesProps>> = ({\n  doughnut,\n  arcWidth,\n  label,\n  colorScheme,\n  width,\n  displayAllLabels,\n  height,\n  explode,\n  id,\n  animated,\n  cornerRadius,\n  padAngle,\n  padRadius,\n  arc,\n  data\n}) => {\n  const { outerRadius, innerRadius, labelWidth } = calculateRadius(\n    height,\n    width,\n    label,\n    arcWidth,\n    doughnut\n  );\n\n  const innerArc = calculateInnerArc(\n    data,\n    innerRadius,\n    outerRadius,\n    cornerRadius,\n    padAngle,\n    padRadius,\n    explode\n  );\n\n  const positions = label\n    ? calculateLabelPositions(\n      data,\n      outerRadius,\n      // 4 is for vertical margins between labels\n      label.props.height + 4,\n      cornerRadius,\n      padAngle,\n      padRadius,\n      displayAllLabels\n    )\n    : [];\n\n  const centroid = calculateCentroid(data, innerRadius, outerRadius, explode);\n\n  function renderItem(arcData: ArcData, index: number) {\n    const safeKey = identifier(arcData.data.key.toString());\n    const color = getColor({\n      data,\n      colorScheme,\n      point: arcData.data,\n      index\n    });\n\n    return (\n      <Fragment key={safeKey}>\n        {positions[index] && (\n          <CloneElement<PieArcLabelProps>\n            id={id}\n            element={label}\n            data={arcData}\n            centroid={centroid}\n            outerRadius={outerRadius}\n            width={labelWidth}\n            position={positions[index]}\n          />\n        )}\n        <CloneElement<PieArcProps>\n          element={arc}\n          id={`${id}-arc-${safeKey}`}\n          data={arcData}\n          animated={animated}\n          arc={innerArc}\n          color={color}\n        />\n      </Fragment>\n    );\n  }\n\n  return <>{data.map(renderItem)}</>;\n};\n\nPieArcSeries.defaultProps = {\n  animated: true,\n  colorScheme: 'cybertron',\n  innerRadius: 0,\n  cornerRadius: 0,\n  padAngle: 0,\n  padRadius: 0,\n  explode: false,\n  displayAllLabels: false,\n  arcWidth: 0.25,\n  label: <PieArcLabel />,\n  arc: <PieArc />\n};\n","import React, { FC, ReactElement, useCallback, useMemo } from 'react';\nimport classNames from 'classnames';\nimport { PieArcDatum } from 'd3-shape';\nimport { pie } from 'd3-shape';\nimport { CloneElement, useId } from 'reablocks';\nimport {\n  ChartProps,\n  ChartContainer,\n  ChartContainerChildProps\n} from '../common/containers';\nimport { ChartShallowDataShape } from '../common/data';\nimport { PieArcSeries, PieArcSeriesProps } from './PieArcSeries';\n\nexport type ArcData = PieArcDatum<ChartShallowDataShape>;\n\nexport interface PieChartProps extends ChartProps {\n  /**\n   * Data the chart will receive to render.\n   */\n  data?: ChartShallowDataShape[];\n\n  /**\n   * Whether the chart is disabled.\n   */\n  disabled?: boolean;\n\n  /**\n   * Whether to display labels even if their value has a small display radius.\n   */\n  displayAllLabels?: boolean;\n\n  /**\n   * The series component that renders the arc components.\n   */\n  series?: ReactElement<PieArcSeriesProps, typeof PieArcSeries>;\n}\n\nexport const PieChart: FC<PieChartProps> = ({\n  id,\n  width,\n  height,\n  className,\n  containerClassName,\n  displayAllLabels,\n  data = [],\n  margins,\n  series\n}) => {\n  const newId = useId(id);\n\n  const internalData = useMemo(() => {\n    const pieLayout = pie<void, ChartShallowDataShape>().value(\n      (d: ChartShallowDataShape) => Number(d.data)\n    );\n\n    // Explode sort doesn't work right...\n    if (!series.props.explode) {\n      pieLayout.sort(null);\n    }\n\n    return pieLayout(data);\n  }, [data, series]);\n\n  const renderSeries = useCallback(\n    ({ chartWidth, chartHeight }: ChartContainerChildProps) => {\n      return (\n        <CloneElement<PieArcSeriesProps>\n          element={series}\n          id={newId}\n          data={internalData}\n          height={chartHeight}\n          width={chartWidth}\n          displayAllLabels={displayAllLabels}\n        />\n      );\n    },\n    [displayAllLabels, internalData, newId, series]\n  );\n\n  return (\n    <ChartContainer\n      id={id}\n      width={width}\n      height={height}\n      margins={margins}\n      containerClassName={containerClassName}\n      xAxisVisible={false}\n      yAxisVisible={false}\n      center={true}\n      className={classNames(className)}\n    >\n      {renderSeries}\n    </ChartContainer>\n  );\n};\n\nPieChart.defaultProps = {\n  margins: 10,\n  series: <PieArcSeries />\n};\n","import { SankeyNode, SankeyLink } from 'd3-sankey';\n\nexport interface NodeExtra {\n  /**\n   * ID of the node. If not provided, the node's index will be used.\n   */\n  id?: string;\n\n  /**\n   * Title of the node.\n   */\n  title: string;\n\n  /**\n   * Color of the node.\n   */\n  color?: string;\n}\n\nexport interface LinkExtra {\n  /**\n   * Color of the link.\n   */\n  color?: string;\n}\n\nexport type SankeyNodeExtra = SankeyNode<NodeExtra, LinkExtra>;\n\nexport type SankeyLinkExtra = SankeyLink<NodeExtra, LinkExtra>;\n\nexport const DEFAULT_COLOR = 'rgba(255, 255, 255, 0.2)';\n\nexport const LABEL_PADDING_PERCENT = 0.1;\n","import React, {\n  FC,\n  Fragment,\n  ReactElement,\n  useCallback,\n  useMemo,\n  useState\n} from 'react';\nimport {\n  sankey,\n  sankeyLeft,\n  sankeyRight,\n  sankeyCenter,\n  sankeyJustify\n} from 'd3-sankey';\nimport {\n  ChartProps,\n  ChartContainer,\n  ChartContainerChildProps\n} from '../common/containers/ChartContainer';\nimport { CloneElement, useId } from 'reablocks';\n\nimport { getColor, ColorSchemeType } from '../common/color';\nimport { SankeyNodeProps, SankeyNode } from './SankeyNode';\nimport { SankeyLinkProps, SankeyLink } from './SankeyLink';\nimport {\n  SankeyNodeExtra,\n  SankeyLinkExtra,\n  LABEL_PADDING_PERCENT\n} from './utils';\nimport { SankeyLabelPosition } from './SankeyLabel';\n\nconst JUSTIFICATION = {\n  justify: sankeyJustify,\n  center: sankeyCenter,\n  left: sankeyLeft,\n  right: sankeyRight\n};\n\nexport type Justification = 'justify' | 'center' | 'left' | 'right';\n\nexport type NodeElement = ReactElement<SankeyNodeProps, typeof SankeyNode>;\n\nexport type LinkElement = ReactElement<SankeyLinkProps, typeof SankeyLink>;\n\nexport interface SankeyProps extends ChartProps {\n  /**\n   * Whether to animate the enter/update/exit. Set internally by `SankeyNode` and `SankeyLink`.\n   */\n  animated?: boolean;\n\n  /**\n   * Color scheme for the nodes. Set internally by `SankeyNode`.\n   */\n  colorScheme?: ColorSchemeType;\n\n  /**\n   * The node alignment method.\n   */\n  justification?: Justification;\n\n  /**\n   * Width of the node.\n   */\n  nodeWidth?: number;\n\n  /**\n   * Vertical padding between nodes in the same column.\n   */\n  nodePadding?: number;\n\n  /**\n   * Label position.\n   */\n  labelPosition?: SankeyLabelPosition;\n\n  /**\n   * Sort function for the nodes.\n   *\n   * If sort is specified, sets the node sort method and returns this Sankey generator.\n   * If sort is not specified, returns the current node sort method, which defaults\n   * to undefined, indicating that vertical order of nodes within each column will\n   * be determined automatically by the layout. If sort is null, the order is fixed\n   * by the input. Otherwise, the specified sort function determines the order;\n   * the function is passed two nodes, and must return a value less than 0 if the\n   * first node should be above the second, and a value greater than 0 if the second\n   * node should be above the first, or 0 if the order is not specified.\n   *\n   * Reference: https://github.com/d3/d3-sankey#sankey_nodeSort\n   */\n  nodeSort?: (a: any, b: any) => number;\n\n  /**\n   * Nodes that are rendered.\n   */\n  nodes: NodeElement[];\n\n  /**\n   * Links that are rendered.\n   */\n  links: LinkElement[];\n}\n\nexport const Sankey: FC<SankeyProps> = ({\n  width,\n  height,\n  margins,\n  className,\n  animated,\n  links,\n  justification,\n  nodeWidth,\n  nodePadding,\n  labelPosition,\n  nodeSort,\n  colorScheme,\n  nodes,\n  containerClassName,\n  ...rest\n}) => {\n  const id = useId(rest.id);\n  const [activeNodes, setActiveNodes] = useState<SankeyNodeExtra[]>([]);\n  const [activeLinks, setActiveLinks] = useState<SankeyLinkExtra[]>([]);\n\n  const getNodeColor = useCallback(\n    (node: NodeElement, index: any) => {\n      if (colorScheme) {\n        return getColor({\n          data: nodes,\n          colorScheme,\n          point: nodes[index],\n          index\n        });\n      } else {\n        return node.props.color;\n      }\n    },\n    [colorScheme, nodes]\n  );\n\n  const onNodeActive = useCallback((node: SankeyNodeExtra) => {\n    const activeNodes: SankeyNodeExtra[] = [node];\n    const activeLinks: SankeyLinkExtra[] = [];\n\n    if (node.sourceLinks) {\n      activeLinks.push(...node.sourceLinks);\n      node.sourceLinks.forEach((sourceLink) => {\n        const sourceLinkTarget = sourceLink.target as SankeyNodeExtra;\n        if (sourceLinkTarget.index !== node.index) {\n          activeNodes.push(sourceLinkTarget);\n        }\n      });\n    }\n\n    if (node.targetLinks) {\n      activeLinks.push(...node.targetLinks);\n      node.targetLinks.forEach((targetLink) => {\n        const targetLinkSource = targetLink.source as SankeyNodeExtra;\n        if (targetLinkSource.index !== node.index) {\n          activeNodes.push(targetLinkSource);\n        }\n      });\n    }\n\n    setActiveNodes(activeNodes);\n    setActiveLinks(activeLinks);\n  }, []);\n\n  const onLinkActive = useCallback((link: SankeyLinkExtra) => {\n    const activeNodes: SankeyNodeExtra[] = [\n      link.source as SankeyNodeExtra,\n      link.target as SankeyNodeExtra\n    ];\n    const activeLinks: SankeyLinkExtra[] = [link];\n\n    setActiveNodes(activeNodes);\n    setActiveLinks(activeLinks);\n  }, []);\n\n  const onInactive = useCallback(() => {\n    setActiveNodes([]);\n    setActiveLinks([]);\n  }, []);\n\n  const nodeMap = useMemo(() => {\n    // Not sure what this is for\n    const nodeMap = new Map<string, NodeElement>();\n    nodes.forEach((node: any) => node && nodeMap.set(node.props.title, node));\n\n    return nodeMap;\n  }, [nodes]);\n\n  const renderNode = useCallback(\n    (\n      computedNode: SankeyNodeExtra,\n      index: number,\n      chartWidth: number,\n      node?: NodeElement\n    ) => {\n      const active = activeNodes.some(\n        (node) => node.index === computedNode.index\n      );\n      const disabled = activeNodes.length > 0 && !active;\n      const labelPadding =\n        labelPosition === 'outside' ? LABEL_PADDING_PERCENT : 0;\n\n      return (\n        <CloneElement<SankeyNodeProps>\n          element={node}\n          key={`node-${index}`}\n          active={active}\n          animated={animated}\n          disabled={disabled}\n          chartWidth={chartWidth}\n          onMouseEnter={() => onNodeActive(computedNode)}\n          onMouseLeave={() => onInactive()}\n          labelPosition={labelPosition}\n          labelPadding={labelPadding}\n          {...computedNode}\n        />\n      );\n    },\n    [activeNodes, animated, onInactive, onNodeActive, labelPosition]\n  );\n\n  const renderLink = useCallback(\n    (computedLink: SankeyLinkExtra, index: number) => {\n      const active = activeLinks.some(\n        (link) => link.index === computedLink.index\n      );\n      const disabled = activeLinks.length > 0 && !active;\n\n      return (\n        <CloneElement<SankeyLinkProps>\n          element={links[index]}\n          active={active}\n          animated={animated}\n          key={`link-${index}`}\n          chartId={`sankey-${id}`}\n          disabled={disabled}\n          {...computedLink}\n          onMouseEnter={() => onLinkActive(computedLink)}\n          onMouseLeave={() => onInactive()}\n        />\n      );\n    },\n    [activeLinks, id, animated, links, onInactive, onLinkActive]\n  );\n\n  const getNodesAndLinks = useCallback(\n    (chartWidth: number, chartHeight: number) => {\n      const labelPadding =\n        labelPosition === 'outside' ? LABEL_PADDING_PERCENT : 0;\n      const padding = labelPadding * chartWidth;\n\n      const sankeyChart = sankey()\n        .extent([\n          [1 + padding, 1],\n          [chartWidth - padding, chartHeight]\n        ])\n        .nodeWidth(nodeWidth)\n        .nodePadding(nodePadding)\n        .nodeSort(nodeSort)\n        .nodeAlign(JUSTIFICATION[justification])\n        .nodeId((node: any) => node.id || node.index);\n\n      const nodesCopy: any = nodes.map((node, index) => ({\n        id: node.props.id,\n        title: node.props.title,\n        color: getNodeColor(node, index)\n      }));\n\n      const linksCopy = links.map((link) => ({\n        source: link.props.source,\n        target: link.props.target,\n        value: link.props.value\n      }));\n\n      const { nodes: sankeyNodes, links: sankeyLinks } = sankeyChart({\n        nodes: nodesCopy,\n        links: linksCopy\n      });\n\n      /*\n      // NOTE: Not sure what this is doing\n      sankeyNodes.sort((a, b) => {\n        const aX0 = a && a.x0 ? a.x0 : 0;\n        const aY0 = a && a.y0 ? a.y0 : 0;\n        const bX0 = b && b.x0 ? b.x0 : 0;\n        const bY0 = b && b.y0 ? b.y0 : 0;\n        return aX0 - bX0 || aY0 - bY0;\n      });\n      */\n\n      return { sankeyNodes, sankeyLinks };\n    },\n    [\n      getNodeColor,\n      nodeSort,\n      justification,\n      links,\n      nodePadding,\n      nodeWidth,\n      nodes,\n      labelPosition\n    ]\n  );\n\n  const renderChart = useCallback(\n    ({ id, chartWidth, chartHeight, chartSized }: ChartContainerChildProps) => {\n      if (!chartSized) {\n        return null;\n      }\n\n      const { sankeyNodes, sankeyLinks } = getNodesAndLinks(\n        chartWidth,\n        chartHeight\n      );\n\n      return (\n        <Fragment key=\"group\">\n          {sankeyLinks.map((link, index) =>\n            renderLink(link as SankeyLinkExtra, index)\n          )}\n          {sankeyNodes.map((node: SankeyNodeExtra, index) =>\n            renderNode(node, index, chartWidth, nodeMap.get(node.title))\n          )}\n        </Fragment>\n      );\n    },\n    [getNodesAndLinks, nodeMap, renderLink, renderNode]\n  );\n\n  return (\n    <ChartContainer\n      id={id}\n      width={width}\n      containerClassName={containerClassName}\n      height={height}\n      margins={margins}\n      className={className}\n    >\n      {renderChart}\n    </ChartContainer>\n  );\n};\n\nSankey.defaultProps = {\n  animated: true,\n  justification: 'justify',\n  nodeWidth: 15,\n  nodePadding: 10,\n  nodePosition: 'inside'\n};\n","import React, { FC } from 'react';\nimport classNames from 'classnames';\nimport { SankeyNodeExtra } from '../utils';\nimport css from './SankeyLabel.module.css';\nimport ellipsize from 'ellipsize';\n\nexport type SankeyLabelPosition = 'inside' | 'outside';\n\nexport interface SankeyLabelFormatProps {\n  x: number;\n  y: number;\n  textAnchor: string;\n  node: SankeyNodeExtra;\n}\n\nexport interface SankeyLabelProps {\n  /**\n   * Whether the element is active or not. Set internally by `Sankey`.\n   */\n  active: boolean;\n\n  /**\n   * Whether the label is disabled. Set internally by `Sankey`.\n   */\n  disabled: boolean;\n\n  /**\n   * Width of the chart. Set internally by `Sankey`.\n   */\n  chartWidth?: number;\n\n  /**\n   * CSS class to apply.\n   */\n  className?: string;\n\n  /**\n   * Fill color.\n   */\n  fill: string;\n\n  /**\n   * Label position. Set internally by `Sankey`.\n   */\n  position?: SankeyLabelPosition;\n\n   /**\n   * Percentage of total width occupied by labels on \n   * either side of the graph inside the container.\n   * Used for auto-ellipsizing labels\n   * Set internally by `Sankey`.\n   */\n   labelPadding?: number;\n\n  /**\n   * Node data. Set internally by `Sankey`.\n   */\n  node?: SankeyNodeExtra;\n\n  /**\n   * Opacity callback. Used internally by `Sankey`.\n   */\n  opacity: (active: boolean, disabled: boolean) => number;\n\n  /**\n   * Padding between the label and the node.\n   */\n  padding?: string | number;\n\n  /**\n   * Whether to show the label or not.\n   */\n  visible: boolean;\n\n  /**\n   * Width of the node set by the 'Sankey'.\n   */\n  nodeWidth: number;\n\n  /**\n   * Custom formatting for the label.\n   */\n  format?: (value: SankeyLabelFormatProps) => any;\n\n  /**\n   * Specify the number of characters at which the text would be ellipsized.\n   * Defaults to 'auto' based on available width and max cut-off at `LABEL_TRUNCATE_LENGTH=10`\n   */\n  ellipsis?: number | 'none' | 'auto'\n}\n\nconst LABEL_PADDING = 5;\nconst LABEL_TRUNCATE_LENGTH = 10;\n\nexport const SankeyLabel: FC<Partial<SankeyLabelProps>> = ({\n  active,\n  chartWidth,\n  className,\n  nodeWidth,\n  disabled,\n  fill,\n  format,\n  node,\n  position,\n  opacity,\n  padding,\n  visible,\n  ellipsis,\n  labelPadding\n}) => {\n  const x0 = node?.x0 || 0;\n  const x1 = node?.x1 || 0;\n  const y0 = node?.y0 || 0;\n  const y1 = node?.y1 || 0;\n  const paddedWidth = nodeWidth + LABEL_PADDING;\n\n  const width = chartWidth || 0;\n  const showRightSide = x0 < width / 2;\n  let x = showRightSide ? x1 + paddedWidth : x0 - paddedWidth;\n  const y = (y1 + y0) / 2;\n\n  let textAnchor = showRightSide ? 'start' : 'end';\n  if (position === 'outside') {\n    textAnchor = showRightSide ? 'end' : 'start';\n    x = showRightSide ? x1 - paddedWidth : x0 + paddedWidth;\n  }\n\n  if (!visible || !node) {\n    return null;\n  }\n\n  let truncatedTitle = '';\n  if (ellipsis === 'auto') {\n    // This math somehow works for now!\n    const avaialableWidth = showRightSide ? x: width-x;\n    truncatedTitle = ellipsize(node.title, Math.min(LABEL_TRUNCATE_LENGTH, avaialableWidth/(labelPadding*100)));\n  } else if (ellipsis === 'none') {\n    truncatedTitle = node.title;\n  } else {\n    truncatedTitle = ellipsize(node.title, ellipsis);\n  }\n\n  return (\n    <text\n      className={classNames(css.label, className)}\n      x={x}\n      y={y}\n      dy=\"0.35em\"\n      textAnchor={textAnchor}\n      fill={fill}\n      opacity={opacity(active, disabled)}\n      style={{ padding }}\n    >\n      {typeof format === 'function'\n        ? format({ x, y, textAnchor, node })\n        : truncatedTitle}\n    </text>\n  );\n};\n\nSankeyLabel.defaultProps = {\n  active: false,\n  fill: '#fff',\n  position: 'inside',\n  opacity: (active, disabled) => (active ? 1 : disabled ? 0.2 : 0.9),\n  visible: true,\n  ellipsis: 'auto'\n};\n","import React, {\n  Fragment,\n  ReactElement,\n  useCallback,\n  useState,\n  useMemo,\n  useRef,\n  FC\n} from 'react';\nimport classNames from 'classnames';\nimport { motion } from 'framer-motion';\nimport { sankeyLinkHorizontal } from 'd3-sankey';\nimport { CloneElement } from 'reablocks';\nimport { formatValue } from '../../common/utils/formatting';\nimport { Tooltip, TooltipProps } from 'reablocks';\nimport {\n  NodeExtra,\n  SankeyNodeExtra,\n  SankeyLinkExtra,\n  DEFAULT_COLOR\n} from '../utils';\nimport css from './SankeyLink.module.css';\nimport { useHoverIntent } from '../../common/utils/useHoverIntent';\nimport { tooltipTheme } from '../../common';\n\nexport interface SankeyLinkProps extends SankeyLinkExtra {\n  /**\n   * Color of the link.\n   */\n  color?: string;\n\n  /**\n   * Whether the element is active or not. Set internally by `Sankey`.\n   */\n  active: boolean;\n\n  /**\n   * Whether to animate the enter/update/exit.\n   */\n  animated: boolean;\n\n  /**\n   * Id of Sankey chart. Set internally by `Sankey`.\n   */\n  chartId: string;\n\n  /**\n   * CSS class to apply.\n   */\n  className?: string;\n\n  /**\n   * Whether the node is disabled. Set internally by `Sankey`.\n   */\n  disabled: boolean;\n\n  /**\n   * Whether to use gradient or not.\n   */\n  gradient?: boolean;\n\n  /**\n   * Opacity callback for the link.\n   */\n  opacity: (active: boolean, disabled: boolean) => number;\n\n  /**\n   * CSS styles to apply.\n   */\n  style?: object;\n\n  /**\n   * Tooltip element.\n   */\n  tooltip?: ReactElement<TooltipProps, typeof Tooltip> | null;\n\n  /**\n   * Width of the link. Set internally by `Sankey`.\n   */\n  width: number;\n\n  /**\n   * Event for when the link is clicked.\n   */\n  onClick?: (event: React.MouseEvent<SVGPathElement>) => void;\n\n  /**\n   * Event for when the link has mouse enter.\n   */\n  onMouseEnter?: (event: React.MouseEvent<SVGPathElement>) => void;\n\n  /**\n   * Event for when the link has mouse leave.\n   */\n  onMouseLeave?: (event: React.MouseEvent<SVGPathElement>) => void;\n}\n\nexport const SankeyLink: FC<Partial<SankeyLinkProps>> = ({\n  gradient,\n  index,\n  source,\n  target,\n  tooltip,\n  chartId,\n  value,\n  active,\n  className,\n  disabled,\n  opacity,\n  style,\n  width,\n  color,\n  y0,\n  y1,\n  onClick,\n  onMouseEnter,\n  onMouseLeave\n}) => {\n  const linkSource = source as SankeyNodeExtra;\n  const linkTarget = target as SankeyNodeExtra;\n\n  const [hovered, setHovered] = useState<boolean>(false);\n  const linkRef = useRef<SVGPathElement | null>(null);\n\n  const getLink = useCallback(() => {\n    return { index, y0, y1, value, width, source, target };\n  }, [index, source, target, value, width, y0, y1]);\n\n  const stroke = useMemo(() => {\n    if (gradient) {\n      return `url(#${chartId}-gradient-${index})`;\n    } else if (color) {\n      return color;\n    }\n\n    return DEFAULT_COLOR;\n  }, [chartId, gradient, index, color]);\n\n  const enterProps = useMemo(() => {\n    const path = sankeyLinkHorizontal();\n    const d = path(getLink()) as string;\n    const strokeWidth = Math.max(1, width);\n    return { d, strokeWidth };\n  }, [getLink, width]);\n\n  const exitProps = useMemo(() => {\n    const path = sankeyLinkHorizontal();\n    const d = path({ ...getLink(), width: 0 }) as string;\n    return { d, strokeWidth: 0 };\n  }, [getLink]);\n\n  const renderTooltipContent = useCallback(() => {\n    return (\n      <div className={css.tooltip}>\n        <div className={css.tooltipLabel}>\n          {`${(source as NodeExtra).title} → ${(target as NodeExtra).title}`}\n        </div>\n        <div className={css.tooltipValue}>{formatValue(value)}</div>\n      </div>\n    );\n  }, [source, target, value]);\n\n  const { pointerOut, pointerOver } = useHoverIntent({\n    onPointerOver: (event) => {\n      setHovered(true);\n      onMouseEnter?.(event as any);\n    },\n    onPointerOut: (event) => {\n      setHovered(false);\n      onMouseLeave?.(event as any);\n    }\n  });\n\n  const ariaLabelData = useMemo(\n    () =>\n      `${(source as NodeExtra).title} → ${\n        (target as NodeExtra).title\n      }: ${formatValue(value)}`,\n    [source, target, value]\n  );\n\n  return (\n    <Fragment>\n      {gradient && (\n        <linearGradient\n          id={`${chartId}-gradient-${index}`}\n          gradientUnits=\"userSpaceOnUse\"\n          x1={linkSource.x1}\n          x2={linkTarget.x0}\n        >\n          <stop offset=\"0%\" stopColor={linkSource.color} />\n          <stop offset=\"100%\" stopColor={linkTarget.color} />\n        </linearGradient>\n      )}\n      <g ref={linkRef}>\n        <motion.path\n          key={`sankey-link-${enterProps.d}-${index}`}\n          className={classNames(css.link, className)}\n          style={style}\n          initial={exitProps}\n          animate={enterProps}\n          exit={exitProps}\n          transition={{\n            duration: 0.5\n          }}\n          stroke={stroke}\n          strokeOpacity={opacity(active, disabled)}\n          onClick={onClick}\n          onPointerOver={pointerOver}\n          onPointerOut={pointerOut}\n          aria-label={ariaLabelData}\n          role=\"graphics-document\"\n        />\n      </g>\n      {!tooltip?.props?.disabled && (\n        <CloneElement<TooltipProps>\n          content={renderTooltipContent}\n          element={tooltip}\n          visible={hovered}\n          reference={linkRef}\n        />\n      )}\n    </Fragment>\n  );\n};\n\nSankeyLink.defaultProps = {\n  active: false,\n  animated: true,\n  disabled: false,\n  gradient: true,\n  opacity: (active, disabled) => (active ? 0.5 : disabled ? 0.1 : 0.35),\n  tooltip: (\n    <Tooltip\n      theme={tooltipTheme}\n      followCursor={true}\n      modifiers={{\n        offset: {\n          offset: '0, 5px'\n        }\n      }}\n    />\n  ),\n  width: 0\n};\n","import React, {\n  Fragment,\n  ReactElement,\n  useCallback,\n  FC,\n  useState,\n  useRef,\n  useMemo\n} from 'react';\nimport classNames from 'classnames';\nimport { motion } from 'framer-motion';\nimport { ChartInternalDataTypes } from '../../common/data';\nimport { CloneElement } from 'reablocks';\nimport { formatValue } from '../../common/utils/formatting';\nimport { Tooltip, TooltipProps } from 'reablocks';\nimport {\n  SankeyLabel,\n  SankeyLabelPosition,\n  SankeyLabelProps\n} from '../SankeyLabel';\nimport { SankeyNodeExtra, DEFAULT_COLOR } from '../utils';\nimport css from './SankeyNode.module.css';\nimport { useHoverIntent } from '../../common/utils/useHoverIntent';\nimport { tooltipTheme } from '../../common';\n\nexport interface SankeyNodeProps extends SankeyNodeExtra {\n  /**\n   * ID of the node. If not provided, the node's index will be used.\n   */\n  id?: string;\n\n  /**\n   * Title of the node.\n   */\n  title: string;\n\n  /**\n   * Color of the node.\n   */\n  color?: string;\n\n  /**\n   * Whether the element is active or not. Set internally by `Sankey`.\n   */\n  active: boolean;\n\n  /**\n   * Whether to animate the enter/update/exit.\n   */\n  animated: boolean;\n\n  /**\n   * Width of the chart. Set internally by `Sankey`.\n   */\n  chartWidth?: number;\n\n  /**\n   * CSS class to apply.\n   */\n  className?: string;\n\n  /**\n   * Whether the node is disabled. Set internally by `Sankey`.\n   */\n  disabled: boolean;\n\n  /**\n   * Label element.\n   */\n  label: ReactElement<SankeyLabelProps, typeof SankeyLabel>;\n\n  /**\n   * Label position. Set internally by `Sankey`.\n   */\n  labelPosition?: SankeyLabelPosition;\n\n  /**\n   * Percentage of total width occupied by labels on\n   * either side of the graph inside the container.\n   * Set internally by `Sankey`.\n   */\n  labelPadding?: number;\n\n  /**\n   * Opacity callback for the node.\n   */\n  opacity: (active: boolean, disabled: boolean) => number;\n\n  /**\n   * CSS styles to apply.\n   */\n  style?: React.StyleHTMLAttributes<SVGRectElement>;\n\n  /**\n   * Tooltip element.\n   */\n  tooltip?: ReactElement<TooltipProps, typeof Tooltip> | null;\n\n  /**\n   * Width of the node. Set internally by `Sankey`.\n   */\n  width?: number;\n\n  /**\n   * Event for when the node is clicked.\n   */\n  onClick?: (event: React.MouseEvent<SVGRectElement>) => void;\n\n  /**\n   * Event for when the node has mouse enter.\n   */\n  onMouseEnter?: (event: React.MouseEvent<SVGRectElement>) => void;\n\n  /**\n   * Event for when the node has mouse leave.\n   */\n  onMouseLeave?: (event: React.MouseEvent<SVGRectElement>) => void;\n}\n\nexport const SankeyNode: FC<Partial<SankeyNodeProps>> = ({\n  active,\n  chartWidth,\n  label,\n  labelPosition,\n  labelPadding,\n  tooltip,\n  title,\n  value,\n  className,\n  color,\n  disabled,\n  index,\n  opacity,\n  style,\n  width,\n  x0,\n  x1,\n  y0,\n  y1,\n  id,\n  sourceLinks,\n  targetLinks,\n  onClick,\n  onMouseEnter,\n  onMouseLeave\n}) => {\n  const node = {\n    id,\n    title,\n    color,\n    sourceLinks,\n    targetLinks,\n    value,\n    index,\n    x0,\n    x1,\n    y0,\n    y1\n  };\n  const nodeWidth = width || (x1 && x0 && x1 - x0 > 0 ? x1 - x0 : 0);\n  const nodeHeight = y1 && y0 && y1 - y0 > 0 ? y1 - y0 : 0;\n\n  const [hovered, setHovered] = useState<boolean>(false);\n  const rectRef = useRef<SVGRectElement | null>(null);\n\n  const renderTooltipContent = useCallback(() => {\n    return (\n      <div className={css.tooltip}>\n        <div className={css.tooltipLabel}>{title}</div>\n        <div className={css.tooltipValue}>\n          {formatValue(value as ChartInternalDataTypes)}\n        </div>\n      </div>\n    );\n  }, [title, value]);\n\n  const { pointerOut, pointerOver } = useHoverIntent({\n    onPointerOver: (event) => {\n      setHovered(true);\n      onMouseEnter?.(event as any);\n    },\n    onPointerOut: (event) => {\n      setHovered(false);\n      onMouseLeave?.(event as any);\n    }\n  });\n\n  const ariaLabelData = useMemo(\n    () => `${title}: ${formatValue(value as ChartInternalDataTypes)}`,\n    [title, value]\n  );\n\n  return (\n    <Fragment>\n      <motion.g\n        ref={rectRef}\n        tabIndex={0}\n        aria-label={ariaLabelData}\n        role=\"graphics-document\"\n      >\n        <motion.rect\n          key={`sankey-node-${x0}-${x1}-${y0}-${y1}-${index}`}\n          className={classNames(css.node, className)}\n          fillOpacity={opacity(active, disabled)}\n          style={style}\n          width={nodeWidth}\n          height={nodeHeight}\n          fill={color}\n          initial={{\n            opacity: 0,\n            attrX: x0,\n            attrY: y0\n          }}\n          animate={{\n            opacity: 1,\n            attrX: x0,\n            attrY: y0\n          }}\n          exit={{\n            opacity: 0,\n            attrX: x0,\n            attrY: y0\n          }}\n          transition={{\n            duration: 0.1\n          }}\n          onClick={onClick}\n          onPointerOver={pointerOver}\n          onPointerOut={pointerOut}\n        />\n      </motion.g>\n      {label !== null && (\n        <CloneElement<SankeyLabelProps>\n          active={active}\n          element={label}\n          disabled={disabled}\n          chartWidth={chartWidth}\n          nodeWidth={nodeWidth}\n          node={node}\n          position={labelPosition}\n          labelPadding={labelPadding}\n        />\n      )}\n      {!tooltip?.props?.disabled && (\n        <CloneElement<TooltipProps>\n          content={renderTooltipContent}\n          element={tooltip}\n          visible={hovered}\n          reference={rectRef}\n        />\n      )}\n    </Fragment>\n  );\n};\n\nSankeyNode.defaultProps = {\n  active: false,\n  animated: true,\n  color: DEFAULT_COLOR,\n  disabled: false,\n  label: <SankeyLabel />,\n  opacity: (active, disabled) => (active ? 1 : disabled ? 0.2 : 0.9),\n  tooltip: (\n    <Tooltip\n      theme={tooltipTheme}\n      followCursor={true}\n      modifiers={{\n        offset: {\n          offset: '0, 5px'\n        }\n      }}\n    />\n  )\n};\n","import React, { FC } from 'react';\nimport { LineChart, LineChartProps } from '../LineChart';\nimport { ChartShallowDataShape } from '../common/data';\nimport { AreaSeries, Line } from '../AreaChart';\nimport { PointSeries } from '../AreaChart';\nimport {\n  LinearXAxis,\n  LinearYAxis,\n  LinearYAxisTickSeries,\n  LinearXAxisTickSeries\n} from '../common/Axis/LinearAxis';\n\nexport interface SparklineChartProps extends LineChartProps {\n  data: ChartShallowDataShape[];\n}\n\nexport const SparklineChart: FC<Partial<SparklineChartProps>> = (props) => <LineChart {...props} />;\n\nSparklineChart.defaultProps = {\n  gridlines: null,\n  series: (\n    <AreaSeries\n      symbols={<PointSeries show=\"hover\" />}\n      interpolation=\"smooth\"\n      markLine={null}\n      area={null}\n      line={<Line strokeWidth={2} />}\n    />\n  ),\n  yAxis: (\n    <LinearYAxis\n      scaled={true}\n      type=\"value\"\n      axisLine={null}\n      tickSeries={<LinearYAxisTickSeries line={null} label={null} />}\n    />\n  ),\n  xAxis: (\n    <LinearXAxis\n      type=\"time\"\n      scaled={true}\n      axisLine={null}\n      tickSeries={<LinearXAxisTickSeries line={null} label={null} />}\n    />\n  )\n};\n","import React, { FC } from 'react';\nimport {\n  AreaChart,\n  AreaChartProps,\n  AreaSeries,\n  Area,\n  Line\n} from '../AreaChart';\nimport { ChartShallowDataShape } from '../common/data';\nimport { PointSeries } from '../AreaChart';\nimport {\n  LinearYAxisTickSeries,\n  LinearYAxis,\n  LinearXAxis,\n  LinearXAxisTickSeries\n} from '../common/Axis/LinearAxis';\nimport { GradientStop, Gradient } from '../common/Gradient';\nimport { Stripes } from '../common/Mask';\n\nexport interface AreaSparklineChartProps extends AreaChartProps {\n  data: ChartShallowDataShape[];\n}\n\nexport const AreaSparklineChart: FC<Partial<AreaSparklineChartProps>> = (\n  props\n) => <AreaChart {...props} />;\n\nAreaSparklineChart.defaultProps = {\n  gridlines: null,\n  series: (\n    <AreaSeries\n      symbols={<PointSeries show=\"hover\" />}\n      interpolation=\"smooth\"\n      markLine={null}\n      area={\n        <Area\n          mask={<Stripes />}\n          gradient={\n            <Gradient\n              stops={[\n                <GradientStop offset=\"10%\" stopOpacity={0} key=\"start\" />,\n                <GradientStop offset=\"80%\" stopOpacity={1} key=\"stop\" />\n              ]}\n            />\n          }\n        />\n      }\n      line={<Line strokeWidth={3} />}\n    />\n  ),\n  yAxis: (\n    <LinearYAxis\n      type=\"value\"\n      scaled={true}\n      axisLine={null}\n      tickSeries={<LinearYAxisTickSeries line={null} label={null} />}\n    />\n  ),\n  xAxis: (\n    <LinearXAxis\n      type=\"time\"\n      scaled={true}\n      axisLine={null}\n      tickSeries={<LinearXAxisTickSeries line={null} label={null} />}\n    />\n  )\n};\n","import React, { FC } from 'react';\nimport { BarChart, BarChartProps } from '../BarChart';\nimport { ChartShallowDataShape } from '../common/data';\nimport {\n  LinearXAxis,\n  LinearYAxis,\n  LinearYAxisTickSeries,\n  LinearXAxisTickSeries\n} from '../common/Axis';\nimport { BarSeries } from '../BarChart';\nimport { schemes } from '../common/color';\n\nexport interface BarSparklineChartProps extends BarChartProps {\n  data: ChartShallowDataShape[];\n}\n\nexport const BarSparklineChart: FC<Partial<BarSparklineChartProps>> = (props) => <BarChart {...props} />;\n\nBarSparklineChart.defaultProps = {\n  gridlines: null,\n  series: <BarSeries colorScheme={schemes.cybertron[0]} />,\n  yAxis: (\n    <LinearYAxis\n      type=\"value\"\n      axisLine={null}\n      tickSeries={<LinearYAxisTickSeries line={null} label={null} />}\n    />\n  ),\n  xAxis: (\n    <LinearXAxis\n      type=\"category\"\n      axisLine={null}\n      tickSeries={<LinearXAxisTickSeries line={null} label={null} />}\n    />\n  )\n};\n","import React, { FC } from 'react';\nimport {\n  StackedBarChart,\n  StackedBarSeries,\n  Bar,\n  BarChartProps\n} from '../BarChart';\nimport {\n  Gradient,\n  GradientStop,\n  LinearYAxis,\n  LinearXAxis,\n  LinearYAxisTickSeries,\n  LinearXAxisTickSeries,\n  TooltipArea,\n  ChartTooltip,\n  TooltipTemplate,\n  formatValue,\n  ChartNestedDataShape\n} from '../common';\n\nexport interface SonarChartProps extends BarChartProps {\n  data: ChartNestedDataShape[];\n}\n\nexport const SonarChart: FC<Partial<SonarChartProps>> = (props) => (\n  <StackedBarChart\n    {...props}\n    margins={0}\n    gridlines={null}\n    series={\n      <StackedBarSeries\n        type=\"stackedDiverging\"\n        colorScheme=\"rgb(17, 207, 247)\"\n        tooltip={\n          <TooltipArea\n            tooltip={\n              <ChartTooltip\n                followCursor={true}\n                modifiers={{\n                  offset: '5px, 5px'\n                }}\n                content={(data, color) => (\n                  <TooltipTemplate\n                    color={color}\n                    value={{\n                      x: formatValue(data.x),\n                      y: `${formatValue(Math.abs(data.data[0].y))}`\n                    }}\n                  />\n                )}\n              />\n            }\n          />\n        }\n        bar={[\n          <Bar\n            key=\"first\"\n            width={1}\n            rangeLines={null}\n            minHeight={1}\n            gradient={\n              <Gradient\n                stops={[\n                  <GradientStop offset=\"5%\" stopOpacity={0.7} key=\"start\" />,\n                  <GradientStop offset=\"90%\" stopOpacity={1} key=\"stop\" />\n                ]}\n              />\n            }\n          />,\n          <Bar\n            key=\"second\"\n            width={1}\n            rangeLines={null}\n            minHeight={1}\n            gradient={\n              <Gradient\n                stops={[\n                  <GradientStop offset=\"5%\" stopOpacity={1} key=\"stop\" />,\n                  <GradientStop offset=\"90%\" stopOpacity={0.7} key=\"start\" />\n                ]}\n              />\n            }\n          />\n        ]}\n      />\n    }\n    yAxis={\n      <LinearYAxis\n        type=\"value\"\n        axisLine={null}\n        tickSeries={<LinearYAxisTickSeries line={null} label={null} />}\n      />\n    }\n    xAxis={\n      <LinearXAxis\n        type=\"category\"\n        axisLine={null}\n        tickSeries={<LinearXAxisTickSeries line={null} label={null} />}\n      />\n    }\n  />\n);\n","import React, { ReactElement, useCallback, FC, useMemo, Fragment } from 'react';\nimport { ChartInternalShallowDataShape } from '../../common/data';\nimport {\n  radialArea,\n  curveCardinalClosed,\n  curveLinearClosed,\n  curveCardinal,\n  curveLinear\n} from 'd3-shape';\nimport { RadialGradient, RadialGradientProps } from '../../common/Gradient';\nimport { CloneElement } from 'reablocks';\nimport { RadialInterpolationTypes } from '../../common/utils/interpolation';\nimport { MotionPath, DEFAULT_TRANSITION } from '../../common/Motion';\n\nexport interface RadialAreaProps {\n  /**\n   * Parsed data shape. Set internally by `RadialAreaChart`.\n   */\n  data: ChartInternalShallowDataShape[];\n\n  /**\n   * Whether to animate the enter/update/exit.\n   */\n  animated: boolean;\n\n  /**\n   * D3 scale for X Axis. Set internally by `RadialAreaChart`.\n   */\n  xScale: any;\n\n  /**\n   * D3 scale for Y Axis. Set internally by `RadialAreaChart`.\n   */\n  yScale: any;\n\n  /**\n   * Interpolation for the area. Set internally by `RadialAreaSeries`.\n   */\n  interpolation: RadialInterpolationTypes;\n\n  /**\n   * Color for the area. Set internally by `RadialAreaSeries`.\n   */\n  color: any;\n\n  /**\n   * Id set internally by `RadialAreaSeries`.\n   */\n  id: string;\n\n  /**\n   * The inner radius for the chart center.\n   */\n  innerRadius: number;\n\n  /**\n   * The outer radius for the chart center.\n   */\n  outerRadius: number;\n\n  /**\n   * CSS classes to apply.\n   */\n  className?: string;\n\n  /**\n   * Index of the area in the series. Set internally by `RadialAreaSeries`.\n   */\n  index: number;\n\n  /**\n   * Gradient to apply to the area.\n   */\n  gradient: ReactElement<RadialGradientProps, typeof RadialGradient> | null;\n\n  /**\n   * Whether the curve should be closed. Set to true by deafult\n   */\n  isClosedCurve: boolean;\n}\n\nexport const RadialArea: FC<Partial<RadialAreaProps>> = ({\n  id,\n  data,\n  className,\n  yScale,\n  color,\n  animated,\n  index,\n  outerRadius,\n  xScale,\n  innerRadius,\n  interpolation,\n  gradient,\n  isClosedCurve\n}) => {\n  const transition = useMemo(\n    () =>\n      animated\n        ? {\n          ...DEFAULT_TRANSITION,\n          delay: index * 0.05\n        }\n        : {\n          type: false,\n          delay: 0\n        },\n    [animated, index]\n  );\n\n  const getFill = useCallback(\n    (c: string) => {\n      if (!gradient) {\n        return c;\n      }\n\n      return `url(#${id}-gradient)`;\n    },\n    [id, gradient]\n  );\n\n  const getPath = useCallback(\n    (d: ChartInternalShallowDataShape[]) => {\n      const curve =\n        interpolation === 'smooth'\n          ? isClosedCurve\n            ? curveCardinalClosed\n            : curveCardinal\n          : isClosedCurve\n            ? curveLinearClosed\n            : curveLinear;\n\n      const radialFn = radialArea()\n        .angle((dd: any) => xScale(dd.x))\n        .innerRadius((_) => innerRadius!)\n        .outerRadius((d: any) => yScale(d.y))\n        .curve(curve);\n\n      return radialFn(d as any);\n    },\n    [interpolation, isClosedCurve, xScale, innerRadius, yScale]\n  );\n\n  const enter = useMemo(\n    () => ({\n      d: getPath(data!),\n      opacity: 1\n    }),\n    [data, getPath]\n  );\n\n  const exit = useMemo(() => {\n    const [yStart] = yScale.domain();\n    return {\n      d: getPath(data!.map((d) => ({ ...d, y: yStart }))),\n      opacity: 0\n    };\n  }, [data, getPath, yScale]);\n\n  const fill = color(data, 0);\n\n  return (\n    <Fragment>\n      <MotionPath\n        custom={{\n          enter,\n          exit\n        }}\n        transition={transition}\n        pointerEvents=\"none\"\n        className={className}\n        fill={getFill(color)}\n      />\n      {gradient && (\n        <CloneElement<RadialGradientProps>\n          element={gradient}\n          id={`${id}-gradient`}\n          radius={outerRadius}\n          color={fill}\n        />\n      )}\n    </Fragment>\n  );\n};\n\nRadialArea.defaultProps = {\n  gradient: <RadialGradient />,\n  isClosedCurve: true\n};\n","import React, { useCallback, useMemo, FC } from 'react';\nimport { ChartInternalShallowDataShape } from '../../common/data';\nimport { radialLine, curveCardinalClosed, curveLinearClosed, curveCardinal, curveLinear } from 'd3-shape';\nimport { RadialInterpolationTypes } from '../../common/utils/interpolation';\nimport { MotionPath, DEFAULT_TRANSITION } from '../../common/Motion';\n\nexport interface RadialLineProps {\n  /**\n   * Parsed data shape. Set internally by `RadialAreaChart`.\n   */\n  data: ChartInternalShallowDataShape[];\n\n  /**\n   * Whether to animate the enter/update/exit. Set internally by `RadialAreaSeries`.\n   */\n  animated: boolean;\n\n  /**\n   * D3 scale for X Axis. Set internally by `RadialAreaChart`.\n   */\n  xScale: any;\n\n  /**\n   * D3 scale for Y Axis. Set internally by `RadialAreaChart`.\n   */\n  yScale: any;\n\n  /**\n   * Color for the area. Set internally by `RadialAreaSeries`.\n   */\n  color: any;\n\n  /**\n   * Interpolation for the area. Set internally by `RadialAreaSeries`.\n   */\n  interpolation: RadialInterpolationTypes;\n\n  /**\n   * Index of the area in the series. Set internally by `RadialAreaSeries`.\n   */\n  index: number;\n\n  /**\n   * Stroke width of the line.\n   */\n  strokeWidth: number;\n\n  /**\n   * CSS classes to apply.\n   */\n  className?: string;\n\n  /**\n   * Internal property to identify if there is a area or not.\n   */\n  hasArea: boolean;\n  \n  /**\n   * Whether the curve should be closed. Set to true by deafult\n   */\n  isClosedCurve: boolean;\n}\n\nexport const RadialLine: FC<Partial<RadialLineProps>> = ({\n  xScale,\n  yScale,\n  className,\n  index,\n  hasArea,\n  color,\n  data,\n  interpolation,\n  strokeWidth,\n  animated,\n  isClosedCurve\n}) => {\n  const fill = color(data, index);\n\n  const getPath = useCallback(\n    (preData: ChartInternalShallowDataShape[]) => {\n      const curve =\n        interpolation === 'smooth' ? (isClosedCurve ? curveCardinalClosed : curveCardinal) : isClosedCurve ? curveLinearClosed : curveLinear;\n\n      const radialFn = radialLine()\n        .angle((d: any) => xScale(d.x))\n        .radius((d: any) => yScale(d.y))\n        .curve(curve);\n\n      return radialFn(preData as any);\n    },\n    [interpolation, isClosedCurve, xScale, yScale]\n  );\n\n  const transition = useMemo(\n    () =>\n      animated\n        ? {\n          ...DEFAULT_TRANSITION,\n          delay: hasArea ? 0 : index * 0.05\n        }\n        : {\n          type: false,\n          delay: 0\n        },\n    [animated, index, hasArea]\n  );\n\n  const enter = useMemo(\n    () => ({\n      d: getPath(data!),\n      opacity: 1\n    }),\n    [data, getPath]\n  );\n\n  const exit = useMemo(() => {\n    const [yStart] = yScale.domain();\n    return {\n      d: getPath(data!.map((d) => ({ ...d, y: yStart }))),\n      opacity: 0\n    };\n  }, [data, yScale, getPath]);\n\n  return (\n    <MotionPath\n      custom={{\n        enter,\n        exit\n      }}\n      transition={transition}\n      className={className}\n      pointerEvents=\"none\"\n      stroke={fill}\n      fill=\"none\"\n      strokeWidth={strokeWidth}\n    />\n  );\n};\n\nRadialLine.defaultProps = {\n  strokeWidth: 2,\n  animated: true,\n  isClosedCurve: true\n};\n","import React, { FC, useCallback, Fragment, ReactElement } from 'react';\nimport {\n  ChartShallowDataShape,\n  buildShallowChartData,\n  ChartInternalShallowDataShape\n} from '../common/data';\nimport { scaleBand, scaleTime } from 'd3-scale';\nimport { getYDomain, getXDomain } from '../common/utils/domains';\nimport {\n  RadialScatterSeries,\n  RadialScatterSeriesProps\n} from './RadialScatterSeries';\nimport {\n  ChartProps,\n  ChartContainer,\n  ChartContainerChildProps\n} from '../common/containers';\nimport { CloneElement } from 'reablocks';\nimport { RadialAxisProps, RadialAxis } from '../common/Axis/RadialAxis';\nimport { getRadialYScale } from '../common/scales';\nimport { uniqueBy } from '../common';\n\nexport interface RadialScatterPlotProps extends ChartProps {\n  /**\n   * Data the chart will receive to render.\n   */\n  data: ChartShallowDataShape[];\n\n  /**\n   * The series component that renders the scatter components.\n   */\n  series: ReactElement<RadialScatterSeriesProps, typeof RadialScatterSeries>;\n\n  /**\n   * The radial axis component for the chart.\n   */\n  axis: ReactElement<RadialAxisProps, typeof RadialAxis> | null;\n\n  /**\n   * The inner radius for the chart center.\n   */\n  innerRadius: number;\n}\n\nexport const RadialScatterPlot: FC<Partial<RadialScatterPlotProps>> = ({\n  id,\n  width,\n  height,\n  margins,\n  className,\n  containerClassName,\n  innerRadius,\n  series,\n  axis,\n  data\n}) => {\n  const getScales = useCallback(\n    (\n      aggregatedData: ChartInternalShallowDataShape[],\n      outer: number,\n      inner: number\n    ) => {\n      let xScale;\n      if (axis?.props.type === 'category') {\n        const xDomain = uniqueBy<ChartInternalShallowDataShape>(\n          aggregatedData,\n          (dd) => dd.x\n        );\n        xScale = scaleBand()\n          .range([0, 2 * Math.PI])\n          .domain(xDomain as any[]);\n      } else {\n        const xDomain = getXDomain({ data: aggregatedData });\n        xScale = scaleTime()\n          .range([0, 2 * Math.PI])\n          .domain(xDomain);\n      }\n\n      const yDomain = getYDomain({ data: aggregatedData, scaled: false });\n      const yScale = getRadialYScale(inner, outer, yDomain);\n\n      return {\n        yScale,\n        xScale\n      };\n    },\n    []\n  );\n\n  const renderChart = useCallback(\n    (containerProps: ChartContainerChildProps) => {\n      const { chartWidth, chartHeight, id } = containerProps;\n      const outerRadius = Math.min(chartWidth, chartHeight) / 2;\n      const aggregatedData = buildShallowChartData(data);\n      const { yScale, xScale } = getScales(\n        aggregatedData,\n        outerRadius,\n        innerRadius\n      );\n\n      return (\n        <Fragment>\n          {axis && (\n            <CloneElement<RadialAxisProps>\n              element={axis}\n              xScale={xScale}\n              height={chartHeight}\n              width={chartWidth}\n              innerRadius={innerRadius}\n            />\n          )}\n          <CloneElement<RadialScatterSeriesProps>\n            element={series}\n            id={id}\n            data={aggregatedData}\n            xScale={xScale}\n            yScale={yScale}\n          />\n        </Fragment>\n      );\n    },\n    [data, getScales, innerRadius, series, axis]\n  );\n\n  return (\n    <ChartContainer\n      id={id}\n      containerClassName={containerClassName}\n      width={width}\n      height={height}\n      margins={margins}\n      xAxisVisible={false}\n      yAxisVisible={false}\n      center={true}\n      className={className}\n    >\n      {renderChart}\n    </ChartContainer>\n  );\n};\n","import React, {\n  ReactNode,\n  useRef,\n  Fragment,\n  ReactElement,\n  FC,\n  useState,\n  useMemo\n} from 'react';\nimport { ChartInternalShallowDataShape } from '../../common/data';\nimport { radialLine } from 'd3-shape';\nimport classNames from 'classnames';\nimport { ChartTooltip, ChartTooltipProps } from '../../common/Tooltip';\nimport { CloneElement } from 'reablocks';\nimport { motion } from 'framer-motion';\nimport { DEFAULT_TRANSITION } from '../../common/Motion';\nimport { schemes } from '../../common/color';\nimport css from './RadialScatterPoint.module.css';\nimport { getAriaLabel } from '../../common';\n\nexport interface RadialScatterPointProps {\n  /**\n   * Parsed data shape. Set internally by `RadialScatterPlot`.\n   */\n  data: ChartInternalShallowDataShape;\n\n  /**\n   * Index of the element in the series. Set internally by `RadialScatterSeries`.\n   */\n  index: number;\n\n  /**\n   * Whether the element is active or not. Set internally by `RadialScatterSeries`.\n   */\n  animated: boolean;\n\n  /**\n   * D3 scale for X Axis. Set internally by `RadialScatterPlot`.\n   */\n  xScale: any;\n\n  /**\n   * D3 scale for Y Axis. Set internally by `RadialScatterPlot`.\n   */\n  yScale: any;\n\n  /**\n   * Fill for the element.\n   */\n  fill: string;\n\n  /**\n   * Id set internally by `RadialScatterPlot`.\n   */\n  id: string;\n\n  /**\n   * Color of the circle.\n   */\n  color: any;\n\n  /**\n   * CSS classes to apply.\n   */\n  className?: any;\n\n  /**\n   * Whether the element is active or not. Set internally by `RadialScatterSeries`.\n   */\n  active?: boolean;\n\n  /**\n   * Whether the elment is visiblbe or not.\n   */\n  visible?: (value, index) => boolean;\n\n  /**\n   * Symbol element to render.\n   */\n  symbol: (value) => ReactNode;\n\n  /**\n   * Size of the circle element.\n   */\n  size?: ((d) => number) | number;\n\n  /**\n   * Tooltip element.\n   */\n  tooltip: ReactElement<ChartTooltipProps, typeof ChartTooltip> | null;\n\n  /**\n   * Event for when a symbol is clicked.\n   */\n  onClick: (event) => void;\n\n  /**\n   * Event for when the symbol has mouse enter.\n   */\n  onMouseEnter: (event) => void;\n\n  /**\n   * Event for when the symbol has mouse leave.\n   */\n  onMouseLeave: (event) => void;\n}\n\nexport const RadialScatterPoint: FC<Partial<RadialScatterPointProps>> = ({\n  size,\n  data,\n  color,\n  index,\n  symbol,\n  active,\n  tooltip,\n  yScale,\n  xScale,\n  animated,\n  className,\n  visible,\n  ...rest\n}) => {\n  const ref = useRef<any>(null);\n  const [hovered, setHovered] = useState<boolean>(false);\n\n  function onMouseEnter(event: React.MouseEvent) {\n    setHovered(true);\n    rest.onMouseEnter({\n      value: data,\n      nativeEvent: event\n    });\n  }\n\n  function onMouseLeave(event: React.MouseEvent) {\n    setHovered(false);\n    rest.onMouseLeave({\n      value: data,\n      nativeEvent: event\n    });\n  }\n\n  function onClick(event: React.MouseEvent) {\n    rest.onClick({\n      value: data,\n      nativeEvent: event\n    });\n  }\n\n  function getTranslate(data: ChartInternalShallowDataShape) {\n    const fn = radialLine()\n      .radius((d: any) => yScale(d.y))\n      .angle((d: any) => xScale(d.x));\n\n    // Parse the generated path to get point coordinates\n    // Ref: https://bit.ly/2CnZcPl\n    const path = fn([data] as any);\n\n    if (path) {\n      const [translateX, translateY] = path.slice(1).slice(0, -1).split(',');\n\n      return {\n        translateX: parseFloat(translateX),\n        translateY: parseFloat(translateY)\n      };\n    }\n  }\n\n  function getTransition() {\n    if (animated) {\n      return {\n        ...DEFAULT_TRANSITION,\n        delay: index * 0.005\n      };\n    } else {\n      return {\n        type: false,\n        delay: 0\n      };\n    }\n  }\n\n  const fill = typeof color === 'function' ? color(data, index) : color;\n  const transform = getTranslate(data);\n  const sizeVal = typeof size === 'function' ? size(data) : size;\n  const transition = getTransition();\n\n  const [yStart] = yScale.domain();\n  const exitTransform = getTranslate({ ...data, y: yStart });\n\n  const ariaLabelData = useMemo(() => getAriaLabel(data), [data]);\n\n  const isVisible = visible ? visible?.(data, index) : active;\n\n  return (\n    <Fragment>\n      <motion.g\n        initial={{ ...exitTransform, opacity: 0 }}\n        animate={{ ...transform, opacity: 1 }}\n        exit={{ ...exitTransform, opacity: 0 }}\n        transition={transition}\n        ref={ref}\n        onMouseEnter={onMouseEnter}\n        onMouseLeave={onMouseLeave}\n        onClick={onClick}\n        className={classNames(className, {\n          [css.inactive]: !active,\n          [css.hidden]: !isVisible\n        })}\n        tabIndex={0}\n        aria-label={ariaLabelData}\n        role=\"graphics-document\"\n      >\n        {symbol && symbol(data)}\n        {!symbol && <circle r={sizeVal} fill={fill} />}\n      </motion.g>\n      {tooltip && (\n        <CloneElement<ChartTooltipProps>\n          element={tooltip}\n          visible={hovered}\n          reference={ref}\n          value={data}\n        />\n      )}\n    </Fragment>\n  );\n};\n\nRadialScatterPoint.defaultProps = {\n  size: 3,\n  color: schemes.cybertron[0],\n  tooltip: <ChartTooltip />,\n  active: true,\n  onClick: () => undefined,\n  onMouseEnter: () => undefined,\n  onMouseLeave: () => undefined\n};\n","import React, {\n  useState,\n  FC,\n  Fragment,\n  ReactElement,\n  useEffect,\n  useCallback\n} from 'react';\nimport { ChartInternalShallowDataShape } from '../../common/data';\nimport {\n  RadialScatterPoint,\n  RadialScatterPointProps\n} from './RadialScatterPoint';\nimport { CloneElement } from 'reablocks';\nimport { identifier } from 'safe-identifier';\nimport { RadialValueMarker, RadialValueMarkerProps } from '../../common';\n\nexport interface RadialScatterSeriesProps {\n  /**\n   * Point that is rendered.\n   */\n  point: ReactElement<RadialScatterPointProps, typeof RadialScatterPoint>;\n\n  /**\n   * D3 scale for X Axis. Set internally by `RadialScatterPlot`.\n   */\n  xScale: any;\n\n  /**\n   * D3 scale for Y Axis. Set internally by `RadialScatterPlot`.\n   */\n  yScale: any;\n\n  /**\n   * Parsed data shape. Set internally by `RadialScatterPlot`.\n   */\n  data: ChartInternalShallowDataShape[];\n\n  /**\n   * Id set internally by `RadialScatterPlot`.\n   */\n  id: string;\n\n  /**\n   * Whether to animate the enter/update/exit.\n   */\n  animated: boolean;\n\n  /**\n   * Active element ids to highlight.\n   */\n  activeIds?: string[];\n\n  /**\n   * When to show the point.\n   */\n  show: boolean;\n\n  /**\n   * Value markers line for the chart.\n   */\n  valueMarkers:\n    | ReactElement<RadialValueMarkerProps, typeof RadialValueMarker>[]\n    | null;\n}\n\nexport const RadialScatterSeries: FC<Partial<RadialScatterSeriesProps>> = ({\n  data,\n  point,\n  xScale,\n  yScale,\n  animated,\n  activeIds,\n  show = true,\n  valueMarkers\n}) => {\n  const [internalActiveIds, setInternalActiveIds] = useState<string[] | null>(\n    activeIds\n  );\n\n  useEffect(() => {\n    setInternalActiveIds(activeIds || []);\n  }, [activeIds]);\n\n  const onMouseEnter = useCallback(\n    ({ value }) => {\n      // Only perform this on unmanaged activations\n      if (!activeIds) {\n        setInternalActiveIds([value.id]);\n      }\n    },\n    [activeIds]\n  );\n\n  const onMouseLeave = useCallback(() => {\n    // Only perform this on unmanaged activations\n    if (!activeIds) {\n      setInternalActiveIds([]);\n    }\n  }, [activeIds]);\n\n  const isVisible = useCallback(() => show, [show]);\n\n  const renderPoint = useCallback(\n    (d: ChartInternalShallowDataShape, index: number) => {\n      let dataId;\n      if (d.id) {\n        dataId = d.id;\n      } else {\n        console.warn(\n          'No \\'id\\' property provided for scatter point; provide one via \\'id\\'.'\n        );\n      }\n\n      const key = identifier(`${dataId || index}`);\n      const active =\n        !(internalActiveIds && internalActiveIds.length) ||\n        internalActiveIds.includes(dataId);\n\n      const pointVisible = point.props?.visible;\n\n      return (\n        <CloneElement<RadialScatterPointProps>\n          /* Trick to pass isVisible callback, directly cannot be passed when point is a cloned element already */\n          {...(pointVisible ? {} : { visible: isVisible })}\n          element={point}\n          key={key}\n          data={d}\n          index={index}\n          active={active}\n          xScale={xScale}\n          yScale={yScale}\n          animated={animated}\n          onMouseEnter={onMouseEnter}\n          onMouseLeave={onMouseLeave}\n        />\n      );\n    },\n    [\n      isVisible,\n      point,\n      internalActiveIds,\n      xScale,\n      yScale,\n      animated,\n      onMouseEnter,\n      onMouseLeave\n    ]\n  );\n\n  const renderValueMarkers = useCallback(\n    () => (\n      <>\n        {valueMarkers?.length &&\n          valueMarkers.map((marker) => (\n            <CloneElement<RadialValueMarkerProps>\n              key={marker.key}\n              element={marker}\n              value={yScale(marker.props.value)}\n            />\n          ))}\n      </>\n    ),\n    [valueMarkers, yScale]\n  );\n\n  return (\n    <Fragment>\n      {renderValueMarkers()}\n      {data.map(renderPoint)}\n    </Fragment>\n  );\n};\n\nRadialScatterSeries.defaultProps = {\n  point: <RadialScatterPoint />,\n  animated: true\n};\n","import React, { useCallback, ReactElement, FC } from 'react';\nimport {\n  RadialScatterSeries,\n  RadialScatterPoint,\n  RadialScatterPointProps\n} from '../../RadialScatterPlot';\nimport { ChartInternalShallowDataShape } from '../../common/data';\nimport { CloneElement } from 'reablocks';\nimport isEqual from 'react-fast-compare';\n\nexport interface RadialPointSeriesProps {\n  /**\n   * Whether the points are animated or not.\n   */\n  animated: boolean;\n\n  /**\n   * Color scheme.\n   */\n  color: any;\n\n  /**\n   * Index of the area in the series. Set internally by `RadialAreaSeries`.\n   */\n  index: number;\n\n  /**\n   * Active values set by parent.\n   */\n  activeValues?: any;\n\n  /**\n   * Parsed data object.\n   */\n  data: ChartInternalShallowDataShape[];\n\n  /**\n   * D3 X-Scale.\n   */\n  yScale: any;\n\n  /**\n   * D3 Y-Scale.\n   */\n  xScale: any;\n\n  /**\n   * When to show the point.\n   */\n  show: boolean | 'hover' | 'first' | 'last';\n\n  /**\n   * Point react component.\n   */\n  point: ReactElement<RadialScatterPointProps, typeof RadialScatterPoint>;\n}\n\nexport const RadialPointSeries: FC<Partial<RadialPointSeriesProps>> = ({\n  data,\n  xScale,\n  yScale,\n  animated,\n  color,\n  activeValues,\n  show,\n  point\n}) => {\n  const isVisible = useCallback(\n    (point: ChartInternalShallowDataShape, index: number) => {\n      const isActive =\n        activeValues && point && isEqual(activeValues.x, point.x);\n\n      if (show === 'hover') {\n        return isActive;\n      } else if (show === 'first') {\n        if (activeValues) {\n          return isActive;\n        } else {\n          return index === 0;\n        }\n      } else if (show === 'last') {\n        if (activeValues) {\n          return isActive;\n        } else {\n          return index === data!.length - 1;\n        }\n      }\n\n      return show;\n    },\n    [data, activeValues, show]\n  );\n\n  return (\n    <RadialScatterSeries\n      animated={animated}\n      data={data}\n      xScale={xScale}\n      yScale={yScale}\n      point={\n        <CloneElement<RadialScatterPointProps>\n          element={point}\n          color={color}\n          tooltip={null}\n          visible={isVisible}\n        />\n      }\n    />\n  );\n};\n\nRadialPointSeries.defaultProps = {\n  show: 'hover',\n  type: 'standard',\n  point: <RadialScatterPoint />\n};\n","import React, {\n  FC,\n  Fragment,\n  ReactElement,\n  useCallback,\n  useState\n} from 'react';\nimport {\n  ChartInternalNestedDataShape,\n  ChartInternalShallowDataShape\n} from '../../common/data';\nimport { getColor, ColorSchemeType, schemes } from '../../common/color';\nimport { CloneElement } from 'reablocks';\nimport { RadialAreaProps, RadialArea } from './RadialArea';\nimport { RadialLine, RadialLineProps } from './RadialLine';\nimport { RadialInterpolationTypes } from '../../common/utils/interpolation';\nimport { RadialPointSeries, RadialPointSeriesProps } from './RadialPointSeries';\nimport { TooltipAreaProps, TooltipArea } from '../../common/Tooltip';\nimport { RadialValueMarker, RadialValueMarkerProps } from '../../common';\n\nexport type RadialPointSeriesType = 'standard' | 'grouped';\n\nexport interface RadialAreaSeriesProps {\n  /**\n   * Parsed data shape. Set internally by `RadialAreaChart`.\n   */\n  data: ChartInternalShallowDataShape[];\n\n  /**\n   * The type of the chart.\n   */\n  type?: RadialPointSeriesType;\n\n  /**\n   * Color scheme for the series.\n   */\n  colorScheme: ColorSchemeType;\n\n  /**\n   * The outer radius for the chart center.\n   */\n  outerRadius: number;\n\n  /**\n   * The inner radius for the chart center.\n   */\n  innerRadius: number;\n\n  /**\n   * D3 scale for X Axis. Set internally by `RadialAreaChart`.\n   */\n  xScale: any;\n\n  /**\n   * D3 scale for Y Axis. Set internally by `RadialAreaChart`.\n   */\n  yScale: any;\n\n  /**\n   * Id set internally by `RadialAreaChart`.\n   */\n  id: string;\n\n  /**\n   * interpolation set internally by `RadialAreaChart`.\n   */\n  interpolation: RadialInterpolationTypes;\n\n  /**\n   * Whether to animate the enter/update/exit.\n   */\n  animated: boolean;\n\n  /**\n   * Height of the chart. Set internally by `RadialAreaChart`.\n   */\n  height: number;\n\n  /**\n   * Width of the chart. Set internally by `RadialAreaChart`.\n   */\n  width: number;\n\n  /**\n   * Area that is rendered.\n   */\n  area: ReactElement<RadialAreaProps, typeof RadialArea> | null;\n\n  /**\n   * Line that is rendered.\n   */\n  line: ReactElement<RadialLineProps, typeof RadialLine> | null;\n\n  /**\n   * Symbols used to show points.\n   */\n  symbols: ReactElement<\n    RadialPointSeriesProps,\n    typeof RadialPointSeries\n  > | null;\n\n  /**\n   * Tooltip for the chart area.\n   */\n  tooltip: ReactElement<TooltipAreaProps, typeof TooltipArea>;\n\n  /**\n   * Start angle for the first value.\n   */\n  startAngle?: number;\n\n  /**\n   * End angle for the last value.\n   */\n  endAngle?: number;\n\n  /**\n   * Whether the curve should be closed. Set to true by deafult\n   */\n  isClosedCurve: boolean;\n\n  /**\n   * Value markers line for the chart.\n   */\n  valueMarkers:\n    | ReactElement<RadialValueMarkerProps, typeof RadialValueMarker>[]\n    | null;\n}\n\nexport const RadialAreaSeries: FC<Partial<RadialAreaSeriesProps>> = ({\n  area,\n  line,\n  symbols,\n  tooltip,\n  xScale,\n  yScale,\n  data,\n  id,\n  animated,\n  width,\n  height,\n  innerRadius,\n  outerRadius,\n  type,\n  colorScheme,\n  interpolation,\n  startAngle,\n  endAngle,\n  isClosedCurve,\n  valueMarkers\n}) => {\n  const [activeValues, setActiveValues] = useState<any | null>(null);\n  const isMulti = type === 'grouped';\n\n  const getColorForPoint = useCallback(\n    (point: ChartInternalShallowDataShape, index: number) => {\n      const key = Array.isArray(point) ? point?.[0]?.key : point?.key;\n\n      return getColor({\n        colorScheme,\n        data,\n        index,\n        point,\n        key\n      });\n    },\n    [colorScheme, data]\n  );\n\n  const renderArea = useCallback(\n    (point: ChartInternalShallowDataShape[], index = 0) => (\n      <>\n        {area && (\n          <CloneElement<RadialAreaProps>\n            element={area}\n            id={`${id}-radial-area-${index}`}\n            xScale={xScale}\n            yScale={yScale}\n            animated={animated}\n            color={getColorForPoint}\n            index={index}\n            data={point}\n            interpolation={interpolation}\n            outerRadius={outerRadius}\n            innerRadius={innerRadius}\n            isClosedCurve={isClosedCurve}\n          />\n        )}\n        {line && (\n          <CloneElement<RadialLineProps>\n            element={line}\n            xScale={xScale}\n            yScale={yScale}\n            hasArea={area !== null}\n            index={index}\n            animated={animated}\n            interpolation={interpolation}\n            color={getColorForPoint}\n            data={point}\n            isClosedCurve={isClosedCurve}\n          />\n        )}\n      </>\n    ),\n    [\n      animated,\n      area,\n      getColorForPoint,\n      id,\n      innerRadius,\n      interpolation,\n      isClosedCurve,\n      line,\n      outerRadius,\n      xScale,\n      yScale\n    ]\n  );\n\n  const renderSymbols = useCallback(\n    (data: ChartInternalShallowDataShape[], index = 0) => {\n      // Animations are only valid for Area\n      const activeSymbols =\n        (symbols && symbols.props.activeValues) || activeValues;\n      const isAnimated = area !== undefined && animated && !activeSymbols;\n\n      return (\n        <CloneElement<RadialPointSeriesProps>\n          element={symbols}\n          activeValues={activeValues}\n          xScale={xScale}\n          index={index}\n          yScale={yScale}\n          data={data}\n          animated={isAnimated}\n          color={getColorForPoint}\n        />\n      );\n    },\n    [activeValues, animated, area, getColorForPoint, symbols, xScale, yScale]\n  );\n\n  const renderSingleSeries = useCallback(\n    (points: ChartInternalShallowDataShape[]) => (\n      <Fragment>\n        {renderArea(points)}\n        {symbols && renderSymbols(points)}\n      </Fragment>\n    ),\n    [renderArea, renderSymbols, symbols]\n  );\n\n  const renderMultiSeries = useCallback(\n    (points: ChartInternalNestedDataShape[]) => (\n      <Fragment>\n        {points\n          .map((point, index) => (\n            <Fragment key={`${point.key!.toString()}`}>\n              {renderArea(point.data, index)}\n            </Fragment>\n          ))\n          .reverse()}\n        {points\n          .map((point, index) => (\n            <Fragment key={`${point.key!.toString()}`}>\n              {renderSymbols(point.data, index)}\n            </Fragment>\n          ))\n          .reverse()}\n      </Fragment>\n    ),\n    [renderArea, renderSymbols]\n  );\n\n  const renderValueMarkers = useCallback(\n    () => (\n      <>\n        {valueMarkers?.length &&\n          valueMarkers.map((marker) => (\n            <CloneElement<RadialValueMarkerProps>\n              key={marker.key}\n              element={marker}\n              value={yScale(marker.props.value)}\n            />\n          ))}\n      </>\n    ),\n    [valueMarkers, yScale]\n  );\n\n  return (\n    <CloneElement<TooltipAreaProps>\n      element={tooltip}\n      xScale={xScale}\n      yScale={yScale}\n      data={data}\n      height={height}\n      width={width}\n      isRadial={true}\n      innerRadius={innerRadius}\n      outerRadius={outerRadius}\n      color={getColorForPoint}\n      onValueEnter={(event) => setActiveValues(event.value)}\n      onValueLeave={() => setActiveValues(null)}\n      startAngle={startAngle}\n      endAngle={endAngle}\n    >\n      <g clipPath={`url(#${id}-path)`}>\n        {isMulti &&\n          renderMultiSeries(data as unknown as ChartInternalNestedDataShape[])}\n        {!isMulti &&\n          renderSingleSeries(data as ChartInternalShallowDataShape[])}\n        {renderValueMarkers()}\n      </g>\n    </CloneElement>\n  );\n};\n\nRadialAreaSeries.defaultProps = {\n  colorScheme: schemes.cybertron,\n  interpolation: 'smooth',\n  type: 'standard',\n  animated: true,\n  area: <RadialArea />,\n  line: <RadialLine />,\n  symbols: <RadialPointSeries />,\n  tooltip: <TooltipArea />,\n  startAngle: 0,\n  endAngle: 2 * Math.PI,\n  isClosedCurve: true\n};\n","import React, { Fragment, ReactElement, FC, useCallback } from 'react';\nimport {\n  ChartInternalShallowDataShape,\n  buildShallowChartData,\n  ChartDataShape,\n  buildNestedChartData,\n  ChartNestedDataShape,\n  ChartShallowDataShape\n} from '../common/data';\nimport { scaleTime, scaleBand, scalePoint } from 'd3-scale';\nimport { getYDomain, getXDomain } from '../common/utils/domains';\nimport {\n  ChartProps,\n  ChartContainer,\n  ChartContainerChildProps\n} from '../common/containers';\nimport { CloneElement } from 'reablocks';\nimport { RadialAreaSeries, RadialAreaSeriesProps } from './RadialAreaSeries';\nimport { RadialAxis, RadialAxisProps } from '../common/Axis/RadialAxis';\nimport { getRadialYScale } from '../common/scales/radial';\nimport { uniqueBy } from '../common/utils';\n\nexport interface RadialAreaChartProps extends ChartProps {\n  /**\n   * Data the chart will receive to render.\n   */\n  data: ChartDataShape[];\n\n  /**\n   * The series component that renders the area components.\n   */\n  series: ReactElement<RadialAreaSeriesProps, typeof RadialAreaSeries>;\n\n  /**\n   * The radial axis component for the chart.\n   */\n  innerRadius: number;\n\n  /**\n   * The inner radius for the chart center.\n   */\n  axis: ReactElement<RadialAxisProps, typeof RadialAxis> | null;\n\n  /**\n   * Start angle for the first value.\n   */\n  startAngle?: number;\n\n  /**\n   * End angle for the last value.\n   */\n  endAngle?: number;\n\n  /**\n   * Whether the curve should be closed. Set to true by deafult\n   */\n  isClosedCurve?: boolean;\n}\n\nexport const RadialAreaChart: FC<Partial<RadialAreaChartProps>> = ({\n  id,\n  width,\n  height,\n  className,\n  data,\n  containerClassName,\n  innerRadius,\n  series,\n  axis,\n  margins,\n  startAngle,\n  endAngle,\n  isClosedCurve\n}) => {\n  const getXScale = useCallback(\n    (points) => {\n      const isFullCircle = Math.abs(endAngle - startAngle) >= 2 * Math.PI;\n      let xScale;\n      if (axis?.props.type === 'category') {\n        const isMultiSeries = series.props.type === 'grouped';\n\n        let xDomain;\n        if (isMultiSeries) {\n          xDomain = uniqueBy<ChartInternalShallowDataShape>(\n            points,\n            (dd) => dd.data,\n            (dd) => dd.x\n          );\n        } else {\n          xDomain = uniqueBy<ChartInternalShallowDataShape>(\n            points,\n            (dd) => dd.x\n          );\n        }\n\n        if (isFullCircle) {\n          xScale = scaleBand()\n            .range([0, 2 * Math.PI])\n            .domain(xDomain as any[]);\n        } else {\n          // scaleBand() excludes the end value from the band:\n          //  https://www.d3indepth.com/scales/#scaleband\n          xScale = scalePoint()\n            .range([startAngle, endAngle])\n            .domain(xDomain as any[]);\n        }\n      } else {\n        const xDomain = getXDomain({ data: points });\n\n        xScale = scaleTime().range([startAngle, endAngle]).domain(xDomain);\n      }\n\n      return xScale;\n    },\n    [axis?.props.type, endAngle, series.props.type, startAngle]\n  );\n\n  const getScales = useCallback(\n    (preData: ChartDataShape[], outerRadius: number, innerRadius: number) => {\n      const isMultiSeries = series.props.type === 'grouped';\n\n      let d;\n      if (isMultiSeries) {\n        d = buildNestedChartData(preData as ChartNestedDataShape[], true);\n      } else {\n        d = buildShallowChartData(preData as ChartShallowDataShape[]);\n      }\n\n      const xScale = getXScale(d);\n      const yDomain = getYDomain({ data: d, scaled: false });\n      const yScale = getRadialYScale(innerRadius, outerRadius, yDomain);\n\n      return {\n        yScale,\n        xScale,\n        result: d\n      };\n    },\n    [getXScale, series.props.type]\n  );\n\n  const renderChart = useCallback(\n    (containerProps: ChartContainerChildProps) => {\n      const { chartWidth, chartHeight, id } = containerProps;\n      const outerRadius = Math.min(chartWidth, chartHeight) / 2;\n      const { yScale, xScale, result } = getScales(\n        data!,\n        outerRadius,\n        innerRadius\n      );\n\n      return (\n        <Fragment>\n          {axis && (\n            <CloneElement<RadialAxisProps>\n              element={axis}\n              xScale={xScale}\n              height={chartHeight}\n              width={chartWidth}\n              innerRadius={innerRadius}\n              startAngle={startAngle}\n              endAngle={endAngle}\n            />\n          )}\n          <CloneElement<RadialAreaSeriesProps>\n            element={series}\n            id={id}\n            data={result}\n            xScale={xScale}\n            yScale={yScale}\n            height={chartHeight}\n            width={chartWidth}\n            outerRadius={outerRadius}\n            innerRadius={innerRadius}\n            startAngle={startAngle}\n            endAngle={endAngle}\n            isClosedCurve={isClosedCurve}\n          />\n        </Fragment>\n      );\n    },\n    [\n      getScales,\n      data,\n      innerRadius,\n      axis,\n      startAngle,\n      endAngle,\n      series,\n      isClosedCurve\n    ]\n  );\n\n  return (\n    <ChartContainer\n      id={id}\n      width={width}\n      height={height}\n      containerClassName={containerClassName}\n      margins={margins}\n      xAxisVisible={false}\n      yAxisVisible={false}\n      center={true}\n      className={className}\n    >\n      {renderChart}\n    </ChartContainer>\n  );\n};\n\nRadialAreaChart.defaultProps = {\n  innerRadius: 0.1,\n  series: <RadialAreaSeries />,\n  axis: <RadialAxis />,\n  margins: 75,\n  startAngle: 0,\n  endAngle: 2 * Math.PI,\n  isClosedCurve: true\n};\n","const pi = Math.PI,\n    tau = 2 * pi,\n    epsilon = 1e-6,\n    tauEpsilon = tau - epsilon;\n\nfunction append(strings) {\n  this._ += strings[0];\n  for (let i = 1, n = strings.length; i < n; ++i) {\n    this._ += arguments[i] + strings[i];\n  }\n}\n\nfunction appendRound(digits) {\n  let d = Math.floor(digits);\n  if (!(d >= 0)) throw new Error(`invalid digits: ${digits}`);\n  if (d > 15) return append;\n  const k = 10 ** d;\n  return function(strings) {\n    this._ += strings[0];\n    for (let i = 1, n = strings.length; i < n; ++i) {\n      this._ += Math.round(arguments[i] * k) / k + strings[i];\n    }\n  };\n}\n\nexport class Path {\n  constructor(digits) {\n    this._x0 = this._y0 = // start of current subpath\n    this._x1 = this._y1 = null; // end of current subpath\n    this._ = \"\";\n    this._append = digits == null ? append : appendRound(digits);\n  }\n  moveTo(x, y) {\n    this._append`M${this._x0 = this._x1 = +x},${this._y0 = this._y1 = +y}`;\n  }\n  closePath() {\n    if (this._x1 !== null) {\n      this._x1 = this._x0, this._y1 = this._y0;\n      this._append`Z`;\n    }\n  }\n  lineTo(x, y) {\n    this._append`L${this._x1 = +x},${this._y1 = +y}`;\n  }\n  quadraticCurveTo(x1, y1, x, y) {\n    this._append`Q${+x1},${+y1},${this._x1 = +x},${this._y1 = +y}`;\n  }\n  bezierCurveTo(x1, y1, x2, y2, x, y) {\n    this._append`C${+x1},${+y1},${+x2},${+y2},${this._x1 = +x},${this._y1 = +y}`;\n  }\n  arcTo(x1, y1, x2, y2, r) {\n    x1 = +x1, y1 = +y1, x2 = +x2, y2 = +y2, r = +r;\n\n    // Is the radius negative? Error.\n    if (r < 0) throw new Error(`negative radius: ${r}`);\n\n    let x0 = this._x1,\n        y0 = this._y1,\n        x21 = x2 - x1,\n        y21 = y2 - y1,\n        x01 = x0 - x1,\n        y01 = y0 - y1,\n        l01_2 = x01 * x01 + y01 * y01;\n\n    // Is this path empty? Move to (x1,y1).\n    if (this._x1 === null) {\n      this._append`M${this._x1 = x1},${this._y1 = y1}`;\n    }\n\n    // Or, is (x1,y1) coincident with (x0,y0)? Do nothing.\n    else if (!(l01_2 > epsilon));\n\n    // Or, are (x0,y0), (x1,y1) and (x2,y2) collinear?\n    // Equivalently, is (x1,y1) coincident with (x2,y2)?\n    // Or, is the radius zero? Line to (x1,y1).\n    else if (!(Math.abs(y01 * x21 - y21 * x01) > epsilon) || !r) {\n      this._append`L${this._x1 = x1},${this._y1 = y1}`;\n    }\n\n    // Otherwise, draw an arc!\n    else {\n      let x20 = x2 - x0,\n          y20 = y2 - y0,\n          l21_2 = x21 * x21 + y21 * y21,\n          l20_2 = x20 * x20 + y20 * y20,\n          l21 = Math.sqrt(l21_2),\n          l01 = Math.sqrt(l01_2),\n          l = r * Math.tan((pi - Math.acos((l21_2 + l01_2 - l20_2) / (2 * l21 * l01))) / 2),\n          t01 = l / l01,\n          t21 = l / l21;\n\n      // If the start tangent is not coincident with (x0,y0), line to.\n      if (Math.abs(t01 - 1) > epsilon) {\n        this._append`L${x1 + t01 * x01},${y1 + t01 * y01}`;\n      }\n\n      this._append`A${r},${r},0,0,${+(y01 * x20 > x01 * y20)},${this._x1 = x1 + t21 * x21},${this._y1 = y1 + t21 * y21}`;\n    }\n  }\n  arc(x, y, r, a0, a1, ccw) {\n    x = +x, y = +y, r = +r, ccw = !!ccw;\n\n    // Is the radius negative? Error.\n    if (r < 0) throw new Error(`negative radius: ${r}`);\n\n    let dx = r * Math.cos(a0),\n        dy = r * Math.sin(a0),\n        x0 = x + dx,\n        y0 = y + dy,\n        cw = 1 ^ ccw,\n        da = ccw ? a0 - a1 : a1 - a0;\n\n    // Is this path empty? Move to (x0,y0).\n    if (this._x1 === null) {\n      this._append`M${x0},${y0}`;\n    }\n\n    // Or, is (x0,y0) not coincident with the previous point? Line to (x0,y0).\n    else if (Math.abs(this._x1 - x0) > epsilon || Math.abs(this._y1 - y0) > epsilon) {\n      this._append`L${x0},${y0}`;\n    }\n\n    // Is this arc empty? We’re done.\n    if (!r) return;\n\n    // Does the angle go the wrong way? Flip the direction.\n    if (da < 0) da = da % tau + tau;\n\n    // Is this a complete circle? Draw two arcs to complete the circle.\n    if (da > tauEpsilon) {\n      this._append`A${r},${r},0,1,${cw},${x - dx},${y - dy}A${r},${r},0,1,${cw},${this._x1 = x0},${this._y1 = y0}`;\n    }\n\n    // Is this arc non-empty? Draw an arc!\n    else if (da > epsilon) {\n      this._append`A${r},${r},0,${+(da >= pi)},${cw},${this._x1 = x + r * Math.cos(a1)},${this._y1 = y + r * Math.sin(a1)}`;\n    }\n  }\n  rect(x, y, w, h) {\n    this._append`M${this._x0 = this._x1 = +x},${this._y0 = this._y1 = +y}h${w = +w}v${+h}h${-w}Z`;\n  }\n  toString() {\n    return this._;\n  }\n}\n\nexport function path() {\n  return new Path;\n}\n\n// Allow instanceof d3.path\npath.prototype = Path.prototype;\n\nexport function pathRound(digits = 3) {\n  return new Path(+digits);\n}\n","import React, { useEffect, useRef, useState } from 'react';\nimport { motion, useMotionValue, useSpring } from 'framer-motion';\nimport { interpolate } from 'd3-interpolate';\nimport { DEFAULT_TRANSITION } from '../../common/Motion';\n\nexport const MotionBar = ({ custom, transition, arc, ...rest }) => {\n  const d = useMotionValue('');\n  const currentYRef = useRef(custom.exit.y);\n  const spring = useSpring(0, DEFAULT_TRANSITION);\n\n  useEffect(() => {\n    const interpolator = interpolate(currentYRef.current, custom.enter.y);\n    const prevSpring = spring.get();\n    let timeoutId;\n\n    if (transition?.delay) {\n      timeoutId = setTimeout(() => {\n        spring.set(prevSpring + 1);\n      }, transition.delay * 1000);\n    } else {\n      spring.set(prevSpring + 1);\n    }\n\n    const unsubscribe = spring.onChange((v) => {\n      currentYRef.current = interpolator(v - prevSpring);\n      d.set(arc({ ...custom.enter, y: currentYRef.current }));\n    });\n\n    return () => {\n      if (timeoutId) {\n        clearTimeout(timeoutId);\n      }\n      unsubscribe();\n    };\n  }, [arc, custom.enter, d, spring, transition.delay]);\n\n  const { d: enterD, ...enterRest } = custom.enter;\n  const { d: exitD, ...exitRest } = custom.exit;\n\n  return (\n    <motion.path\n      {...rest}\n      initial={exitRest}\n      exit={exitRest}\n      animate={enterRest}\n      transition={transition}\n      d={transition.type !== false ? d : enterD}\n      tabIndex={0}\n    />\n  );\n};\n","import React, { FC } from 'react';\nimport { motion } from 'framer-motion';\n\nexport interface RadialGuideBarProps {\n  active: boolean;\n  path: string;\n  fill?: string;\n  opacity?: number;\n}\n\nexport const RadialGuideBar: FC<Partial<RadialGuideBarProps>> = ({\n  active,\n  path,\n  fill = '#eee',\n  opacity = 0.2\n}) => (\n  <motion.path\n    d={path}\n    fill={fill}\n    pointerEvents=\"none\"\n    initial=\"hidden\"\n    animate={active ? 'visible' : 'hidden'}\n    variants={{\n      hidden: { opacity: 0 },\n      visible: { opacity }\n    }}\n  />\n);\n\nRadialGuideBar.defaultProps = {\n  fill: '#eee',\n  opacity: 0.2\n};\n","import React, {\n  FC,\n  Fragment,\n  ReactElement,\n  useCallback,\n  useMemo,\n  useRef\n} from 'react';\nimport { ChartInternalShallowDataShape } from '../../common/data';\nimport { arc } from 'd3-shape';\nimport { Gradient } from '../../common/Gradient';\nimport bind from 'memoize-bind';\nimport chroma from 'chroma-js';\nimport { path } from 'd3-path';\nimport { DEFAULT_TRANSITION } from '../../common/Motion';\nimport { MotionBar } from './MotionBar';\nimport { RadialGuideBar, RadialGuideBarProps } from './RadialGuideBar';\nimport { CloneElement } from 'reablocks';\nimport { scaleBand, scaleLinear } from 'd3-scale';\n\nexport interface RadialBarProps {\n  /**\n   * Parsed data shape. Set internally by `RadialBarChart`.\n   */\n  data: ChartInternalShallowDataShape;\n\n  /**\n   * The inner radius for the chart center.\n   */\n  innerRadius: number;\n\n  /**\n   * Index of the element in the series. Set internally by `RadialBarSeries`.\n   */\n  index: number;\n\n  /**\n   * Whether the element is active or not. Set internally by `RadialBarSeries`.\n   */\n  animated: boolean;\n\n  /**\n   * D3 scale for X Axis. Set internally by `RadialBarChart`.\n   */\n  xScale: any;\n\n  /**\n   * D3 scale for Y Axis. Set internally by `RadialBarChart`.\n   */\n  yScale: any;\n\n  /**\n   * Color of the bar.\n   */\n  color: any;\n\n  /**\n   * Whether to use gradient or not.\n   */\n  gradient: boolean;\n\n  /**\n   * Id set internally by `RadialBarSeries`.\n   */\n  id: string;\n\n  /**\n   * Total number of bars used for animation. Set internally by `RadialBarSeries`.\n   */\n  barCount: number;\n\n  /**\n   * Total number of nested bars inside each group. Set internally by `RadialBarSeries`.\n   */\n  innerBarCount: number;\n\n  /**\n   * Index of the group. Set internally by `BarSeries`.\n   */\n  groupIndex?: number;\n\n  /**\n   * CSS classes to apply.\n   */\n  className?: string;\n\n  /**\n   * Whether the bar is curved or not.\n   */\n  curved: boolean;\n\n  /**\n   * Guide bar component.\n   */\n  guide: ReactElement<RadialGuideBarProps, typeof RadialGuideBar> | null;\n\n  /**\n   * Active caused by hover.\n   */\n  active: boolean;\n\n  /**\n   * Event for when a symbol is clicked.\n   */\n  onClick: (event) => void;\n\n  /**\n   * Event for when the symbol has mouse enter.\n   */\n  onMouseEnter: (event) => void;\n\n  /**\n   * Event for when the symbol has mouse leave.\n   */\n  onMouseLeave: (event) => void;\n}\n\nexport const RadialBar: FC<Partial<RadialBarProps>> = ({\n  animated,\n  innerRadius,\n  xScale,\n  yScale,\n  curved,\n  id,\n  gradient,\n  barCount,\n  innerBarCount,\n  groupIndex,\n  className,\n  data,\n  active,\n  guide,\n  index,\n  color,\n  onClick,\n  onMouseEnter,\n  onMouseLeave\n}) => {\n  const previousEnter = useRef<any | null>(null);\n  const fill = color(data, index);\n  const currentColorShade = active ? chroma(fill).brighten(0.5) : fill;\n\n  const transition = useMemo(() => {\n    if (animated) {\n      return {\n        ...DEFAULT_TRANSITION,\n        delay: (index / barCount) * 0.9\n      };\n    } else {\n      return {\n        type: false,\n        delay: 0\n      };\n    }\n  }, [animated, barCount, index]);\n\n  const getFill = useCallback(\n    (color: string) => {\n      if (!gradient) {\n        return color;\n      }\n\n      return `url(#${id}-gradient)`;\n    },\n    [gradient, id]\n  );\n\n  const getArc = useCallback(\n    (data: ChartInternalShallowDataShape) => {\n      const outerRadius = yScale(data.y);\n\n      if (curved) {\n        const startAngle = xScale(data.x);\n        const endAngle = startAngle + xScale.bandwidth();\n\n        const arcFn = arc()\n          .innerRadius(innerRadius)\n          .outerRadius(outerRadius)\n          .startAngle(startAngle)\n          .endAngle(endAngle)\n          .padAngle(0.01)\n          .padRadius(innerRadius);\n\n        return arcFn(data as any);\n      } else {\n        const isMultiSeries = groupIndex !== undefined;\n        const xScaleDomain = xScale.domain();\n        const xScaleRange = xScale.range();\n        const isFullCircle =\n          Math.abs(xScaleRange[1] - xScaleRange[0]) >= 2 * Math.PI;\n\n        let xScaleBandwidth;\n        let rotateMid;\n        let startAngle;\n        let endAngle;\n        if (isFullCircle) {\n          xScaleBandwidth = xScale.bandwidth();\n\n          // Align groups centrally about the label axis\n          rotateMid =\n            isMultiSeries && xScaleBandwidth ? xScaleBandwidth / 2 : 0;\n          startAngle = xScale(data.x) - Math.PI * 0.5 - rotateMid;\n          endAngle = startAngle + xScaleBandwidth;\n        } else {\n          xScaleBandwidth = scaleBand()\n            .domain(xScaleDomain)\n            .range(xScaleRange)\n            .bandwidth();\n          rotateMid =\n            isMultiSeries && xScaleBandwidth ? xScaleBandwidth / 2 : 0;\n\n          if (index === 0) {\n            // Squeeze in the first group aligning the first bar in the group with the start margin\n            startAngle = xScale(data.x) - Math.PI * 0.5;\n            endAngle = startAngle + xScaleBandwidth - rotateMid;\n          } else if (index === barCount - 1) {\n            // Squeeze in the last group aligning the last bar in the group with the end margin\n            endAngle = xScaleRange[1] - Math.PI * 0.5;\n            startAngle = endAngle - xScaleBandwidth + rotateMid;\n          } else {\n            // Other groups are center aligned with the label axis\n            startAngle = xScale(data.x) - Math.PI * 0.5 - rotateMid;\n            endAngle = startAngle + xScaleBandwidth;\n          }\n        }\n\n        const innerAngleDistance = endAngle - startAngle;\n        const arcLength = innerRadius * innerAngleDistance;\n        const outerAngleDistance = arcLength / outerRadius;\n        const halfAngleDistanceDelta =\n          (innerAngleDistance - outerAngleDistance) / 2;\n\n        const innerDiff = innerAngleDistance / innerBarCount;\n        const innerStart = isMultiSeries\n          ? startAngle + groupIndex * innerDiff\n          : startAngle;\n        const innerEnd = isMultiSeries ? innerStart + innerDiff : endAngle;\n        const outerDiff = outerAngleDistance / innerBarCount;\n        const halfAngleDiffDistanceDelta = isMultiSeries\n          ? (innerDiff - outerDiff) / 2\n          : halfAngleDistanceDelta;\n\n        const pathFn = path();\n        pathFn.arc(0, 0, innerRadius, innerStart, innerEnd);\n        pathFn.arc(\n          0,\n          0,\n          outerRadius,\n          innerEnd - halfAngleDiffDistanceDelta,\n          innerStart + halfAngleDiffDistanceDelta,\n          true\n        );\n\n        return pathFn.toString();\n      }\n    },\n    [\n      barCount,\n      curved,\n      groupIndex,\n      index,\n      innerBarCount,\n      innerRadius,\n      xScale,\n      yScale\n    ]\n  );\n\n  const renderBar = useCallback(\n    (color: string) => {\n      const fill = getFill(color);\n\n      // Track previous props\n      const prev = previousEnter.current\n        ? { ...previousEnter.current }\n        : undefined;\n      previousEnter.current = { ...data };\n\n      const [yStart, yEnd] = yScale.domain();\n      const exit = {\n        ...data,\n        y: yStart\n      };\n\n      const guidePath = getArc({\n        ...data,\n        y: yEnd\n      }) as string;\n\n      return (\n        <Fragment>\n          {guide && (\n            <CloneElement<RadialGuideBarProps>\n              element={guide}\n              active={active}\n              path={guidePath}\n            />\n          )}\n          <MotionBar\n            arc={getArc}\n            custom={{\n              enter: data,\n              exit,\n              previousEnter: prev\n            }}\n            transition={transition}\n            fill={fill}\n            className={className}\n            onMouseEnter={(event) =>\n              onMouseEnter?.({\n                value: data,\n                nativeEvent: event\n              })\n            }\n            onMouseLeave={(event) =>\n              onMouseLeave?.({\n                value: data,\n                nativeEvent: event\n              })\n            }\n            onClick={(event) =>\n              onClick?.({\n                value: data,\n                nativeEvent: event\n              })\n            }\n          />\n        </Fragment>\n      );\n    },\n    [\n      active,\n      className,\n      data,\n      getArc,\n      getFill,\n      guide,\n      onClick,\n      onMouseEnter,\n      onMouseLeave,\n      transition,\n      yScale\n    ]\n  );\n\n  return (\n    <Fragment>\n      {renderBar(currentColorShade)}\n      {gradient && <Gradient id={`${id}-gradient`} color={currentColorShade} />}\n    </Fragment>\n  );\n};\n\nRadialBar.defaultProps = {\n  gradient: true,\n  curved: false,\n  guide: <RadialGuideBar />,\n  onClick: () => undefined,\n  onMouseEnter: () => undefined,\n  onMouseLeave: () => undefined\n};\n","import React, {\n  FC,\n  Fragment,\n  ReactElement,\n  useState,\n  useCallback,\n  useMemo\n} from 'react';\nimport {\n  ChartInternalDataShape,\n  ChartInternalNestedDataShape,\n  ChartInternalShallowDataShape\n} from '../../common/data';\nimport { RadialBar, RadialBarProps } from './RadialBar';\nimport { CloneElement } from 'reablocks';\nimport { ColorSchemeType, getColor, schemes } from '../../common/color';\nimport {\n  TooltipAreaProps,\n  TooltipArea,\n  ChartTooltip\n} from '../../common/Tooltip';\nimport isEqual from 'react-fast-compare';\nimport { RadialValueMarker, RadialValueMarkerProps } from '../../common';\n\nexport type RadialBarSeriesType = 'standard' | 'grouped';\nexport interface RadialBarSeriesProps {\n  /**\n   * Parsed data shape. Set internally by `RadialBarChart`.\n   */\n  data: ChartInternalDataShape[];\n\n  /**\n   * Color scheme for the series.\n   */\n  colorScheme: ColorSchemeType;\n\n  /**\n   * The inner radius for the chart center.\n   */\n  innerRadius: number;\n\n  /**\n   * The outer radius for the chart center.\n   */\n  outerRadius: number;\n\n  /**\n   * D3 scale for X Axis. Set internally by `RadialBarChart`.\n   */\n  xScale: any;\n\n  /**\n   * D3 scale for Y Axis. Set internally by `RadialBarChart`.\n   */\n  yScale: any;\n\n  /**\n   * Id set internally by `RadialBarChart`.\n   */\n  id: string;\n\n  /**\n   * Bar that is rendered.\n   */\n  bar: ReactElement<RadialBarProps, typeof RadialBar>;\n\n  /**\n   * Whether to animate the enter/update/exit.\n   */\n  animated: boolean;\n\n  /**\n   * Height of the chart. Set internally by `RadialBarChart`.\n   */\n  height: number;\n\n  /**\n   * Width of the chart. Set internally by `RadialBarChart`.\n   */\n  width: number;\n\n  /**\n   * Tooltip for the chart area.\n   */\n  tooltip: ReactElement<TooltipAreaProps, typeof TooltipArea>;\n\n  /**\n   * Start angle for the first value.\n   */\n  startAngle?: number;\n\n  /**\n   * End angle for the last value.\n   */\n  endAngle?: number;\n\n  /**\n   * The type of the chart.\n   */\n  type?: RadialBarSeriesType;\n\n  /**\n   * Value markers line for the chart.\n   */\n  valueMarkers:\n    | ReactElement<RadialValueMarkerProps, typeof RadialValueMarker>[]\n    | null;\n}\n\nexport const RadialBarSeries: FC<Partial<RadialBarSeriesProps>> = ({\n  data,\n  id,\n  innerRadius,\n  outerRadius,\n  xScale,\n  yScale,\n  height,\n  width,\n  tooltip,\n  colorScheme,\n  bar,\n  animated,\n  startAngle,\n  endAngle,\n  type,\n  valueMarkers\n}) => {\n  const [activeValues, setActiveValues] = useState<any | null>(null);\n  const isMultiSeries = useMemo(() => type === 'grouped', [type]);\n\n  const renderBar = useCallback(\n    (\n      point: ChartInternalShallowDataShape,\n      innerBarCount: number,\n      index: number,\n      barCount: number,\n      groupIndex?: number\n    ) => {\n      const active = activeValues && data && isEqual(activeValues.x, point.x);\n\n      return (\n        <Fragment key={index}>\n          <CloneElement<RadialBarProps>\n            element={bar}\n            id={`radialbar-${id}-${index}`}\n            index={index}\n            data={point}\n            xScale={xScale}\n            active={active}\n            yScale={yScale}\n            innerRadius={innerRadius}\n            color={(point) => getColor({ data, point, index: 0, colorScheme })}\n            barCount={barCount}\n            innerBarCount={innerBarCount}\n            groupIndex={groupIndex}\n            animated={animated}\n            startAngle={startAngle}\n            endAngle={endAngle}\n          />\n        </Fragment>\n      );\n    },\n    [\n      activeValues,\n      animated,\n      bar,\n      colorScheme,\n      data,\n      endAngle,\n      id,\n      innerRadius,\n      startAngle,\n      xScale,\n      yScale\n    ]\n  );\n\n  const renderBarGroup = useCallback(\n    (\n      data: ChartInternalShallowDataShape[],\n      innerBarCount: number,\n      barCount: number,\n      groupIndex?: number\n    ) => {\n      return (\n        <Fragment>\n          {data.map((barData, barIndex) =>\n            renderBar(barData, innerBarCount, barIndex, barCount, groupIndex)\n          )}\n        </Fragment>\n      );\n    },\n    [renderBar]\n  );\n\n  const renderValueMarkers = useCallback(\n    () => (\n      <>\n        {valueMarkers?.length &&\n          valueMarkers.map((marker) => (\n            <CloneElement<RadialValueMarkerProps>\n              key={marker.key}\n              element={marker}\n              value={yScale(marker.props.value)}\n            />\n          ))}\n      </>\n    ),\n    [valueMarkers, yScale]\n  );\n\n  return (\n    <CloneElement<TooltipAreaProps>\n      element={tooltip}\n      xScale={xScale}\n      yScale={yScale}\n      data={data}\n      height={height}\n      width={width}\n      isRadial={true}\n      innerRadius={innerRadius}\n      outerRadius={outerRadius}\n      onValueEnter={(event) => setActiveValues(event.value)}\n      onValueLeave={() => setActiveValues(null)}\n      color={(point, index) => getColor({ data, point, index, colorScheme })}\n      startAngle={startAngle}\n      endAngle={endAngle}\n    >\n      {isMultiSeries\n        ? (data as ChartInternalNestedDataShape[]).map((groupData, index) => (\n          <g key={`bar-group-${index}`}>\n            {renderBarGroup(\n                groupData.data as ChartInternalShallowDataShape[],\n                data.length,\n                groupData.data.length,\n                index\n            )}\n          </g>\n        ))\n        : renderBarGroup(\n            data as ChartInternalShallowDataShape[],\n            1,\n            data.length\n        )}\n      {renderValueMarkers()}\n    </CloneElement>\n  );\n};\n\nRadialBarSeries.defaultProps = {\n  colorScheme: schemes.cybertron[0],\n  tooltip: <TooltipArea tooltip={<ChartTooltip followCursor={true} />} />,\n  bar: <RadialBar />,\n  animated: true,\n  startAngle: 0,\n  endAngle: 2 * Math.PI,\n  type: 'standard'\n};\n","import React, { useCallback, FC, Fragment, ReactElement } from 'react';\nimport {\n  ChartShallowDataShape,\n  ChartInternalShallowDataShape,\n  buildShallowChartData,\n  ChartDataShape,\n  buildNestedChartData,\n  ChartNestedDataShape\n} from '../common/data';\nimport { scaleBand, scalePoint } from 'd3-scale';\nimport { getYDomain } from '../common/utils/domains';\nimport { RadialBarSeries, RadialBarSeriesProps } from './RadialBarSeries';\nimport {\n  ChartProps,\n  ChartContainer,\n  ChartContainerChildProps\n} from '../common/containers';\nimport { CloneElement } from 'reablocks';\nimport { RadialAxis, RadialAxisProps } from '../common/Axis/RadialAxis';\nimport { getRadialYScale } from '../common/scales';\nimport { uniqueBy } from '../common/utils/array';\n\nexport interface RadialBarChartProps extends ChartProps {\n  /**\n   * Data the chart will receive to render.\n   */\n  data: ChartDataShape[];\n\n  /**\n   * The series component that renders the bar components.\n   */\n  series: ReactElement<RadialBarSeriesProps, typeof RadialBarSeries>;\n\n  /**\n   * The radial axis component for the chart.\n   */\n  axis: ReactElement<RadialAxisProps, typeof RadialAxis> | null;\n\n  /**\n   * The inner radius for the chart center.\n   */\n  innerRadius: number;\n\n  /**\n   * Start angle for the first value.\n   */\n  startAngle?: number;\n\n  /**\n   * End angle for the last value.\n   */\n  endAngle?: number;\n}\n\nexport const RadialBarChart: FC<Partial<RadialBarChartProps>> = ({\n  id,\n  width,\n  height,\n  margins,\n  className,\n  containerClassName,\n  data,\n  innerRadius,\n  series,\n  axis,\n  startAngle,\n  endAngle\n}) => {\n  const getXScale = useCallback(\n    (points) => {\n      const isFullCircle = Math.abs(endAngle - startAngle) >= 2 * Math.PI;\n      let xScale;\n      if (axis?.props.type === 'category') {\n        const isMultiSeries = series.props.type === 'grouped';\n\n        let xDomain;\n        if (isMultiSeries) {\n          xDomain = uniqueBy<ChartInternalShallowDataShape>(\n            points,\n            (dd) => dd.data,\n            (dd) => dd.x\n          );\n        } else {\n          xDomain = uniqueBy<ChartInternalShallowDataShape>(\n            points,\n            (dd) => dd.x\n          );\n        }\n\n        if (isFullCircle) {\n          xScale = scaleBand()\n            .range([0, 2 * Math.PI])\n            .domain(xDomain as any[]);\n        } else {\n          // scaleBand() excludes the end value from the band:\n          //  https://www.d3indepth.com/scales/#scaleband\n          xScale = scalePoint()\n            .range([startAngle, endAngle])\n            .domain(xDomain as any[]);\n        }\n      } else {\n        const xDomain = uniqueBy(points, (d) => d.x);\n\n        xScale = scaleBand()\n          .range([startAngle, endAngle])\n          .domain(xDomain as any[]);\n      }\n\n      return xScale;\n    },\n    [axis?.props.type, endAngle, series.props.type, startAngle]\n  );\n\n  const getScales = useCallback(\n    (preData: ChartDataShape[], innerRadius: number, outerRadius: number) => {\n      const isMultiSeries = series.props.type === 'grouped';\n      let newData;\n      if (isMultiSeries) {\n        newData = buildNestedChartData(preData as ChartNestedDataShape[], true);\n      } else {\n        newData = buildShallowChartData(preData as ChartShallowDataShape[]);\n      }\n\n      const yDomain = getYDomain({ data: newData, scaled: false });\n\n      const yScale = getRadialYScale(innerRadius, outerRadius, yDomain);\n\n      const xScale = getXScale(newData);\n\n      return {\n        xScale,\n        yScale,\n        newData\n      };\n    },\n    [getXScale, series.props.type]\n  );\n\n  const renderChart = useCallback(\n    ({ chartWidth, chartHeight, id }: ChartContainerChildProps) => {\n      const outerRadius = Math.min(chartWidth, chartHeight) / 2;\n      const { yScale, xScale, newData } = getScales(\n        data,\n        innerRadius,\n        outerRadius\n      );\n\n      return (\n        <Fragment>\n          {axis && (\n            <CloneElement<RadialAxisProps>\n              element={axis}\n              xScale={xScale}\n              height={chartHeight}\n              width={chartWidth}\n              innerRadius={innerRadius}\n              startAngle={startAngle}\n              endAngle={endAngle}\n            />\n          )}\n          <CloneElement<RadialBarSeriesProps>\n            element={series}\n            id={id}\n            data={newData}\n            height={chartHeight}\n            width={chartWidth}\n            xScale={xScale}\n            yScale={yScale}\n            innerRadius={innerRadius}\n            outerRadius={outerRadius}\n            startAngle={startAngle}\n            endAngle={endAngle}\n          />\n        </Fragment>\n      );\n    },\n    [axis, data, endAngle, getScales, innerRadius, series, startAngle]\n  );\n\n  return (\n    <ChartContainer\n      id={id}\n      width={width}\n      height={height}\n      margins={margins}\n      xAxisVisible={false}\n      yAxisVisible={false}\n      center={true}\n      className={className}\n      containerClassName={containerClassName}\n    >\n      {renderChart}\n    </ChartContainer>\n  );\n};\n\nRadialBarChart.defaultProps = {\n  innerRadius: 10,\n  margins: 75,\n  axis: <RadialAxis />,\n  series: <RadialBarSeries />,\n  startAngle: 0,\n  endAngle: 2 * Math.PI\n};\n","import React, { FC, ReactElement, useMemo } from 'react';\nimport { arc } from 'd3-shape';\nimport { PieArc, ArcData } from '../../PieChart';\nimport { ChartShallowDataShape } from '../../common/data';\nimport { ChartTooltip, ChartTooltipProps } from '../../common/Tooltip';\nimport { Gradient, GradientProps } from '../../common/Gradient';\n\nexport interface RadialGaugeArcProps {\n  /**\n   * ID generated by the chart.\n   */\n  id?: string;\n\n  /**\n   * Data set by the `RadialGaugeSeries` components.\n   */\n  data?: ChartShallowDataShape;\n\n  /**\n   * Start angle set by the `RadialGaugeSeries` components.\n   */\n  startAngle: number;\n\n  /**\n   * End angle set by the `RadialGaugeSeries` components.\n   */\n  endAngle: number;\n\n  /**\n   * Inner radius set by the `RadialGaugeSeries` components.\n   */\n  innerRadius: number;\n\n  /**\n   * Outer radius set by the `RadialGaugeSeries` components.\n   */\n  outerRadius: number;\n\n  /**\n   * Color set by the `RadialGaugeSeries` components.\n   */\n  color: any;\n\n  /**\n   * Corner Radius of the arcs, see https://github.com/d3/d3-shape#arc_cornerRadius\n   */\n  cornerRadius?: number;\n\n  /**\n   * Pad Angle between adjacent arcs, see https://github.com/d3/d3-shape#arc_padAngle\n   */\n  padAngle?: number;\n\n  /**\n   * Pad Radius between adjacent arcs, see https://github.com/d3/d3-shape#arc_padRadius\n   */\n  padRadius?: number;\n\n  /**\n   * Animation set by the `RadialGaugeSeries` component.\n   */\n  animated: boolean;\n\n  /**\n   * Disable the interactions.\n   */\n  disabled: boolean;\n\n  /**\n   * Fill the arc.\n   */\n  fill?: string;\n\n  /**\n   * Gradient shades for the bar.\n   */\n  gradient: ReactElement<GradientProps, typeof Gradient> | null;\n\n  /**\n   * Tooltip component.\n   */\n  tooltip: ReactElement<ChartTooltipProps, typeof ChartTooltip> | null;\n\n  /**\n   * Event for when the arc is clicked.\n   */\n  onClick: (event) => void;\n\n  /**\n   * Event for when the arc has mouse enter.\n   */\n  onMouseEnter: (event) => void;\n\n  /**\n   * Event for when the arc has mouse leave.\n   */\n  onMouseLeave: (event) => void;\n}\n\nexport const RadialGaugeArc: FC<Partial<RadialGaugeArcProps>> = ({\n  data,\n  gradient,\n  startAngle,\n  id,\n  endAngle,\n  innerRadius,\n  outerRadius,\n  cornerRadius,\n  padAngle,\n  color,\n  animated,\n  disabled,\n  fill,\n  onClick,\n  onMouseEnter,\n  onMouseLeave,\n  tooltip\n}) => {\n  /**\n   * This function will generate the arcs\n   * https://github.com/d3/d3-shape#arcs\n   */\n  const arcGenerator = useMemo(() => {\n    return arc<ArcData>()\n      .innerRadius(innerRadius)\n      .outerRadius(outerRadius)\n      .cornerRadius(cornerRadius);\n  }, [innerRadius, outerRadius, cornerRadius]);\n\n  const arcElement = useMemo(() => {\n    const arcData: ArcData = {\n      // @ts-ignore Data must be passed\n      data: data || {},\n      startAngle,\n      endAngle,\n      padAngle\n    };\n\n    return (\n      <PieArc\n        id={id}\n        arc={arcGenerator}\n        data={arcData}\n        animated={animated}\n        color={color}\n        gradient={gradient}\n        disabled={disabled}\n        tooltip={tooltip}\n        onClick={onClick}\n        onMouseEnter={onMouseEnter}\n        onMouseLeave={onMouseLeave}\n      />\n    );\n  }, [\n    id,\n    arcGenerator,\n    startAngle,\n    endAngle,\n    padAngle,\n    data,\n    animated,\n    color,\n    gradient,\n    disabled,\n    tooltip,\n    onClick,\n    onMouseEnter,\n    onMouseLeave\n  ]);\n\n  return (\n    <g>\n      {fill && <circle fill={fill} r={outerRadius} />}\n      {arcElement}\n    </g>\n  );\n};\n\nRadialGaugeArc.defaultProps = {\n  cornerRadius: 0,\n  padAngle: 0,\n  padRadius: 0,\n  color: '#353d44',\n  animated: true,\n  disabled: false,\n  tooltip: <ChartTooltip />\n};\n","import React, { FC } from 'react';\nimport {\n  ChartShallowDataShape,\n  ChartInternalDataTypes\n} from '../../../common/data';\nimport { formatValue } from '../../../common/utils';\nimport classNames from 'classnames';\nimport css from './RadialGaugeLabel.module.css';\n\nexport interface RadialGaugeLabelProps {\n  /**\n   * Data set by the `RadialGaugeSeries` component.\n   */\n  data: ChartShallowDataShape;\n\n  /**\n   * Offset set by the `RadialGaugeSeries` component.\n   */\n  offset: number;\n\n  /**\n   * Classname to apply to the label.\n   */\n  className?: any;\n\n  /**\n   * Label click event.\n   */\n  onClick: (event: { data; nativeEvent }) => void;\n}\n\nexport const RadialGaugeLabel: FC<Partial<RadialGaugeLabelProps>> = ({\n  data,\n  className,\n  offset,\n  onClick = () => undefined\n}) => {\n  const label = formatValue(data.key as ChartInternalDataTypes);\n\n  return (\n    <text\n      x=\"0\"\n      y={offset}\n      textAnchor=\"middle\"\n      // This is only valid when placed below the chart\n      alignmentBaseline={'text-after-edge'}\n      onClick={(nativeEvent) => onClick({ data, nativeEvent })}\n      className={classNames(className, css.valueLabel)}\n    >\n      {label}\n    </text>\n  );\n};\n","import React, { FC } from 'react';\nimport { ChartShallowDataShape } from '../../../common/data';\nimport classNames from 'classnames';\nimport css from './RadialGaugeValueLabel.module.css';\nimport { useCount } from '../../../common/Count';\n\nexport interface RadialGaugeValueLabelProps {\n  /**\n   * Data set by the `RadialGaugeSeries` component.\n   */\n  data: ChartShallowDataShape;\n\n  /**\n   * Classname to apply to the value label.\n   */\n  className?: any;\n}\n\nexport const RadialGaugeValueLabel: FC<Partial<RadialGaugeValueLabelProps>> = ({\n  data,\n  className\n}) => {\n  const ref = useCount({\n    to: data.data as number\n  });\n\n  return (\n    <text\n      dy=\"-0.5em\"\n      x=\"0\"\n      y=\"15\"\n      textAnchor=\"middle\"\n      className={classNames(className, css.valueLabel)}\n      ref={ref}\n    />\n  );\n};\n","import React, { FC } from 'react';\nimport { RadialGaugeArc, RadialGaugeArcProps } from './RadialGaugeArc';\n\nexport const RadialGaugeOuterArc: FC<Partial<RadialGaugeArcProps>> = (\n  props\n) => <RadialGaugeArc {...props} />;\n\nRadialGaugeOuterArc.defaultProps = {\n  animated: false,\n  disabled: true\n};\n","import React, {\n  cloneElement,\n  FC,\n  Fragment,\n  ReactElement,\n  useCallback,\n  useMemo\n} from 'react';\nimport { range, min } from 'd3-array';\nimport { scaleBand } from 'd3-scale';\nimport { ChartDataShape, ChartShallowDataShape } from '../../common';\nimport { ColorSchemeType, getColor } from '../../common/color';\nimport { RadialGaugeArc, RadialGaugeArcProps } from './RadialGaugeArc';\nimport { RadialGaugeLabel, RadialGaugeLabelProps } from './RadialGaugeLabel';\nimport {\n  RadialGaugeValueLabel,\n  RadialGaugeValueLabelProps\n} from './RadialGaugeValueLabel';\nimport { RadialGaugeOuterArc } from './RadialGaugeOuterArc';\nimport { identifier } from 'safe-identifier';\n\nexport interface RadialGaugeSeriesProps {\n  /**\n   * Unique id for the series.\n   */\n  id?: string;\n\n  /**\n   * Data to render set by `RadialGauge` component.\n   */\n  data: ChartShallowDataShape[];\n\n  /**\n   * D3 scale function set by `RadialGauge` component.\n   */\n  scale: any;\n\n  /**\n   * Start angle set by `RadialGauge` component.\n   */\n  startAngle: number;\n\n  /**\n   * Start angle set by `RadialGauge` component.\n   */\n  endAngle: number;\n\n  /**\n   * The \"thickness\" of the arcs\n   */\n  arcWidth?: number;\n\n  /**\n   * Width set by `RadialGauge` component.\n   */\n  width: number;\n\n  /**\n   * Height set by `RadialGauge` component.\n   */\n  height: number;\n\n  /**\n   * Padding between each gauge.\n   */\n  padding: number;\n\n  /**\n   * Color scheme to apply.\n   */\n  colorScheme: ColorSchemeType;\n\n  /**\n   * Arc component.\n   */\n  innerArc: ReactElement<RadialGaugeArcProps, typeof RadialGaugeArc>;\n\n  /**\n   * Outer arc component. This is the 'fill' element.\n   */\n  outerArc: ReactElement<RadialGaugeArcProps, typeof RadialGaugeArc> | null;\n\n  /**\n   * Label component.\n   */\n  label: ReactElement<RadialGaugeLabelProps, typeof RadialGaugeLabel> | null;\n\n  /**\n   * Value label component.\n   */\n  valueLabel: ReactElement<\n    RadialGaugeValueLabelProps,\n    typeof RadialGaugeValueLabel\n  > | null;\n\n  /**\n   * Min width for a gauge. Only applicable in multi-series gauges.\n   */\n  minGaugeWidth: number;\n}\n\nexport const RadialGaugeSeries: FC<Partial<RadialGaugeSeriesProps>> = ({\n  data,\n  scale,\n  startAngle,\n  endAngle,\n  arcWidth,\n  outerArc,\n  innerArc,\n  label,\n  valueLabel,\n  colorScheme,\n  id,\n  padding,\n  minGaugeWidth,\n  ...props\n}) => {\n  const { columns, width, height, xScale, yScale } = useMemo(() => {\n    let rows = 1;\n    let columns = data.length;\n\n    if (props.width / data.length < minGaugeWidth) {\n      while (props.width / columns < minGaugeWidth) {\n        rows += 1;\n        columns = Math.ceil(data.length / rows);\n      }\n    }\n\n    const xScale: any = scaleBand();\n    xScale.domain(range(columns));\n    xScale.rangeRound([0, props.width], 0.1);\n\n    const yScale: any = scaleBand();\n    yScale.domain(range(rows));\n    yScale.rangeRound([0, props.height], 0.1);\n\n    return {\n      columns,\n      xScale,\n      yScale,\n      width: xScale.bandwidth(),\n      height: yScale.bandwidth()\n    };\n  }, [data.length, minGaugeWidth, props.height, props.width]);\n\n  const renderGauge = useCallback(\n    (point: ChartShallowDataShape, index: number) => {\n      const dataEndAngle = scale(point.data as number);\n\n      const outerRadius =\n        (min([width - padding * 2, height - padding * 2]) as number) / 2;\n\n      const innerRadius = outerRadius - arcWidth;\n\n      const labelOffset = height / 2;\n\n      const x = xScale(index % columns);\n      const y = yScale(Math.floor(index / columns));\n\n      const xOffset = x + width / 2;\n      const yOffset = y + height / 2;\n      const key = identifier(point.key?.toLocaleString());\n\n      return (\n        <g\n          key={key}\n          transform={`translate(${xOffset}, ${yOffset})`}\n        >\n          {outerArc &&\n            cloneElement(outerArc, {\n              id: `${id}-${key}-outer`,\n              outerRadius,\n              innerRadius,\n              startAngle,\n              endAngle\n            })}\n          {innerArc &&\n            cloneElement(innerArc, {\n              id: `${id}-${key}-inner`,\n              outerRadius,\n              innerRadius,\n              startAngle,\n              endAngle: dataEndAngle,\n              data: point,\n              color: getColor({\n                data,\n                colorScheme,\n                point,\n                index\n              })\n            })}\n          {valueLabel && cloneElement(valueLabel, { data: point })}\n          {label && cloneElement(label, { data: point, offset: labelOffset })}\n        </g>\n      );\n    },\n    [\n      id,\n      arcWidth,\n      colorScheme,\n      columns,\n      data,\n      endAngle,\n      height,\n      innerArc,\n      label,\n      outerArc,\n      padding,\n      scale,\n      startAngle,\n      valueLabel,\n      width,\n      xScale,\n      yScale\n    ]\n  );\n\n  return <Fragment>{data.map(renderGauge)}</Fragment>;\n};\n\nRadialGaugeSeries.defaultProps = {\n  arcWidth: 5,\n  outerArc: <RadialGaugeOuterArc />,\n  innerArc: <RadialGaugeArc />,\n  label: <RadialGaugeLabel />,\n  valueLabel: <RadialGaugeValueLabel />,\n  colorScheme: ['#00ECB1'],\n  padding: 20,\n  minGaugeWidth: 50\n};\n","import React, { FC, JSX, useMemo } from 'react';\nimport { arc } from 'd3-shape';\n\nimport {\n  ChartNestedDataShape,\n  ChartShallowDataShape,\n  ChartTooltip,\n  ColorSchemeType,\n  getColor\n} from '../../common';\nimport { ArcData, PieArc } from '../../PieChart';\nimport { RadialGaugeArcProps } from './RadialGaugeArc';\n\nexport type RadialGaugeStackedArcProps = Omit<\n  RadialGaugeArcProps,\n  'endAngle' | 'data' | 'color'\n> & {\n  /**\n   * Data set by the `StackedRadialGaugeSeries` components.\n   */\n  data: ChartNestedDataShape;\n\n  /**\n   * D3 scale function set by `RadialGauge` component.\n   */\n  scale: (x: number) => number;\n\n  /**\n   * Color scheme to apply set by 'StackedRadialGaugeSeries' component.\n   */\n  colorScheme: ColorSchemeType;\n};\n\nexport const RadialGaugeStackedArc: FC<Partial<RadialGaugeStackedArcProps>> = ({\n  id,\n  data,\n  scale,\n  innerRadius,\n  outerRadius,\n  cornerRadius,\n  padAngle,\n  startAngle,\n  colorScheme,\n  ...restProps\n}) => {\n  const arcGenerator = useMemo(() => {\n    return arc<ArcData>()\n      .innerRadius(innerRadius)\n      .outerRadius(outerRadius)\n      .cornerRadius(cornerRadius);\n  }, [innerRadius, outerRadius, cornerRadius]);\n\n  const stackedArcs = useMemo(() => {\n    let prevEndAngle = startAngle;\n\n    function renderArc(\n      point: ChartShallowDataShape,\n      index: number\n    ): JSX.Element {\n      const value = point.data as number;\n      const startArcAngle = prevEndAngle;\n      const endArcAngle = startArcAngle + scale(value) - startAngle;\n      prevEndAngle = endArcAngle;\n\n      const arcData: ArcData = {\n        data: point,\n        startAngle: startArcAngle,\n        endAngle: endArcAngle,\n        padAngle,\n        value,\n        index\n      };\n\n      const color = getColor({\n        colorScheme,\n        data: [data],\n        point: point,\n        index,\n        active: [data],\n        isMultiSeries: true\n      });\n\n      return (\n        <PieArc\n          {...restProps}\n          id={point.key.toLocaleString()}\n          key={point.key.toLocaleString()}\n          arc={arcGenerator}\n          data={arcData}\n          color={color}\n        />\n      );\n    }\n\n    return data.data.map(renderArc);\n  }, [arcGenerator, colorScheme, data, padAngle, restProps, scale, startAngle]);\n\n  return <g key={id}>{stackedArcs}</g>;\n};\n\nRadialGaugeStackedArc.defaultProps = {\n  cornerRadius: 0,\n  padAngle: 0,\n  padRadius: 0,\n  animated: true,\n  disabled: false,\n  tooltip: <ChartTooltip />\n};\n","import React, { FC } from 'react';\nimport classNames from 'classnames';\nimport css from './StackedRadialGaugeValueLabel.module.css';\n\nexport interface StackedRadialGaugeValueLabelProps {\n  /**\n   * A label shown at the center\n   */\n  label: string;\n\n  /**\n   * A class name to apply\n   */\n  className?: string;\n\n  /**\n   * A y offset to apply to the label\n   */\n  yOffset?: number;\n}\n\nexport const StackedRadialGaugeValueLabel: FC<\n  Partial<StackedRadialGaugeValueLabelProps>\n> = ({ label, className, yOffset }) => (\n  <>\n    {label && (\n      <text\n        x=\"0\"\n        y={yOffset}\n        textAnchor=\"middle\"\n        alignmentBaseline=\"middle\"\n        className={classNames(className, css.stackedValueLabel)}\n      >\n        {label}\n      </text>\n    )}\n  </>\n);\n\nStackedRadialGaugeValueLabel.defaultProps = {\n  yOffset: 0\n};\n","import React, { cloneElement, FC, ReactElement, useCallback } from 'react';\nimport { range } from 'd3-array';\nimport { scaleBand } from 'd3-scale';\nimport {\n  ChartDataShape,\n  ChartNestedDataShape,\n  ChartShallowDataShape\n} from '../../common/data';\nimport { ColorSchemeType, getColor } from '../../common/color';\nimport { RadialGaugeArc, RadialGaugeArcProps } from './RadialGaugeArc';\nimport {\n  RadialGaugeStackedArc,\n  RadialGaugeStackedArcProps\n} from './RadialGaugeStackedArc';\nimport {\n  StackedRadialGaugeValueLabel,\n  StackedRadialGaugeValueLabelProps\n} from './StackedRadialGaugeValueLabel';\nimport {\n  StackedRadialGaugeDescriptionLabel,\n  StackedRadialGaugeDescriptionLabelProps\n} from './StackedRadialGaugeDescriptionLabel';\n\nexport interface StackedRadialGaugeSeriesProps {\n  /**\n   * Data to render set by `RadialGauge` component.\n   */\n  data: ChartDataShape[];\n\n  /**\n   * D3 scale function set by `RadialGauge` component.\n   */\n  scale: any;\n\n  /**\n   * Start angle set by `RadialGauge` component.\n   */\n  startAngle: number;\n\n  /**\n   * Start angle set by `RadialGauge` component.\n   */\n  endAngle: number;\n\n  /**\n   * Width set by `RadialGauge` component.\n   */\n  width: number;\n\n  /**\n   * Height set by `RadialGauge` component.\n   */\n  height: number;\n\n  /**\n   * Color scheme to apply.\n   */\n  colorScheme: ColorSchemeType;\n\n  /**\n   * Arc component.\n   */\n  innerArc: ReactElement<RadialGaugeArcProps, typeof RadialGaugeArc>;\n\n  /**\n   * Stacked Arc component.\n   */\n  stackedInnerArc: ReactElement<\n    RadialGaugeStackedArcProps,\n    typeof RadialGaugeStackedArc\n  >;\n\n  /**\n   * Outer arc component. This is the 'fill' element.\n   */\n  outerArc: ReactElement<RadialGaugeArcProps, typeof RadialGaugeArc> | null;\n\n  /**\n   * Label component.\n   */\n  label: ReactElement<\n    StackedRadialGaugeValueLabelProps,\n    typeof StackedRadialGaugeValueLabel\n  > | null;\n\n  /**\n   * Description label component.\n   */\n  descriptionLabel: ReactElement<\n    StackedRadialGaugeDescriptionLabelProps,\n    typeof StackedRadialGaugeDescriptionLabel\n  > | null;\n\n  /**\n   * A factor from 0 to 1 determining how much of the Gauge should be filled with arcs\n   */\n  fillFactor: number;\n\n  /**\n   * Padding between the stacked arcs, following d3 bandwidth innerPadding\n   */\n  arcPadding: number;\n}\n\nconst isChartNestedData = (\n  point: ChartDataShape\n): point is ChartNestedDataShape => {\n  return Array.isArray(point.data);\n};\n\nexport const StackedRadialGaugeSeries: FC<\n  Partial<StackedRadialGaugeSeriesProps>\n> = ({\n  data,\n  width,\n  height,\n  scale,\n  startAngle,\n  endAngle,\n  outerArc,\n  innerArc,\n  stackedInnerArc,\n  label,\n  descriptionLabel,\n  colorScheme,\n  fillFactor,\n  arcPadding\n}) => {\n  const radius = Math.min(width, height) / 2;\n  const innerRadius = radius * (1 - Math.min(fillFactor, 1));\n\n  const rAxis = scaleBand()\n    .domain(range(data.length))\n    .range([innerRadius, radius])\n    .paddingInner(arcPadding);\n\n  const renderOuterArc = useCallback(\n    (outerRadius: number, innerRadius: number) => {\n      return (\n        outerArc &&\n        cloneElement(outerArc, {\n          outerRadius,\n          innerRadius,\n          startAngle,\n          endAngle\n        })\n      );\n    },\n    [outerArc, startAngle, endAngle]\n  );\n\n  const renderInnerArc = useCallback(\n    (\n      outerRadius: number,\n      innerRadius: number,\n      dataEndAngle: number,\n      point: ChartShallowDataShape,\n      index: number\n    ) => {\n      const color = getColor({ data, colorScheme, point, index });\n\n      return (\n        innerArc &&\n        cloneElement(innerArc, {\n          outerRadius,\n          innerRadius,\n          startAngle,\n          endAngle: dataEndAngle,\n          data: point,\n          color\n        })\n      );\n    },\n    [innerArc, startAngle, data, colorScheme]\n  );\n\n  const renderStackedArc = useCallback(\n    (outerRadius: number, innerRadius: number, point: ChartNestedDataShape, index: number) => {\n      return (\n        <>\n          {stackedInnerArc &&\n            cloneElement(stackedInnerArc, {\n              outerRadius,\n              innerRadius,\n              colorScheme,\n              startAngle,\n              scale: scale?.[index] ?? scale?.[index] ?? scale,\n              data: point\n            })}\n        </>\n      );\n    },\n    [stackedInnerArc, colorScheme, startAngle, scale]\n  );\n\n  const renderStackedGauges = useCallback(\n    (point: ChartDataShape, index: number) => {\n      const outerRadius = rAxis(index as any);\n      const innerRadius = outerRadius - rAxis.bandwidth();\n\n      return (\n        <g key={point.key.toLocaleString()}>\n          {renderOuterArc(outerRadius, innerRadius)}\n          {isChartNestedData(point)\n            ? renderStackedArc(outerRadius, innerRadius, point, index)\n            : renderInnerArc(\n              outerRadius,\n              innerRadius,\n              scale?.[index]?.(point.data) ?? scale?.[0]?.(point.data) ?? scale(point.data),\n              point,\n              index\n            )}\n        </g>\n      );\n    },\n    [rAxis, renderOuterArc, renderStackedArc, renderInnerArc, scale]\n  );\n\n  return (\n    <>\n      <g transform={`translate(${width / 2}, ${height / 2})`}>\n        {data.map(renderStackedGauges)}\n        {descriptionLabel}\n        {label}\n      </g>\n    </>\n  );\n};\n\nStackedRadialGaugeSeries.defaultProps = {\n  outerArc: <RadialGaugeArc disabled={true} animated={false} />,\n  innerArc: <RadialGaugeArc animated={true} />,\n  stackedInnerArc: <RadialGaugeStackedArc animated={true} />,\n  label: <StackedRadialGaugeValueLabel />,\n  colorScheme: ['#00ECB1'],\n  fillFactor: 0.2,\n  arcPadding: 0.15\n};\n","import React, { FC } from 'react';\nimport classNames from 'classnames';\nimport css from './StackedRadialGaugeDescriptionLabel.module.css';\n\nexport interface StackedRadialGaugeDescriptionLabelProps {\n  /**\n   * A label shown at the center\n   */\n  label: string;\n\n  /**\n   * A class name to apply\n   */\n  className?: string;\n\n  /**\n   * A y offset to apply to the label\n   */\n  yOffset?: number;\n}\n\nexport const StackedRadialGaugeDescriptionLabel: FC<\n  Partial<StackedRadialGaugeDescriptionLabelProps>\n> = ({ label, className, yOffset }) => (\n  <>\n    {label && (\n      <text\n        x=\"0\"\n        y={yOffset - 20}\n        textAnchor=\"middle\"\n        alignmentBaseline=\"middle\"\n        className={classNames(className, css.stackedDescriptionLabel)}\n      >\n        {label}\n      </text>\n    )}\n  </>\n);\n\nStackedRadialGaugeDescriptionLabel.defaultProps = {\n  yOffset: 0\n};\n","import React, { cloneElement, FC, ReactElement, useCallback } from 'react';\nimport { scaleLinear } from 'd3-scale';\nimport {\n  ChartContainer,\n  ChartContextProps,\n  ChartProps\n} from '../common/containers';\nimport { ChartDataShape } from '../common/data';\nimport {\n  RadialGaugeSeries,\n  RadialGaugeSeriesProps,\n  StackedRadialGaugeSeries,\n  StackedRadialGaugeSeriesProps\n} from './RadialGaugeSeries';\nimport { useId } from 'reablocks';\n\nexport interface RadialGaugeProps extends ChartProps {\n  /**\n   * Data the chart will receive to render.\n   */\n  data: ChartDataShape[];\n\n  /**\n   * Min value to scale on.\n   */\n  minValue?: number | number[];\n\n  /**\n   * Max value to scale on.\n   */\n  maxValue?: number | number[];\n\n  /**\n   * Start angle for the first value.\n   */\n  startAngle?: number;\n\n  /**\n   * End angle for the last value.\n   */\n  endAngle?: number;\n\n  /**\n   * Gauge series component to render.\n   */\n  series?: ReactElement<\n    RadialGaugeSeriesProps | StackedRadialGaugeSeriesProps,\n    typeof RadialGaugeSeries | typeof StackedRadialGaugeSeries\n  >;\n}\n\nexport const RadialGauge: FC<RadialGaugeProps> = ({\n  id,\n  width,\n  height,\n  margins,\n  className,\n  data,\n  minValue,\n  maxValue,\n  startAngle,\n  endAngle,\n  series,\n  containerClassName\n}) => {\n  const newId = useId(id);\n\n  const renderSeries = useCallback(\n    ({ chartHeight, chartWidth }: ChartContextProps) => {\n      let scale;\n\n      if (Array.isArray(maxValue)) {\n        scale = maxValue.map((max, index) =>\n          scaleLinear()\n            .domain([minValue?.[index] ?? minValue?.[0] ?? minValue, max])\n            .range([startAngle, endAngle])\n        );\n      } else if (Array.isArray(minValue)) {\n        scale = minValue.map((min, index) =>\n          scaleLinear()\n            .domain([min, maxValue?.[index] ?? maxValue?.[0] ?? maxValue])\n            .range([startAngle, endAngle])\n        );\n      } else {\n        scale = scaleLinear()\n          .domain([minValue, maxValue])\n          .range([startAngle, endAngle]);\n      }\n\n      return cloneElement(series, {\n        id: newId,\n        scale,\n        data,\n        startAngle,\n        endAngle,\n        width: chartWidth,\n        height: chartHeight\n      });\n    },\n    [data, endAngle, maxValue, minValue, series, startAngle, newId]\n  );\n\n  return (\n    <ChartContainer\n      id={id}\n      width={width}\n      height={height}\n      margins={margins}\n      xAxisVisible={false}\n      yAxisVisible={false}\n      className={className}\n      containerClassName={containerClassName}\n    >\n      {renderSeries}\n    </ChartContainer>\n  );\n};\n\nRadialGauge.defaultProps = {\n  minValue: 0,\n  maxValue: 100,\n  startAngle: 0,\n  endAngle: Math.PI * 2,\n  series: <RadialGaugeSeries />\n};\n","import React, {\n  FC,\n  Fragment,\n  MouseEvent,\n  ReactElement,\n  useMemo,\n  useState,\n  useRef,\n  ReactNode\n} from 'react';\nimport { ChartTooltip, ChartTooltipProps } from '../../common/Tooltip';\nimport { CloneElement } from 'reablocks';\nimport {\n  constructFunctionProps,\n  PropFunctionTypes\n} from '../../common/utils/functions';\nimport chroma from 'chroma-js';\nimport classNames from 'classnames';\nimport { motion } from 'framer-motion';\nimport { DEFAULT_TRANSITION } from '../../common/Motion';\nimport { ChartInternalShallowDataShape } from '../../common/data';\nimport css from './HeatmapCell.module.css';\nimport { useHoverIntent } from '../../common/utils/useHoverIntent';\nimport { getAriaLabel } from '../../common';\n\nexport type HeatmapCellProps = {\n  /**\n   * X Position set by `HeatmapSeries`.\n   */\n  x: number;\n\n  /**\n   * Y Position set by `HeatmapSeries`.\n   */\n  y: number;\n\n  /**\n   * rx SVG Attribute.\n   */\n  rx: number;\n\n  /**\n   * ry SVG Attribute.\n   */\n  ry: number;\n\n  /**\n   * Height of cell set by `HeatmapSeries`.\n   */\n  height: number;\n\n  /**\n   * Width of cell set by `HeatmapSeries`.\n   */\n  width: number;\n\n  /**\n   * Total count of cells set by `HeatmapSeries`.\n   */\n  cellCount: number;\n\n  /**\n   * Tooltip component.\n   */\n  tooltip: ReactElement<ChartTooltipProps, typeof ChartTooltip> | null;\n\n  /**\n   * Fill color set by `HeatmapSeries`.\n   */\n  fill: string;\n\n  /**\n   * Stroke color set by `HeatmapSeries`.\n   */\n  stroke: string;\n\n  /**\n   * Symbol element to render.\n   */\n  symbol?: (data: ChartInternalShallowDataShape) => ReactNode;\n\n  /**\n   * Data object set by `Heatmap`.\n   */\n  data: ChartInternalShallowDataShape;\n\n  /**\n   * Whether cell is animated or not set by `HeatmapSeries`.\n   */\n  animated: boolean;\n\n  /**\n   * Cell index set by `HeatmapSeries`.\n   */\n  cellIndex: number;\n\n  /**\n   * Cursor style attribute.\n   */\n  cursor: string;\n\n  /**\n   * Event for when the bar is clicked.\n   */\n  onClick: (event) => void;\n\n  /**\n   * Event for when the bar has mouse enter.\n   */\n  onMouseEnter: (event) => void;\n\n  /**\n   * Event for when the bar has mouse leave.\n   */\n  onMouseLeave: (event) => void;\n} & PropFunctionTypes;\n\ninterface HeatmapCellState {\n  active?: boolean;\n}\n\n// Set padding modifier for the tooltips\nconst modifiers = {\n  offset: {\n    offset: '0, 3px'\n  }\n};\n\nexport const HeatmapCell: FC<Partial<HeatmapCellProps>> = ({\n  rx,\n  ry,\n  cursor,\n  tooltip,\n  onClick,\n  onMouseEnter,\n  onMouseLeave,\n  data,\n  animated,\n  cellIndex,\n  cellCount,\n  fill,\n  stroke,\n  symbol,\n  x,\n  y,\n  style,\n  className,\n  ...rest\n}) => {\n  const [active, setActive] = useState(false);\n  const rect = useRef<SVGRectElement | null>(null);\n\n  const { pointerOut, pointerOver } = useHoverIntent({\n    onPointerOver: (event) => {\n      setActive(true);\n      onMouseEnter({\n        value: data,\n        nativeEvent: event\n      });\n    },\n    onPointerOut: (event) => {\n      setActive(false);\n      onMouseLeave({\n        value: data,\n        nativeEvent: event\n      });\n    }\n  });\n\n  const onMouseClick = (event: MouseEvent) => {\n    onClick({\n      value: data,\n      nativeEvent: event\n    });\n  };\n\n  const tooltipData = useMemo(\n    () => ({\n      y: data.value,\n      x: `${data.key} ∙ ${data.x}`,\n      data\n    }),\n    [data]\n  );\n\n  const transition = useMemo(() => {\n    if (animated) {\n      return {\n        ...DEFAULT_TRANSITION,\n        delay: (cellIndex / cellCount) * 0.005\n      };\n    } else {\n      return {\n        type: false,\n        delay: 0\n      };\n    }\n  }, [animated, cellIndex, cellCount]);\n\n  const extras = constructFunctionProps({ style, className }, data);\n  const isTransparent = fill === 'transparent';\n  const appliedStroke =\n    active && !isTransparent\n      ? chroma(stroke || fill).brighten(1)\n      : stroke || fill;\n\n  const ariaLabelData = useMemo(\n    () => getAriaLabel({ ...tooltipData, data: null }),\n    [tooltipData]\n  );\n\n  const renderedSymbol = useMemo(\n    () => (symbol ? symbol(data!) : null),\n    [data, symbol]\n  );\n\n  return (\n    <Fragment>\n      <g ref={rect}>\n        {renderedSymbol ? (\n          <motion.g\n            {...rest}\n            fill={fill}\n            stroke={appliedStroke}\n            style={{ ...extras.style, cursor }}\n            className={extras?.className}\n            transform={`translate(${x}, ${y})`}\n            initial={{\n              opacity: 0\n            }}\n            animate={{\n              opacity: 1\n            }}\n            exit={{\n              opacity: 0\n            }}\n            transition={transition}\n            onPointerOver={pointerOver}\n            onPointerOut={pointerOut}\n            onClick={onMouseClick}\n            tabIndex={0}\n            aria-label={ariaLabelData}\n            role=\"graphics-document\"\n          >\n            {renderedSymbol}\n          </motion.g>\n        ) : (\n          <motion.rect\n            {...rest}\n            fill={fill}\n            stroke={appliedStroke}\n            x={x}\n            y={y}\n            rx={rx}\n            ry={ry}\n            style={{ ...extras.style, cursor }}\n            className={classNames(css.cell, extras.className)}\n            initial={{\n              opacity: 0\n            }}\n            animate={{\n              opacity: 1\n            }}\n            exit={{\n              opacity: 0\n            }}\n            transition={transition}\n            onPointerOver={pointerOver}\n            onPointerOut={pointerOut}\n            onClick={onMouseClick}\n            tabIndex={0}\n            aria-label={ariaLabelData}\n            role=\"graphics-document\"\n          />\n        )}\n      </g>\n      {tooltip && !(tooltip.props as any).disabled && !isTransparent && (\n        <CloneElement<ChartTooltipProps>\n          element={tooltip}\n          visible={active}\n          modifiers={(tooltip.props as any).modifiers || modifiers}\n          reference={rect}\n          value={tooltipData}\n        />\n      )}\n    </Fragment>\n  );\n};\n\nHeatmapCell.defaultProps = {\n  rx: 2,\n  ry: 2,\n  cursor: 'auto',\n  tooltip: <ChartTooltip />,\n  onClick: () => undefined,\n  onMouseEnter: () => undefined,\n  onMouseLeave: () => undefined\n};\n","import React, { FC, ReactElement, Fragment } from 'react';\nimport { HeatmapCell, HeatmapCellProps } from './HeatmapCell';\nimport { CloneElement } from 'reablocks';\nimport { ColorSchemeType } from '../../common/color';\nimport { ChartInternalNestedDataShape } from '../../common/data';\nimport {\n  ColorSchemeStyleArray,\n  createColorSchemeValueScales,\n  getColorSchemeStyles\n} from '../../common/color/helper';\n\nexport interface HeatmapSeriesProps {\n  /**\n   * Padding between cells.\n   */\n  padding: number;\n\n  /**\n   * Id set by `Heatmap`.\n   */\n  id: string;\n\n  /**\n   * Parsed data set by `Heatmap`.\n   */\n  data: ChartInternalNestedDataShape[];\n\n  /**\n   * D3 scale for X Axis. Set internally by `Heatmap`.\n   */\n  xScale: any;\n\n  /**\n   * D3 scale for Y Axis. Set internally by `Heatmap`.\n   */\n  yScale: any;\n\n  /**\n   * Color scheme for the chart.\n   */\n  colorScheme: ColorSchemeType | ColorSchemeStyleArray;\n\n  /**\n   * Color for the empty cell of the chart.\n   */\n  emptyColor: string;\n\n  /**\n   * Whether the chart is animated or not.\n   */\n  animated: boolean;\n\n  /**\n   * Cell component that will be rendered.\n   */\n  cell: ReactElement<HeatmapCellProps, typeof HeatmapCell>;\n\n  /**\n   * Selected cell(s) in active state\n   */\n  selections?: any;\n}\n\nexport const HeatmapSeries: FC<Partial<HeatmapSeriesProps>> = ({\n  animated,\n  emptyColor,\n  colorScheme,\n  cell: cellElement,\n  xScale,\n  yScale,\n  data,\n  id,\n  selections\n}) => {\n  const valueScales = createColorSchemeValueScales(\n    data,\n    colorScheme,\n    emptyColor,\n    selections\n  );\n  const height = yScale.bandwidth();\n  const width = xScale.bandwidth();\n  const cellCount = [...yScale.domain(), ...xScale.domain()].length;\n\n  const renderCell = ({\n    row,\n    cell,\n    rowIndex,\n    cellIndex,\n    width,\n    height,\n    cellCount\n  }) => {\n    const x = xScale(row.key);\n    const y = yScale(cell.x);\n    const style = getColorSchemeStyles(cell, valueScales);\n\n    return (\n      <CloneElement<HeatmapCellProps>\n        key={`${id}-${rowIndex}-${cellIndex}`}\n        element={cellElement}\n        animated={animated}\n        cellIndex={rowIndex + cellIndex}\n        cellCount={cellCount}\n        x={x}\n        y={y}\n        fill={style?.fill}\n        stroke={style?.stroke}\n        width={width}\n        height={height}\n        data={cell}\n        style={style}\n      />\n    );\n  };\n\n  return (\n    <Fragment>\n      {data.map((row, rowIndex) =>\n        row.data.map((cell, cellIndex) =>\n          renderCell({\n            height,\n            width,\n            cellCount,\n            row,\n            cell,\n            rowIndex,\n            cellIndex\n          })\n        )\n      )}\n    </Fragment>\n  );\n};\n\nHeatmapSeries.defaultProps = {\n  padding: 0.1,\n  animated: true,\n  emptyColor: 'rgba(200,200,200,0.08)',\n  colorScheme: ['rgba(28, 107, 86, 0.5)', '#2da283'],\n  cell: <HeatmapCell />\n};\n","import React, { useCallback, Fragment, ReactElement, FC } from 'react';\nimport {\n  ChartProps,\n  ChartContainer,\n  ChartContainerChildProps\n} from '../common/containers/ChartContainer';\nimport { ChartNestedDataShape, buildNestedChartData } from '../common/data';\nimport { CloneElement } from 'reablocks';\nimport {\n  isAxisVisible,\n  LinearAxisProps,\n  LinearXAxis,\n  LinearYAxis,\n  LinearYAxisTickSeries,\n  LinearXAxisTickSeries,\n  LinearYAxisTickLabel,\n  LinearXAxisTickLabel,\n  LinearAxis\n} from '../common/Axis';\nimport { HeatmapSeries, HeatmapSeriesProps } from './HeatmapSeries';\nimport { scaleBand } from 'd3-scale';\nimport { uniqueBy } from '../common/utils/array';\n\nexport interface HeatmapProps extends ChartProps {\n  /**\n   * Data the chart will receive to render.\n   */\n  data: ChartNestedDataShape[];\n\n  /**\n   * The series component that renders the cell components.\n   */\n  series: ReactElement<HeatmapSeriesProps, typeof HeatmapSeries>;\n\n  /**\n   * The linear axis component for the Y Axis of the chart.\n   */\n  yAxis: ReactElement<LinearAxisProps, typeof LinearAxis>;\n\n  /**\n   * The linear axis component for the X Axis of the chart.\n   */\n  xAxis: ReactElement<LinearAxisProps, typeof LinearAxis>;\n\n  /**\n   * Any secondary axis components. Useful for multi-axis charts.\n   */\n  secondaryAxis?: ReactElement<LinearAxisProps, typeof LinearAxis>[];\n}\n\nexport const Heatmap: FC<Partial<HeatmapProps>> = ({\n  data,\n  margins,\n  series,\n  yAxis,\n  xAxis,\n  secondaryAxis,\n  id,\n  width,\n  height,\n  className,\n  containerClassName\n}) => {\n  const getScalesData = useCallback(\n    (chartHeight: number, chartWidth: number) => {\n      const nestedData = buildNestedChartData(data);\n\n      const xDomain: any =\n        xAxis.props.domain || uniqueBy(nestedData, (d) => d.key);\n\n      const xScale = scaleBand()\n        .range([0, chartWidth])\n        .domain(xDomain)\n        .paddingInner(series.props.padding || 0.1);\n\n      const yDomain: any =\n        yAxis.props.domain ||\n        uniqueBy(\n          nestedData,\n          (d) => d.data,\n          (d) => d.x\n        );\n\n      const yScale = scaleBand()\n        .domain(yDomain)\n        .range([chartHeight, 0])\n        .paddingInner(series.props.padding || 0.1);\n\n      return {\n        yScale,\n        xScale,\n        data: nestedData\n      };\n    },\n    [data, xAxis, yAxis, series]\n  );\n\n  const renderChart = useCallback(\n    (containerProps: ChartContainerChildProps) => {\n      const { chartWidth, chartHeight, updateAxes, id, chartSized } =\n        containerProps;\n      const {\n        xScale,\n        yScale,\n        data: scalesData\n      } = getScalesData(chartHeight, chartWidth);\n\n      return (\n        <Fragment>\n          <CloneElement<LinearAxisProps>\n            element={xAxis}\n            height={chartHeight}\n            width={chartWidth}\n            scale={xScale}\n            visibility={chartSized ? 'visible' : 'hidden'}\n            onDimensionsChange={(event) => updateAxes('horizontal', event)}\n          />\n          <CloneElement<LinearAxisProps>\n            element={yAxis}\n            height={chartHeight}\n            width={chartWidth}\n            scale={yScale}\n            visibility={chartSized ? 'visible' : 'hidden'}\n            onDimensionsChange={(event) => updateAxes('vertical', event)}\n          />\n          {secondaryAxis &&\n            secondaryAxis.map((axis, i) => (\n              <CloneElement<LinearAxisProps>\n                key={i}\n                element={axis}\n                height={chartHeight}\n                width={chartWidth}\n                visibility={chartSized ? 'visible' : 'hidden'}\n                onDimensionsChange={(event) => updateAxes('horizontal', event)}\n              />\n            ))}\n          {chartSized && (\n            <CloneElement<HeatmapSeriesProps>\n              element={series}\n              id={`heat-series-${id}`}\n              data={scalesData}\n              xScale={xScale}\n              yScale={yScale}\n            />\n          )}\n        </Fragment>\n      );\n    },\n    [getScalesData, secondaryAxis, series, xAxis, yAxis]\n  );\n\n  return (\n    <ChartContainer\n      id={id}\n      width={width}\n      height={height}\n      margins={margins}\n      containerClassName={containerClassName}\n      xAxisVisible={isAxisVisible(xAxis.props)}\n      yAxisVisible={isAxisVisible(yAxis.props)}\n      className={className}\n    >\n      {renderChart}\n    </ChartContainer>\n  );\n};\n\nHeatmap.defaultProps = {\n  data: [],\n  margins: 10,\n  series: <HeatmapSeries padding={0.3} />,\n  yAxis: (\n    <LinearYAxis\n      type=\"category\"\n      axisLine={null}\n      tickSeries={\n        <LinearYAxisTickSeries\n          line={null}\n          label={<LinearYAxisTickLabel padding={5} />}\n        />\n      }\n    />\n  ),\n  xAxis: (\n    <LinearXAxis\n      type=\"category\"\n      axisLine={null}\n      tickSeries={\n        <LinearXAxisTickSeries\n          line={null}\n          label={<LinearXAxisTickLabel padding={5} />}\n        />\n      }\n    />\n  )\n};\n","import { range, min } from 'd3-array';\nimport { ChartShallowDataShape } from '../common/data';\n\nexport type CalendarView = 'year' | 'month';\n\nconst getFirstOfMonth = (date: Date) =>\n  new Date(date.getFullYear(), date.getMonth(), 1);\n\nexport const addWeeksToDate = (date: Date, weeks: number) => {\n  const d = new Date(date.getTime());\n  d.setDate(d.getDate() + weeks * 7);\n  return d;\n};\n\nconst getStartOfDay = (date: Date) => {\n  const d = new Date(date.getTime());\n  d.setHours(0, 0, 0, 0);\n  return d;\n};\n\nconst getNewDayFromDay = (date: Date, num: number) => {\n  const d = new Date(date.getTime());\n  d.setDate(d.getDate() + num);\n  return d;\n};\n\nexport const weekDays: string[] = (() => {\n  const base = new Date(Date.UTC(2017, 0, 2));\n  return range(7).map(() => {\n    const name = base.toLocaleDateString('default', { weekday: 'short' });\n    base.setDate(base.getDate() + 1);\n    return name;\n  });\n})();\n\nexport const buildDataScales = (\n  rawData: ChartShallowDataShape[],\n  view: CalendarView\n) => {\n  // Get the most recent date to get the range from\n  // From the end date, lets find the start year/month of that\n  // From that start year/month, lets find the end year/month for our bounds\n  const startDate = min(rawData, (d) => d.key) || new Date();\n  const start = getFirstOfMonth(startDate);\n  const endDomain = view === 'year' ? 53 : 5;\n  const end = addWeeksToDate(start, endDomain);\n\n  // Base on the view type, swap out some ranges\n  const xDomainRange = view === 'year' ? 53 : 5;\n\n  // Build our x/y domains for days of week + number of weeks in year\n  const yDomain = range(7).reverse();\n  const xDomain = range(xDomainRange);\n\n  // Filter out dates that are not in the start/end ranges\n  // and turn them into something our chart can read\n  const dates = rawData\n    .filter(\n      (d) =>\n        (d.key as Date).getTime() > start.getTime() ||\n        (d.key as Date).getTime() < end.getTime()\n    )\n    .map((d) => ({\n      key: getStartOfDay(d.key as Date),\n      data: d.data\n    }));\n\n  // Find the first day of the duration and subtract the delta\n  const firstDayOfStart = start.getDay();\n  const curDate = getNewDayFromDay(start, -firstDayOfStart);\n  const rows: any[] = [];\n\n  // Build out the dataset for the n duration\n  for (let week = 0; week < xDomainRange; week++) {\n    const row = {\n      key: week,\n      data: [] as any\n    };\n\n    for (let day = 0; day <= 6; day++) {\n      const dayValue = dates.find((d) => d.key.getTime() === curDate.getTime());\n\n      row.data.push({\n        key: day,\n        data: dayValue?.data ?? undefined,\n        metadata: {\n          date: new Date(curDate.getTime()),\n          start: start,\n          end: end\n        }\n      });\n\n      curDate.setDate(curDate.getDate() + 1);\n    }\n\n    rows.push(row);\n  }\n\n  return {\n    data: rows,\n    yDomain,\n    xDomain,\n    start\n  };\n};\n","import React, { FC, useMemo } from 'react';\nimport { ChartShallowDataShape } from '../common/data';\nimport { Heatmap, HeatmapProps } from './Heatmap';\nimport {\n  LinearXAxis,\n  LinearYAxis,\n  LinearYAxisTickSeries,\n  LinearXAxisTickSeries,\n  LinearYAxisTickLabel,\n  LinearXAxisTickLabel\n} from '../common/Axis';\nimport { HeatmapSeries, HeatmapCell } from './HeatmapSeries';\nimport { ChartTooltip } from '../common/Tooltip';\nimport { formatValue } from '../common/utils/formatting';\nimport {\n  buildDataScales,\n  CalendarView,\n  addWeeksToDate,\n  weekDays\n} from './calendarUtils';\n\nexport interface CalendarHeatmapProps extends Omit<HeatmapProps, 'data'> {\n  /**\n   * Chart data shape.\n   */\n  data: ChartShallowDataShape[];\n\n  /**\n   * Height of the component.\n   */\n  height: number;\n\n  /**\n   * Width of the component.\n   */\n  width: number;\n\n  /**\n   * View of the calendar renderer.\n   */\n  view: CalendarView;\n}\n\n// Format the xAxis label for the start + n week\nconst xAxisLabelFormat = (start: Date) => (weeks: number) =>\n  addWeeksToDate(start, weeks).toLocaleString('default', { month: 'long' });\n\nexport const CalendarHeatmap: FC<Partial<CalendarHeatmapProps>> = ({\n  view,\n  data,\n  ...rest\n}) => {\n  const {\n    data: domainData,\n    yDomain,\n    xDomain,\n    start\n  } = useMemo(() => buildDataScales(data, view), [data, view]);\n\n  // For month, only pass 1 tick value\n  const xTickValues = view === 'year' ? undefined : [1];\n\n  // Get the yAxis label formatting based on view type\n  const yAxisLabelFormat = view === 'year' ? (d) => weekDays[d] : () => null;\n\n  return (\n    <Heatmap\n      {...rest}\n      data={domainData}\n      yAxis={\n        <LinearYAxis\n          type=\"category\"\n          axisLine={null}\n          domain={yDomain}\n          tickSeries={\n            <LinearYAxisTickSeries\n              tickSize={20}\n              line={null}\n              label={\n                <LinearYAxisTickLabel padding={5} format={yAxisLabelFormat} />\n              }\n            />\n          }\n        />\n      }\n      xAxis={\n        <LinearXAxis\n          type=\"category\"\n          axisLine={null}\n          domain={xDomain}\n          tickSeries={\n            <LinearXAxisTickSeries\n              line={null}\n              tickValues={xTickValues}\n              label={\n                <LinearXAxisTickLabel\n                  padding={5}\n                  align=\"end\"\n                  format={xAxisLabelFormat(start)}\n                />\n              }\n            />\n          }\n        />\n      }\n    />\n  );\n};\n\nCalendarHeatmap.defaultProps = {\n  view: 'year',\n  series: (\n    <HeatmapSeries\n      padding={0.3}\n      emptyColor=\"transparent\"\n      cell={\n        <HeatmapCell\n          tooltip={\n            <ChartTooltip\n              content={(d) =>\n                `${formatValue(d.data.metadata.date)} ∙ ${formatValue(\n                  d.data.value\n                )}`\n              }\n            />\n          }\n        />\n      }\n    />\n  )\n};\n","import React, { FC } from 'react';\nimport { Bar, BarProps } from '../BarChart';\nimport { ChartTooltip, TooltipTemplate } from '../common/Tooltip';\n\nexport type LinearGaugeBarProps = BarProps;\n\nexport const LinearGaugeBar: FC<Partial<LinearGaugeBarProps>> = (props) => (\n  <Bar {...props} />\n);\n\nLinearGaugeBar.defaultProps = {\n  tooltip: (\n    <ChartTooltip\n      placement=\"top\"\n      content={(data) => (\n        <TooltipTemplate value={{ y: data.value, x: data.y }} />\n      )}\n    />\n  )\n};\n","import React, { FC } from 'react';\n\nexport interface LinearGaugeOuterBarProps extends SVGRect {\n  /**\n   * Height of the chart. Set by `LinearGauge` component.\n   */\n  height: number;\n\n  /**\n   * Width of the chart. Set by `LinearGauge` component.\n   */\n  width: number;\n\n  /**\n   * Fill for the bar element.\n   */\n  fill: string;\n}\n\nexport const LinearGaugeOuterBar: FC<Partial<LinearGaugeOuterBarProps>> = ({\n  height,\n  width,\n  fill,\n  ...rest\n}) => (\n  <rect\n    {...rest}\n    fill={fill}\n    width={Math.max(width!, 0)}\n    height={Math.max(height!, 0)}\n  />\n);\n\nLinearGaugeOuterBar.defaultProps = {\n  fill: '#484848'\n};\n","import React, { Fragment, ReactElement, FC } from 'react';\nimport { BarSeries, BarSeriesProps } from '../BarChart';\nimport { LinearGaugeBar, LinearGaugeBarProps } from './LinearGaugeBar';\nimport {\n  LinearGaugeOuterBar,\n  LinearGaugeOuterBarProps\n} from './LinearGaugeOuterBar';\nimport { CloneElement } from 'reablocks';\n\nexport interface LinearGaugeSeriesProps extends Omit<BarSeriesProps, 'bar'> {\n  /**\n   * Height of the chart. Set by `LinearGauge` component.\n   */\n  height: number;\n\n  /**\n   * Width of the chart. Set by `LinearGauge` component.\n   */\n  width: number;\n\n  /**\n   * Whether its a multi-series or not. Set by `LinearGauge` component.\n   */\n  isMultiSeries: boolean;\n\n  /**\n   * Bar element. Only applicable for single series.\n   */\n  bar: ReactElement<LinearGaugeBarProps, typeof LinearGaugeBar>;\n\n  /**\n   * Outer bar element. Only applicable for single series.\n   */\n  outerBar: ReactElement<LinearGaugeOuterBarProps, typeof LinearGaugeOuterBar>;\n}\n\nexport const LinearGaugeSeries: FC<Partial<LinearGaugeSeriesProps>> = ({\n  height,\n  width,\n  bar,\n  outerBar,\n  isMultiSeries,\n  ...rest\n}) => (\n  <Fragment>\n    {!isMultiSeries && outerBar && (\n      <CloneElement<LinearGaugeOuterBarProps>\n        element={outerBar}\n        height={height}\n        width={width}\n      />\n    )}\n    <BarSeries\n      {...rest}\n      layout=\"horizontal\"\n      tooltip={null}\n      bar={<CloneElement<LinearGaugeOuterBarProps> element={bar} />}\n    />\n  </Fragment>\n);\n\nLinearGaugeSeries.defaultProps = {\n  outerBar: <LinearGaugeOuterBar />,\n  bar: <LinearGaugeBar />\n};\n","import React, { FC, Fragment, ReactElement, useCallback, useMemo } from 'react';\nimport {\n  ChartProps,\n  ChartContainer,\n  ChartContainerChildProps\n} from '../common/containers';\nimport {\n  ChartShallowDataShape,\n  buildBarStackData,\n  ChartInternalNestedDataShape,\n  buildShallowChartData,\n  ChartNestedDataShape\n} from '../common/data';\nimport { getXScale, getYScale } from '../common/scales';\nimport { CloneElement } from 'reablocks';\nimport { LinearGaugeSeries, LinearGaugeSeriesProps } from './LinearGaugeSeries';\n\nexport interface LinearGaugeProps extends ChartProps {\n  /**\n   * Data the chart will receive to render.\n   */\n  data: ChartShallowDataShape | ChartShallowDataShape[];\n\n  /**\n   * The series component that renders the bar components.\n   */\n  series: ReactElement<LinearGaugeSeriesProps, typeof LinearGaugeSeries>;\n\n  /**\n   * Min value to scale on. Only applicable for single-series.\n   */\n  minValue: number;\n\n  /**\n   * Max value to scale on. Only applicable for single-series.\n   */\n  maxValue: number;\n}\n\nexport const LinearGauge: FC<Partial<LinearGaugeProps>> = ({\n  id,\n  width,\n  height,\n  margins,\n  className,\n  containerClassName,\n  series,\n  data,\n  minValue,\n  maxValue\n}) => {\n  const transformedData = useMemo(() => {\n    if (Array.isArray(data)) {\n      return buildBarStackData(\n        [\n          {\n            key: 'default',\n            data\n          }\n        ] as ChartNestedDataShape[],\n        'expand',\n        'horizontal'\n      );\n    } else {\n      return buildShallowChartData([data], 'horizontal');\n    }\n  }, [data]);\n\n  const getScales = useCallback(\n    (\n      isMultiSeries: boolean,\n      data: ChartInternalNestedDataShape[],\n      width: number,\n      height: number,\n      minValue: number,\n      maxValue: number\n    ) => {\n      const domain = !isMultiSeries ? [minValue, maxValue] : undefined;\n\n      const keyScale = getXScale({\n        width,\n        type: 'value',\n        data,\n        domain,\n        isMultiSeries\n      });\n\n      const valueScale = getYScale({\n        type: 'category',\n        height,\n        data,\n        isMultiSeries\n      });\n\n      return {\n        keyScale,\n        valueScale\n      };\n    },\n    []\n  );\n\n  const renderChart = useCallback(\n    ({ chartHeight, chartWidth, id, chartSized }: ChartContainerChildProps) => {\n      const isMultiSeries = Array.isArray(data);\n      const type = isMultiSeries ? 'stackedNormalized' : 'standard';\n      const { keyScale, valueScale } = getScales(\n        isMultiSeries,\n        transformedData as ChartInternalNestedDataShape[],\n        chartWidth,\n        chartHeight,\n        minValue,\n        maxValue\n      );\n\n      return (\n        <Fragment>\n          {chartSized && (\n            <CloneElement<LinearGaugeSeriesProps>\n              element={series}\n              id={`linear-gauge-series-${id}`}\n              data={transformedData}\n              isCategorical={true}\n              xScale={keyScale}\n              yScale={valueScale}\n              type={type}\n              height={chartHeight}\n              width={chartWidth}\n              isMultiSeries={isMultiSeries}\n            />\n          )}\n        </Fragment>\n      );\n    },\n    [data, getScales, maxValue, minValue, series, transformedData]\n  );\n\n  return (\n    <ChartContainer\n      id={id}\n      width={width}\n      height={height}\n      margins={margins}\n      className={className}\n      containerClassName={containerClassName}\n    >\n      {renderChart}\n    </ChartContainer>\n  );\n};\n\nLinearGauge.defaultProps = {\n  minValue: 0,\n  maxValue: 100,\n  series: <LinearGaugeSeries />\n};\n","import { useEffect } from 'react';\nimport { DEFAULT_TRANSITION } from '../common/Motion';\nimport { useMotionValue, useSpring } from 'framer-motion';\nimport { interpolate } from 'd3-interpolate';\n\nexport const useInterpolate = ({ data, animated }) => {\n  const transition = animated\n    ? { ...DEFAULT_TRANSITION }\n    : {\n        delay: 0,\n        type: false\n      };\n\n  const d = useMotionValue(data.path);\n  const spring = useSpring(0, { stiffness: 300, damping: 30 });\n\n  useEffect(() => {\n    const interpolator = interpolate(d.get(), data.path);\n    const prevSpring = spring.get();\n    spring.set(1 + prevSpring);\n\n    return spring.on('change', (v) => d.set(interpolator(v - prevSpring)));\n  }, [d, data.path, spring]);\n\n  return { transition, d };\n};\n","import React, {\n  FC,\n  useRef,\n  ReactElement,\n  useState,\n  Fragment,\n  useMemo\n} from 'react';\nimport { IVennLayout } from '@upsetjs/venn.js';\nimport { ChartTooltip, ChartTooltipProps } from '../common/Tooltip';\nimport { CloneElement } from 'reablocks';\nimport { motion } from 'framer-motion';\nimport { useInterpolate } from './useInterpolate';\nimport { Mask, MaskProps } from '../common/Mask';\nimport { Gradient, GradientProps } from '../common/Gradient';\nimport { useHoverIntent } from '../common/utils/useHoverIntent';\nimport { Glow, getAriaLabel } from '../common';\nimport { generateGlowStyles } from '../common/Glow/utils';\n\nexport interface VennArcProps {\n  /**\n   * Whether the shape is active or not.\n   */\n  active?: boolean | null;\n\n  /**\n   * Id set by the parent.\n   */\n  id: string;\n\n  /**\n   * Whether the chart is animated or not.\n   */\n  animated?: boolean;\n\n  /**\n   * Fill color for the arc.\n   */\n  fill: string;\n\n  /**\n   * Stroke for the arc.\n   */\n  stroke?:\n    | string\n    | ((\n        data: IVennLayout<any>[],\n        index: number,\n        isActive: boolean | null,\n        isHovered: boolean | null\n      ) => string);\n\n  /**\n   * The internal data object built by venn.js\n   */\n  data: IVennLayout<any>;\n\n  /**\n   * Whether the chart is disabled.\n   */\n  disabled?: boolean;\n\n  /**\n   * Stroke on the arc.\n   */\n  strokeWidth?: number;\n\n  /**\n   * Initial style of arc.\n   */\n  initialStyle?: any;\n\n  /**\n   * Active style of arc.\n   */\n  activeStyle?: any;\n\n  /**\n   * Inactive style of arc.\n   */\n  inactiveStyle?: any;\n\n  /**\n   * CSS Styles for the arc.\n   */\n  style?: any;\n\n  /**\n   * Tooltip element.\n   */\n  tooltip?: ReactElement<ChartTooltipProps, typeof ChartTooltip> | null;\n\n  /**\n   * Mask element for the arc.\n   */\n  mask: ReactElement<MaskProps, typeof Mask> | null;\n\n  /**\n   * Gradient shades for the arc.\n   */\n  gradient: ReactElement<GradientProps, typeof Gradient> | null;\n\n  /**\n   * Glow styling for the arc.\n   */\n  glow: Glow;\n\n  /**\n   * Event for when the arc is clicked.\n   */\n  onClick: (event) => void;\n\n  /**\n   * Event for when the arc has mouse enter.\n   */\n  onMouseEnter: (event) => void;\n\n  /**\n   * Event for when the arc has mouse leave.\n   */\n  onMouseLeave: (event) => void;\n}\n\nexport const VennArc: FC<Partial<VennArcProps>> = ({\n  data,\n  fill,\n  disabled,\n  animated,\n  stroke,\n  mask,\n  id,\n  style,\n  active,\n  inactiveStyle,\n  activeStyle,\n  initialStyle,\n  strokeWidth,\n  gradient,\n  glow,\n  tooltip,\n  onClick,\n  onMouseEnter,\n  onMouseLeave\n}) => {\n  const [internalActive, setInternalActive] = useState<boolean>(false);\n  const arcRef = useRef<any | null>(null);\n  const { transition, d } = useInterpolate({ animated, data });\n  const currentStyle = active\n    ? activeStyle\n    : active === null\n      ? inactiveStyle\n      : initialStyle;\n\n  const arcFill =\n    gradient && !mask\n      ? `url(#gradient-${id})`\n      : mask\n        ? `url(#mask-pattern-${id})`\n        : fill;\n\n  const { pointerOut, pointerOver } = useHoverIntent({\n    onPointerOver: (event) => {\n      if (!disabled) {\n        setInternalActive(true);\n        onMouseEnter?.({\n          value: data.data,\n          nativeEvent: event\n        });\n      }\n    },\n    onPointerOut: (event) => {\n      if (!disabled) {\n        setInternalActive(false);\n        onMouseLeave?.({\n          value: data.data,\n          nativeEvent: event\n        });\n      }\n    }\n  });\n\n  const tooltipData = useMemo(\n    () => ({ y: data.data.size, x: data.data?.sets?.join(' | ') }),\n    [data]\n  );\n  const ariaLabelData = useMemo(() => getAriaLabel(tooltipData), [tooltipData]);\n\n  return (\n    <g\n      title={data.data.key}\n      onPointerOver={pointerOver}\n      onPointerOut={pointerOut}\n      onClick={(event) => {\n        if (!disabled) {\n          onClick?.({\n            value: data.data,\n            nativeEvent: event\n          });\n        }\n      }}\n      tabIndex={0}\n      aria-label={ariaLabelData}\n      role=\"graphics-document\"\n    >\n      <motion.path\n        ref={arcRef}\n        fill={arcFill}\n        id={`${id}-arc`}\n        strokeWidth={strokeWidth}\n        stroke={stroke as string}\n        transition={transition}\n        d={d}\n        initial={initialStyle}\n        animate={currentStyle}\n        style={{\n          ...style,\n          ...generateGlowStyles({\n            glow,\n            colorSchemeColor: typeof stroke === 'string' ? stroke : null\n          })\n        }}\n      />\n      {mask && (\n        <Fragment>\n          <Mask id={`mask-${id}`} fill={`url(#gradient-${id})`} />\n          <CloneElement<MaskProps>\n            element={mask}\n            id={`mask-pattern-${id}`}\n            fill={fill}\n          />\n        </Fragment>\n      )}\n      {gradient && (\n        <CloneElement<GradientProps>\n          element={gradient}\n          id={`gradient-${id}`}\n          color={fill}\n        />\n      )}\n      {tooltip && !tooltip.props.disabled && (\n        <CloneElement<ChartTooltipProps>\n          element={tooltip}\n          visible={!!internalActive}\n          reference={arcRef}\n          value={tooltipData}\n        />\n      )}\n    </g>\n  );\n};\n\nVennArc.defaultProps = {\n  active: false,\n  inactiveStyle: { opacity: 0.3 },\n  activeStyle: { opacity: 0.8 },\n  initialStyle: { opacity: 0.6 },\n  strokeWidth: 3,\n  gradient: <Gradient />,\n  tooltip: <ChartTooltip />,\n  onClick: () => undefined,\n  onMouseEnter: () => undefined,\n  onMouseLeave: () => undefined\n};\n","import React, { FC } from 'react';\nimport { motion } from 'framer-motion';\nimport { wrapText } from '../common/utils/wrapText';\nimport { DEFAULT_TRANSITION } from '../common/Motion';\n\nexport interface VennLabelProps {\n  /**\n   * Whether the shape is active or not.\n   */\n  active?: boolean | null;\n\n  /**\n   * Set by the parent element.\n   */\n  id?: string;\n\n  /**\n   * Show all labels or just the large ones. Default false.\n   */\n  showAll?: boolean;\n\n  /**\n   * The label type to show.\n   */\n  labelType: 'key' | 'value';\n\n  /**\n   * Should wrap text or not.\n   */\n  wrap?: boolean;\n\n  /**\n   * The internal data object built by venn.js\n   */\n  data: any;\n\n  /**\n   * Font size of the text.\n   */\n  fontSize?: number;\n\n  /**\n   * Font family of the text.\n   */\n  fontFamily?: string;\n\n  /**\n   * Fill of the text.\n   */\n  fill?: string;\n\n  /**\n   * Whether the chart is animated or not.\n   */\n  animated?: boolean;\n\n  /**\n   * Format label.\n   */\n  format?: (data) => any;\n}\n\nexport const VennLabel: FC<Partial<VennLabelProps>> = ({\n  data,\n  format,\n  id,\n  active,\n  labelType,\n  showAll,\n  wrap,\n  animated,\n  fill,\n  fontSize,\n  fontFamily\n}) => {\n  // If the text area is very large, then lets just skip showing the label\n  if (!showAll && !data.arcs?.filter((a) => a.large).length) {\n    return null;\n  }\n\n  const key =\n    labelType === 'key' ? data.data?.sets?.join(' | ') : data.data.size;\n\n  const transition = animated ? DEFAULT_TRANSITION : { delay: 0, type: false };\n  const text = wrap\n    ? wrapText({\n      key,\n      x: data.text.x,\n      fontFamily,\n      fontSize,\n      width: data?.circles?.[0]?.radius\n    })\n    : key;\n\n  return (\n    <motion.text\n      id={`${id}-text`}\n      fill={fill}\n      pointerEvents=\"none\"\n      fontFamily={fontFamily}\n      fontSize={fontSize}\n      initial={\n        {\n          attrX: data.text.x,\n          attrY: data.text.y,\n          opacity: 1\n        } as any\n      }\n      animate={\n        {\n          attrX: data.text.x,\n          attrY: data.text.y,\n          opacity: active === null ? 0.3 : 1\n        } as any\n      }\n      transition={transition}\n      textAnchor=\"middle\"\n    >\n      {format ? format(data) : text}\n    </motion.text>\n  );\n};\n\nVennLabel.defaultProps = {\n  labelType: 'key',\n  showAll: false,\n  wrap: true,\n  animated: true,\n  fontSize: 11,\n  fontFamily: 'sans-serif'\n};\n","import React, { FC, Fragment, isValidElement } from 'react';\nimport { motion } from 'framer-motion';\nimport { DEFAULT_TRANSITION } from '../common/Motion';\n\nexport interface VennOuterLabelProps {\n  /**\n   * The internal data object built by venn.js\n   */\n  data: any;\n\n  /**\n   * Font size of the text.\n   */\n  fontSize?: number;\n\n  /**\n   * Font family of the text.\n   */\n  fontFamily?: string;\n\n  /**\n   * Fill of the text.\n   */\n  fill?: string;\n\n  /**\n   * Whether the chart is animated or not.\n   */\n  animated?: boolean;\n\n  /**\n   * Format label.\n   */\n  format?: (data) => any;\n}\n\nexport const VennOuterLabel: FC<Partial<VennOuterLabelProps>> = ({\n  data,\n  format,\n  animated,\n  fill,\n  fontSize,\n  fontFamily\n}) => {\n  const transition = animated ? DEFAULT_TRANSITION : { delay: 0, type: false };\n  const text = data.set.data.key;\n\n  const label = format ? format(data) : text;\n  const isElement = isValidElement(label);\n  const showIcon = isElement && data.set.icon;\n\n  // TODO: framer-motion doesn't seem to like the translates on the g\n  // initial={pos} animate={pos}\n  const pos = {\n    x: showIcon ? data.set.icon.x : data.set.text.x,\n    y: showIcon ? data.set.icon.y : data.set.text.y\n  };\n\n  return (\n    <Fragment>\n      {isElement ? (\n        <g style={{ transform: `translate(${pos.x}px, ${pos.y}px)` }}>\n          {label}\n        </g>\n      ) : (\n        <motion.text\n          fill={fill}\n          style={{ pointerEvents: 'none', fontFamily, fontSize }}\n          textAnchor={data.set.align === 'middle' ? 'center' : data.set.align}\n          alignmentBaseline={data.set.verticalAlign}\n          initial={\n            {\n              attrX: pos.x,\n              attrY: pos.y\n            } as any\n          }\n          animate={\n            {\n              attrX: pos.x,\n              attrY: pos.y\n            } as any\n          }\n          transition={transition}\n        >\n          {label}\n        </motion.text>\n      )}\n    </Fragment>\n  );\n};\n\nVennOuterLabel.defaultProps = {\n  animated: true,\n  fill: '#000',\n  fontSize: 14,\n  fontFamily: 'sans-serif'\n};\n","import React, {\n  FC,\n  Fragment,\n  ReactElement,\n  useCallback,\n  useState,\n  useMemo\n} from 'react';\nimport { IVennLayout } from '@upsetjs/venn.js';\nimport { ColorSchemeType, getColor } from '../common/color';\nimport { VennArc, VennArcProps } from './VennArc';\nimport { VennLabel, VennLabelProps } from './VennLabel';\nimport { motion } from 'framer-motion';\nimport { CloneElement } from 'reablocks';\nimport chroma from 'chroma-js';\nimport { VennOuterLabel, VennOuterLabelProps } from './VennOuterLabel';\nimport invert from 'invert-color';\nimport { DEFAULT_TRANSITION } from '../common/Motion';\nimport { identifier } from 'safe-identifier';\n\nexport interface VennSeriesProps {\n  /**\n   * Id set by the parent.\n   */\n  id: string;\n\n  /**\n   * Active managed selections.\n   */\n  selections?: string[];\n\n  /**\n   * The internal data object built by venn.js\n   */\n  data: IVennLayout<any>[];\n\n  /**\n   * Color scheme for the chart.\n   */\n  colorScheme: ColorSchemeType;\n\n  /**\n   * Whether the chart is disabled.\n   */\n  disabled?: boolean;\n\n  /**\n   * Whether the chart is animated or not.\n   */\n  animated?: boolean;\n\n  /**\n   * Label element.\n   */\n  label?: ReactElement<VennLabelProps, typeof VennLabel> | null;\n\n  /**\n   * Label element.\n   */\n  outerLabel?: ReactElement<VennOuterLabelProps, typeof VennOuterLabel> | null;\n\n  /**\n   * Arc element.\n   */\n  arc?: ReactElement<VennArcProps, typeof VennArc> | null;\n}\n\nexport const VennSeries: FC<Partial<VennSeriesProps>> = ({\n  data,\n  id,\n  selections,\n  animated,\n  disabled,\n  colorScheme,\n  outerLabel,\n  arc,\n  label\n}) => {\n  const transition = animated ? DEFAULT_TRANSITION : { type: false, delay: 0 };\n  const [actives, setActives] = useState<string[]>([]);\n  const [hovered, setHovered] = useState<string | null>(null);\n\n  const onActivate = useCallback(\n    (point: string) => {\n      setHovered(point);\n\n      setActives(\n        data\n          .filter((d) => d.data?.key.indexOf(point) > -1)\n          .map((d) => d.data?.key)\n      );\n    },\n    [data]\n  );\n\n  const renderArc = useCallback(\n    (d: IVennLayout<any> & { set?: any }, index: number) => {\n      // Get the colors of the fill\n      const fill = getColor({\n        data,\n        colorScheme,\n        point: d.data,\n        index\n      });\n\n      const textFill = fill\n        ? invert(chroma(fill).darken(0.5).hex(), true)\n        : 'white';\n\n      const arcFill = arc.props.fill || fill;\n\n      const key = d?.data?.key;\n      const safeKey = identifier(d.data?.key);\n      const isSelected = selections?.includes(key);\n\n      // Get the state of the arc\n      const isHovered = hovered === key || isSelected;\n      const isActive =\n        isSelected ||\n        actives.includes(key) ||\n        (actives.length > 0 ? null : false);\n\n      const getStrokeColor = () => {\n        if (typeof arc.props.stroke === 'function') {\n          return arc.props.stroke(data, index, isActive, isHovered);\n        }\n        if (arc.props.stroke !== undefined) {\n          return arc.props.stroke;\n        }\n\n        // fallback to fill (determined by colorScheme) if stroke is undefined\n        return fill;\n      };\n\n      const stroke = getStrokeColor();\n\n      const arcStroke =\n        stroke ||\n        chroma(arcFill)\n          .darken(isActive ? 0.8 : 0.5)\n          .hex();\n\n      return (\n        <Fragment key={safeKey}>\n          <CloneElement<VennArcProps>\n            element={arc}\n            id={`${id}-${safeKey}`}\n            data={d}\n            fill={arcFill}\n            stroke={arcStroke}\n            disabled={disabled}\n            animated={animated}\n            active={isActive}\n            onMouseEnter={() => onActivate(key)}\n            onMouseLeave={() => {\n              setActives([]);\n              setHovered(null);\n            }}\n          />\n          {label && (\n            <CloneElement<VennLabelProps>\n              element={label}\n              data={d}\n              id={`${id}-${safeKey}`}\n              active={isActive}\n              animated={animated}\n              fill={textFill}\n              {...label.props}\n            />\n          )}\n          {d.set && outerLabel && (\n            <CloneElement<VennLabelProps>\n              element={outerLabel}\n              data={d}\n              animated={animated}\n            />\n          )}\n        </Fragment>\n      );\n    },\n    [\n      data,\n      colorScheme,\n      arc,\n      selections,\n      hovered,\n      actives,\n      id,\n      disabled,\n      animated,\n      label,\n      outerLabel,\n      onActivate\n    ]\n  );\n\n  const topArcs = useMemo(() => {\n    const result = [];\n\n    if (actives.length > 0) {\n      result.push(...actives.filter((s) => s !== hovered));\n    }\n\n    if (selections?.length) {\n      result.push(\n        ...selections.filter((s) => !actives.includes(s) && s !== hovered)\n      );\n    }\n\n    if (hovered) {\n      result.push(hovered);\n    }\n\n    return result;\n  }, [hovered, actives, selections]);\n\n  return (\n    <motion.g\n      initial={{ opacity: 0, scale: 0 }}\n      animate={{ opacity: 1, scale: 1 }}\n      transition={transition}\n    >\n      {data.map(renderArc)}\n      {topArcs.length > 0 &&\n        topArcs.map((a) => (\n          <use\n            key={a}\n            xlinkHref={`#${id}-${a}-arc`}\n            style={{ pointerEvents: 'none' }}\n          />\n        ))}\n      {data.map((d, index) => (\n        <use\n          key={index}\n          xlinkHref={`#${id}-${identifier(d.data?.key)}-text`}\n          style={{ pointerEvents: 'none' }}\n        />\n      ))}\n    </motion.g>\n  );\n};\n\nVennSeries.defaultProps = {\n  animated: true,\n  disabled: false,\n  colorScheme: 'cybertron',\n  outerLabel: <VennOuterLabel />,\n  arc: <VennArc />,\n  label: <VennLabel />\n};\n","import venn0 from './venn0.json';\nimport venn1 from './venn1.json';\nimport venn2 from './venn2.json';\nimport venn3 from './venn3.json';\nimport venn4 from './venn4.json';\nimport venn5 from './venn5.json';\n\nexport interface BoundingBox {\n  width: number;\n  height: number;\n}\n\n// Static shapes for rendering\nconst shapes = [venn0, venn1, venn2, venn3, venn4, venn5];\n\n/**\n * Sort helper.\n * Reference: https://stackoverflow.com/a/64449554/1288340\n */\nconst upto = (limit) => Array.from({ length: limit }, (_, i) => i);\n\n/**\n * Detect ellipse.\n * Reference: https://github.com/upsetjs/chartjs-chart-venn/blob/master/src/model/generate.ts#L4\n */\nfunction isEllipse(d) {\n  return typeof d.rx === 'number';\n}\n\n/**\n * Generate all combinations of a given array.\n * Reference: https://stackoverflow.com/questions/5752002/find-all-possible-subset-combos-in-an-array\n */\nfunction combinations(array: string[]) {\n  return (new Array(1 << array.length) as any)\n    .fill()\n    .map((_e1, i) => array.filter((_e2, j) => i & (1 << j)));\n}\n\n/**\n * Given a array set, lookup the data.\n */\nfunction lookup(combo: string[], data: any[]) {\n  const key = combo.join('|');\n  const found = data.find((d) => d.key === key);\n\n  return {\n    key,\n    sets: combo,\n    size: found?.size || 0\n  };\n}\n\n/**\n * Build the data combinations for the layout.\n */\nfunction buildData(data: any[]) {\n  // Collect all unique sets and sort by size\n  const uniqueSets = data\n    .filter((d) => d.sets.length === 1)\n    .sort((a, b) => b.size - a.size);\n\n  // Map our unique sets\n  const uniqueSetKeys = uniqueSets.map((u) => u.key);\n\n  // Build all combos and return 1+ combos\n  const sets: any[] = combinations(uniqueSetKeys);\n  const filteredSets = sets.slice(1, sets.length);\n\n  // Sort the child sets based on the parent\n  const result = filteredSets.map((d) =>\n    [...d].sort((a, b) => uniqueSetKeys.indexOf(a) - uniqueSetKeys.indexOf(b))\n  );\n\n  // Sort the data based on index of keys and length\n  // Reference: https://stackoverflow.com/a/64449554/1288340\n  result.sort(\n    (a, b) =>\n      a.length - b.length ||\n      upto(a.length).reduce(\n        (diff, i) =>\n          diff || uniqueSetKeys.indexOf(a[i]) - uniqueSetKeys.indexOf(b[i]),\n        0\n      )\n  );\n\n  // reshape the data key so they will match combos\n  const keyedData = data.map((d) => {\n    const sets = [...d.sets].sort(\n      (a, b) => uniqueSetKeys.indexOf(a) - uniqueSetKeys.indexOf(b)\n    );\n    const key = sets.join('|');\n\n    return {\n      size: d.size,\n      sets,\n      key\n    };\n  });\n\n  return {\n    uniqueCount: uniqueSets.length,\n    data: result.map((r) => lookup(r, keyedData))\n  };\n}\n\n/**\n * Generate the arc slice path.\n * Reference: https://github.com/upsetjs/chartjs-chart-venn/blob/master/src/model/generate.ts#L4\n */\nexport function generateArcSlicePath(s: any, refs: any[]) {\n  return `M ${s.x1},${s.y1} ${s.arcs\n    .map((arc) => {\n      const ref = refs[arc.ref];\n      const rx = isEllipse(ref) ? ref.rx : ref.r;\n      const ry = isEllipse(ref) ? ref.ry : ref.r;\n      const rot = isEllipse(ref) ? ref.rotation : 0;\n      return `A ${rx} ${ry} ${rot} ${arc.large ? 1 : 0} ${arc.sweep ? 1 : 0} ${\n        arc.x2\n      } ${arc.y2}`;\n    })\n    .join(' ')}`;\n}\n\n/**\n * Build the layout for the given chart.\n * Reference: https://github.com/upsetjs/chartjs-chart-venn/blob/master/src/model/generate.ts#L4\n */\nfunction buildLayout({ data, uniqueCount }, box: BoundingBox) {\n  const shape = shapes[Math.min(shapes.length - 1, uniqueCount)];\n  const f = Math.min(box.width / shape.bb.width, box.height / shape.bb.height);\n  const x = f * -shape.bb.x + (box.width - f * shape.bb.width) / 2 + 0;\n  const y = f * -shape.bb.y + (box.height - f * shape.bb.height) / 2 + 0;\n  const mx = (v: number) => x + f * v;\n  const my = (v: number) => y + f * v;\n\n  const shapeSets = shape.sets.map((c, i) => ({\n    ...c,\n    ...{\n      data: data[i],\n      cx: mx(c.cx),\n      cy: my(c.cy),\n      text: {\n        x: mx(c.text.x),\n        y: my(c.text.y)\n      },\n      ...(c.icon\n        ? {\n          icon: {\n            x: mx(c.icon.x),\n            y: my(c.icon.y)\n          }\n        }\n        : {})\n    },\n    ...(isEllipse(c)\n      ? {\n        rx: c.rx * f,\n        ry: c.ry * f\n      }\n      : {\n        r: c.r * f\n      })\n  }));\n\n  const intersections = shape.intersections.map((c, i) => ({\n    text: {\n      x: mx(c.text.x),\n      y: my(c.text.y)\n    },\n    x1: mx(c.x1),\n    y1: my(c.y1),\n    data: data[i],\n    set: shapeSets[i],\n    arcs: c.arcs.map((a) => ({\n      ...a,\n      x2: mx(a.x2),\n      y2: my(a.y2)\n    }))\n  }));\n\n  return intersections.map((i) => ({\n    ...i,\n    path: generateArcSlicePath(i, shapeSets)\n  }));\n}\n\n/**\n * Generate the star euler layout.\n * Adapted from: https://github.com/upsetjs/chartjs-chart-venn\n */\nexport function starEulerLayout(data: any[], bb: BoundingBox) {\n  return buildLayout(buildData(data), bb);\n}\n","import React, { FC, Fragment, ReactElement, useCallback } from 'react';\nimport {\n  ChartContainer,\n  ChartContainerChildProps,\n  ChartProps\n} from '../common/containers';\nimport { layout } from '@upsetjs/venn.js';\nimport { VennSeries, VennSeriesProps } from './VennSeries';\nimport { CloneElement } from 'reablocks';\nimport { starEulerLayout } from './starEuler';\n\nexport interface VennDiagramData {\n  /**\n   * List of Keys for the data.\n   */\n  key: string[];\n\n  /**\n   * Size of the data keys.\n   */\n  data: number;\n}\n\nexport interface VennDiagramProps extends ChartProps {\n  /**\n   * Type of the chart.\n   */\n  type?: 'venn' | 'euler' | 'starEuler';\n\n  /**\n   * Data the chart will receive to render.\n   */\n  data: VennDiagramData[];\n\n  /**\n   * The series component that renders the arc and label components.\n   */\n  series?: ReactElement<VennSeriesProps, typeof VennSeries> | null;\n\n  /**\n   * Whether the chart is disabled.\n   */\n  disabled?: boolean;\n}\n\nexport const VennDiagram: FC<VennDiagramProps> = ({\n  id,\n  type,\n  width,\n  height,\n  margins,\n  className,\n  containerClassName,\n  data,\n  disabled,\n  series\n}) => {\n  const renderChart = useCallback(\n    (containerProps: ChartContainerChildProps) => {\n      const normalized = data.map((d) => ({\n        key: d.key.join('|'),\n        sets: d.key,\n        size: d.data\n      }));\n\n      let layoutData;\n      if (type === 'starEuler') {\n        layoutData = starEulerLayout(normalized, {\n          height: containerProps.height,\n          width: containerProps.width\n        });\n      } else {\n        layoutData = layout(normalized, {\n          height: containerProps.height,\n          width: containerProps.width,\n          distinct: type !== 'euler'\n        });\n      }\n\n      return (\n        <CloneElement<VennSeriesProps>\n          element={series}\n          data={layoutData}\n          disabled={disabled}\n          id={containerProps.id}\n        />\n      );\n    },\n    [data, disabled, series, type]\n  );\n\n  return (\n    <ChartContainer\n      id={id}\n      width={width}\n      height={height}\n      margins={margins}\n      containerClassName={containerClassName}\n      xAxisVisible={false}\n      yAxisVisible={false}\n      center={false}\n      className={className}\n    >\n      {renderChart}\n    </ChartContainer>\n  );\n};\n\nVennDiagram.defaultProps = {\n  type: 'venn',\n  series: <VennSeries />\n};\n","import React, {\n  FC,\n  Fragment,\n  MouseEventHandler,\n  ReactElement,\n  useMemo,\n  useRef,\n  useState\n} from 'react';\nimport { HierarchyCircularNode } from 'd3-hierarchy';\nimport { ChartTooltip, ChartTooltipProps } from '../common/Tooltip';\nimport { CloneElement } from 'reablocks';\nimport { motion } from 'framer-motion';\nimport { Gradient, GradientProps } from '../common/Gradient';\nimport { Mask, MaskProps } from '../common/Mask';\nimport { DEFAULT_TRANSITION } from '../common/Motion';\nimport { useHoverIntent } from '../common/utils/useHoverIntent';\nimport { Glow } from '../common/Glow';\nimport { generateGlowStyles } from '../common/Glow/utils';\nimport { getAriaLabel } from '../common';\n\nexport interface BubbleProps {\n  /**\n   * Id set by the parent.\n   */\n  id: string;\n\n  /**\n   * The internal data object built by d3\n   */\n  data: HierarchyCircularNode<any>;\n\n  /**\n   * Fill for the bubble.\n   */\n  fill: string;\n\n  /**\n   * Whether the chart is animated or not.\n   */\n  animated?: boolean;\n\n  /**\n   * Tooltip element.\n   */\n  tooltip?: ReactElement<ChartTooltipProps, typeof ChartTooltip> | null;\n\n  /**\n   * Mask element for the bubble.\n   */\n  mask: ReactElement<MaskProps, typeof Mask> | null;\n\n  /**\n   * Glow styling for the bubble.\n   */\n  glow?: Glow;\n\n  /**\n   * Gradient shades for the bubble.\n   */\n  gradient: ReactElement<GradientProps, typeof Gradient> | null;\n\n  /**\n   * Event for when the bubble is clicked.\n   */\n  onClick?: (\n    event: React.MouseEvent<SVGCircleElement>,\n    currentItem?: HierarchyCircularNode<any>\n  ) => void;\n\n  /**\n   * Event for when the mouse enters bubble.\n   */\n  onMouseEnter?: (event) => void;\n\n  /**\n   * Event for when the mouse leaves the bubble.\n   */\n  onMouseLeave?: (event) => void;\n}\n\nexport const Bubble: FC<Partial<BubbleProps>> = ({\n  id,\n  data,\n  fill,\n  mask,\n  gradient,\n  glow,\n  onClick,\n  onMouseEnter,\n  onMouseLeave,\n  animated,\n  tooltip = <ChartTooltip />\n}) => {\n  const [internalActive, setInternalActive] = useState<boolean>(false);\n  const bubbleRef = useRef<any | null>(null);\n  const transition = animated ? DEFAULT_TRANSITION : { type: false, delay: 0 };\n\n  const { pointerOut, pointerOver } = useHoverIntent({\n    onPointerOver: (event) => {\n      setInternalActive(true);\n      onMouseEnter?.(event);\n    },\n    onPointerOut: (event) => {\n      setInternalActive(false);\n      onMouseLeave?.(event);\n    }\n  });\n\n  const arcFill =\n    gradient && !mask\n      ? `url(#gradient-${id})`\n      : mask\n        ? `url(#mask-pattern-${id})`\n        : fill;\n\n  const tooltipData = useMemo(\n    () => ({ y: data.data.data, x: data.data.key }),\n    [data]\n  );\n  const ariaLabelData = useMemo(() => getAriaLabel(tooltipData), [tooltipData]);\n\n  return (\n    <Fragment>\n      <motion.circle\n        id={`${id}-bubble`}\n        ref={bubbleRef}\n        fill={arcFill}\n        style={generateGlowStyles({ glow })}\n        initial={{\n          r: data.r,\n          cx: data.x,\n          cy: data.y\n        }}\n        animate={{\n          r: data.r,\n          cx: data.x,\n          cy: data.y\n        }}\n        transition={transition}\n        onClick={(event) => onClick && onClick(event, data)}\n        onPointerOver={pointerOver}\n        onPointerOut={pointerOut}\n        tabIndex={0}\n        aria-label={ariaLabelData}\n        role=\"graphics-document\"\n      />\n      {mask && (\n        <Fragment>\n          <Mask id={`mask-${id}`} fill={`url(#gradient-${id})`} />\n          <CloneElement<MaskProps>\n            element={mask}\n            id={`mask-pattern-${id}`}\n            fill={fill}\n          />\n        </Fragment>\n      )}\n      {gradient && (\n        <CloneElement<GradientProps>\n          element={gradient}\n          id={`gradient-${id}`}\n          color={fill}\n        />\n      )}\n      {tooltip && !tooltip.props.disabled && (\n        <CloneElement<ChartTooltipProps>\n          element={tooltip}\n          visible={!!internalActive}\n          reference={bubbleRef}\n          value={tooltipData}\n        />\n      )}\n    </Fragment>\n  );\n};\n","import React, { FC, isValidElement } from 'react';\nimport { HierarchyCircularNode } from 'd3-hierarchy';\nimport { motion } from 'framer-motion';\nimport { wrapText } from '../common/utils/wrapText';\nimport { DEFAULT_TRANSITION } from '../common/Motion';\n\nexport interface BubbleLabelProps {\n  /**\n   * Id set by the parent.\n   */\n  id: string;\n\n  /**\n   * The internal data object built by d3\n   */\n  data: HierarchyCircularNode<any>;\n\n  /**\n   * Font size of the text.\n   */\n  fontSize?: number;\n\n  /**\n   * Font family of the text.\n   */\n  fontFamily?: string;\n\n  /**\n   * Fill of the text.\n   */\n  fill?: string;\n\n  /**\n   * Should wrap text or not.\n   */\n  wrap?: boolean;\n\n  /**\n   * Whether the chart is animated or not.\n   */\n  animated?: boolean;\n\n  /**\n   * Format label.\n   */\n  format?: (data) => any;\n}\n\nexport const BubbleLabel: FC<Partial<BubbleLabelProps>> = ({\n  id,\n  data,\n  format,\n  wrap,\n  fill,\n  fontSize,\n  fontFamily,\n  animated\n}) => {\n  const transition = animated ? DEFAULT_TRANSITION : { type: false, delay: 0 };\n  let isElement = false;\n  let label;\n\n  if (format) {\n    label = format(data);\n    isElement = isValidElement(label);\n  }\n\n  if (!isElement) {\n    const text = wrap\n      ? wrapText({\n        key: data.data.key,\n        fontFamily,\n        fontSize,\n        width: data.r\n      })\n      : data.data.key;\n\n    return (\n      <motion.text\n        initial={{\n          x: data.x,\n          y: data.y\n        }}\n        animate={{\n          x: data.x,\n          y: data.y\n        }}\n        transition={transition}\n        id={`${id}-text`}\n        style={{ pointerEvents: 'none', fontFamily, fontSize }}\n        fill={fill}\n        textAnchor=\"middle\"\n      >\n        {text}\n      </motion.text>\n    );\n  }\n\n  return (\n    <g style={{ transform: `translate(${data.x}px, ${data.y}px)` }}>{label}</g>\n  );\n};\n\nBubbleLabel.defaultProps = {\n  wrap: true,\n  fontSize: 14,\n  fontFamily: 'sans-serif'\n};\n","import React, { FC, Fragment, ReactElement } from 'react';\nimport { motion } from 'framer-motion';\nimport { HierarchyCircularNode } from 'd3-hierarchy';\nimport { ColorSchemeType, getColor } from '../common/color';\nimport { Bubble, BubbleProps } from './Bubble';\nimport { BubbleLabel, BubbleLabelProps } from './BubbleLabel';\nimport { CloneElement } from 'reablocks';\nimport invert from 'invert-color';\nimport chroma from 'chroma-js';\nimport { DEFAULT_TRANSITION } from '../common/Motion';\nimport { identifier } from 'safe-identifier';\n\nexport interface BubbleSeriesProps {\n  /**\n   * Id set by the parent.\n   */\n  id: string;\n\n  /**\n   * The internal data object built by d3\n   */\n  data: HierarchyCircularNode<any>[];\n\n  /**\n   * Whether the chart is animated or not.\n   */\n  animated?: boolean;\n\n  /**\n   * Color scheme for the chart.\n   */\n  colorScheme: ColorSchemeType;\n\n  /**\n   * Bubble element.\n   */\n  bubble?: ReactElement<BubbleProps, typeof Bubble>;\n\n  /**\n   * Bubble element.\n   */\n  format?: (item: any) => ReactElement<BubbleProps, typeof Bubble>;\n\n  /**\n   * Label element.\n   */\n  label?: ReactElement<BubbleLabelProps, typeof BubbleLabel>;\n}\n\nexport const BubbleSeries: FC<Partial<BubbleSeriesProps>> = ({\n  id,\n  data,\n  colorScheme,\n  animated,\n  bubble,\n  format,\n  label\n}) => {\n  const transition = animated ? DEFAULT_TRANSITION : { type: false, delay: 0 };\n\n  const renderBubble = (item, index) => {\n    const fill = getColor({\n      data,\n      colorScheme,\n      point: item.data,\n      index\n    });\n\n    const textFill = fill\n      ? invert(chroma(fill).darken(0.5).hex(), true)\n      : 'white';\n\n    return (\n      <motion.g\n        key={(item.data as any).key}\n        initial={{\n          scale: 0.5,\n          opacity: 0\n        }}\n        animate={{\n          scale: 1,\n          opacity: 1\n        }}\n        transition={transition}\n      >\n        <CloneElement<BubbleProps>\n          element={format ? format(item) : bubble}\n          id={identifier(`${id}-${item.data.key}-bubble`)}\n          animated={animated}\n          data={item}\n          fill={fill}\n        />\n        <CloneElement<BubbleLabelProps>\n          element={label}\n          id={identifier(`${id}-${item.data.key}-label`)}\n          animated={animated}\n          data={item}\n          fill={textFill}\n        />\n      </motion.g>\n    );\n  };\n\n  return <Fragment>{data.map(renderBubble)}</Fragment>;\n};\n\nBubbleSeries.defaultProps = {\n  colorScheme: 'cybertron',\n  animated: true,\n  bubble: <Bubble />,\n  label: <BubbleLabel />\n};\n","import React, { FC, ReactElement, useCallback } from 'react';\nimport { hierarchy, pack } from 'd3-hierarchy';\nimport { CloneElement } from 'reablocks';\nimport {\n  ChartContainer,\n  ChartContainerChildProps,\n  ChartProps,\n  ChartShallowDataShape\n} from '../common';\nimport { BubbleSeries, BubbleSeriesProps } from './BubbleSeries';\n\nexport interface BubbleChartProps extends ChartProps {\n  /**\n   * Data the chart will receive to render.\n   */\n  data: ChartShallowDataShape[];\n\n  /**\n   * The series component that renders the arc components.\n   */\n  series?: ReactElement<BubbleSeriesProps, typeof BubbleSeries>;\n}\n\nexport const BubbleChart: FC<Partial<BubbleChartProps>> = ({\n  data,\n  id,\n  width,\n  height,\n  className,\n  containerClassName,\n  margins,\n  series\n}) => {\n  const getData = useCallback(\n    (cw: number, ch: number) => {\n      const bubble = pack().size([cw, ch]).padding(3);\n\n      const root = hierarchy<any>({ children: data })\n        .sum((d) => d.data)\n        .sort((a, b) => b.data - a.data);\n\n      return bubble(root).leaves();\n    },\n    [data]\n  );\n\n  const renderChart = useCallback(\n    ({ chartWidth, chartHeight, ...rest }: ChartContainerChildProps) => {\n      const circles = getData(chartWidth, chartHeight);\n\n      return (\n        <CloneElement<BubbleSeriesProps>\n          element={series}\n          id={`${rest.id}-series`}\n          data={circles}\n        />\n      );\n    },\n    [series, getData]\n  );\n\n  return (\n    <ChartContainer\n      id={id}\n      width={width}\n      height={height}\n      containerClassName={containerClassName}\n      margins={margins}\n      xAxisVisible={false}\n      yAxisVisible={false}\n      className={className}\n    >\n      {renderChart}\n    </ChartContainer>\n  );\n};\n\nBubbleChart.defaultProps = {\n  data: [],\n  margins: 10,\n  series: <BubbleSeries />\n};\n","import React, { FC } from 'react';\nimport { calculateDimensions, wrapText } from '../common/utils';\nimport { formatValue } from '../common/utils/formatting';\n\nexport interface TreeMapLabelProps {\n  /**\n   * Id set by the parent.\n   */\n  id: string;\n\n  /**\n   * The internal data object built by d3\n   */\n  data: any;\n\n  /**\n   * Font size of the text.\n   */\n  fontSize?: number;\n\n  /**\n   * Font family of the text.\n   */\n  fontFamily?: string;\n\n  /**\n   * Fill of the text.\n   */\n  fill?: string;\n\n  /**\n   * Should wrap text or not.\n   */\n  wrap?: boolean;\n\n  /**\n   * Placement of the text.\n   */\n  placement?: 'start' | 'middle' | 'end';\n}\n\nexport const TreeMapLabel: FC<Partial<TreeMapLabelProps>> = ({\n  id,\n  data,\n  fill,\n  wrap,\n  placement,\n  fontSize,\n  fontFamily\n}) => {\n  const key = data.data.key;\n  const width = data.x1 - data.x0;\n  const text = wrapText({\n    key,\n    fontFamily,\n    fontSize,\n    paddingX: 10,\n    wrap,\n    paddingY: 10,\n    width,\n    height: data.y1 - data.y0\n  });\n  const size = calculateDimensions(\n    typeof text === 'string' ? text : key,\n    fontFamily,\n    fontSize\n  );\n\n  const offsetX =\n    placement === 'start'\n      ? 10\n      : placement === 'middle'\n        ? (width - size.width) / 2\n        : width - size.width - 10;\n\n  return (\n    <g style={{ transform: `translate(${offsetX}px, 15px)` }}>\n      <text\n        id={`${id}-text`}\n        style={{ pointerEvents: 'none', fontFamily, fontSize }}\n        fill={fill}\n      >\n        {text}\n      </text>\n    </g>\n  );\n};\n\nTreeMapLabel.defaultProps = {\n  fill: '#FFF',\n  wrap: true,\n  fontSize: 14,\n  fontFamily: 'sans-serif',\n  placement: 'start'\n};\n","import React, {\n  FC,\n  ReactElement,\n  useRef,\n  useState,\n  Fragment,\n  useMemo\n} from 'react';\nimport { motion } from 'framer-motion';\nimport chroma from 'chroma-js';\nimport { ChartTooltip, ChartTooltipProps } from '../common/Tooltip';\nimport { CloneElement } from 'reablocks';\nimport { DEFAULT_TRANSITION } from '../common/Motion';\nimport { useHoverIntent } from '../common/utils/useHoverIntent';\nimport { getAriaLabel } from '../common';\n\nexport interface TreeMapRectProps {\n  /**\n   * The internal data object built by d3\n   */\n  data: any;\n\n  /**\n   * Id set by the parent.\n   */\n  id: string;\n\n  /**\n   * Fill for the rect.\n   */\n  fill: string;\n\n  /**\n   * Whether the chart is animated or not.\n   */\n  animated?: boolean;\n\n  /**\n   * Cursor for the element.\n   */\n  cursor?: string;\n\n  /**\n   * Tooltip element.\n   */\n  tooltip?: ReactElement<ChartTooltipProps, typeof ChartTooltip> | null;\n\n  /**\n   * Event for when the arc is clicked.\n   */\n  onClick?: (event, data) => void;\n\n  /**\n   * Event for when the arc has mouse enter.\n   */\n  onMouseEnter?: (event, data) => void;\n\n  /**\n   * Event for when the arc has mouse leave.\n   */\n  onMouseLeave?: (event, data) => void;\n}\n\nexport const TreeMapRect: FC<Partial<TreeMapRectProps>> = ({\n  data,\n  fill,\n  animated,\n  cursor,\n  tooltip,\n  onMouseEnter,\n  onMouseLeave,\n  onClick\n}) => {\n  const [internalActive, setInternalActive] = useState<boolean>(false);\n  const rectRef = useRef<any | null>(null);\n  const transition = animated ? DEFAULT_TRANSITION : { type: false, delay: 0 };\n  const currentFill = internalActive ? chroma(fill).darken(0.8).hex() : fill;\n\n  const { pointerOut, pointerOver } = useHoverIntent({\n    onPointerOver: (event) => {\n      setInternalActive(true);\n      onMouseEnter?.(event, data);\n    },\n    onPointerOut: (event) => {\n      setInternalActive(false);\n      onMouseLeave?.(event, data);\n    }\n  });\n\n  const tooltipLabel = useMemo(() => {\n    const getKey = (node): string[] => {\n      if (!node.parent) {\n        return [];\n      }\n      return [...getKey(node.parent), node.data.key];\n    };\n    return getKey(data).join(' → ');\n  }, [data]);\n\n  const tooltipData = useMemo(\n    () => ({ y: data.value, x: tooltipLabel }),\n    [data, tooltipLabel]\n  );\n  const ariaLabelData = useMemo(() => getAriaLabel(tooltipData), [tooltipData]);\n\n  return (\n    <Fragment>\n      <motion.rect\n        ref={rectRef}\n        initial={{\n          fill: currentFill,\n          width: data.x1 - data.x0,\n          height: data.y1 - data.y0\n        }}\n        animate={{\n          fill: currentFill,\n          width: data.x1 - data.x0,\n          height: data.y1 - data.y0\n        }}\n        style={{ cursor }}\n        transition={transition}\n        onClick={(event) => {\n          onClick?.(event, data);\n        }}\n        onPointerOver={pointerOver}\n        onPointerOut={pointerOut}\n        tabIndex={0}\n        aria-label={ariaLabelData}\n        role=\"graphics-document\"\n      />\n      {tooltip && !tooltip.props.disabled && (\n        <CloneElement<ChartTooltipProps>\n          element={tooltip}\n          visible={!!internalActive}\n          reference={rectRef}\n          value={tooltipData}\n        />\n      )}\n    </Fragment>\n  );\n};\n\nTreeMapRect.defaultProps = {\n  cursor: 'pointer',\n  tooltip: <ChartTooltip />\n};\n","import React, { FC, Fragment, ReactElement } from 'react';\nimport { motion } from 'framer-motion';\nimport { CloneElement } from 'reablocks';\nimport { ColorSchemeType, getColor } from '../common/color';\nimport { TreeMapLabel, TreeMapLabelProps } from './TreeMapLabel';\nimport { TreeMapRect, TreeMapRectProps } from './TreeMapRect';\nimport invert from 'invert-color';\nimport chroma from 'chroma-js';\nimport { DEFAULT_TRANSITION } from '../common/Motion';\n\nexport interface TreeMapSeriesProps {\n  /**\n   * Id set by the parent.\n   */\n  id: string;\n\n  /**\n   * The internal data object built by d3\n   */\n  data: any[];\n\n  /**\n   * Whether the chart is animated or not.\n   */\n  animated?: boolean;\n\n  /**\n   * Color scheme for the chart.\n   */\n  colorScheme: ColorSchemeType;\n\n  /**\n   * Rect element to be rendered.\n   */\n  rect?: ReactElement<TreeMapRectProps, typeof TreeMapRect>;\n\n  /**\n   * Label element to be rendered.\n   */\n  label?: ReactElement<TreeMapLabelProps, typeof TreeMapLabel>;\n}\n\nexport const TreeMapSeries: FC<Partial<TreeMapSeriesProps>> = ({\n  id,\n  data,\n  colorScheme,\n  animated,\n  rect,\n  label\n}) => {\n  const transition = animated ? DEFAULT_TRANSITION : { type: false, delay: 0 };\n\n  const renderItem = (item: any, index: number) => {\n    const fill = getColor({\n      data,\n      colorScheme,\n      point: item.data,\n      index\n    });\n\n    const textFill = fill\n      ? invert(chroma(fill).darken(0.5).hex(), true)\n      : 'white';\n\n    return (\n      <motion.g\n        key={item.data.key}\n        initial={{\n          scale: 0.5,\n          opacity: 0,\n          x: item.x0,\n          y: item.y0\n        }}\n        animate={{\n          scale: 1,\n          opacity: 1,\n          x: item.x0,\n          y: item.y0\n        }}\n        transition={transition}\n      >\n        <CloneElement<TreeMapRectProps>\n          element={rect}\n          id={`${id}-${item.data.key}-rect`}\n          animated={animated}\n          data={item}\n          fill={fill}\n        />\n        <CloneElement<TreeMapLabelProps>\n          element={label}\n          id={`${id}-${item.data.key}-label`}\n          data={item}\n          fill={textFill}\n        />\n      </motion.g>\n    );\n  };\n\n  return <Fragment>{data.map((d, index) => renderItem(d, index))}</Fragment>;\n};\n\nTreeMapSeries.defaultProps = {\n  colorScheme: 'cybertron',\n  animated: true,\n  rect: <TreeMapRect />,\n  label: <TreeMapLabel />\n};\n","import React, { FC, ReactElement, useCallback } from 'react';\nimport {\n  ChartContainer,\n  ChartContainerChildProps,\n  ChartProps\n} from '../common/containers/ChartContainer';\nimport { ChartNestedDataShape, ChartShallowDataShape } from '../common/data';\nimport { hierarchy, treemap, treemapSquarify } from 'd3-hierarchy';\nimport { TreeMapSeries, TreeMapSeriesProps } from './TreeMapSeries';\nimport { CloneElement } from 'reablocks';\n\nexport interface TreeMapProps extends ChartProps {\n  /**\n   * Data the chart will receive to render.\n   */\n  data: ChartShallowDataShape[] | ChartNestedDataShape[];\n\n  /**\n   * The series component that renders the components.\n   */\n  series?: ReactElement<TreeMapSeriesProps, typeof TreeMapSeries>;\n\n  /**\n   * Inner padding for the treemap. Defaults to 5.\n   */\n  paddingInner?: number;\n\n  /**\n   * Outer padding for the treemap. Defaults to 5.\n   */\n  paddingOuter?: number;\n\n  /**\n   * Padding top for the treemap. This is used for the title\n   * spacing in nested situations. Defaults to 30.\n   */\n  paddingTop?: number;\n}\n\nexport const TreeMap: FC<Partial<TreeMapProps>> = ({\n  data,\n  id,\n  containerClassName,\n  paddingInner,\n  paddingTop,\n  paddingOuter,\n  width,\n  height,\n  className,\n  margins,\n  series\n}) => {\n  const getData = useCallback(\n    (cw: number, ch: number) => {\n      const root = hierarchy<any>({ data: data }, (d) => d.data)\n        .sum((d) => d.data)\n        .sort((a, b) => b.data - a.data);\n\n      const t = treemap()\n        .size([cw, ch])\n        .tile(treemapSquarify)\n        .round(true)\n        .paddingInner(paddingInner)\n        .paddingOuter(paddingOuter)\n        .paddingTop(paddingTop);\n\n      const tree = t(root);\n      const nodes = [];\n\n      const getAllNodes = (node) => {\n        if (node?.parent) {\n          // Don't add root node\n          nodes.push(node);\n        }\n        for (let child of node?.children || []) {\n          getAllNodes(child);\n        }\n      };\n\n      getAllNodes(tree);\n      return nodes;\n    },\n    [data, paddingInner, paddingOuter, paddingTop]\n  );\n\n  const renderChart = useCallback(\n    ({ chartWidth, chartHeight, ...rest }: ChartContainerChildProps) => {\n      const datas = getData(chartWidth, chartHeight);\n      return (\n        <CloneElement<TreeMapSeriesProps>\n          element={series}\n          {...rest}\n          id={`${id || rest.id}-series`}\n          data={datas}\n        />\n      );\n    },\n    [series, getData, id]\n  );\n\n  return (\n    <ChartContainer\n      id={id}\n      width={width}\n      height={height}\n      containerClassName={containerClassName}\n      margins={margins}\n      xAxisVisible={false}\n      yAxisVisible={false}\n      className={className}\n    >\n      {renderChart}\n    </ChartContainer>\n  );\n};\n\nTreeMap.defaultProps = {\n  margins: 0,\n  paddingInner: 5,\n  paddingOuter: 5,\n  paddingTop: 30,\n  series: <TreeMapSeries />,\n  data: []\n};\n","import React, { FC, useCallback } from 'react';\nimport {\n  ChartInternalDataTypes,\n  ChartShallowDataShape,\n  ColorSchemeType,\n  DEFAULT_TRANSITION,\n  formatValue,\n  getAriaLabel,\n  getColor\n} from '../common';\nimport { motion } from 'framer-motion';\nimport classNames from 'classnames';\nimport css from './BarListSeries.module.css';\n\nexport type BarListLabelPosition = 'none' | 'top' | 'start' | 'end' | 'bottom';\n\nexport interface BarListSeriesProps {\n  /**\n   * Data for the chart.\n   */\n  data?: ChartShallowDataShape[];\n\n  /**\n   * Color scheme for the chart.\n   */\n  colorScheme?: ColorSchemeType;\n\n  /**\n   * The label position.\n   */\n  labelPosition?: BarListLabelPosition;\n\n  /**\n   * The value position.\n   */\n  valuePosition?: BarListLabelPosition;\n\n  /**\n   * The bar item class name.\n   */\n  itemClassName?: string;\n\n  /**\n   * Label css class name.\n   */\n  labelClassName?: string;\n\n  /**\n   * Label value class name.\n   */\n  valueClassName?: string;\n\n  /**\n   * Bar component class name.\n   */\n  barClassName?: string;\n\n  /**\n   * Bar container class name.\n   */\n  outerBarClassName?: string;\n\n  /**\n   * Custom label format.\n   */\n  labelFormat?: (data: ChartInternalDataTypes, index: number) => any;\n\n  /**\n   * Custom value format\n   */\n  valueFormat?: (data: ChartInternalDataTypes, index: number) => any;\n\n  /**\n   * Item was clicked.\n   */\n  onItemClick?: (data: ChartShallowDataShape) => void;\n\n  /**\n   * Item had mouse enter.\n   */\n  onItemMouseEnter?: (data: ChartShallowDataShape) => void;\n\n  /**\n   * Item had mouse leave.\n   */\n  onItemMouseLeave?: (data: ChartShallowDataShape) => void;\n}\n\nexport const BarListSeries: FC<Partial<BarListSeriesProps>> = ({\n  data,\n  colorScheme,\n  itemClassName,\n  labelClassName,\n  outerBarClassName,\n  valueClassName,\n  labelFormat,\n  barClassName,\n  labelPosition,\n  valuePosition,\n  valueFormat,\n  onItemClick,\n  onItemMouseEnter,\n  onItemMouseLeave\n}) => {\n  const renderBar = useCallback(\n    (item, index) => {\n      const fill = getColor({\n        data,\n        colorScheme,\n        point: item.data,\n        index\n      });\n\n      return (\n        <div className={classNames(css.outerBar, outerBarClassName)}>\n          <motion.div\n            transition={DEFAULT_TRANSITION}\n            className={classNames(css.bar, barClassName)}\n            initial={{ width: '0%' }}\n            animate={{ width: `${item.data}%` }}\n            style={{ background: fill }}\n            tabIndex={0}\n            aria-label={getAriaLabel(item)}\n            role=\"graphics-document\"\n          />\n        </div>\n      );\n    },\n    [barClassName, outerBarClassName, colorScheme, data]\n  );\n\n  return (\n    <>\n      {data.map((d, i) => {\n        const label = labelFormat ? labelFormat(d.key as any, i) : d.key;\n\n        const valueLabel = valueFormat\n          ? valueFormat(d.metadata.value, i)\n          : formatValue(d.metadata.value);\n\n        return (\n          <div\n            key={d.key as string}\n            role=\"listitem\"\n            className={classNames(css.item, itemClassName, {\n              [css.clickable]: onItemClick,\n              [css.valueBottom]: valuePosition === 'bottom',\n              [css.valueStart]: valuePosition === 'start',\n              [css.valueEnd]: valuePosition === 'end',\n              [css.valueNone]: valuePosition === 'none',\n              [css.labelBottom]: labelPosition === 'bottom',\n              [css.labelTop]: labelPosition === 'top',\n              [css.labelStart]: labelPosition === 'start',\n              [css.labelEnd]: labelPosition === 'end',\n              [css.labelNone]: labelPosition === 'none'\n            })}\n            onMouseEnter={() => onItemMouseEnter?.(d)}\n            onMouseLeave={() => onItemMouseLeave?.(d)}\n            onClick={() => onItemClick?.(d)}\n          >\n            <label title={label} className={classNames(css.label, labelClassName)}>\n              {label}\n            </label>\n            {renderBar(d, i)}\n            <label\n              title={valueLabel}\n              className={classNames(css.valueLabel, valueClassName)}\n            >\n              <small>{valueLabel}</small>\n            </label>\n          </div>\n        );\n      })}\n    </>\n  );\n};\n\nBarListSeries.defaultProps = {\n  colorScheme: 'cybertron',\n  labelPosition: 'top',\n  valuePosition: 'none'\n};\n","import { max } from 'd3-array';\nimport { scaleLinear } from 'd3-scale';\nimport { motion } from 'framer-motion';\nimport { CloneElement, useId } from 'reablocks';\nimport React, { FC, ReactElement, useMemo } from 'react';\nimport { ChartShallowDataShape } from '../common';\nimport { BarListSeries, BarListSeriesProps } from './BarListSeries';\n\nexport interface BarListProps {\n  /**\n   * ID for the chart.\n   */\n  id?: string;\n\n  /**\n   * CSS Classname for the element.\n   */\n  className?: string;\n\n  /**\n   * Style for the element.\n   */\n  style?: React.CSSProperties;\n\n  /**\n   * Data for the chart.\n   */\n  data: ChartShallowDataShape[];\n\n  /**\n   * Sort direction of the data.\n   */\n  sortDirection?: 'asc' | 'desc' | 'none';\n\n  /**\n   * Series to render.\n   */\n  series?: ReactElement<BarListSeriesProps, typeof BarList>;\n\n  /**\n   * Whether the values are percentages or absolute values.\n   * In the latter case, the chart would be relative\n   */\n  type?: 'percent' | 'count';\n}\n\nexport const BarList: FC<BarListProps> = ({\n  data,\n  id,\n  className,\n  sortDirection,\n  style,\n  series,\n  type\n}) => {\n  const curId = useId(id);\n\n  const mashedData = useMemo(() => {\n    const maxVal = type === 'count' ? max(data, (d) => d.data) : 100;\n    const domainVal = maxVal == 0 ? [0] : [0, maxVal];\n    const groupScale = scaleLinear().domain(domainVal).rangeRound([0, 100]);\n\n    const mashed = data.map((d) => ({\n      ...d,\n      data: groupScale(d.data as number),\n      metadata: {\n        value: d.data,\n        percent: (data.length * (d.data as number)) / 100\n      }\n    }));\n\n    if (sortDirection === 'asc') {\n      mashed.sort((a, b) => a.data - b.data);\n    } else if (sortDirection === 'desc') {\n      mashed.sort((a, b) => b.data - a.data);\n    }\n\n    return mashed;\n  }, [data, sortDirection]);\n\n  return (\n    <motion.section\n      role=\"list\"\n      variants={{\n        initial: {\n          transition: {\n            staggerChildren: 0.05,\n            staggerDirection: -1 as any\n          }\n        },\n        animate: {\n          transition: {\n            staggerChildren: 0.07,\n            delayChildren: 0.2\n          }\n        }\n      }}\n      id={curId}\n      className={className}\n      style={style}\n    >\n      <CloneElement<BarListSeriesProps> element={series} data={mashedData} />\n    </motion.section>\n  );\n};\n\nBarList.defaultProps = {\n  data: [],\n  sortDirection: 'desc',\n  series: <BarListSeries />,\n  type: 'count'\n};\n","import React, { FC } from 'react';\nimport { motion } from 'framer-motion';\nimport { DEFAULT_TRANSITION, schemes } from '../common';\n\nexport interface MeterColumnProps {\n  /**\n   * The value of the meter.\n   */\n  value: number;\n\n  /**\n   * The height of the column.\n   */\n  height?: number;\n\n  /**\n   * The index of the column.\n   */\n  index: number;\n\n  /**\n   * The scale to use.\n   */\n  scale: any;\n\n  /**\n   * The active fill color.\n   */\n  activeFill: string;\n\n  /**\n   * The inactive fill color.\n   */\n  inActiveFill: string;\n\n  /**\n   * Additional class names to apply.\n   */\n  className?: string;\n\n  /**\n   * The total number of columns. Set internally.\n   */\n  count?: number;\n\n  /**\n   * Whether to animate the column.\n   */\n  animated?: boolean;\n}\n\nexport const MeterColumn: FC<Partial<MeterColumnProps>> = ({\n  index,\n  scale,\n  value,\n  count,\n  height,\n  className,\n  animated,\n  activeFill,\n  inActiveFill\n}) => {\n  const isActive = scale(index) <= scale(value);\n  const fill = isActive ? activeFill : inActiveFill;\n  const transition = animated\n    ? {\n      ...DEFAULT_TRANSITION,\n      delay: (index / count) * 0.5\n    }\n    : {\n      type: false,\n      delay: 0\n    };\n\n  return (\n    <motion.div\n      key={index}\n      initial={{\n        background: inActiveFill,\n        height\n      }}\n      animate={{\n        background: fill,\n        height\n      }}\n      tranisition={transition}\n      className={className}\n    />\n  );\n};\n\nMeterColumn.defaultProps = {\n  activeFill: schemes.cybertron[0],\n  inActiveFill: '#414242',\n  height: 32,\n  animated: true\n};\n","import React, { FC, ReactElement } from 'react';\nimport { scaleLinear } from 'd3-scale';\nimport classNames from 'classnames';\nimport { MeterColumn, MeterColumnProps } from './MeterColumn';\nimport { CloneElement } from 'reablocks';\nimport css from './Meter.module.css';\n\nexport interface MeterProps {\n  /**\n   * The value of the meter.\n   */\n  value: number;\n\n  /**\n   * The minimum value of the meter.\n   */\n  min?: number;\n\n  /**\n   * The maximum value of the meter.\n   */\n  max?: number;\n\n  /**\n   * The number of columns to display.\n   */\n  columns?: number;\n\n  /**\n   * Additional class names to apply.\n   */\n  className?: string;\n\n  /**\n   * The gap between columns.\n   */\n  gap?: number;\n\n  /**\n   * Additional styles to apply.\n   */\n  style?: React.CSSProperties;\n\n  /**\n   * The column to render.\n   */\n  column: ReactElement<MeterColumnProps, typeof MeterColumn> | null;\n}\n\nexport const Meter: FC<Partial<MeterProps>> = ({\n  min,\n  max,\n  className,\n  column,\n  gap,\n  style,\n  value,\n  columns\n}) => {\n  const scale = scaleLinear().domain([min, max]).range([0, 100]);\n  const cols = scale.ticks(columns);\n\n  return (\n    <div\n      className={classNames(css.container, className)}\n      style={{ gap: `${gap}px`, ...style }}\n    >\n      {cols.map((index) => (\n        <CloneElement<MeterColumnProps>\n          element={column}\n          key={index}\n          count={cols.length}\n          index={index}\n          scale={scale}\n          value={value}\n        />\n      ))}\n    </div>\n  );\n};\n\nMeter.defaultProps = {\n  min: 0,\n  max: 100,\n  columns: 10,\n  gap: 15,\n  style: {},\n  column: <MeterColumn />\n};\n","import React, { FC } from 'react';\nimport { ChartNestedDataShape } from '../common/data';\nimport {\n  RadialAreaChart,\n  RadialAreaChartProps,\n  RadialAreaSeries,\n  RadialAreaSeriesProps,\n  RadialPointSeries\n} from '../RadialAreaChart';\nimport {\n  RadialAxis,\n  RadialAxisArcLine,\n  RadialAxisArcSeries\n} from '../common/Axis/RadialAxis';\n\nexport interface RadarChartSeriesProps extends RadialAreaSeriesProps {}\n\nexport const RadarChartSeries: FC<Partial<RadarChartSeriesProps>> = (props) => (\n  <RadialAreaSeries {...props} />\n);\n\nRadarChartSeries.defaultProps = {\n  area: null,\n  type: 'grouped',\n  symbols: <RadialPointSeries show />\n};\n","import React, { FC } from 'react';\nimport { ChartNestedDataShape } from '../common/data';\nimport { RadialAreaChart, RadialAreaChartProps } from '../RadialAreaChart';\nimport {\n  RadialAxis,\n  RadialAxisArcLine,\n  RadialAxisArcSeries\n} from '../common/Axis/RadialAxis';\nimport { RadarChartSeries } from './RadarChartSeries';\n\nexport interface RadarChartProps extends RadialAreaChartProps {\n  data: ChartNestedDataShape[];\n}\n\nexport const RadarChart: FC<Partial<RadarChartProps>> = (props) => (\n  <RadialAreaChart {...props} />\n);\n\nRadarChart.defaultProps = {\n  series: <RadarChartSeries />,\n  axis: (\n    <RadialAxis\n      type=\"category\"\n      arcs={\n        <RadialAxisArcSeries\n          count={5}\n          arc={null}\n          line={<RadialAxisArcLine />}\n        />\n      }\n    />\n  )\n};\n","import React, { FC, ReactElement, useMemo } from 'react';\nimport { ChartShallowDataShape } from '../../common/data';\nimport { area } from 'd3-shape';\nimport {\n  InterpolationTypes,\n  getAriaLabel,\n  interpolate\n} from '../../common/utils';\nimport { ColorSchemeType, getColor, schemes } from '../../common/color';\nimport { Gradient, GradientProps, GradientStop } from '../../common/Gradient';\nimport { CloneElement } from 'reablocks';\nimport { motion } from 'framer-motion';\nimport {\n  ChartTooltip,\n  TooltipArea,\n  TooltipAreaProps,\n  TooltipTemplate\n} from '../../common/Tooltip';\nimport { Glow } from '../../common';\nimport { generateGlowStyles } from '../../common/Glow/utils';\n\nexport interface FunnelArcProps {\n  /**\n   * Unique identifier for the arc. Set internally by `FunnelChart`.\n   */\n  id: string;\n\n  /**\n   * Data to render the funnel. Set internally by `FunnelChart`.\n   */\n  data: ChartShallowDataShape[];\n\n  /**\n   * Opacity of the funnel arc.\n   */\n  opacity?: number;\n\n  /**\n   * Index of the funnel arc. Set internally by `FunnelChart`.\n   */\n  index?: number;\n\n  /**\n   * The chart funnel style to use.\n   */\n  variant?: 'default' | 'layered';\n\n  /**\n   * xScale for the funnel. Set internally by `FunnelChart`.\n   */\n  xScale: any;\n\n  /**\n   * yScale for the funnel. Set internally by `FunnelChart`.\n   */\n  yScale: any;\n\n  /**\n   * Interpolation for the area. Set internally by `AreaSeries`.\n   */\n  interpolation: InterpolationTypes;\n\n  /**\n   * Color scheme for the chart.\n   */\n  colorScheme: ColorSchemeType;\n\n  /**\n   * Gradient to apply to the area.\n   */\n  gradient: ReactElement<GradientProps, typeof Gradient> | null;\n\n  /**\n   * Glow styling for the arc.\n   */\n  glow?: Glow;\n\n  /**\n   * Tooltip for the chart area.\n   */\n  tooltip: ReactElement<TooltipAreaProps, typeof TooltipArea>;\n}\n\nexport const FunnelArc: FC<Partial<FunnelArcProps>> = ({\n  data,\n  id,\n  xScale,\n  opacity,\n  index,\n  variant,\n  yScale,\n  interpolation,\n  colorScheme,\n  gradient,\n  glow,\n  tooltip\n}) => {\n  // Note: Need to append the last section\n  const internalData = [...data, data[data.length - 1]];\n\n  const areaGenerator = area()\n    .curve(interpolate(interpolation))\n    .x((_d, i) => xScale(i))\n    .y0(yScale(0))\n    .y1(({ data }: any) => yScale(data));\n\n  const areaMirrorGenerator = area()\n    .curve(interpolate(interpolation))\n    .x((_d, i) => xScale(i))\n    .y0(yScale(0))\n    .y1(({ data }: any) => yScale(-data));\n\n  const fillColor = getColor({\n    data,\n    domain: [0, 1, 2, 3],\n    colorScheme,\n    key: index\n  });\n\n  const fillTop = gradient ? `url(#gradient-${id}-top)` : fillColor;\n  const fillBottom = gradient ? `url(#gradient-${id}-bottom)` : fillColor;\n\n  const [height] = yScale.range();\n  const [_, width] = xScale.range();\n\n  const ariaLabelData = useMemo(() => getAriaLabel(data), [data]);\n\n  return (\n    <CloneElement<TooltipAreaProps>\n      element={tooltip}\n      xScale={xScale}\n      yScale={yScale}\n      data={data as any}\n      height={height}\n      width={width}\n      tooltip={\n        <ChartTooltip\n          followCursor\n          content={(data, color) => {\n            const value = {\n              x: data.key,\n              y: data.data,\n              value: data.data\n            };\n\n            return <TooltipTemplate value={value} color={color} />;\n          }}\n        />\n      }\n    >\n      <g\n        pointerEvents={tooltip ? 'none' : 'auto'}\n        style={generateGlowStyles({ glow })}\n        aria-label={ariaLabelData}\n        role=\"graphics-document\"\n      >\n        <motion.path\n          d={areaGenerator(internalData as any[])}\n          fill={fillTop}\n          stroke=\"none\"\n          initial={{\n            opacity: 0\n          }}\n          animate={{\n            opacity\n          }}\n        />\n        <motion.path\n          d={areaMirrorGenerator(internalData as any[])}\n          fill={fillBottom}\n          stroke=\"none\"\n          initial={{\n            opacity: 0\n          }}\n          animate={{\n            opacity\n          }}\n        />\n        {gradient && (\n          <>\n            <CloneElement<GradientProps>\n              element={gradient}\n              id={`gradient-${id}-top`}\n              color={fillColor}\n            />\n            <CloneElement<GradientProps>\n              element={gradient}\n              id={`gradient-${id}-bottom`}\n              color={fillColor}\n            />\n          </>\n        )}\n      </g>\n    </CloneElement>\n  );\n};\n\nFunnelArc.defaultProps = {\n  gradient: (\n    <Gradient\n      direction=\"horizontal\"\n      stops={[\n        <GradientStop offset=\"0%\" stopOpacity={1} key=\"stop\" />,\n        <GradientStop offset=\"80%\" stopOpacity={0.5} key=\"start\" />\n      ]}\n    />\n  ),\n  interpolation: 'smooth',\n  colorScheme: schemes.cybertron[0],\n  animated: true,\n  variant: 'default',\n  opacity: 1,\n  tooltip: null\n};\n","import React, { FC, useCallback } from 'react';\nimport { ChartShallowDataShape } from '../../../common/data';\nimport {\n  calculateDimensions,\n  formatValue,\n  wrapText\n} from '../../../common/utils';\nimport { motion } from 'framer-motion';\n\nexport interface FunnelAxisLabelProps {\n  /**\n   * Data object for the label. Set internally by `FunnelAxis`.\n   */\n  data: ChartShallowDataShape;\n\n  /**\n   * Index of the label. Set internally by `FunnelAxis`.\n   */\n  index: number;\n\n  /**\n   * Color of the text.\n   */\n  fill: string;\n\n  /**\n   * Font size of the text.\n   */\n  fontSize: number;\n\n  /**\n   * Font family of the text.\n   */\n  fontFamily: string;\n\n  /**\n   * Padding of the label.\n   */\n  padding?: number;\n\n  /**\n   * Class name to apply to the text.\n   */\n  className?: string;\n\n  /**\n   * xScale for the funnel. Set internally by `FunnelAxis`.\n   */\n  xScale: any;\n\n  /**\n   * yScale for the funnel. Set internally by `FunnelAxis`.\n   */\n  yScale: any;\n\n  /**\n   * Positioning of the label.\n   */\n  position?: 'top' | 'middle' | 'bottom';\n\n  /**\n   * Whether to show the value of the data.\n   * Defaults to `true`.\n   */\n  showValue?: boolean;\n\n  /**\n   * Visibility of the label.\n   */\n  labelVisibility?: 'auto' | 'always';\n}\n\nexport const FunnelAxisLabel: FC<Partial<FunnelAxisLabelProps>> = ({\n  data,\n  index,\n  xScale,\n  yScale,\n  fontFamily,\n  padding,\n  fontSize,\n  fill,\n  className,\n  position,\n  showValue,\n  labelVisibility\n}) => {\n  const x = xScale(index) + padding;\n  const [height] = yScale.range();\n  const y = height / 2 + padding;\n  const label = data.key as string;\n  const nextOffset = xScale(index + 1);\n  const width = (nextOffset ? nextOffset - xScale(index) : 0) - padding;\n  const size = calculateDimensions(label, fontFamily, fontSize);\n  const text = wrapText({\n    key: label,\n    size,\n    paddingY: padding,\n    paddingX: padding,\n    width,\n    height,\n    fontFamily,\n    fontSize,\n    visibility: labelVisibility\n  });\n\n  const getTransformString = useCallback(() => {\n    let transform: string;\n\n    switch (position) {\n    case 'top':\n      transform = `translate(${x}, ${fontSize * 3})`; // fontSize * 3 is to account for the total height of the label\n      break;\n    case 'middle':\n      transform = `translate(${x}, ${y})`;\n      break;\n    case 'bottom':\n      {\n        // If the text is wrapping, we need to account for the height of all the lines\n        const textWrapHeight = Array.isArray(text)\n          ? text.slice(1).reduce((acc, curr) => acc + curr.props.dy, 0) // Don't include first line's dy in order to align properly\n          : 0;\n        transform = `translate(${x}, ${height - padding - textWrapHeight})`;\n      }\n      break;\n    }\n\n    return transform;\n  }, [position, x, fontSize, y, text, height, padding]);\n\n  // If the labels don't fit, just hide them\n  if (labelVisibility !== 'always' && size.width > width) {\n    return null;\n  }\n\n  return (\n    <motion.g\n      transform={getTransformString()}\n      initial={{ opacity: 0 }}\n      animate={{ opacity: 1 }}\n    >\n      {showValue && (\n        <text\n          pointerEvents=\"none\"\n          fill={fill}\n          y={-(fontSize + padding)}\n          className={className}\n          dominantBaseline=\"middle\"\n          fontFamily={fontFamily}\n          fontSize={fontSize * 2}\n        >\n          {formatValue(data.data as any)}\n        </text>\n      )}\n      <text\n        pointerEvents=\"none\"\n        fill={fill}\n        className={className}\n        dominantBaseline=\"middle\"\n        fontFamily={fontFamily}\n        fontSize={fontSize}\n      >\n        {text}\n      </text>\n    </motion.g>\n  );\n};\n\nFunnelAxisLabel.defaultProps = {\n  fontSize: 13,\n  padding: 10,\n  fontFamily: 'sans-serif',\n  fill: '#fff',\n  position: 'middle',\n  showValue: true,\n  labelVisibility: 'auto'\n};\n","import React, { FC } from 'react';\n\nexport interface FunnelAxisLineProps {\n  /**\n   * Color of the axis lines.\n   */\n  strokeColor: string;\n\n  /**\n   * Width of the axis lines.\n   */\n  strokeWidth: number;\n\n  /**\n   * xScale for the funnel. Set internally by `FunnelChart`.\n   */\n  xScale: any;\n\n  /**\n   * yScale for the funnel. Set internally by `FunnelChart`.\n   */\n  yScale: any;\n\n  /**\n   * Index of the line. Set internally by `FunnelAxis`.\n   */\n  index: number;\n}\n\nexport const FunnelAxisLine: FC<Partial<FunnelAxisLineProps>> = ({\n  strokeColor,\n  strokeWidth,\n  yScale,\n  xScale,\n  index\n}) => {\n  const [height] = yScale.range();\n\n  return (\n    <line\n      x1={xScale(index)}\n      y1={0}\n      x2={xScale(index)}\n      y2={height}\n      stroke={strokeColor}\n      strokeWidth={strokeWidth}\n      pointerEvents=\"none\"\n    />\n  );\n};\n\nFunnelAxisLine.defaultProps = {\n  strokeColor: '#333',\n  strokeWidth: 2\n};\n","import React, { FC, Fragment, ReactElement } from 'react';\nimport { ChartShallowDataShape } from '../../../common/data';\nimport { range } from 'd3-array';\nimport { FunnelAxisLabel, FunnelAxisLabelProps } from './FunnelAxisLabel';\nimport { CloneElement } from 'reablocks';\nimport { FunnelAxisLine, FunnelAxisLineProps } from './FunnelAxisLine';\n\nexport interface FunnelAxisProps {\n  /**\n   * Data to render the funnel. Set internally by `FunnelChart`.\n   */\n  data: ChartShallowDataShape[];\n\n  /**\n   * xScale for the funnel. Set internally by `FunnelChart`.\n   */\n  xScale: any;\n\n  /**\n   * yScale for the funnel. Set internally by `FunnelChart`.\n   */\n  yScale: any;\n\n  /**\n   * The funnel axis line.\n   */\n  line?: ReactElement<FunnelAxisLineProps, typeof FunnelAxisLine> | null;\n\n  /**\n   * Label component for the axis.\n   */\n  label?: ReactElement<FunnelAxisLabelProps, typeof FunnelAxisLabel> | null;\n}\n\nexport const FunnelAxis: FC<Partial<FunnelAxisProps>> = ({\n  data,\n  xScale,\n  yScale,\n  line,\n  label\n}) => {\n  const lines = range(0, data.length);\n\n  return (\n    <>\n      {lines.map((index) => (\n        <Fragment key={index}>\n          {line && index !== 0 && (\n            <CloneElement<FunnelAxisLineProps>\n              element={line}\n              index={index}\n              xScale={xScale}\n              yScale={yScale}\n            />\n          )}\n          {label && (\n            <CloneElement<FunnelAxisLabelProps>\n              element={label}\n              index={index}\n              data={data[index]}\n              xScale={xScale}\n              yScale={yScale}\n            />\n          )}\n        </Fragment>\n      ))}\n    </>\n  );\n};\n\nFunnelAxis.defaultProps = {\n  label: <FunnelAxisLabel />,\n  line: <FunnelAxisLine />\n};\n","import React, { MouseEvent, useCallback, useMemo } from 'react';\nimport { FunnelArc } from './FunnelArc';\nimport { CloneElement } from 'reablocks';\nimport { FunnelArcProps } from './FunnelArc';\nimport { FunnelAxis, FunnelAxisProps } from './FunnelAxis';\nimport {\n  ChartShallowDataShape,\n  getClosestContinousScalePoint,\n  getPositionForTarget\n} from '../../common';\nimport { ClickEvent } from '../../common/types';\nimport { scaleLinear } from 'd3-scale';\nimport { max } from 'd3-array';\n\nexport interface FunnelSeriesProps {\n  /**\n   * Parsed data shape. Set internally by `FunnelChart`.\n   */\n  data: ChartShallowDataShape[];\n\n  /**\n   * Id of the funnel chart. Set internally by `FunnelChart`.\n   */\n  id: string;\n\n  /**\n   * The arc component that renders the funnel shape.\n   */\n  arc: React.ReactElement<FunnelArcProps, typeof FunnelArc>;\n\n  /**\n   * The axis component that renders the funnel axis.\n   */\n  axis: React.ReactElement<FunnelAxisProps, typeof FunnelAxis>;\n\n  /**\n   * Height of the chart. Set internally by `FunnelChart`.\n   */\n  height: number;\n\n  /**\n   * Width of the chart. Set internally by `FunnelChart`.\n   */\n  width: number;\n\n  /**\n   * Event for when a segment is clicked.\n   */\n  onSegmentClick?: (e: ClickEvent) => void;\n}\n\nexport const FunnelSeries: React.FC<Partial<FunnelSeriesProps>> = ({\n  data,\n  id,\n  arc,\n  axis,\n  height,\n  width,\n  onSegmentClick\n}) => {\n  // Calculate the funnel data on mount and when data changes\n  const getScales = useCallback(\n    (height: number, width: number) => {\n      const yScale = scaleLinear()\n        .domain([-max(data, ({ data }) => data), max(data, ({ data }) => data)])\n        .nice()\n        .range([height, 0]);\n\n      const xScale = scaleLinear().domain([0, data.length]).range([0, width]);\n\n      const transformedData = data.map((d, i) => ({\n        ...d,\n        key: d.key,\n        x: xScale(i),\n        i\n      }));\n\n      return {\n        data: transformedData,\n        yScale,\n        xScale\n      };\n    },\n    [data]\n  );\n\n  const { datas, halfOffset } = useMemo(() => {\n    // The 'layered' variant is actually just a series of funnel charts\n    // laid on top of each other to create the effect of a layered funnel.\n    if (arc.props.variant === 'layered') {\n      const offset = height / 4;\n      const halfOffset = offset / 2;\n\n      return {\n        halfOffset,\n        datas: [\n          { data, ...getScales(height, width) },\n          { data, ...getScales(height - offset, width) },\n          { data, ...getScales(height - offset * 2, width) }\n        ]\n      };\n    } else {\n      return {\n        halfOffset: 0,\n        datas: [{ data, ...getScales(height, width) }]\n      };\n    }\n  }, [data, arc, height, width, getScales]);\n\n  const handleSegmentClick = useCallback(\n    (e: MouseEvent) => {\n      if (onSegmentClick) {\n        const { xScale, data } = datas[0];\n        const { clientX, clientY, target } = e;\n        const position = getPositionForTarget({ target, clientX, clientY });\n        const value = getClosestContinousScalePoint({\n          pos: position.x,\n          scale: xScale,\n          data,\n          attr: 'i'\n        });\n\n        onSegmentClick({\n          value: { key: value.key, data: value.data },\n          nativeEvent: e\n        });\n      }\n    },\n    [datas, onSegmentClick]\n  );\n\n  return (\n    <>\n      {datas.map((d, i) => (\n        <g\n          key={i}\n          style={{ transform: `translate(0, ${i * halfOffset}px)` }}\n          onClick={handleSegmentClick}\n        >\n          <CloneElement<FunnelArcProps>\n            element={arc}\n            {...d}\n            id={`${id}-arc-${i}`}\n            index={i}\n          />\n        </g>\n      ))}\n      <CloneElement<FunnelAxisProps>\n        element={axis}\n        data={data}\n        xScale={datas[0].xScale}\n        yScale={datas[0].yScale}\n      />\n    </>\n  );\n};\n\nFunnelSeries.defaultProps = {\n  arc: <FunnelArc />,\n  axis: <FunnelAxis />\n};\n","import React, { FC, ReactElement, useCallback } from 'react';\nimport { CloneElement, useId } from 'reablocks';\nimport {\n  ChartContainer,\n  ChartContainerChildProps,\n  ChartProps\n} from '../common/containers';\nimport { ChartShallowDataShape } from '../common/data';\nimport { FunnelSeries, FunnelSeriesProps } from './FunnelSeries/FunnelSeries';\n\nexport interface FunnelChartProps extends ChartProps {\n  /**\n   * Chart shape used to render the funnel.\n   */\n  data: ChartShallowDataShape[];\n\n  /**\n   * The series component that renders the funnel components.\n   */\n  series: ReactElement<FunnelSeriesProps, typeof FunnelSeries>;\n}\n\nexport const FunnelChart: FC<Partial<FunnelChartProps>> = ({\n  data,\n  width,\n  margins,\n  height,\n  className,\n  containerClassName,\n  series,\n  ...rest\n}) => {\n  const id = useId(rest.id);\n\n  const renderChart = useCallback(\n    ({ id, chartWidth, chartHeight, chartSized }: ChartContainerChildProps) => {\n      if (!chartSized) {\n        return null;\n      }\n\n      return (\n        <CloneElement<FunnelSeriesProps>\n          element={series}\n          id={`funnel-series-${id}`}\n          data={data}\n          height={chartHeight}\n          width={chartWidth}\n        />\n      );\n    },\n    [data, series]\n  );\n\n  return (\n    <ChartContainer\n      id={id}\n      width={width}\n      height={height}\n      margins={margins}\n      containerClassName={containerClassName}\n      className={className}\n    >\n      {renderChart}\n    </ChartContainer>\n  );\n};\n\nFunnelChart.defaultProps = {\n  margins: 0,\n  series: <FunnelSeries />\n};\n"],"mappings":"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;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EC5OA;AAMA,MAAMw/C,EAAA;EAMN/nD,CAAA,MAAS;EACAC,CAAA;EACTlE,KAAA;EAMAD,MAAA,EAAS;AACC;AAGV,MAAAksD,KAAA;EAKA9B,IAAA;EACQ+B,aAAM;EACZF;AAEO;AAAA,MACLG,MAAA,IAAAC,KAAA,EAAAC,KAAA,EAAAC,KAAA,EAAAC,KAAA,EAAAC,KAAA,EAAAP,KAAA;AAAA,MACAQ,IAAM,GAAAC,KAAA,IAAAvmD,KAAA,CAAA6zB,IAAA;EAAA/0B,MAAA,EAAAynD;AAAA,IAAAlU,CAAA,EAAAxxC,CAAA,KAAAA,CAAA;AAAA,SACN2lD,SAAMA,CAAA5iD,CAAA;EAAe,cAAAA,CAAA,CAAAg7B,EAAA;AAEzB;AAKA,SAAS6nB,YAAUA,CAAAC,KAAa;EAE9B,OAAM,IAAA1mD,KAAA,MAAa0mD,KAChB,CAAA5nD,MAAQ,EAAA1C,IAAQ,GAAA6D,GAAK,EAAA0mD,GAAA,EAAA9lD,CAAA,KACrB6lD,KAAK,CAAC/vB,MAAG,EAAAiwB,GAAQ,EAAA1b,CAAA,KAAOrqC,CAAE,IAAI,IAAAqqC,CAAA;AAGjC;AAGM,SAAA2b,OAAcC,KAAA,EAAAzmD,IAAA,EAAa;EACjC,MAAMD,GAAA,GAAA0mD,KAAA,CAAA3mD,IAAe,KAAK;EAG1B,MAAM4vB,KAAA,GAAA1vB,IAAS,CAAA6hD,IAAA,CAAAt+C,CAAA,IAAaA,CAAA,CAAAxD,GAAA,KAAAA,GAAA;EAAA,OAAK;IAC0CA,GAAA;IAKpE4jD,IAAA,EAAA8C,KAAA;IACL/pD,IAAI,GAAAgzB,KACA,WAAW,SAAAA,KACb,CAAKhzB,IAAE,KAAM;EAAE;AAEqD;AAClE,SACFgqD,UAAA1mD,IAAA;EAAA,MAAA2mD,UAAA,GAAA3mD,IAAA,CAAAs2B,MAAA,CAAA/yB,CAAA,IAAAA,CAAA,CAAAogD,IAAA,CAAAllD,MAAA,QAAA0d,IAAA,EAAA1L,CAAA,EAAAC,CAAA,KAAAA,CAAA,CAAAhU,IAAA,GAAA+T,CAAA,CAAA/T,IAAA;EAIJ,MAAMkqD,aAAY,GAAAD,UAAU,CAAA/mD,GAAM,CAAAinD,CAAA,IAAAA,CAAA,CAAA9mD,GAAA;EAChC,MAAA+mD,KAAM,GAAAV,YAAa,CAAIQ,aAAE;EAAA,MACtBG,YAAS,GAAAD,KAAA,CAAAjwC,KAAc,IAAQiwC,KAAK,CAAAroD,MAAA;EAAuB,MAAAmD,MAAA,GAAAmlD,YAAA,CAAAnnD,GAAA,CAExD2D,CAAA,QAAAA,CAAM,EAAA4Y,IAAA,CAAK,CAAA1L,CAAA,EAAAC,CAAK,KAAGk2C,aAAA,CAAAh4C,OAAA,CAAA6B,CAAA,IAAAm2C,aAAA,CAAAh4C,OAAA,CAAA8B,CAAA,EAElB;EAAA9O,MACL,CAAAua,IAAM,CAAE,CAAA1L,CACR,EAAAC,CAAA,KAAAD,CAAA,CAAAhS,MAAA,GAAAiS,CAAA,CAAAjS,MAAA,IAAAwnD,IAAA,CAAAx1C,CAAA,CAAAhS,MAAA,EAAAsgB,MAAA,CACA,CAAAioC,IAAA,EAAAxmD,CAAA,KAAAwmD,IAAA,IAAAJ,aAAA,CAAAh4C,OAAA,CAAA6B,CAAA,CAAAjQ,CAAA,KAAAomD,aAAA,CAAAh4C,OAAA,CAAA8B,CAAA,CAAAlQ,CAAA,KAEH,CAEM;EAAA,MACLymD,SAAa,GAAAjnD,IAAA,CAAAJ,GAAW,CAAA2D,CAAA;IACxB,MAAM2jD,MAAA,GAAO,IAAK3jD,CAAA,CAAAogD,IAAM,EAAAxnC,IAAO,CAAa,CAAA1L,CAAA,EAAAC,CAAA,KAAAk2C,aAAA,CAAAh4C,OAAA,CAAA6B,CAAA,IAAAm2C,aAAA,CAAAh4C,OAAA,CAAA8B,CAAA,CAEhD;IAMgB,MAAA3Q,GAAA,GAAAmnD,MAAA,CAAApnD,IAAA,IAAqB;IAC5B;MAEGpD,IAAA,EAAA6G,CAAA,CAAA7G,IAAM;MACZinD,IAAM,EAAAuD,MAAK;MACXnnD;IACA;EACO;EAGR,OACA;IACLonD,WAAA,EAAAR,UAAA,CAAAloD,MAAA;IAMAuB,IAAA,EAAS4B,MAAA,CAAAhC,GAAA,CAAY2H,CAAE,IAAAi/C,MAAM,CAAAj/C,CAAA,EAAA0/C,SAAe;EACpC;AACN;AACA,SAAMG,oBAAkBA,CAAAlmD,CAAK,EAAAmmD,IAAI;EACjC,YAAAvuD,MAAA,CAAUoI,CAAA,CAAIzI,EAAC,OAAAK,MAAA,CAAAoI,CAAM,CAAAvI,EAAG,OAAAG,MAAA,CAAAoI,CAAK,CAAAmH,IAAI,CAAAzI,GAAA,CAAAoJ,IAAS,IAAI;IAC9C,MAAM/N,GAAK,GAACosD,IAAc,CAAAr+C,IAAI,CAAA/N,GAAI;IAClC,MAAMsjC,EAAA,GAAM4nB,SAAkB,CAAAlrD,GAAI,IAAAA,GAAA,CAAAsjC,EAAA,GAAAtjC,GAAA,CAAAsM,CAAA;IAElC,MAAMi3B,EAAA,GAAA2nB,SAAY,CAAAlrD,GAAM,IAAKA,GAAI,CAACujC,EAAA,GAAGvjC,GAAA,CAAAsM,CAAO;IAC1C,MAAG+/C,GAAA,GAAAnB,SAAA,CAAAlrD,GAAA,IAAAA,GAAA,CAAAiB,QAAA;IACH,YAAApD,MAAA,CAAGylC,EAAA,OAAAzlC,MAAA,CAAA0lC,EAAA,OAAA1lC,MAAA,CAAAwuD,GAAA,OAAAxuD,MAAA,CAAAkQ,IAAA,CAAAi7C,KAAA,eAAAnrD,MAAA,CAAAkQ,IAAA,CAAAu+C,KAAA,eAAAzuD,MAAA,CAAAkQ,IAAA,CAAAtQ,EAAA,OAAAI,MAAA,CAAAkQ,IAAA,CAAApQ,EAAA;EAAA,GAAAkH,IACD,IAAM;AAAM;AACD,SACX0nD,WAAWA,CAAAC,OAAA,EAAAC,GAAA;EAAA;IAAA1nD,IAAA;IAAAmnD;EAAA,IAAAM,OAAA;EAAA,MACXE,KAAM,GAAAhC,MAAA,CAAAnrD,IAAA,CAAA2R,GAAA,CAAAw5C,MAAA,CAAAlnD,MAAA,MAAA0oD,WAAA;EAAA,MACJvmC,CAAA,GAAGpmB,IAAK,CAAA2R,GAAA,CAAKu7C,GAAC,CAAAluD,KAAA,GAAAmuD,KAAA,CAAAnC,EAAA,CAAAhsD,KAAA,EAAAkuD,GAAA,CAAAnuD,MAAA,GAAAouD,KAAA,CAAAnC,EAAA,CAAAjsD,MAAA;EAAA,MACdkE,CAAA,GAAGmjB,CAAA,GAAK,CAAA+mC,KAAM,CAAAnC,EAAA,CAAA/nD,CAAA,IAAAiqD,GAAA,CAAAluD,KAAA,GAAAonB,CAAA,GAAA+mC,KAAA,CAAAnC,EAAA,CAAAhsD,KAAA;EAAA,MAChBkE,CAAA,GAAAkjB,CAAA,IAAA+mC,KAAA,CAAAnC,EAAA,CAAA9nD,CAAA,IAAAgqD,GAAA,CAAAnuD,MAAA,GAAAqnB,CAAA,GAAA+mC,KAAA,CAAAnC,EAAA,CAAAjsD,MAAA;EAAA,MACAquD,EAAI,GAAE9jD,CAAA,IACFrG,CAAA,GAAAmjB,CAAA,GAAA9c,CAAA;EAAA,MACA+jD,EAAA,GAAM/jD,CAAA,IAAApG,CAAA,GAAAkjB,CAAA,GAAA9c,CAAA;EAAA,MAAAgkD,SACE,GAAEH,KAAM,CAAAhE,IAAA,CAAA/jD,GAAA,EAAA4K,CAAA,EAAAhK,CAAA;IAAA,GAAAgK,CAAA;IACA;MAChBxK,IAEA,EAACA,IAAA,CAAAQ,CAAA;MACPyH,EAAA,EAAA2/C,EAAA,CAAAp9C,CAAA,CAAAvC,EAAA;MACAC,EAAI,EAAA2/C,EAAA,CAAAr9C,CAAA,CAAAtC,EAAU,CAAC;MAEXzM,IAAI,EAAE;QACNgC,CAAA,EAAImqD,EAAE,CAAAp9C,CAAA,CAAA/O,IAAK,CAAAgC,CAAA;QAEXC,CAAA,EAAAmqD,EAAA,CAAAr9C,CAAA,CAAA/O,IAAA,CAAAiC,CAAA;MACA;MACF,IAAA8M,CAAA,CAAAg6C,IAAA;QACFA,IAAA;UAEI/mD,CAAA,EAAAmqD,EAAA,CAAAp9C,CAAA,CAAAg6C,IAAA,CAAA/mD,CAAA,CAAgB;UACdC,CAAA,EAAAmqD,EAAA,CAAAr9C,CAAA,CAAAg6C,IAAA,CAAA9mD,CAAA;QACJ;MACA,IAAG,EAAG;IACR;IACA,IAAAyoD,SAAW,CAAA37C,CAAA;MACX+zB,EAAI,EAAA/zB,CAAG,CAAA+zB,EAAE,GAAE3d,CAAA;MACX4d,EAAA,EAAMh0B,CAAA,CAAAg0B,EAAA,GAAM5d;IACZ;MACArZ,CAAA,EAAAiD,CAAM,CAAAjD,CAAE,GAAAqZ;IAAiB;EACpB;EACQ,MACXmnC,cAAW,GAAAJ,KAAA,CAAAjC,aAAA,CAAA9lD,GAAA,EAAA4K,CAAA,EAAAhK,CAAA;IAAA/E,IACX;MACFgC,CAAA,EAAAmqD,EAAA,CAAAp9C,CAAA,CAAA/O,IAAA,CAAAgC,CAAA;MAEKC,CAAA,EAAAmqD,EAAA,CAAAr9C,CAAA,CAAA/O,IAAA,CAAAiC,CAAA;IACL;IACAjF,EAAA,EAAAmvD,EAAM,CAAAp9C,CAAA,CAAA/R,EAAA;IACNE,EAAA,EAAAkvD,EAAA,CAAAr9C,CAAA,CAAA7R,EAAA;IACJqH,IAAA,EAAAA,IAAA,CAAAQ,CAAA;IAMgB+T,GAAA,EAAAuzC,SAAA,CAAAtnD,CAAA;IACd6H,IAAA,EAAOmC,CAAA,CAAAnC,IAAA,CAAAzI,GAAA,CAAY6Q,CAAA;MACrB,GAAAA,CAAA;MCpJa/X,EAAA,EAAAkvD,EAAA,CAAAn3C,CAAA,CAAA/X,EAAA;MACXE,EAAA,EAAAivD,EAAA,CAAAp3C,CAAA,CAAA7X,EAAA;IACA;EACA;EACA,OAAAmvD,cAAA,CAAAnoD,GAAA,CAAAY,CAAA;IACA,GAAAA,CAAA;IACA4xB,IAAA,EAAAg1B,oBAAA,CAAA5mD,CAAA,EAAAsnD,SAAA;EACA;AAAA;AACA,SACAE,gBAAAhoD,IAAA,EAAAioD,GAAA;EACA,OAAAT,WAAA,CAAAd,SAAA,CAAA1mD,IAAA,GAAAioD,GAAA;AACF;AACE,MAAAC,WAAM,GAAAC,OAAA,IAWyB;EAAA,IAXzB;IAAcnwD,EAClB;IACEwJ,IAAA;IAAoChI,KAAA;IACfD,MACnB;IAAQoR,OACR;IAAQ5S,SACR;IAEEmiB,kBAAA;IACJla,IAAA;IACE+U,QAAA;IAAyC6G;EAChB,IAAAusC,OAAA;EACD,MAAA9uB,WACvB,GAAAp/B,WAAA,CAAA8qC,cACI;IACL,MAAA5lB,UAAa,GAAAnf,IAAO,CAAAJ,GAAA,CAAA2D,CAAA,KAAY;MAAAxD,GAC9B,EAAAwD,CAAA,CAAAxD,GAAQ,CAAAD,IAAA;MAAe6jD,IACvB,EAAApgD,CAAA,CAAAxD,GAAO;MAAerD,IACtB,EAAA6G,CAAA,CAAAvD;IAAmB,GACpB;IACH,IAAAooD,UAAA;IAGE,IAAA5mD,IAAA;MAAC4mD,UAAA,GAAAJ,eAAA,CAAA7oC,UAAA;QAAA5lB,MAAA,EAAAwrC,cAAA,CAAAxrC,MAAA;QACCC,KAAA,EAAAurC,cAAS,CAAAvrC;MAAA,EACT;IAAM,OACN;MAAA4uD,UACI,GAAAnxD,MAAA,CAAAkoB,UAAe;QAAA5lB,MAAA,EAAAwrC,cAAA,CAAAxrC,MAAA;QAAAC,KAAA,EAAAurC,cAAA,CAAAvrC,KAAA;QAGzB6uD,QAAA,EAAA7mD,IAAA;MACC;IAA4B;IAI7B,sBAAAhJ,GAAA,CAACO,YAAA;MACCC,OAAA,EAAA4iB,MAAA;MACA5b,IAAA,EAAAooD,UAAA;MACArzC,QAAA;MACA/c,EAAA,EAAA+sC,cAAA,CAAA/sC;IACA,CACA;EAAc,GACA,CAAAgI,IACd,EAAA+U,QAAQ,EAAA6G,MAAA,EAAApa,IAAA;EACR,OAEC,eAAAhJ,GAAA,CAAAqhB,cAAA;IAGP7hB,EAAA;IAEAwB,KAAA;IACED,MAAM;IACNoR,OAAA;IACFuP,kBAAA;IC9BaC,YAAoC;IAC/CC,YAAA;IACAL,MAAA;IACAhiB,SAAA;IACAQ,QAAA,EAAA8gC;EACA,CACA;AAAA;AACA6uB,WACA,CAAAjvD,YAAA;EACAuI,IAAA;EACAoa,MAAA,iBAAApjB,GAAA,CAAAksD,UAAA;AAAA;AAEF,MAAM4D,MAAA,GAAAC,OAAA,IAaF;EAAA,IAbE;IACJvwD,EAAA;IACMgI,IAAA;IACNjE,IAAA;IAEAq+B,IAAA;IAAmDhW,QACjD,EAAA+V,SAAgB;IACdlE,IAAA;IACA9R,OAAA;IAAeF,YACjB;IAAAC,YACA;IACEuS,QAAA;IACAlN,OAAA,EAAAC,QAAA,kBAAAhxB,GAAA,CAAAswB,YAAe;EAAA,IAAAy/B,OAAA;EACjB,MACD,CAAA3pB,cAAA,EAAAC,iBAAA,IAAA9kC,QAAA;EAEK,MAAAyuD,SAAA,GACJ50C,MAAA,KAAY,CAAC;EAMf,MAAM4d,UAAA,GAAAiF,QAAc,GAAAzF,kBAAA;IAAAxvB,IAAA;IAAA4yB,KAAA;EAAA;EAAA,MAClB;IAAAqT,UAAY;IAAKD;EAAW,CAAG,GAAAX,cAAU;IACzCG,aAAK,EAAAl4B,KAAA;MAAA+vB,iBAAA;MAED5a,YAAA,QAAgB,QAAQ,IAAMA,YAAA,CAAanV,KAAA;IAEjD;IAEIm4B,YAAA,EAAAn4B,KAAA;MAAC+vB,iBAAO;MAAP3a,YAAA,oBAAAA,YAAA,CAAApV,KAAA;IAAA;EACU;EACJ,MACL40C,OAAM,GAAAvpB,SAAA,KAAAC,IAAA,oBAAAthC,MAAA,CAAAd,EAAA,SAAAoiC,IAAA,wBAAAthC,MAAA,CAAAd,EAAA,SAAA+D,IAAA;EAAA,MACN2kC,WAAO,GAAA1iC,OAAA,CAA2B,OAClC;IAAAN,CAAA,EAAAsC,IAAS,CAAAA,IAAA,CAAAA,IAAA;IAAAvC,CAAA,EAAAuC,IAAA,CAAAA,IAAA,CAAAD;EAAA,KAAAC,IAAA,CACC;EACC,MAAAm3B,aACA,GAAAn5B,OAAA,OAAAwB,YAAA,CAAAkhC,WAAA,IAAAA,WAAA;EAAA,OACX,eAAAroC,IAAA,CAAAC,QAAA;IAAAC,QAAA,kBACSC,GAAA,CAAArC,MACP,CAAGohC,MAAK;MACCv/B,EACT,KAAAc,MAAA,CAAId,EAAA,YAAK;MACXiD,GAAA,EAAAutD,SAAA;MACAzsD,IAAA,EAAA2nD,OAAA;MACAthD,KAAA,EAAA2zB,kBAAoB;QAAAE;MAAW;MAC/B/d,OAAA;QACA3Q,CAAA,EAAAvH,IAAA,CAAAuH,CAAA;QACAU,EAAA,EAAAjI,IAAU,CAAAvC,CAAA;QACVyK,EAAA,EAAAlI,IAAA,CAAAtC;MACA;MAAKtH,OAAA;QACPmR,CAAA,EAAAvH,IAAA,CAAAuH,CAAA;QACCU,EAAA,EAAAjI,IAAA,CAAAvC,CAAA;QAEIyK,EAAA,EAAAlI,IAAA,CAAAtC;MACD;MAAC8zB,UAAA;MAAArN,OAAA,EAAArV,KAAA,IAAAqV,OAAA,IAAAA,OAAA,CAAArV,KAAA,EAAA9O,IAAA;MAAAgnC,aACU,EAAAQ,WAAA;MAAAP,YACL,EAAAQ,UAAkB;MAAApsB,QACtB;MAAA,cAAA8b,aAAA;MACFE,IAAA;IAAA,CAGH,GACC+C,IAAC,mBAAA/hC,IAAA,CAAAC,QAAA;MAAAC,QAAA,kBAAAC,GAAA,CAAAwiC,IAAA;QAAAhjC,EAAA,UAAAc,MAAA,CAAAd,EAAA;QAAA+D,IAAA,mBAAAjD,MAAA,CAAAd,EAAA;MAAA,mBACUQ,GAAA,CACTO,YAAI,EACJ;QAAOC,OAAA,EAAAohC,IAAA;QACTpiC,EAAA,kBAAAc,MAAA,CAAAd,EAAA;QAED+D;MACE;IAAA,EACC,EAASo+B,SACT,IAAS,eAAE3hC,GAAA,CAAAO,YACX,EAAW;MACJC,OAAA,EAAAmhC,SAAA;MACTniC,EAAA,cAAAc,MAAA,CAAAd,EAAA;MAEJgsB,KAAA,EAAAjoB;IAEJ,CC9HO,GACLytB,QAAA,KAAAA,QAAA,CAAArwB,KAAA,CAAA4b,QAAA,mBAAAvc,GAAA,CACAO,YAAA,EACA;MACAC,OAAA,EAAAwwB,QAAA;MACAQ,OAAA,IAAA4U,cAAA;MACAhS,SAAA,EAAA47B,SAAA;MACAptC,KAAA,EAAAslB;IACA,CACF;EACE;AACA;AACI,MAAA+nB,WAAA,GAAAC,OAAA,IAYE;EAAA,IAZF;IAEJ1wD,EAAA;IACEgI,IAAA;IACA2D,MAAA;IACF0O,IAAA;IAEAtW,IAAI;IACIC,QAAA;IACOC,UACJ;IAAUw6B;EACf,IAAAiyB,OAAA;EACA,MACAl3B,UAAY,GAAAiF,QAAA,GAAAzF,kBAAA;IAAAxvB,IAAA;IAAA4yB,KAAA;EAAA;EAAA,IACbiwB,SACM,QAAK;EAGZ,IAAAnhD,MAAA;EAAA,IAACS,MAAA,EAAO;IAAAT,MAAP,GAAAS,MAAA,CAAA3D,IAAA;IAAAqkD,SACC,GAAAC,cAAS,CAAAphD,MAAA;EAAA;EACC,KAAAmhD,SACL,EAAK;IAAA,MACV5oD,IAAA,GAAA4W,IAAA,GAAAH,QAAA;MAAAnS,GACA,EAAAC,IAAA,CAAAA,IAAS,CAAAD,GAAA;MAAA9D,UACJ;MAAKD,QACL;MAAKxC,KACV,EAAAwG,IAAA,CAAAuH;IAAA,KACAvH,IAAA,CAAAA,IAAA,CAAAD,GAAA;IAAA,OACA,eAASvH,GAAA,CAAArC,MACT,CAAAsF,IAAS,EAA4C;MAErDyc,OAAA;QAECza,CAAA,EAAAuC,IAAA,CAAAvC,CAAA;QAAAC,CAAA,EAAAsC,IAAA,CAAAtC;MAAA;MAGPtH,OAAA;QAGGqH,CAAA,EAAAuC,IAAA,CAAAvC,CAAA;QAELC,CAAA,EAAAsC,IAAA,CAAAtC;MAEA;MACQ8zB,UAAA;MACNx5B,EAAA,KAAAc,MAAA,CAAUd,EAAA;MACVoK,KAAA,EAAY;QAAAoD,aAAA;QAAAvJ,UAAA;QAAAD;MAAA;MACdD,IAAA;MC1DaD,UAAA,UAAgD;MAC3DvD,QAAA,EAAAkD;IACA,CACA;EACA;EACA,sBAAAjD,GAAA;IAAA4J,KAAA;MAAApH,SAAA,eAAAlC,MAAA,CAAAkH,IAAA,CAAAvC,CAAA,UAAA3E,MAAA,CAAAkH,IAAA,CAAAtC,CAAA;IAAA;IAAAnF,QAAA,EAAA2K;EAAA;AAAA;AACAulD,WACA,CAAAxvD,YAAA;EACFoZ,IAAM;EACJrW,QAAM;EAEAC,UAAA;AACJ;AAAsB,MACpB0sD,YAAA,GAAAC,OAAA,IAWC;EAAA,IAXD;IAAA5wD,EAAA;IACAgI,IACA;IAAY0kB,WACZ;IAAA+R,QACD;IAEDoyB,MAAA;IAKEllD,MAAA;IAAAxI,KAAC,EAAA+H;EAAO,IAAA0lD,OAAA;EAAP,MAECp3B,UAAS,GAAAiF,QAAA,GAAAzF,kBAAA;IAAAxvB,IAAA;IAAA4yB,KAAA;EAAA;EAAA,MAAA00B,YACA,GAAAA,CAAAvuB,KAAA,EAAAv0B,KAAA;IAAA,MACPjK,IAAA,GAAA62B,QAAS;MAAA5yB,IACX;MAAA0kB,WACS;MAAA9e,KACP,EAAA20B,KAAO,CAAAv6B,IAAA;MAAAgG;IACE;IACX,MACA++C,QAAA,GAAAhpD,IAAA,GAAA7E,MAAA,CAAAnB,MAAA,CAAAgG,IAAA,EAAAipD,MAAA,MAAApjB,GAAA;IAAA,OAEA,eAAAvpC,IAAA,CAAAlC,MAAA,CAAAmhC,CAAA;MAACpf,OAAA;QAAAtgB,KACC;QAAiCggB,OACjC,EAAI;MAA0C;MAC9CxhB,OACA;QAAMwB,KACN;QAAAggB,OAAA;MAAA;MACF4Z,UACA;MAAAj5B,QAAC,kBAAAC,GAAA,CAAAO,YACU;QAETC,OAAA,EAAA2K,MAAA,GAAAA,MAAA,CAAA42B,KAAA,IAAAsuB,MAAA;QACA7wD,EAAA,EAAAzB,UAAM,IAAAuC,MAAA,CAAAd,EAAA,OAAAc,MAAA,CAAAyhC,KAAA,CAAAv6B,IAAA,CAAAD,GAAA;QACN02B,QAAM;QAAAz2B,IAAA,EAAAu6B,KAAA;QACRx+B;MAAA,IAxBM,eAAkBvD,GAAA,CAAAO,YAAA,EAyB1B;QAIIC,OAAA,EAAAkK,MAAA;QACVlL,EAAA,EAAAzB,UAAA,IAAAuC,MAAA,CAAAd,EAAA,OAAAc,MAAA,CAAAyhC,KAAA,CAAAv6B,IAAA,CAAAD,GAAA;QAEa02B,QAAA;QACXz2B,IAAa,EAAAu6B,KAAA;QACHx+B,IAAA,EAAAgpD;MACV,CACA;ICvFW,GACXxqB,KAAA,CAAAv6B,IAAA,CAAAD,GACA;EACA;EACA,sBAAAvH,GAAA,CAAAF,QAAA;IAAAC,QAAA,EAAAyH,IAAA,CAAAJ,GAAA,CAAAkpD,YAAA;EAAA;AAAA;AACAH,YACA,CAAA1vD,YAAA;EACAyrB,WAAA;EACA+R,QAAA;EACFoyB,MAAM,iBAAArwD,GAAA,CAAA8vD,MAAA;EACJntD,KAAA,EAAM,eAAU3C,GAAA,CAAAiwD,WAAA;AAAA;AAEN,MAAAM,WAAA,GAAAC,OAAA,IAgBJ;EAAA,IAhBa;IAEThpD,IAAA;IAIChI,EAAA;SACT;IAAAuB,MACC;IAAIxB,SAAA;IAGPmiB,kBAAM;IAAcvP,OACf;IACKiR;EAGJ,IAAAotC,OAAA;EAAA,MAACC,OAAA,GAAAhvD,WAAA,EAAAs9C,EAAA,EAAA2R,EAAA;IAAA,MACCL,MAAA,GAAS1xD,IAAA,GAAAuF,IAAA,EAAA66C,EAAA,EAAA2R,EAAA,GAAA/sD,OAAA;IAAA,MACTgtD,IAAI,GAAG/xD,SAAO;MAAAmB,QAAA,EAAAyH;IAAA,GAAA8e,GAAA,CAAAvb,CAAA,IAAAA,CAAA,CAAAvD,IAAA,EAAAmc,IAAA,EAAA1L,CAAA,EAAAC,CAAA,KAAAA,CAAA,CAAA1Q,IAAA,GAAAyQ,CAAA,CAAAzQ,IAAA;IAAA,OACd6oD,MAAM,CAAAM,IAAA,EAAAC,MAAA;EAAA,IAAAppD,IAAA;EAGZ,MACCq5B,WAAQ,GAAOp/B,WAAA,CAAAovD,OAAA;IAAA;MAAA79C,UAAA;MAAAC,WAAA;MAAA,GAAAxF;IAAA,IAAAojD,OAAA;IAIhB,MAAAnF,OAAA,GAAA+E,OAAA,CAAAz9C,UAAA,EAAAC,WAAA;IAAC,sBAAAjT,GAAA,CAAAO,YAAA,EACC;MACAC,OAAA,EAAA4iB,MAAA;MACA5jB,EAAA,KAAAc,MAAA,CAAAmN,IAAA,CAAAjO,EAAA;MACAgI,IAAA,EAAAkkD;IACA,CACA;EAAc,GACA,CAAAtoC,MACd,EAAAqtC,OAAA;EAEC,sBAAAzwD,GAAA,CAAAqhB,cAAA,EAGP;IAEA7hB,EAAA;IACEwB,KAAO;IACPD,MAAS;IACT2gB,kBAAA;IACFvP,OAAA;ICxCawP,YAAA,OAAgD;IAC3DC,YAAA;IACAriB,SAAA;IACAQ,QAAA,EAAA8gC;EACA,CACA;AAAA;AACA0vB,WACA,CAAA9vD,YAAA;EACF+G,IAAM;EACE2K,OAAA;EACAiR,MAAA,iBAAkBpjB,GAAA,CAAAmwD,YAAK;AAC7B;AAAsB,MACpBW,YAAA,GAAAC,OAAA,IAQD;EAAA,IARC;IAAAvxD,EACA;IAAAgI,IACA;IAAAjE,IACA;IAAUsW,IACV;IAAAwX,SACA;IAAU7tB,QACV;IAAAC;EACuB,IAAAstD,OAAA;EAEzB,MAAMxpD,GAAA,GAAAC,IAAO,CAAAA,IAAA,CAAAD,GAAA;EAAA,MACXvG,KAAO,GAAAwG,IAAS,CAAAvH,EAAA,GAAAuH,IAAA,CAAWwc,EAAA;EAAO,MAClC/gB,IAAA,GAAAyW,QAAA;IACAnS,GAAA;IAAA9D,UAAA;IAGFD,QAAM;IAQJsW,QAAA;IACGD,IAAA;IAAAD,QAAA;IAAA5Y,KACC;IAASD,MACT,EAAAyG,IAAS,CAAArH,EAAA,GAAAqH,IAAA,CAAAyc;EAA4C;EACrD,MAEC/f,IAAA,GAAAoF,mBAAA,QAAArG,IAAA,gBAAAA,IAAA,GAAAsE,GAAA,EAEL9D,UAAA,EAEJD,QAEA;EACE,MAAMouB,OAAA,GAAAP,SAAA,oBAAAA,SAAA,iBAAArwB,KAAA,GAAAkD,IAAA,CAAAlD,KAAA,QAAAA,KAAA,GAAAkD,IAAA,CAAAlD,KAAA;EACN,OAAM,eAAAhB,GAAA;IAAA4J,KAAA;MAAApH,SAAA,eAAAlC,MAAA,CAAAsxB,OAAA;IAAA;IAAA7xB,QAAA,iBAAAC,GAAA,CACN,QACA;MACAR,EAAA,KAAAc,MAAA,CAAWd,EAAA;MACboK,KAAA;QAAAoD,aAAA;QAAAvJ,UAAA;QAAAD;MAAA;MC/BaD,IAAA;MACXxD,QAAA,EAAAkD;IACA,CACA;EAAA;AAAA;AACA6tD,YACA,CAAArwD,YAAA;EACA8C,IAAA;EACAsW,IAAA;EACArW,QAAA;EACFC,UAAM;EACJ4tB,SAAO;AACD;AACN,MAAA2/B,WAAM,GAAAC,OAAA,IAUF;EAAA,IAVe;IACbzpD,IAAA;IAENjE,IAAA;IAAmD06B,QACjD;IACEjiB,MAAA;IACA+U,OAAA,EAAAC,QAAA;IAAsBvF,YACxB;IAAAC,YACA;IACEC;EACA,IAAAslC,OAAA;EAAsB,MACxB,CAAA7qB,cAAA,EAAAC,iBAAA,IAAA9kC,QAAA;EAAA,MACD28B,OAAA,GAAA9iB,MAAA;EAEK,MAAA4d,UAAA,GAAAiF,QAAe,GAAQzF,kBAAM;IAAAxvB,IAAA;IAAA4yB,KAAA;EAAA;EAC3B,MAAAs1B,WAAS,GAAC9qB,cAAmB,GAAA7oC,MAAA,CAAAgG,IAAA,EAAAipD,MAAA,MAAApjB,GAAA,KAAA7lC,IAAA;EAC7B;IAAA0rC,UAAM;IAAAD;EAAQ,IAAAX,cAAA;IAChBG,aAAO,EAAAl4B,KAAA;MACT+vB,iBAAA;MACO5a,YAAI,QAAO,QAAK,IAAMA,YAAa,CAAAnV,KAAG,EAAA9O,IAAA;IAAA;IAE/CinC,YAAO,EAAOn4B,KAAM,IAAK;MACvB+vB,iBAAK;MAET3a,YAAM,IAAc,gBAAAA,YAAA,CAAApV,KAAA,EAAA9O,IAAA;IAClB;EAAwC,EACxC;EAAmB,MAAA2pD,aAAA,GAAA3rD,OAAA;IAEf,MAAA4rD,MAAA,GAAA76C,KAAgB;MAEtB,KAAAA,KAAA,CAAAY,MAAA;QAEI;MAAC;MAAA,WAAAi6C,MAAA,CAAA76C,KAAA,CAAAY,MAAA,GAAAZ,KAAA,CAAA/O,IAAA,CAAAD,GAAA;IAAA;IACM,OACL6pD,MAAS,CAAA5pD,IAAA,EAAAF,IAAA;EAAA,IAAAE,IACP;EAAM,MAAA0gC,WACC,GAAK1iC,OAAK,CAAK,OACtB;IAAAN,CAAA,EAAAsC,IAAQ,CAAAob,KAAK;IAAK3d,CAAA,EAAAksD;EAAK,KAAA3pD,IACzB,EAAA2pD,aAAA;EACS,MAAAxyB,aACD,GAAAn5B,OAAA,OAAAwB,YAAA,CAAAkhC,WAAA,IAAAA,WAAA;EAAA,sBACMroC,IAAK,CAAAC,QAAK;IAAAC,QAAA,kBACdC,GAAK,CAAUrC,MACzB,CAAAmZ,IAAA;MAEArU,GAAA,EAAAy7B,OAAA;MACAxe,OAAA,EAAS;QACPnc,IAAA,EAAA2tD,WAAA;QACFlwD,KAAA,EAAAwG,IAAA,CAAAvH,EAAA,GAAAuH,IAAA,CAAAwc,EAAA;QACAjjB,MAAA,EAAAyG,IAAA,CAAerH,EAAA,GAAAqH,IAAA,CAAAyc;MACf;MACArmB,OAAA;QACA2F,IAAA,EAAA2tD,WAAY;QACZlwD,KAAK,EAAAwG,IAAA,CAAAvH,EAAA,GAAAuH,IAAA,CAAAwc,EAAA;QAAAjjB,MAAA,EAAAyG,IAAA,CAAArH,EAAA,GAAAqH,IAAA,CAAAyc;MACP;MACCra,KAAA;QAAYoS;MAAA;MACVgd,UAAA;MAAArN,OAAA,EAAArV,KAAA;QACCqV,OAAS,oBAAAA,OAAA,CAAArV,KAAA,EAAA9O,IAAA;MACT;MACAgnC,aAAW,EAAAQ,WAAA;MACXP,YAAO,EAAAQ,UAAA;MAAApsB,QAAA;MACT,cAAA8b,aAAA;MAEJE,IAAA;IAEJ,CAEA,GACE7N,QAAQ,KAAAA,QAAA,CAAArwB,KAAA,CAAA4b,QAAA,mBAAAvc,GAAA,CACRO,YAAA,EACF;MCvGaC,OAAA,EAAAwwB,QAAkD;MAC7DQ,OAAA,IAAA4U,cAAA;MACAhS,SAAA,EAAA8J,OAAA;MACAtb,KAAA,EAAAslB;IACA,CACA;EACA;AACF;AACE8oB,WAAM,CAAAvwD,YAAa;EAEbub,MAAA;EACJ+U,OAAA,EAAM,eAAgB/wB,GAAA,CAAAswB,YAAA;AAAA;AACpB,MACA+gC,aAAA,GAAAC,OAAA,IAUC;EAAA,IAVD;IAAA9xD,EAAA;IACYgI,IACZ;IAAA0kB,WACD;IAED+R,QAAM;IAKJnnB,IAAA;IAAAnU,KAAC,EAAA+H;EAAO,IAAA4mD,OAAA;EAAP,MAECt4B,UAAS,GAAAiF,QAAA,GAAAzF,kBAAA;IAAAxvB,IAAA;IAAA4yB,KAAA;EAAA;EAAA,MAAAgX,UACA,GAAAA,CAAA7Q,KAAA,EAAAv0B,KAAA;IAAA,MACPjK,IAAA,GAAA62B,QAAS;MAAA5yB,IACT;MAAQ0kB,WACL;MAAK9e,KACV,EAAA20B,KAAA,CAAAv6B,IAAA;MAAAgG;IACS;IACA,MACP++C,QAAA,GAAShpD,IAAA,GAAA7E,MAAA,CAAAnB,MAAA,CAAAgG,IAAA,EAAAipD,MAAA,MAAApjB,GAAA;IAAA,OACT,eAAQvpC,IAAA,CAAAlC,MACR,CAAGmhC,CAAA,EAAK;MAEVpf,OAAA;QAEAtgB,KAAA;QAAAggB,OAAA;QAAAna,CAAA,EAAC88B,KAAA,CAAA/d,EAAA;QAAA9e,CAAA,EAAA68B,KAAA,CAAA9d;MAAA;MACUrmB,OACT;QAA0BwB,KAC1B;QAAAggB,OACA,GAAM;QAAAna,CAAA,EAAA88B,KACN,CAAA/d,EAAA;QAAA9e,CAAA,EAAA68B,KAAA,CAAA9d;MAAA;MACF+U,UACA;MAAAj5B,QAAC,kBAAAC,GAAA,CAAAO,YACU;QAETC,OAAM,EAAAsW,IAAA;QACNtX,EAAA,KAAAc,MAAA,CAAMd,EAAA,OAAAc,MAAA,CAAAyhC,KAAA,CAAAv6B,IAAA,CAAAD,GAAA;QAAA02B,QAAA;QACRz2B,IAAA,EAAAu6B,KAAA;QAAAx+B;MAAA,CA3BK,GAAU,eAAAvD,GAAA,CA4BjBO,YAAA,EAIG;QACTC,OAAA,EAAAkK,MAAA;QAEclL,EAAA,KAAAc,MAAA,CAAAd,EAAA,OAAAc,MAAA,CAAAyhC,KAAe,CAAAv6B,IAAA,CAAAD,GAAA;QAC3BC,IAAa,EAAAu6B,KAAA;QACHx+B,IAAA,EAAAgpD;MACV,CACA;IClEW,GACXxqB,KAAA,CAAAv6B,IAAA,CAAAD,GACA;EACA;EACA,sBAAAvH,GAAA,CAAAF,QAAA;IAAAC,QAAA,EAAAyH,IAAA,CAAAJ,GAAA,EAAA2D,CAAA,EAAAyC,KAAA,KAAAolC,UAAA,CAAA7nC,CAAA,EAAAyC,KAAA;EAAA;AAAA;AACA6jD,aACA,CAAA5wD,YAAA;EACAyrB,WAAA;EACA+R,QAAA;EACAnnB,IAAA,iBAAA9W,GAAA,CAAAgxD,WAAA;EACAruD,KAAA,iBAAA3C,GAAA,CAAA8wD,YAAA;AAAA;AAEF,MAAMS,OAAA,GAAAC,OAAA,IAwBI;EAAA,IAxBJ;IACJhqD,IAAA;IAAgBhI,EACd;IACQkiB,kBAAO;IAIP2V,YAAA;IAQAo6B,UAAA;IACN38C,YAAM;IAEA9T,KAAA;IACJD,MAAA;IAEExB,SAAA;IAAe4S,OACjB;IACAiR;EACE,IAAAouC,OAAA;EAAiB,MACnBf,OAAA,GAAAhvD,WAAA,EAAAs9C,EAAA,EAAA2R,EAAA;IAGF,MAAAC,IAAA,GAAY/xD,SAAI;MAAA4I;IAAA,GAAAuD,CAAA,IAAAA,CAAA,CAAAvD,IAAA,EAAA8e,GAAA,CAAAvb,CAAA,IAAAA,CAAA,CAAAvD,IAAA,EAAAmc,IAAA,EAAA1L,CAAA,EAAAC,CAAA,KAAAA,CAAA,CAAA1Q,IAAA,GAAAyQ,CAAA,CAAAzQ,IAAA;IACT,MAAAkqD,CAAA,GAAA7yD,OAAA,GAAAqF,IAAA,EAAA66C,EAAA,EAAA2R,EAAA,GAAAiB,IAAA,CAAA7yD,eAAA,EAAAgM,KAAA,OAAAusB,YAAA,CAAAA,YAAA,EAAAviB,YAAA,CAAAA,YAAA,EAAA28C,UAAA,CAAAA,UAAA;IACT,MAAAG,IAAA,GAAAF,CAAA,CAAAf,IAAA;IACC,MAAM1c,KAAA;IAAsC,MAAA4d,WAAA,GAAAt7C,KAAA;MAGzC,IAAAA,KAAA,QAAc,YAAAA,KAAA,CAAAY,MAAA;QACf88B,KAAA,CAAAhsC,IAAY,CAAAsO,KAAA;MACP;MAEJ,SAAAkH,KAAA,KAAAlH,KAAA,oBAAAA,KAAA,CAAAxW,QAAA;QAAC8xD,WAAA,CAAAp0C,KAAA;MAAA;IAAA;IACUo0C,WACL,CAAAD,IAAA;IAAA,OACJ3d,KAAO;EAAa,GACd,CAAAzsC,IAAA,EAAA6vB,YAAA,EAAAviB,YAAA,EAAA28C,UAAA;EAAA,MAGZ5wB,WAAA,GAAAp/B,WAAA,CACAqwD,OAAA,IAAoB;IAAA,IAAnB;MAAA9+C,UAAQ;MAAAC,WAAW;MAAA,GAAAxF;IAAA,IAAAqkD,OAAA;IAAA,MAAAC,KAAA,GAAAtB,OAAA,CAAAz9C,UAAA,EAAAC,WAAA;IAIpB,sBAAAjT,GAAA,CAACO,YAAA;MACCC,OAAA,EAAA4iB,MAAA;MACA,GAAA3V,IAAA;MACAjO,EAAA,KAAAc,MAAA,CAAAd,EAAA,IAAAiO,IAAA,CAAAjO,EAAA;MACAgI,IAAA,EAAAuqD;IACA,CACA;EAAc,GACA,CAAA3uC,MACd,EAAAqtC,OAAA,EAAAjxD,EAAA;EAEC,sBAAAQ,GAAA,CAAAqhB,cAAA,EAGP;IAEA7hB,EAAQ;IACNwB,KAAS;IACTD,MAAA;IACA2gB,kBAAc;IACdvP,OAAA;IACAwP,YAAA;IACAC,YAAO;IACTriB,SAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ECnCOyyD,SAAM;EACXrvD,KAAA;EACAsvD,QAAA;EACAC,UAAA;EACAC,QAAA;EACAC,WAAA;EACAC,SAAA;EACAhQ,UAAA;EACAiQ,SAAA;EACArI,QAAA;EACAvgB;AAAA;AACA,MACA6oB,aAAA,GAAAC,OAAA,IAeS;EAAA,IAfT;IACAhrD,IAAA;IACA0kB,WAAA;IACFumC,aAAM;IACJC,cAAM;IAAYC,iBACT;IACLC,cAAM;IAAgBC,WACpB;IAAAC,YACA;IAAA/e,aACO;IAAKgf,aACZ;IAAAC,WACD;IAEDC,WAAA;IAEIC,gBAAQ;IAAAC;EAAP,IAAAX,OAAA;EACa,MAAAlqB,SACZ,GAAA7mC,WAAW,CAAgC,CAAAsgC,KAC3C,EAAAv0B,KAAA,KAAW;IAAY,MACvBjK,IAAA,GAAS62B,QAAE,CAAO;MAAgB5yB,IAClC;MAA0B0kB,WAC1B;MAAU9e,KACV,EAAA20B,KAAA,CAAAv6B,IAAY;MAAiBgG;IACxB;IAET,sBAAAxN,GAAA;MAAAT,SAAA,EAAAuZ,UAAA,CAAAs6C,KAAA,CAAAnJ,QAAA,EAAA0I,iBAAA;MAAA5yD,QAAA,iBAAAC,GAAA,CAEJrC,MAAA,CAAA01D,GAAA,EACC;QAAkDr6B,UAAA,EAAAR,kBAAA;QAKhDj5B,SAAA,EAAAuZ,UAAA,CAAAs6C,KAAA,CAAA1pB,GAAA,EAAAopB,YAAA;QACOpzC,OAAA,EAAQ;UAAA1e,KAAA;QAAc;QAEtBpD,OAAA;UAAAoD,KAAa,KAAAV,MAAA,CAAAyhC,KAAA,CAAAv6B,IACf;QAAA;QAIFoC,KAAA;UAAA0iB,UAAA,EAAA/oB;QAAA;QAACsf,QAAA;QAAA,cAAA7b,YAAA,CAAA+6B,KAAA;QAEClD,IAAK;MACL,CAA+C;IAAA,EAC7C;EAAiB,GACoB,CAAAi0B,YAChC,EAAAH,iBAAa,EAAAzmC,WAAkB,EAAA1kB,IAAA;EACF,sBAC7BxH,GAAS,CAAGwP,UAAA;IAAAzP,QAAkB,EAAAyH,IAAA,CAAAJ,GAAA,EAAA2D,CAAA,EAAA/C,CAAA;MAAA,MACnC0C,MAAC,GAAImoD,WAAW,GAAGA,WAAA,CAAA9nD,CAAA,CAAAxD,GAAkB,EAAAS,CAAA,IAAA+C,CAAA,CAAAxD,GAAA;MAAA,MACrCw7C,WAAK,GAAAiQ,WAAW,GAAAA,WAAkB,CAAAjoD,CAAA,CAAAgZ,QAAA,CAAAnB,KAAA,EAAA5a,CAAA,IAAArB,WAAA,CAAAoE,CAAA,CAAAgZ,QAAA,CAAAnB,KAAA;MAAA,OACjC,eAAc/iB,IAAG,CAAkB,KACnC,EAAiC;QACCg/B,IACpC;QACDt/B,SAAA,EAAAuZ,UAAoB,CAAAs6C,KAAA,CAAAE,IAAA,EAAAb,aAAA;UACpB,CAAAW,KAAA,CAAAd,SAAc,GAAMW,WAAA;UACpB,CAAAG,KAAA,CAAShB,WAAM,GAAAW,aAAA;UAEf,CAAAK,KAAA,CAAAlB,UAAA,GAAAa,aAAA;UAAC,CAAAK,KAAA,CAAAG,QAAA,GAAAR,aAAM,UAAO;UAGb,CAAAK,KAAA,CAAAf,SAAc,GAAAU,aAAA;UACf,CAAAK,KAAA,CAAAI,WAAA,GAAAzf,aAAA;UAAA,CAAAqf,KAAC,CAAAjB,QAAA,GAAApe,aAAA;UAAA,CAAAqf,KAAA,CAAAK,UAAA,GAAA1f,aAAA;UAAA,CAAAqf,KACC,CAAAnB,QAAO,GAAAle,aAAA;UAAA,CAAAqf,KACP,CAAApB,SAAW,GAAAje,aAAe;QAA0B;QAEjCtoB,YAAA,EAAAA,CAAA,KAAAynC,gBAAA,oBAAAA,gBAAA,CAAAnoD,CAAA;QAAA2gB,YACrB,EAAAA,CAAA,KAAAynC,gBAAA,oBAAAA,gBAAA,CAAApoD,CAAA;QAAA4gB,OAAA,EAAAA,CAAA,KAAAsnC,WAAA,oBAAAA,WAAA,CAAAloD,CAAA;QAAAhL,QAAA,GA3BO,eAAAC,GAAA;UAAAurB,KAAA,EAAA7gB,MAAA;UAAAnL,SAAA,EAAAuZ,UAAA,CAAAs6C,KAAA,CAAAzwD,KAAA,EAAA+vD,cAAA;UAAA3yD,QAAA,EAAA2K;QAAA,IAAA49B,SAAA,CAAAv9B,CAAA,EAAA/C,CAAA,GA+Bf,eAAAhI,GAAA,CAEJ,SAEA;UACEurB,KAAa,EAAAw3B,WAAA;UACbxjD,SAAe,EAAAuZ,UAAA,CAAAs6C,KAAA,CAAA/Q,UAAA,EAAAuQ,cAAA;UACf7yD,QAAe,iBAAAC,GAAA;YAAAD,QAAA,EAAAgjD;UAAA;QACjB,CCvIa;MAEX,GACAh4C,CAAA,CAAAxD,GACA;IACA;EAAA;AAAA;AACAgrD,aACA,CAAA9xD,YAAA;EACFyrB,WAAM;EACE6nB,aAAA,EAAQ,KAAM;EAEdgf,aAAA;AACE;AACA,MAAAW,OAAA,GAAAC,OAAA,IASJ;EAAA,IATI;IACAnsD,IAAA;IAENhI,EAAA;IAAgCD,SAC3B;IAAAq0D,aACG;IAA2BhqD,KACjC;IAAUwZ,MACR;IAASpa;EACqC,IAAA2qD,OAAA;EAChD,MACA9xC,KAAA,GAAApiB,KAAA,CAAAD,EAAA;EAEF,MAAIq0D,UAAA,GAAAruD,OAAkB,OAAO;IAC3B,MAAAoO,MAAO,GAAM5K,IAAG,KAAM,OAAE,GAAOX,GAAE,CAAAb,IAAI,EAAAuD,CAAA,IAAAA,CAAA,CAAAvD,IAAA;IAAA,MAAAssD,SAC5B,GAAAlgD,MAAA,KAAkB,SAAQ,IAAAA,MAAA;IACnC,MAAA4jB,UAAa,GAAG/mB,WAAQ,GAAOlI,MAAM,CAAAurD,SAAA,EAAAz9B,UAAA;IACvC,MAAA09B,MAAA,GAAAvsD,IAAA,CAAAJ,GAAA,CAAA2D,CAAA;MAEO,GAAAA,CAAA;MACLvD,IAAA,EAAMgwB,UAAA,CAAAzsB,CAAA,CAAavD,IAAC;MAGtBuc,QAAA;QAACnB,KAAO,EAAA7X,CAAA,CAAAvD,IAAA;QAAPwsD,OAAA,EAAAxsD,IAAA,CAAAvB,MAAA,GAAA8E,CAAA,CAAAvD,IAAA;MACC;IAAK,EACL;IAAU,IACRosD,aAAS;MAAAG,MACP,CAAApwC,IAAA,EAAA1L,CAAA,EAAYC,CAAA,KAAAD,CAAA,CAAAzQ,IAAA,GAAA0Q,CAAA,CAAA1Q,IAAA;IAAA,WACVosD,aAAA,KAAiB;MAAAG,MACjB,CAAApwC,IAAA,EAAA1L,CAAA,EAAAC,CAAA,KAAAA,CAAA,CAAkB1Q,IAAA,GAAAyQ,CAAA,CAAAzQ,IAAA;IAAA;IACpB,OACFusD,MAAA;EAAA,IAAAvsD,IACA,EAAAosD,aAAS;EAAA,sBACK5zD,GAAA,CAAArC,MAAA,CAAAs2D,OACV,EAAiB;IACFp1B,IACjB;IAAAohB,QACF;MACFvgC,OAAA;QACIsZ,UAAA;UACJk7B,eAAA;UACAC,gBAAA;QAEA;MAAqE;MAAAv2D,OAAA;QAG3Eo7B,UAAA;UAEQk7B,eAAe;UACdE,aAAA;QACP;MACA;IACA;IACF50D,EAAA,EAAAqiB,KAAA;IC5DatiB,SAAA;IACXqK,KAAA;IACA7J,QAAA,iBAAAC,GAAA,CAAAO,YAAA;MAAAC,OAAA,EAAA4iB,MAAA;MAAA5b,IAAA,EAAAqsD;IAAA;EACA,CACA;AAAA;AACAH,OACA,CAAAjzD,YAAA;EACA+G,IAAA;EACAosD,aAAA;EACAxwC,MAAA,iBAAApjB,GAAA,CAAAuyD,aAAA;EACFvpD,IAAM;AACJ;AACM,MAAAqrD,WAAO,GAAAC,OAAA,IAYV;EAAA,IAZU;IACb9mD,KAAA;IACIpO,KACG,EAAAC,MAAA;IAAAujB,KACH,EAAAhc,MAAQ;IAAiB0H,KAEzB;IAAAvN,MACA;IAAMxB,SACC;IAAA0+B,QAAA;IAITs2B,UAAA;IAAAC;EAAQ,IAAAF,OAAA;EAAP,MAEC9yB,QAAS,GAAAniC,MAAA,CAAAmO,KAAA,KAAAnO,MAAA,CAAAuH,MAAA;EAAA,MACPrD,IAAA,GAAAi+B,QAAY,GAAA+yB,UAAA,GAAAC,YAAA;EAAA,MACZx7B,UAAA,GAAAiF,QAAA;IAAA,GACFzF,kBAAA;IAAAoD,KACA,EAAApuB,KAAS,GAAAc,KAAA;EAAA;IACKtF,IACZ;IAAA4yB,KACF;EAAA;EACa,OACb,eAAA57B,GAAA,CAAArC,MAAA,CAAA01D,GAAA,EAVK;IAAA3zC,OAAA;MAaX4M,UAAA,EAAAkoC,YAAA;MAEAzzD;IACE;IACAnD,OAAA;MACA0uB,UAAQ,EAAA/oB,IAAA;MACRxC;IACF;;;UC/CO;AAAwC;AAC7CszD,WACA,CAAA5zD,YAAA;EACA8zD,UAAA,EAAA16B,OAAA,CAAAC,SAAA;EACA06B,YAAA;EACAzzD,MAAA;EACAk9B,QAAA;AAAA;AACA,MACA7c,SAAA;AACF,MAAMyc,GAAA;EACJzc;AACM;AAGJ,MAAAqzC,KAAA,GAAAC,OAAA,IAMe;EAAA,IANf;IAAA/gD,GAAC,EAAA8D,IAAA;IAAApP,GAAA,EAAAqP,IAAA;IAAAnY,SACC;IAA8Co1D,MAC9C;IAAmCC,GAAA;IAGjChrD,KAAA;IAACgZ,KAAA,EAAAhc,MAAA;IAAAq8C;EACU,IAAAyR,OAAA;EAEG,MAAAr1D,MACZ,GAAAoR,WAAA,GAAAlI,MAAA,EAAAkP,IAAA,EAAAC,IAAA,GAAA9X,KAAA;EAAA,MAAAi1D,IACA,GAAAx1D,MAAA,CAAAuI,KAAA,CAAAq7C,OAAA;EAAA,sBACAjjD,GAAA;IAJKT,SAMR,EAAAuZ,UAAA,CAAA+kB,GAAA,CAAAzc,SAAA,EAAA7hB,SAAA;IAAAqK,KAAA;MAAAgrD,GAAA,KAAAt0D,MAAA,CAAAs0D,GAAA;MAAA,GAAAhrD;IAAA;IAAA7J,QAAA,EAAA80D,IAAA,CAAAztD,GAAA,CAAAoG,KAAA,mBAAAxN,GAAA,CAGPO,YAAA,EAEM;MACCC,OAAA,EAAAm0D,MAAA;MACArmD,KAAA,EAAAumD,IAAA,CAAA5uD,MAAA;MACLuH,KAAS;MACJpO,KAAA,EAAAC,MAAA;MACGujB,KAAA,EAAAhc;IACR,GACF4G,KCvEa;EAIb,CACE;AAAM;AACAinD,KACN,CAAAh0D,YAAS;EACXkT,GAAA;ECXOtL,GAAA,EAAM;EAIb46C,OAAA,EAAW;EACT2R,GAAA;EACAhrD,KAAA,EACE;EAAA+qD,MAAC,iBAAA30D,GAAA,CAAAq0D,WAAA;AAAA;AAAA,MACCS,gBAAK,GAAAn0D,KAAA,mBAAAX,GAAA,CAAAo7C,gBAAA;EAAA,GAAAz6C;AAAA;AAAAm0D,gBAEH,CAAAr0D,YAAA;EAAAwhC,IAAA,EAAC;EAAAj5B,IAAA;EAAA46B,OAAA,EACC,eAAO5jC,GAAA,CAAAk7C,iBAAA;IAAA7Z,IAAA;EAAA;AAAA;AACF,MAAA0zB,UACL,GAAAp0D,KAAA,mBAAOX,GAAA,CAAAu7C,eAAkB;EAAA,GAAA56C;AAAA;AAAAo0D,UAAA,CAAAt0D,YAAA;EAAA2iB,MAC3B,iBAAApjB,GAAA,CAAA80D,gBAAA;EAAAlyD,IAAA,iBAAA5C,GAAA,CAEJ0a,UAAA,EAEJ;ICmDa1R,IAAA,YAA0C;IACrD6G,IAAA,iBAAA7P,GAAA,CACAsQ,mBAAA,EACA;MACAhC,KAAA;MACAa,GAAA;MACAzM,IAAA,iBAAA1C,GAAA,CAAA0Q,iBAAA;IACA,CACA;EACA,CACA;AAAA;AACA,MACAskD,SAAA,GAAAC,OAAA,IA2BA;EAAA,IA3BA;IACFztD,IAAM;IAEEhI,EAAA;IAENob,MAAM;IAMNwE,OAAM;IAMN5R,KAAA;IAA2B0nD,OACzB;IAAAnoC,MACA;IAAmB+U,aACnB;IAAA5V,WACK;IAAAN,QACN,EAAA+V,SAAA;IAEDlE,IAAA;IACA1M,OAAM,EAAAC;EAEN,IAAAikC,OAAA;EACA,MAAMhiB,YAAS,GAAI,IAAAzrC,IAAO,EAAAA,IAAM,CAAAA,IAAA,CAAAvB,MAAA;EAE1B,MAAAkvD,aAAA,GAAgBlzB,IAAA,GAAAC,KAAQ,CAAArkC,WAAM,CAAAikC,aAAqB,CAAI,CAAC,CAAA78B,CAAA,EAAA6J,EAAA,EAAA9G,CAAA,KAAA4S,MAAA,CAAA5S,CAAA,GAAAic,EAAA,CAAA8I,MAAA,KAAA5sB,EAAA,CAAAi1D,OAAA;IAAA;MAAA5tD,IAAA,EAAAorB;IAAA,IAAAwiC,OAAA;IAAA,OAAAroC,MAAA,CAAA6F,KAAA;EAAA;EAG5D,MAAAyiC,mBAAA,GAAApzB,IAAA,GAAAC,KAAA,CAAArkC,WAAA,CAAAikC,aAAA,GAAA78B,CAAA,EAAA6J,EAAA,EAAA9G,CAAA,KAAA4S,MAAA,CAAA5S,CAAA,GAAAic,EAAA,CAAA8I,MAAA,KAAA5sB,EAAA,CAAAm1D,OAAA;IAAA;MAAA9tD,IAAA,EAAAorB;IAAA,IAAA0iC,OAAA;IAAA,OAAAvoC,MAAA,EAAA6F,KAAA;EAAA;EAAA,MAAC2iC,SAAA,GAAAn7B,QAAA;IAAA5yB,IAAA;IAAAe,MACC,MAAS;IAAA2jB,WACT;IAAA3kB,GACA,EAAAiG;EAAA;EACA,MACAgoD,OAAA,GAAA7zB,SAAA,oBAAArhC,MAAA,CAAAd,EAAA,aAAA+1D,SAAA;EAAA,MACAE,UAAA,GAAA9zB,SAAA,oBAAArhC,MAAA,CAAAd,EAAA,gBAAA+1D,SAAA;EAAA,MACA,CAAAx0D,MACE,IAAAgsB,MAAA,CAAAntB,KAAA;EAAA,MAAC,CAAA45C,CAAA,EAAAx4C,KAAA,IAAA4Z,MAAA,CAAAhb,KAAA;EAAA,MAAA++B,aAAA,GAAAn5B,OAAA,OAAAwB,YAAA,CAAAQ,IAAA,IAAAA,IAAA;EAAA,sBACaxH,GAAA,CAAAO,YACZ,EACE;IAAcC,OAAA,EACZwwB,QAAQ;IAAApW,MAAA;IACAmS,MAAA;IACIvlB,IAAA;IAGPzG,MAAA;IAA6CC,KACtD;IAAA+vB,OAAA,iBAAA/wB,GAAA,CACFswB,YAAA,EAGF;MAAC+Z,YAAA;MAAA7Z,OAAA,EAAAA,CAAAoC,KAAA,EAAApH,KAAA;QACC,MAAA5kB,MAAA,GAAe;UACf3B,CAAA,EAAO2tB,KAAA,CAAArrB,GAAA;UACPrC,CAAA,EAAA0tB,KAAA,CAAAprB,IAAY;UACZob,KAAK,EAAAgQ,KAAA,CAAAprB;QAEL;QAAA,sBAAAxH,GAAA,CAAAyvB,eAAA;UAAA7M,KAAA,EAAAhc,MAAA;UAAA4kB;QAAA;MAAA;IAAQ,CAAP;IACuCzrB,QAAA,EACtC,eAAMF,IAAA,MACC;MACEmN,aACP,EAAAgkB,QAAS;MAAApnB,KAAA,EACX2zB,kBAAA;QAAAE;MAAA;MAAA,YACA,EAAAkB,aAAS;MAAAE,IAAA,qBACP;MAAA9+B,QACF,kBAAAC,GAAA,CACFrC,MAAA,CAAAi8B,IAAA,EACA;QAAC7uB,CAAA,EAAAoqD,aAAO,CAAAliB,YAAA;QAAP1vC,IAAA,EAAAiyD,OAAA;QACCn1D,MAAG;QACHqf,OAAM;UACNN,OAAO;QACP;QAASxhB,OACP;UACFwhB;QACA;MAAS,CACP,GACF,eAAApf,GAAA,CACFrC,MAAA,CAAAi8B,IAAA,EACC;QAEG7uB,CAAA,EAAAsqD,mBAAA,CAAApiB,YAAA;QAAC1vC,IAAA,EAAAkyD,UAAA;QAAAp1D,MAAA;QAAAqf,OACC;UACAN,OAAI;QAAc;QACXxhB,OAAA;UACTwhB;QACA;MAAA,CAAC,GAAAuiB,SACC,mBAAS9hC,IAAA,CAAA2P,UAAA;QAAAzP,QAAA,kBACLC,GAAA,CAAcO,YACX;UACTC,OAAA,EAAAmhC,SAAA;UACFniC,EAAA,cAAAc,MAAA,CAAAd,EAAA;UAAAgsB,KAAA,EAAA+pC;QAAA,CAEJ,kBAAAv1D,GAAA,CAAAO,YAAA,EAGN;UAEUC,OAAe,EAAAmhC,SAAA;UAErBniC,EAAA,cAAAc,MAAA,CAAAd,EAAA;UAACgsB,KAAA,EAAA+pC;QAAA,CACC;MACO;IACgD,CAEvD;EAAA,CACF;AAAA;AAEaP,SACf,CAAAv0D,YAAa,GAAQ;EACrBmrB,QAAA,EAAU,eAAA5rB,GAAA,CACV2uB,QAAS,EACT;IACAxP,SAAS;IACX0P,KAAA,GC7Ia,eAAqD7uB,GAAC,CAAAuuB,YAAA;MAAA1jB,MAAA;MAAA4jB,WAAA;IAAA,YACjE,eAAAzuB,GAAA,CAAAuuB,YAAA;MAAA1jB,MAAA;MAAA4jB,WAAA;IAAA;EAEA,CACA;EACAqT,aAAA;EACA5V,WAAA,EAAA2N,OAAA,CAAAC,SAAA;EACAmE,QAAA;EACAi3B,OAAA;EACA91C,OAAA;EACA2R,OAAA;AAAA;AACA,MACA2kC,eAAA,GAAAC,OAAA,IAaE;EAAA,IAbF;IACFnuD,IAAM;IACEgG,KAAA;IACNoN,MAAM;IACAmS,MAAA;IACNtpB,UAAM;IACAE,OAAA;IACNH,QAAM;IACND,IAAA;IACAhE,SAAM;IAAgBqB,QACf;IAAAg1D,SACL;IAAAC;EACU,IAAAF,OAAA;EACA,MACV1wD,CAAA,GAAA2V,MAAA,CAAApN,KAAA,IAAA7J,OAAA;EAAA,MACA,CAAA5C,MAAA,IAAAgsB,MAAA,CAAAntB,KAAA;EAAA,MACAsF,CAAA,GAAAnE,MAAA,OAAA4C,OAAA;EAAA,MACA+G,MAAA,GAAAlD,IAAA,CAAAD,GAAA;EAAA,MACAuuD,UAAY,GAAAl7C,MAAA,CAAApN,KAAA;EAAA,MACbxM,KAAA,IAAA80D,UAAA,GAAAA,UAAA,GAAAl7C,MAAA,CAAApN,KAAA,SAAA7J,OAAA;EAEK,MAAAO,IAAA,GAAAoF,mBAAqB,CAAAoB,MAAY,EAAAjH,UAAM,EAAAD,QAAA;EACvC,MAAAP,IAAA,GAAAyW,QAAA;IAEJnS,GAAA,EAAAmD,MAAQ;IAAUxG,IAClB;IACE0V,QAAA,EAAAjW,OAAY;IACZmW,QAAA,EAAAnW,OAAA;IAAA3C,KACF;IACcD,MAAA;IACZ0C,UAAA;IAAAD,QACG;IACHvC,UAAA,EAAA40D;EAEE;EAGA,MAAAE,kBAAY,GAAAt0D,WAAc,OAAK;IAAiC,IAClEqD,UAAA;IACA,QAAAlE,QAAA;MACF;QAEOkE,UAAA,gBAAAxE,MAAA,CAAA2E,CAAA,QAAA3E,MAAA,CAAAkD,QAAA;QACL;MAGA;QACKsB,UAAA,gBAAAxE,MAAA,CAAA2E,CAAA,QAAA3E,MAAA,CAAA4E,CAAA;QACT;MAGE;QAAC;UAAA,MAAA8wD,cAAA,GAAA7uD,KAAA,CAAAD,OAAA,CAAAjE,IAAA,IAAAA,IAAA,CAAAob,KAAA,IAAAkI,MAAA,EAAAhN,GAAA,EAAA08C,IAAA,KAAA18C,GAAA,GAAA08C,IAAA,CAAAt1D,KAAA,CAAAoN,EAAA;UACCjJ,UAAW,gBAAAxE,MAAA,CAAmB2E,CAAA,QAAA3E,MAAA,CAAAS,MAAA,GAAA4C,OAAA,GAAAqyD,cAAA;QAC9B;QACA;IAAsB;IAErB,OACClxD,UAAA;EAAA,IAAAlE,QAAC,EAAAqE,CAAA,EAAAzB,QAAA,EAAA0B,CAAA,EAAAjC,IAAA,EAAAlC,MAAA,EAAA4C,OAAA;EAAA,IAAAkyD,eAAA,iBAAA3xD,IAAA,CAAAlD,KAAA,GAAAA,KAAA;IAAA,WACC;EAAc;EACd,sBACKnB,IAAW,CAAAlC,MAAA,CAAAmhC,CAChB;IACiBt8B,SACjB,EAAAuzD,kBAAA;IAAAr2C,OACA;MAAAN,OAAU;IAAA;IAAWxhB,OAEpB;MAAAwhB,OAAA;IAAA;IAA4Brf,QAAA,GAC/B61D,SAAA,mBAAA51D,GAAA,CAEF,QAAC;MAAAgN,aAAA;MACCzJ,IAAA;MACA2B,CAAA,IAAA1B,QAAA,GAAAG,OAAA;MACApE,SAAA;MACAib,gBAAA,EAAiB;MACjB/W,UAAA;MACAD,QAAA,EAAAA,QAAA;MAECzD,QAAA,EAAA4G,WAAA,CAAAa,IAAA,CAAAA,IAAA;IAAA,CACH,kBAAAxH,GAAA;MAGNgN,aAAA;MAEAzJ,IAAgB;MACJhE,SAAA;MACDib,gBAAA;MACT/W,UAAY;MACND,QAAA;MACIzD,QAAA,EAAAkD;IACV,CACA;ECjJK,CACL;AAAA;AACAyyD,eACA,CAAAj1D,YAAA;EACA+C,QAAA;EACAG,OAAA;EACFF,UAAM;EACJF,IAAA,EAAM,MAAC;EAGL3C,QAAA;EAAAg1D,SAAC;EAAAC,eAAA;AAAA;AACiB,MAChBK,cAAI,GAAAC,OAAA,IAKU;EAAA,IALV;IAAAl3D,WACA;IAAYC,WACZ;IAAA6tB,MACJ;IAAQnS,MACR;IAAApN;EACc,IAAA2oD,OAAA;EAAA,OAAAp1D,MAAA,IAAAgsB,MAAA,CAAAntB,KAAA;EAGpB,sBAAAI,GAAA,CAEA,QACE;IACAC,EAAA,EAAA2a,MAAa,CAAApN,KAAA;IACfrN,EAAA;ICpBaD,EAAA,EAAA0a,MAAA,CAAApN,KAA4C;IACvDpN,EAAA,EAAAW,MAAA;IACAV,MAAA,EAAApB,WAAA;IACAC,WAAA;IACA8N,aAAA;EACA,CACF;AACE;AAEAkpD,cAAA,CAAAz1D,YAAA;EAISxB,WAAQ;EACPC,WAAC;AAAA;AAAA,MAAAk3D,UACC,GAASC,OAAA,IAMZ;EAAA,IANY;IAAA7uD,IAAA;IACToT,MACA;IAAAmS,MACA;IAAArqB,IAAA,EAAAW,KAAA;IAAAV,KACF,EAAA+H;EAAA,IAAA2rD,OAAA;EAGA,MAACC,KAAA,GAAA12D,KAAA,IAAA4H,IAAA,CAAAvB,MAAA;EAAA,sBAAAjG,GAAA,CAAAwP,UAAA;IAAAzP,QAAA,EAAAu2D,KAAA,CAAAlvD,GAAA,CAAAoG,KAAA,mBAAA3N,IAAA,CAAAC,QAAA;MAAAC,QAAA,GAAAsD,KACC,IAAAmK,KAAS,yBAAAxN,GAAA,CAAAO,YACT;QAEAC,OAAA,EAAA6C,KAAA;QACAmK,KAAA;QAAAoN,MAAA;QACFmS;MAAA,CAMZ,GAEAriB,MAAA,IAAW,eAAe1K,GAAA,CACxBO,YAAA,EACA;QACFC,OAAA,EAAAkK,MAAA;QCtBa8C,KAAA;QACXhG,IAAA,EAAAA,IAAA,CAAAgG,KAAA;QACAoN,MAAA;QACAmS;MACA,CACA;IACA,GAAAvf,KAAA;EAAA;AAAA;AAEF4oD,UAAM,CAAA31D,YAAA;EAEJkC,KAAA,EAAM,eAAY3C,GAAA,CAAA01D,eAAA;EAAAhzD,IACf,iBAAgB1C,GAAkB,CAAAk2D,cAAA;AACjC;AAKA,MAAAK,YAAM,GAASC,OAAA,IASR;EAAA,IATQ;IAEfhvD,IAAA;IAA4ChI,EAAA;IACvC2P,GAAA,EAAAqB,IACH;IAAO5N,IAAA;IACI7B,MACX;IAAAC,KACA;IAEKy1D;EAAA,IAAAD,OAAA;EACC,MACN51B,SAAA,GAAAn/B,WAAA,EAAAE,OACA,EAAAC,MAAA;IAAA,MAAAmrB,MAAA,GAAAtc,WAAA,GAAAlI,MAAA,GAAAF,GAAA,CAAAb,IAAA,EAAAkvD,OAAA;MAAA;QAAAlvD,IAAA,EAAAorB;MAAA,IAAA8jC,OAAA;MAAA,OAAA9jC,KAAA;IAAA,IAAAvqB,GAAA,CAAAb,IAAA,EAAAmvD,OAAA;MAAA;QAAAnvD,IAAA,EAAAorB;MAAA,IAAA+jC,OAAA;MAAA,OAAA/jC,KAAA;IAAA,KAAA2D,IAAA,GAAA32B,KAAA,EAAA+B,OAAA;IAEJ,MAAAiZ,MAAA,GAAAnK,WAAA,GAAAlI,MAAA,KAAAf,IAAA,CAAAvB,MAAA,GAAArG,KAAA,KAAAgC,MAAA;IACC,MAAIyoD,eAAA,GAAA7iD,IAAA,CAAAJ,GAAA,EAAA2D,CAAA,EAAA/C,CAAA;MAAA,GAAA+C,CAAA;MAGDxD,GAAE,EAAAwD,CAAA,CAAAxD,GAAO;MAGTtC,CAAA,EAAA2V,MAAI,CAAA5S,CAAM;MACZA;IACA;IAEO;MACLR,IAAA,EAAA6iD,eAAA;MACAt9B,MAAA;MAAOnS;IAC+B;EACS,GACI,CAAApT,IACnD;EAAA,MACF;IAAAuqD,KACK;IAAA6E;EAAA,IAAApxD,OAAA;IACE,IAAAgL,IAAA,CAAA7P,KAAA,CAAAu0D,OAAA;MAAA,MACLrqD,MAAA,GAAY9J,MAAA;MAAA,MACZ81D,WAAU,GAAMhsD,MAAG;MAA0B;QAEjD+rD,UAAA,EAAAC,WAAA;QACE9E,KAAM,GAEJ;UAAAvqD,IAAA;UAAA,GAAAo5B,SAAqB,CAAA7/B,MAAA,EAAAC,KAAA;QAAA,GACxB;UAAkBwG,IAAA;UAAA,GAAAo5B,SAAA,CAAA7/B,MAAA,GAAA8J,MAAA,EAAA7J,KAAA;QAAA,GACb;UAAAwG,IAAA;UAAA,GAAAo5B,SAAgB,CAAA7/B,MAAA,GAAA8J,MAAA,MAAA7J,KAAA;QAAA;MAElB;IACA;MACA;QAA4C41D,UACrC;QAAS7E,KACd;UAAOvqD,IAAA;UAAA,GAAAo5B,SAAA,CAAA7/B,MAAA,EAAAC,KAAA;QAAA;MAAA;IACP;EACM,IAAAwG,IACP,EAAAgJ,IAAA,EAAAzP,MAAA,EAAAC,KAAA,EAAA4/B,SAAA;EAEc,MAAAk2B,kBAAA,GAAAr1D,WAAA,CAAAkc,CAAA,IACb;IAA0C,IAC1C84C,cAAa;MAAA,MACd;QAAA77C,MAAA;QAAApT,IAAA,EAAAorB;MAAA,IAAAm/B,KAAA;MACH;QAAAn7C,OAAA;QAAAC,OAAA;QAAAL;MAAA,IAAAmH,CAAA;MACF,MAAA/c,QAAA,GAAA8V,oBAAA;QAAAF,MAAA;QAAAI,OAAA;QAAAC;MAAA;MACC,MAAOjQ,MAAA,GAAAsO,6BAAc;QAAAE,GAAA,EAAAxU,QAAA,CAAAqE,CAAA;QAKnB7F,KAAA,EAAAwb,MAAA;QAAMpT,IAAI,EAACorB,KAAG;QACZvf,IAAA;MAAA;MAECojD,cAAS;QACT7zC,KAAA,EAAS;UAAArb,GAAA,EAAAX,MAAA,CAAAW,GAAA;UAAAC,IAAA,EAAAZ,MAAA,CAAAY;QAAA;QAETiV,WAAA,EAAAkB;MAAA,EAAC;IAAA;EAAA,GACU,CAAAo0C,KAAA,EACR0E,cAAG;EACc,sBACX52D,IAAA,CAAA2P,UAAA;IAAAzP,QAAA,GAAAgyD,KAAA,CAAA3qD,GAAA,EAAA2D,CAAA,EAAA/C,CAAA,oBAAAhI,GAAA,IACT;MATK4J,KAAA;QAAApH,SAAA,kBAAAlC,MAAA,CAAA0H,CAAA,GAAA4uD,UAAA;MAAA;MAWRjrC,OAAA,EAAAmrC,kBAAA;MACD/2D,QAAA,iBAAAC,GAAA,CAACO,YAAA;QACCC,OAAS,EAAAgQ,IAAA;QACT,GAAAzF,CAAA;QACAvL,EAAA,KAAAc,MAAA,CAAQd,EAAA,WAAAc,MAAA,CAAS0H,CAAA;QACjBwF,KAAQ,EAAAxF;MAAS,CACnB;IACF,GAEJA,CAEA,IACE,eAAAhI,GAAA,CACAO,YAAA,EACF;MC1IaC,OAAA,EAAAoC,IAA8C;MACzD4E,IAAA;MACAoT,MAAA,EAAAm3C,KAAA,IAAAn3C,MAAA;MACAmS,MAAA,EAAAglC,KAAA,IAAAhlC;IACA,CACA;EACA;AAAA;AACAwpC,YACG,CAAA91D,YAAA;EACL0O,GAAA,EAAM,eAAAnP,GAAA,CAAAg1D,SAAA;EACEpyD,IAAA,iBAAgB5C,GAAE,CAAAo2D,UAAA;AAExB;AAAoB,MACjBW,WAAM,GAAAC,OAAA,IAQsB;EAAA,IARtB;IACLxvD,IAAA;IACSxG,KAAA;IAAAmR,OACT;IAGEpR,MAAA;IAAAxB,SAAC;IAAAmiB,kBAAA;IAAA0B,MAAA;IACU,GAAA3V;EACc,IAAAupD,OAAA;EACvB,MAAAx3D,EACA,GAAAC,KAAQ,CAAAgO,IAAA,CAAAjO,EAAA;EAAA,MAAAqhC,WACD,GAAAp/B,WAAA,CAAAw1D,OAAA;IAAA;MAAAz3D,EAAA,EAAAuhC,GAAA;MAAA/tB,UAAA;MAAAC,WAAA;MAAAoP;IAAA,IAAA40C,OAAA;IAAA,KAAA50C,UAAA;MAGb;IACC;IAAY,sBAAAriB,GAAA,CAIbO,YAAA,EAAC;MAAAC,OAAA,EAAA4iB,MAAA;MACC5jB,EAAA,mBAAAc,MAAA,CAAAygC,GAAA;MACAv5B,IAAA;MACAzG,MAAA,EAAAkS,WAAA;MACAjS,KAAA,EAAAgS;IACA,CACA;EAAA,GAEC,CAAAxL,IAAA,EAAA4b,MAAA;EAGP,sBAAApjB,GAAA,CAEAqhB,cAAY,EACV;IACA7hB,EAAA;IACFwB,KAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}