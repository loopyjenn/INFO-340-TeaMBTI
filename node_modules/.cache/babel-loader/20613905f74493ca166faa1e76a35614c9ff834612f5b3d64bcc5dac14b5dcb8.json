{"ast":null,"code":"/**\n * name: body-scroll-lock-upgrade\n * version: v1.1.0\n * author: Rick.li\n */\nlet hasPassiveEvents = false;\nif (typeof window !== \"undefined\") {\n  const passiveTestOptions = {\n    get passive() {\n      hasPassiveEvents = true;\n      return void 0;\n    }\n  };\n  window.addEventListener(\"testPassive\", null, passiveTestOptions);\n  window.removeEventListener(\"testPassive\", null, passiveTestOptions);\n}\nconst isIosDevice = typeof window !== \"undefined\" && window.navigator && window.navigator.platform && (/iP(ad|hone|od)/.test(window.navigator.platform) || window.navigator.platform === \"MacIntel\" && window.navigator.maxTouchPoints > 1);\nlet locks = [];\nlet locksIndex = /* @__PURE__ */new Map();\nlet documentListenerAdded = false;\nlet initialClientY = -1;\nlet previousBodyOverflowSetting;\nlet htmlStyle;\nlet bodyStyle;\nlet previousBodyPaddingRight;\nconst allowTouchMove = el => locks.some(lock => {\n  if (lock.options.allowTouchMove && lock.options.allowTouchMove(el)) {\n    return true;\n  }\n  return false;\n});\nconst preventDefault = rawEvent => {\n  const e = rawEvent || window.event;\n  if (allowTouchMove(e.target)) {\n    return true;\n  }\n  if (e.touches.length > 1) return true;\n  if (e.preventDefault) e.preventDefault();\n  return false;\n};\nconst setOverflowHidden = options => {\n  if (previousBodyPaddingRight === void 0) {\n    const reserveScrollBarGap = !!options && options.reserveScrollBarGap === true;\n    const scrollBarGap = window.innerWidth - document.documentElement.getBoundingClientRect().width;\n    if (reserveScrollBarGap && scrollBarGap > 0) {\n      const computedBodyPaddingRight = parseInt(window.getComputedStyle(document.body).getPropertyValue(\"padding-right\"), 10);\n      previousBodyPaddingRight = document.body.style.paddingRight;\n      document.body.style.paddingRight = `${computedBodyPaddingRight + scrollBarGap}px`;\n    }\n  }\n  if (previousBodyOverflowSetting === void 0) {\n    previousBodyOverflowSetting = document.body.style.overflow;\n    document.body.style.overflow = \"hidden\";\n  }\n};\nconst restoreOverflowSetting = () => {\n  if (previousBodyPaddingRight !== void 0) {\n    document.body.style.paddingRight = previousBodyPaddingRight;\n    previousBodyPaddingRight = void 0;\n  }\n  if (previousBodyOverflowSetting !== void 0) {\n    document.body.style.overflow = previousBodyOverflowSetting;\n    previousBodyOverflowSetting = void 0;\n  }\n};\nconst setPositionFixed = () => window.requestAnimationFrame(() => {\n  const $html = document.documentElement;\n  const $body = document.body;\n  if (bodyStyle === void 0) {\n    htmlStyle = {\n      ...$html.style\n    };\n    bodyStyle = {\n      ...$body.style\n    };\n    const {\n      scrollY,\n      scrollX,\n      innerHeight\n    } = window;\n    $html.style.height = \"100%\";\n    $html.style.overflow = \"hidden\";\n    $body.style.position = \"fixed\";\n    $body.style.top = `${-scrollY}px`;\n    $body.style.left = `${-scrollX}px`;\n    $body.style.width = \"100%\";\n    $body.style.height = \"auto\";\n    $body.style.overflow = \"hidden\";\n    setTimeout(() => window.requestAnimationFrame(() => {\n      const bottomBarHeight = innerHeight - window.innerHeight;\n      if (bottomBarHeight && scrollY >= innerHeight) {\n        $body.style.top = -(scrollY + bottomBarHeight) + \"px\";\n      }\n    }), 300);\n  }\n});\nconst restorePositionSetting = () => {\n  if (bodyStyle !== void 0) {\n    const y = -parseInt(document.body.style.top, 10);\n    const x = -parseInt(document.body.style.left, 10);\n    const $html = document.documentElement;\n    const $body = document.body;\n    $html.style.height = (htmlStyle == null ? void 0 : htmlStyle.height) || \"\";\n    $html.style.overflow = (htmlStyle == null ? void 0 : htmlStyle.overflow) || \"\";\n    $body.style.position = bodyStyle.position || \"\";\n    $body.style.top = bodyStyle.top || \"\";\n    $body.style.left = bodyStyle.left || \"\";\n    $body.style.width = bodyStyle.width || \"\";\n    $body.style.height = bodyStyle.height || \"\";\n    $body.style.overflow = bodyStyle.overflow || \"\";\n    window.scrollTo(x, y);\n    bodyStyle = void 0;\n  }\n};\nconst isTargetElementTotallyScrolled = targetElement => targetElement ? targetElement.scrollHeight - targetElement.scrollTop <= targetElement.clientHeight : false;\nconst handleScroll = (event, targetElement) => {\n  const clientY = event.targetTouches[0].clientY - initialClientY;\n  if (allowTouchMove(event.target)) {\n    return false;\n  }\n  if (targetElement && targetElement.scrollTop === 0 && clientY > 0) {\n    return preventDefault(event);\n  }\n  if (isTargetElementTotallyScrolled(targetElement) && clientY < 0) {\n    return preventDefault(event);\n  }\n  event.stopPropagation();\n  return true;\n};\nconst disableBodyScroll = (targetElement, options) => {\n  if (!targetElement) {\n    console.error(\"disableBodyScroll unsuccessful - targetElement must be provided when calling disableBodyScroll on IOS devices.\");\n    return;\n  }\n  locksIndex.set(targetElement, (locksIndex == null ? void 0 : locksIndex.get(targetElement)) ? (locksIndex == null ? void 0 : locksIndex.get(targetElement)) + 1 : 1);\n  if (locks.some(lock2 => lock2.targetElement === targetElement)) {\n    return;\n  }\n  const lock = {\n    targetElement,\n    options: options || {}\n  };\n  locks = [...locks, lock];\n  if (isIosDevice) {\n    setPositionFixed();\n  } else {\n    setOverflowHidden(options);\n  }\n  if (isIosDevice) {\n    targetElement.ontouchstart = event => {\n      if (event.targetTouches.length === 1) {\n        initialClientY = event.targetTouches[0].clientY;\n      }\n    };\n    targetElement.ontouchmove = event => {\n      if (event.targetTouches.length === 1) {\n        handleScroll(event, targetElement);\n      }\n    };\n    if (!documentListenerAdded) {\n      document.addEventListener(\"touchmove\", preventDefault, hasPassiveEvents ? {\n        passive: false\n      } : void 0);\n      documentListenerAdded = true;\n    }\n  }\n};\nconst clearAllBodyScrollLocks = () => {\n  if (isIosDevice) {\n    locks.forEach(lock => {\n      lock.targetElement.ontouchstart = null;\n      lock.targetElement.ontouchmove = null;\n    });\n    if (documentListenerAdded) {\n      document.removeEventListener(\"touchmove\", preventDefault, hasPassiveEvents ? {\n        passive: false\n      } : void 0);\n      documentListenerAdded = false;\n    }\n    initialClientY = -1;\n  }\n  if (isIosDevice) {\n    restorePositionSetting();\n  } else {\n    restoreOverflowSetting();\n  }\n  locks = [];\n  locksIndex.clear();\n};\nconst enableBodyScroll = targetElement => {\n  if (!targetElement) {\n    console.error(\"enableBodyScroll unsuccessful - targetElement must be provided when calling enableBodyScroll on IOS devices.\");\n    return;\n  }\n  locksIndex.set(targetElement, (locksIndex == null ? void 0 : locksIndex.get(targetElement)) ? (locksIndex == null ? void 0 : locksIndex.get(targetElement)) - 1 : 0);\n  if ((locksIndex == null ? void 0 : locksIndex.get(targetElement)) === 0) {\n    locks = locks.filter(lock => lock.targetElement !== targetElement);\n    locksIndex == null ? void 0 : locksIndex.delete(targetElement);\n  }\n  if (isIosDevice) {\n    targetElement.ontouchstart = null;\n    targetElement.ontouchmove = null;\n    if (documentListenerAdded && locks.length === 0) {\n      document.removeEventListener(\"touchmove\", preventDefault, hasPassiveEvents ? {\n        passive: false\n      } : void 0);\n      documentListenerAdded = false;\n    }\n  }\n  if (locks.length === 0) {\n    if (isIosDevice) {\n      restorePositionSetting();\n    } else {\n      restoreOverflowSetting();\n    }\n  }\n};\nexport { clearAllBodyScrollLocks, disableBodyScroll, enableBodyScroll };","map":{"version":3,"names":["hasPassiveEvents","window","passiveTestOptions","passive","addEventListener","removeEventListener","isIosDevice","navigator","platform","test","maxTouchPoints","locks","locksIndex","Map","documentListenerAdded","initialClientY","previousBodyOverflowSetting","htmlStyle","bodyStyle","previousBodyPaddingRight","allowTouchMove","el","some","lock","options","preventDefault","rawEvent","e","event","target","touches","length","setOverflowHidden","reserveScrollBarGap","scrollBarGap","innerWidth","document","documentElement","getBoundingClientRect","width","computedBodyPaddingRight","parseInt","getComputedStyle","body","getPropertyValue","style","paddingRight","overflow","restoreOverflowSetting","setPositionFixed","requestAnimationFrame","$html","$body","scrollY","scrollX","innerHeight","height","position","top","left","setTimeout","bottomBarHeight","restorePositionSetting","y","x","scrollTo","isTargetElementTotallyScrolled","targetElement","scrollHeight","scrollTop","clientHeight","handleScroll","clientY","targetTouches","stopPropagation","disableBodyScroll","console","error","set","get","lock2","ontouchstart","ontouchmove","clearAllBodyScrollLocks","forEach","clear","enableBodyScroll","filter","delete"],"sources":["/Users/jenn/Desktop/info340/project-jsorror/node_modules/body-scroll-lock-upgrade/src/body-scroll-lock.ts"],"sourcesContent":["export type BodyScrollOptions = {\n  reserveScrollBarGap?: boolean | undefined;\n  allowTouchMove?: ((el: EventTarget) => boolean) | undefined;\n};\n\ntype BodyStyleType = {\n  position: string;\n  top: string;\n  left: string;\n  width: string;\n  height: string;\n  overflow: string;\n};\n\ninterface Lock {\n  targetElement: HTMLElement;\n  options: BodyScrollOptions;\n}\n\n// Older browsers don't support event options, feature detect it.\nlet hasPassiveEvents = false;\nif (typeof window !== 'undefined') {\n  const passiveTestOptions: any = {\n    get passive() {\n      hasPassiveEvents = true;\n      return undefined;\n    },\n  };\n  (window as any).addEventListener('testPassive', null, passiveTestOptions);\n  (window as any).removeEventListener('testPassive', null, passiveTestOptions);\n}\n\nconst isIosDevice =\n  typeof window !== 'undefined' &&\n  window.navigator &&\n  window.navigator.platform &&\n  (/iP(ad|hone|od)/.test(window.navigator.platform) ||\n    (window.navigator.platform === 'MacIntel' &&\n      window.navigator.maxTouchPoints > 1));\ntype HandleScrollEvent = TouchEvent;\n\nlet locks: Array<Lock> = [];\nlet locksIndex: Map<any, number> = new Map();\nlet documentListenerAdded: boolean = false;\nlet initialClientY: number = -1;\nlet previousBodyOverflowSetting: string | undefined;\nlet htmlStyle:\n  | {\n      height: string;\n      overflow: string;\n    }\n  | undefined;\nlet bodyStyle: BodyStyleType | undefined;\n\nlet previousBodyPaddingRight: string | undefined;\n\n// returns true if `el` should be allowed to receive touchmove events.\nconst allowTouchMove = (el: EventTarget): boolean =>\n  locks.some((lock) => {\n    if (lock.options.allowTouchMove && lock.options.allowTouchMove(el)) {\n      return true;\n    }\n\n    return false;\n  });\n\nconst preventDefault = (rawEvent: HandleScrollEvent): boolean => {\n  const e: any = rawEvent || window.event;\n\n  // For the case whereby consumers adds a touchmove event listener to document.\n  // Recall that we do document.addEventListener('touchmove', preventDefault, { passive: false })\n  // in disableBodyScroll - so if we provide this opportunity to allowTouchMove, then\n  // the touchmove event on document will break.\n  if (allowTouchMove(e.target)) {\n    return true;\n  }\n\n  // Do not prevent if the event has more than one touch (usually meaning this is a multi touch gesture like pinch to zoom).\n  if (e.touches.length > 1) return true;\n\n  if (e.preventDefault) e.preventDefault();\n\n  return false;\n};\n\nconst setOverflowHidden = (options?: BodyScrollOptions) => {\n  // If previousBodyPaddingRight is already set, don't set it again.\n  if (previousBodyPaddingRight === undefined) {\n    const reserveScrollBarGap =\n      !!options && options.reserveScrollBarGap === true;\n    const scrollBarGap =\n      window.innerWidth -\n      document.documentElement.getBoundingClientRect().width;\n\n    if (reserveScrollBarGap && scrollBarGap > 0) {\n      const computedBodyPaddingRight = parseInt(\n        window\n          .getComputedStyle(document.body)\n          .getPropertyValue('padding-right'),\n        10\n      );\n      previousBodyPaddingRight = document.body.style.paddingRight;\n      document.body.style.paddingRight = `${\n        computedBodyPaddingRight + scrollBarGap\n      }px`;\n    }\n  }\n\n  // If previousBodyOverflowSetting is already set, don't set it again.\n  if (previousBodyOverflowSetting === undefined) {\n    previousBodyOverflowSetting = document.body.style.overflow;\n    document.body.style.overflow = 'hidden';\n  }\n};\n\nconst restoreOverflowSetting = () => {\n  if (previousBodyPaddingRight !== undefined) {\n    document.body.style.paddingRight = previousBodyPaddingRight;\n\n    // Restore previousBodyPaddingRight to undefined so setOverflowHidden knows it\n    // can be set again.\n    previousBodyPaddingRight = undefined;\n  }\n\n  if (previousBodyOverflowSetting !== undefined) {\n    document.body.style.overflow = previousBodyOverflowSetting;\n\n    // Restore previousBodyOverflowSetting to undefined\n    // so setOverflowHidden knows it can be set again.\n    previousBodyOverflowSetting = undefined;\n  }\n};\n\nconst setPositionFixed = () =>\n  window.requestAnimationFrame(() => {\n    const $html = document.documentElement;\n    const $body = document.body;\n    // If bodyStyle is already set, don't set it again.\n    if (bodyStyle === undefined) {\n      htmlStyle = { ...$html.style };\n      bodyStyle = { ...$body.style };\n\n      // Update the dom inside an animation frame\n      const { scrollY, scrollX, innerHeight } = window;\n\n      $html.style.height = '100%';\n      $html.style.overflow = 'hidden';\n\n      $body.style.position = 'fixed';\n      $body.style.top = `${-scrollY}px`;\n      $body.style.left = `${-scrollX}px`;\n      $body.style.width = '100%';\n      $body.style.height = 'auto';\n      $body.style.overflow = 'hidden';\n\n      setTimeout(\n        () =>\n          window.requestAnimationFrame(() => {\n            // Attempt to check if the bottom bar appeared due to the position change\n            const bottomBarHeight = innerHeight - window.innerHeight;\n            if (bottomBarHeight && scrollY >= innerHeight) {\n              // Move the content further up so that the bottom bar doesn't hide it\n              $body.style.top = -(scrollY + bottomBarHeight) + 'px';\n            }\n          }),\n        300\n      );\n    }\n  });\n\nconst restorePositionSetting = () => {\n  if (bodyStyle !== undefined) {\n    // Convert the position from \"px\" to Int\n    const y = -parseInt(document.body.style.top, 10);\n    const x = -parseInt(document.body.style.left, 10);\n\n    // Restore styles\n    const $html = document.documentElement;\n    const $body = document.body;\n\n    $html.style.height = htmlStyle?.height || '';\n    $html.style.overflow = htmlStyle?.overflow || '';\n\n    $body.style.position = bodyStyle.position || '';\n    $body.style.top = bodyStyle.top || '';\n    $body.style.left = bodyStyle.left || '';\n    $body.style.width = bodyStyle.width || '';\n    $body.style.height = bodyStyle.height || '';\n    $body.style.overflow = bodyStyle.overflow || '';\n\n    // Restore scroll\n    window.scrollTo(x, y);\n\n    bodyStyle = undefined;\n  }\n};\n\n// https://developer.mozilla.org/en-US/docs/Web/API/Element/scrollHeight#Problems_and_solutions\nconst isTargetElementTotallyScrolled = (targetElement: HTMLElement): boolean =>\n  targetElement\n    ? targetElement.scrollHeight - targetElement.scrollTop <=\n      targetElement.clientHeight\n    : false;\n\nconst handleScroll = (\n  event: HandleScrollEvent,\n  targetElement: HTMLElement\n): boolean => {\n  const clientY = event.targetTouches[0].clientY - initialClientY;\n\n  if (allowTouchMove(event.target as EventTarget)) {\n    return false;\n  }\n\n  if (targetElement && targetElement.scrollTop === 0 && clientY > 0) {\n    // element is at the top of its scroll.\n    return preventDefault(event);\n  }\n\n  if (isTargetElementTotallyScrolled(targetElement) && clientY < 0) {\n    // element is at the bottom of its scroll.\n    return preventDefault(event);\n  }\n\n  event.stopPropagation();\n  return true;\n};\n\n/**\n *\n * @param targetElement HTMLElement\n * @param options BodyScrollOptions\n * @returns void\n */\nexport const disableBodyScroll = (\n  targetElement: HTMLElement,\n  options?: BodyScrollOptions\n): void => {\n  // targetElement must be provided\n  if (!targetElement) {\n    // eslint-disable-next-line no-console\n    console.error(\n      'disableBodyScroll unsuccessful - targetElement must be provided when calling disableBodyScroll on IOS devices.'\n    );\n    return;\n  }\n\n  locksIndex.set(\n    targetElement,\n    locksIndex?.get(targetElement)\n      ? (locksIndex?.get(targetElement) as number) + 1\n      : 1\n  );\n  // disableBodyScroll must not have been called on this targetElement before\n  if (locks.some((lock) => lock.targetElement === targetElement)) {\n    return;\n  }\n\n  const lock = {\n    targetElement,\n    options: options || {},\n  };\n  locks = [...locks, lock];\n\n  if (isIosDevice) {\n    setPositionFixed();\n  } else {\n    setOverflowHidden(options);\n  }\n\n  if (isIosDevice) {\n    targetElement.ontouchstart = (event: HandleScrollEvent) => {\n      if (event.targetTouches.length === 1) {\n        // detect single touch.\n        initialClientY = event.targetTouches[0].clientY;\n      }\n    };\n    targetElement.ontouchmove = (event: HandleScrollEvent) => {\n      if (event.targetTouches.length === 1) {\n        // detect single touch.\n        handleScroll(event, targetElement);\n      }\n    };\n\n    if (!documentListenerAdded) {\n      document.addEventListener(\n        'touchmove',\n        preventDefault,\n        hasPassiveEvents ? { passive: false } : undefined\n      );\n      documentListenerAdded = true;\n    }\n  }\n};\n\nexport const clearAllBodyScrollLocks = (): void => {\n  if (isIosDevice) {\n    // Clear all locks ontouchstart/ontouchmove handlers, and the references.\n    locks.forEach((lock: Lock) => {\n      lock.targetElement.ontouchstart = null;\n      lock.targetElement.ontouchmove = null;\n    });\n\n    if (documentListenerAdded) {\n      (document as any).removeEventListener(\n        'touchmove',\n        preventDefault,\n        hasPassiveEvents ? { passive: false } : undefined\n      );\n      documentListenerAdded = false;\n    }\n\n    // Reset initial clientY.\n    initialClientY = -1;\n  }\n\n  if (isIosDevice) {\n    restorePositionSetting();\n  } else {\n    restoreOverflowSetting();\n  }\n\n  locks = [];\n  locksIndex.clear();\n};\n\n/**\n * @param targetElement\n * @returns void\n */\nexport const enableBodyScroll = (targetElement: HTMLElement): void => {\n  if (!targetElement) {\n    // eslint-disable-next-line no-console\n    console.error(\n      'enableBodyScroll unsuccessful - targetElement must be provided when calling enableBodyScroll on IOS devices.'\n    );\n    return;\n  }\n\n  locksIndex.set(\n    targetElement,\n    locksIndex?.get(targetElement)\n      ? (locksIndex?.get(targetElement) as number) - 1\n      : 0\n  );\n  if (locksIndex?.get(targetElement) === 0) {\n    locks = locks.filter((lock) => lock.targetElement !== targetElement);\n    locksIndex?.delete(targetElement);\n  }\n\n  if (isIosDevice) {\n    targetElement.ontouchstart = null;\n    targetElement.ontouchmove = null;\n\n    if (documentListenerAdded && locks.length === 0) {\n      (document as any).removeEventListener(\n        'touchmove',\n        preventDefault,\n        hasPassiveEvents ? { passive: false } : undefined\n      );\n      documentListenerAdded = false;\n    }\n  }\n\n  if (locks.length === 0) {\n    if (isIosDevice) {\n      restorePositionSetting();\n    } else {\n      restoreOverflowSetting();\n    }\n  }\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}