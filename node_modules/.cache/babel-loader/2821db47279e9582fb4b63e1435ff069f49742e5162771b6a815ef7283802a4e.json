{"ast":null,"code":"(function () {\n  \"use strict\";\n\n  try {\n    if (typeof document != \"undefined\") {\n      var elementStyle = document.createElement(\"style\");\n      elementStyle.appendChild(document.createTextNode(\"._handle_bk7m7_1 {\\n  fill: var(--color-handle-fill);\\n  stroke: var(--color-handle-stroke);\\n}\\n\\n._dragging_bk7m7_6 {\\n  fill: var(--color-handle-drag-fill);\\n}\\n\\n._dot_bk7m7_10 {\\n  fill: var(--color-handle-dots);\\n}\\n\\n._line_bk7m7_14 {\\n  stroke: var(--color-handle-line);\\n}\\n._slice_1knu8_1 {\\n  fill: var(--color-primary);\\n}\\n\\n._unsliced_1knu8_5 {\\n  fill: var(--color-background);\\n  opacity: 0.5;\\n  pointer-events: none;\\n}\\n._container_1u3dt_1 {\\n  /** Old mappings - to be removed in next major */\\n  --color-background: rgb(51, 51, 51);\\n  --color-on-background: #fff;\\n\\n  --color-tooltip: rgba(0, 5, 11, 0.9);\\n  --color-on-tooltip: #fff;\\n\\n  --color-handle-fill: #2c343a;\\n  --color-handle-stroke: #67c2e4;\\n  --color-handle-drag-fill: transparent;\\n  --color-handle-dots: #67c2e4;\\n  --color-handle-line: #67c2e4;\\n\\n  /** New mappings */\\n  --tooltip-background: var(--color-tooltip);\\n  --tooltip-color: var(--color-on-tooltip);\\n  --tooltip-border-radius: 5px;\\n  --tooltip-spacing: 5px;\\n\\n  --chart-background: var(--color-background);\\n  --chart-color: var(--color-on-background);\\n\\n  --chart-handle-fill: var(--color-handle-fill);\\n  --chart-handle-stroke: var(--color-handle-stroke);\\n  --chart-handle-drag-fill: var(--color-handle-drag-fill);\\n  --chart-handle-dots: var(--color-handle-dots);\\n  --chart-handle-line: var(--color-handle-line);\\n}\\n\\n  ._container_1u3dt_1 ._svg_1u3dt_30:focus {\\n      outline: none;\\n    }\\n\\n  ._container_1u3dt_1 ._svg_1u3dt_30:focus-visible {\\n      outline: auto;\\n    }\\n._container_19vag_1 {\\n  display: flex;\\n  overflow: auto;\\n}\\n\\n  ._container_19vag_1._horizontal_19vag_5 {\\n    align-items: center;\\n    flex-direction: row;\\n  }\\n\\n  ._container_19vag_1._vertical_19vag_10 {\\n    flex-direction: column;\\n  }\\n._symbol_f5unn_1 {\\n  width: 15px;\\n  height: 3px;\\n}\\n._entry_1493o_1 {\\n  display: flex;\\n  color: var(--color-on-primary);\\n  padding: 8px;\\n  will-change: transparency;\\n  transition: opacity 150ms ease-in;\\n}\\n\\n  ._entry_1493o_1._vertical_1493o_8 {\\n    flex-direction: row;\\n    align-items: center;\\n  }\\n\\n  ._entry_1493o_1._vertical_1493o_8:first-child {\\n      padding-top: 0;\\n    }\\n\\n  ._entry_1493o_1._vertical_1493o_8:last-child {\\n      padding-bottom: 0;\\n    }\\n\\n  ._entry_1493o_1._vertical_1493o_8 ._label_1493o_20 {\\n      margin-left: 8px;\\n    }\\n\\n  ._entry_1493o_1._vertical_1493o_8 svg {\\n      display: block;\\n      margin: 0 auto;\\n    }\\n\\n  ._entry_1493o_1._horizontal_1493o_30 {\\n    align-items: center;\\n    flex-direction: row;\\n  }\\n\\n  ._entry_1493o_1._horizontal_1493o_30:first-child {\\n      padding-left: 0;\\n    }\\n\\n  ._entry_1493o_1._horizontal_1493o_30:last-child {\\n      padding-right: 0;\\n    }\\n\\n  ._entry_1493o_1._horizontal_1493o_30 ._label_1493o_20 {\\n      margin-left: 8px;\\n    }\\n\\n  ._entry_1493o_1 ._label_1493o_20 {\\n    font-size: 12px;\\n  }\\n\\n  ._entry_1493o_1 svg {\\n    width: 15px;\\n    height: 15px;\\n  }\\n._container_1gnp9_1 {\\n  display: flex;\\n  height: 100%;\\n}\\n\\n  ._container_1gnp9_1._vertical_1gnp9_5 {\\n    flex-direction: column;\\n    max-width: 55px;\\n  }\\n\\n  ._container_1gnp9_1._vertical_1gnp9_5 ._start_1gnp9_9,\\n    ._container_1gnp9_1._vertical_1gnp9_5 ._end_1gnp9_10 {\\n      text-align: center;\\n      padding: 5px 0;\\n      width: 100%;\\n    }\\n\\n  ._container_1gnp9_1._vertical_1gnp9_5 ._gradient_1gnp9_16 {\\n      width: 25px;\\n      margin: 0 auto;\\n    }\\n\\n  ._container_1gnp9_1._horizontal_1gnp9_22 {\\n    flex-direction: row-reverse;\\n  }\\n\\n  ._container_1gnp9_1._horizontal_1gnp9_22 ._start_1gnp9_9,\\n    ._container_1gnp9_1._horizontal_1gnp9_22 ._end_1gnp9_10 {\\n      max-width: 20%;\\n    }\\n\\n  ._container_1gnp9_1._horizontal_1gnp9_22 ._start_1gnp9_9 {\\n      text-align: right;\\n      padding-left: 5px;\\n    }\\n\\n  ._container_1gnp9_1._horizontal_1gnp9_22 ._end_1gnp9_10 {\\n      text-align: left;\\n      padding-right: 5px;\\n    }\\n\\n  ._container_1gnp9_1 ._gradient_1gnp9_16 {\\n    flex: 1;\\n    width: 100%;\\n    border-radius: 2px;\\n  }\\n\\n  ._container_1gnp9_1 ._start_1gnp9_9,\\n  ._container_1gnp9_1 ._end_1gnp9_10 {\\n    color: var(--color-on-primary);\\n    font-size: 12px;\\n    white-space: nowrap;\\n    overflow: hidden;\\n    text-overflow: ellipsis;\\n  }\\n._gridLine_5yx3q_1 {\\n  shape-rendering: crispEdges;\\n  pointer-events: none;\\n}\\n._gridStripe_xcrvl_1 {\\n  pointer-events: none;\\n}\\n._markLine_1sfls_1 {\\n  pointer-events: none;\\n  stroke-dasharray: 4, 4;\\n  stroke-linecap: round;\\n}\\n._label_uiu20_1 {\\n  font-size: 16px;\\n  margin-bottom: 3px;\\n  color: var(--color-on-tooltip);\\n}\\n\\n._value_uiu20_7 {\\n  font-size: 13px;\\n  color: var(--color-on-tooltip);\\n  opacity: 0.7;\\n}\\n\\n._subValue_uiu20_13 {\\n  display: block;\\n  text-align: left;\\n  padding: 3px 5px;\\n}\\n\\n._subValue_uiu20_13 ._subValueColor_uiu20_18 {\\n    width: 5px;\\n    height: 15px;\\n    margin-right: 8px;\\n    display: inline-block;\\n  }\\n\\n._subValue_uiu20_13 ._subValueName_uiu20_25 {\\n    margin-right: 5px;\\n  }\\n._base_b22et_1 {\\n  white-space: nowrap;\\n  text-align: center;\\n  will-change: transform, opacity;\\n  background-color: var(--tooltip-background);\\n  color: var(--tooltip-color);\\n  padding: var(--tooltip-spacing);\\n  border-radius: var(--tooltip-border-radius);\\n}\\n\\n  ._base_b22et_1 ._disablePointer_b22et_10 {\\n    cursor: not-allowed;\\n  }\\n._inactive_jp2yc_1 {\\n  opacity: 0.2;\\n}\\n\\n._hidden_jp2yc_5 {\\n  opacity: 0;\\n}\\n._scatterPlot_gc5eo_1 {\\n  overflow: visible;\\n}\\n._point_u68jv_1 {\\n  stroke: rgba(255, 255, 255, 0.5);\\n  stroke-width: 1px;\\n}\\n._areaChart_yyojn_1 {\\n  overflow: visible;\\n}\\n._barChart_sfjii_1 {\\n  overflow: visible;\\n}\\n\\n  ._barChart_sfjii_1._stackedNormalized_sfjii_4 .bar, ._barChart_sfjii_1._stacked_sfjii_4 .bar, ._barChart_sfjii_1._marimekko_sfjii_6 .bar {\\n      stroke: var(--color-background);\\n      stroke-width: 0.2;\\n    }\\n._marker_agib4_1 {\\n  fill: var(--color-primary);\\n  cursor: pointer;\\n}\\n._label_qd893_1 {\\n  font-size: 12px;\\n  -webkit-user-select: none;\\n     -moz-user-select: none;\\n          user-select: none;\\n  pointer-events: none;\\n}\\n._link_1oi50_1 {\\n  fill: none;\\n  transition: stroke-opacity 100ms ease-in-out, stroke 100ms ease-in-out;\\n  mix-blend-mode: initial;\\n}\\n\\n._tooltip_1oi50_7 {\\n  text-align: center;\\n  pointer-events: none;\\n}\\n\\n._tooltip_1oi50_7 ._tooltipLabel_1oi50_11 {\\n    font-size: 16px;\\n    margin-bottom: 3px;\\n    color: rgba(255, 255, 255, 1);\\n    text-align: center;\\n  }\\n\\n._tooltip_1oi50_7 ._tooltipValue_1oi50_18 {\\n    font-size: 13px;\\n    color: rgba(255, 255, 255, 0.7);\\n    text-align: center;\\n  }\\n._node_oqk6h_1 {\\n  transition: opacity 100ms ease-in-out, fill-opacity 100ms ease-in-out;\\n}\\n\\n._tooltip_oqk6h_5 {\\n  text-align: center;\\n  padding: 0 8px;\\n  pointer-events: none;\\n}\\n\\n._tooltip_oqk6h_5 ._tooltipLabel_oqk6h_10 {\\n    font-size: 16px;\\n    margin-bottom: 3px;\\n    color: rgba(255, 255, 255, 1);\\n    text-align: center;\\n  }\\n\\n._tooltip_oqk6h_5 ._tooltipValue_oqk6h_17 {\\n    font-size: 13px;\\n    color: rgba(255, 255, 255, 0.7);\\n    text-align: center;\\n  }\\n._inactive_kwc4n_1 {\\n  opacity: 0.4;\\n  transition: opacity 200ms ease-in-out;\\n}\\n\\n._hidden_kwc4n_6 {\\n  opacity: 0;\\n}\\n._valueLabel_1eyd5_1 {\\n  font-size: 14px;\\n  font-weight: 400;\\n  fill: var(--color-on-background);\\n  opacity: 0.6;\\n}\\n._valueLabel_1h164_1 {\\n  font-size: 18px;\\n  font-weight: 400;\\n  fill: var(--color-on-background);\\n}\\n._stackedValueLabel_1w6zx_1 {\\n  font-size: 18px;\\n  font-weight: 400;\\n  fill: var(--color-on-background);\\n}\\n._stackedDescriptionLabel_1h95t_1 {\\n  font-size: 12px;\\n  font-weight: 400;\\n  fill: var(--color-on-background);\\n}\\n._cell_r3f8c_1 {\\n  transition: stroke 150ms ease-in-out;\\n}\\n._item_18e6r_1 {\\n  margin-bottom: 5px;\\n  align-items: center;\\n  display: grid;\\n  grid-column-gap: 5px;\\n  grid-row-gap: 3px;\\n}\\n\\n  ._item_18e6r_1._labelStart_18e6r_8._valueEnd_18e6r_9 {\\n      grid-template-columns: 2fr 2fr 1fr;\\n      grid-template-areas: 'label bar value-label';\\n    }\\n\\n  ._item_18e6r_1._labelBottom_18e6r_15._valueEnd_18e6r_9 {\\n      grid-template-columns: 1fr 50px;\\n      grid-template-areas:\\n        'bar value-label'\\n        'label label';\\n    }\\n\\n  ._item_18e6r_1._labelNone_18e6r_24 ._label_18e6r_8 {\\n      display: none;\\n    }\\n\\n  ._item_18e6r_1._labelNone_18e6r_24._valueEnd_18e6r_9 {\\n      grid-template-columns: 1fr 50px;\\n      grid-template-areas: 'bar value-label';\\n    }\\n\\n  ._item_18e6r_1._labelEnd_18e6r_35._valueStart_18e6r_36 {\\n      grid-template-columns: 50px 1fr 1fr;\\n      grid-template-areas: 'value-label bar label';\\n    }\\n\\n  ._item_18e6r_1._labelTop_18e6r_42._valueStart_18e6r_36 {\\n      grid-template-columns: 50px 1fr;\\n      grid-template-areas:\\n        'label label'\\n        'value-label bar';\\n    }\\n\\n  ._item_18e6r_1._labelTop_18e6r_42._valueEnd_18e6r_9 {\\n      grid-template-columns: 1fr 50px;\\n      grid-template-areas:\\n        'label label'\\n        'bar value-label';\\n    }\\n\\n  ._item_18e6r_1._labelTop_18e6r_42._valueBottom_18e6r_57 {\\n      grid-template-columns: 1fr;\\n      grid-template-areas:\\n        'label'\\n        'bar'\\n        'value-label';\\n    }\\n\\n  ._item_18e6r_1._labelTop_18e6r_42._valueNone_18e6r_65 {\\n      grid-template-columns: 1fr;\\n      grid-template-areas:\\n        'label'\\n        'bar';\\n    }\\n\\n  ._item_18e6r_1._labelTop_18e6r_42._valueNone_18e6r_65 ._valueLabel_18e6r_71 {\\n        display: none;\\n      }\\n\\n  ._item_18e6r_1._clickable_18e6r_77 {\\n    cursor: pointer;\\n  }\\n\\n  ._item_18e6r_1 ._label_18e6r_8,\\n  ._item_18e6r_1 ._valueLabel_18e6r_71 {\\n    cursor: inherit;\\n  }\\n\\n  ._item_18e6r_1 ._label_18e6r_8 {\\n    grid-area: label;\\n  }\\n\\n  ._item_18e6r_1 ._valueLabel_18e6r_71 {\\n    grid-area: value-label;\\n    line-height: 10px;\\n    text-overflow: ellipsis;\\n    overflow-x: hidden;\\n  }\\n\\n  ._item_18e6r_1 ._outerBar_18e6r_97 {\\n    grid-area: bar;\\n    width: 100%;\\n    height: 10px;\\n    display: flex;\\n    align-items: center;\\n  }\\n\\n  ._item_18e6r_1 ._bar_18e6r_105 {\\n    height: 5px;\\n  }\\n._container_13giw_1 {\\n  display: flex;\\n  flex-direction: row;\\n  justify-content: space-between;\\n  align-items: center;\\n}\\n\\n  ._container_13giw_1 > div {\\n    flex: 1;\\n  }\"));\n      document.head.appendChild(elementStyle);\n    }\n  } catch (e) {\n    console.error(\"vite-plugin-css-injected-by-js\", e);\n  }\n})();\nimport { jsxs, jsx, Fragment as Fragment$1 } from \"react/jsx-runtime\";\nimport { useId, CloneElement, Tooltip } from \"reablocks\";\nimport { Fragment, createRef, useState, useCallback, useEffect, useMemo, useRef, Children, cloneElement, createContext, useContext, Component, forwardRef, useImperativeHandle, createElement, isValidElement } from \"react\";\nimport ellipsize from \"ellipsize\";\nimport { max, min, bisector, range, median, histogram, extent as extent$1, maxIndex } from \"d3-array\";\nimport { arc, line as line$1, curveMonotoneX, curveStep, curveLinear, stack, stackOffsetExpand, stackOffsetDiverging, area, pie, radialArea, curveCardinalClosed, curveCardinal, curveLinearClosed, radialLine } from \"d3-shape\";\nimport { scaleLinear, scaleTime, scaleBand, scaleOrdinal, scaleQuantile, scalePoint } from \"d3-scale\";\nimport humanFormat from \"human-format\";\nimport { applyToPoint, inverse, applyToPoints, smoothMatrix, transform, translate, scale, identity, fromDefinition, fromObject } from \"transformation-matrix\";\nimport classNames from \"classnames\";\nimport bind from \"memoize-bind\";\nimport useDimensions from \"react-cool-dimensions\";\nimport bigInt from \"big-integer\";\nimport chroma from \"chroma-js\";\nimport isEqual from \"react-fast-compare\";\nimport { useMotionValue, useSpring, motion, animate } from \"framer-motion\";\nimport { interpolate as interpolate$1 } from \"d3-interpolate\";\nimport { identifier } from \"safe-identifier\";\nimport { geoNaturalEarth1, geoMercator, geoPath } from \"d3-geo\";\nimport { sankey, sankeyJustify, sankeyCenter, sankeyLeft, sankeyRight, sankeyLinkHorizontal } from \"d3-sankey\";\nimport { layout } from \"@upsetjs/venn.js\";\nimport invert from \"invert-color\";\nimport { pack, hierarchy, treemap, treemapSquarify } from \"d3-hierarchy\";\nconst LinearAxisLine = ({\n  strokeColor,\n  strokeWidth,\n  strokeGradient,\n  scale: scale2,\n  orientation,\n  className\n}) => {\n  const id = useId();\n  const [range0, range1] = scale2.range();\n  return /* @__PURE__ */jsxs(Fragment, {\n    children: [/* @__PURE__ */jsx(\"line\", {\n      className,\n      x1: orientation === \"vertical\" ? 0 : range0,\n      x2: orientation === \"vertical\" ? 1e-5 : range1,\n      y1: orientation === \"vertical\" ? range0 : 0,\n      y2: orientation === \"vertical\" ? range1 : 1e-5,\n      strokeWidth,\n      stroke: strokeGradient ? `url(#axis-gradient-${id})` : strokeColor\n    }), strokeGradient && /* @__PURE__ */jsx(CloneElement, {\n      element: strokeGradient,\n      id: `axis-gradient-${id}`\n    })]\n  });\n};\nLinearAxisLine.defaultProps = {\n  strokeColor: \"#8F979F\",\n  strokeWidth: 1\n};\nconst LinearAxis = props => {\n  const {\n    position,\n    tickSeries,\n    axisLine,\n    height,\n    width,\n    scale: scale2,\n    orientation,\n    visibility = \"visible\",\n    onDimensionsChange\n  } = props;\n  const containerRef = createRef();\n  const [dimensions, setDimensions] = useState({\n    height,\n    width\n  });\n  const updateDimensions = useCallback(() => {\n    const shouldOffset = position !== \"center\";\n    let height2;\n    let width2;\n    if (shouldOffset) {\n      const dims = containerRef.current.getBoundingClientRect();\n      width2 = Math.floor(dims.width);\n      height2 = Math.floor(dims.height);\n    }\n    if (orientation === \"vertical\") {\n      if (dimensions.width !== width2) {\n        setDimensions({\n          ...dimensions,\n          width: width2\n        });\n        onDimensionsChange({\n          width: width2\n        });\n      }\n    } else {\n      if (dimensions.height !== height2) {\n        setDimensions({\n          ...dimensions,\n          height: height2\n        });\n        onDimensionsChange({\n          height: height2\n        });\n      }\n    }\n  }, [containerRef, dimensions, onDimensionsChange, orientation, position]);\n  useEffect(() => {\n    updateDimensions();\n  }, [updateDimensions, height, width, scale2]);\n  function getPosition() {\n    let translateY2 = 0;\n    let translateX2 = 0;\n    if (position === \"end\" && orientation === \"horizontal\") {\n      translateY2 = height;\n    } else if (position === \"center\" && orientation === \"horizontal\") {\n      translateY2 = height / 2;\n    } else if (position === \"end\" && orientation === \"vertical\") {\n      translateX2 = width;\n    } else if (position === \"center\" && orientation === \"vertical\") {\n      translateX2 = width / 2;\n    }\n    return {\n      translateX: translateX2,\n      translateY: translateY2\n    };\n  }\n  const {\n    translateX,\n    translateY\n  } = getPosition();\n  return /* @__PURE__ */jsxs(\"g\", {\n    transform: `translate(${translateX}, ${translateY})`,\n    ref: containerRef,\n    visibility,\n    children: [axisLine && /* @__PURE__ */jsx(CloneElement, {\n      element: axisLine,\n      height,\n      width,\n      scale: scale2,\n      orientation\n    }), (tickSeries.props.line || tickSeries.props.label) && /* @__PURE__ */jsx(CloneElement, {\n      element: tickSeries,\n      height,\n      width,\n      scale: scale2,\n      orientation,\n      axis: props\n    })]\n  });\n};\nLinearAxis.defaultProps = {\n  scaled: false,\n  roundDomains: false,\n  axisLine: /* @__PURE__ */jsx(LinearAxisLine, {}),\n  onDimensionsChange: () => void 0\n};\nconst LinearAxisTickLabel = ({\n  text,\n  fullText,\n  angle,\n  orientation,\n  half,\n  line: line2,\n  textAnchor,\n  position,\n  className,\n  fill,\n  fontSize,\n  fontFamily,\n  rotation,\n  padding,\n  formatTooltip,\n  align\n}) => {\n  function getAlign() {\n    if ((align === \"inside\" || align === \"outside\") && half === \"center\") {\n      return \"center\";\n    }\n    if (align === \"inside\") {\n      return half === \"start\" ? \"end\" : \"start\";\n    }\n    if (align === \"outside\") {\n      return half === \"start\" ? \"start\" : \"end\";\n    }\n    return align;\n  }\n  function getTickLineSpacing() {\n    if (!line2) {\n      return [0, 0];\n    }\n    const size = line2.props.size ?? 3;\n    const position2 = line2.props.position ?? \"center\";\n    if (position2 === \"start\") {\n      return [size * -1, 0];\n    } else if (position2 === \"end\") {\n      return [0, size];\n    } else {\n      return [size * -0.5, size * 0.5];\n    }\n  }\n  function getOffset() {\n    const adjustedPadding = typeof padding === \"number\" ? {\n      fromAxis: padding,\n      alongAxis: padding\n    } : padding;\n    const spacing = getTickLineSpacing();\n    const offset1 = position === \"start\" ? spacing[0] - adjustedPadding.fromAxis : position === \"end\" ? spacing[1] + adjustedPadding.fromAxis : 0;\n    const align2 = getAlign();\n    let offset2 = 0;\n    offset2 += align2 === \"center\" ? 0 : align2 === \"start\" ? -adjustedPadding.alongAxis : adjustedPadding.alongAxis;\n    const horz = orientation === \"horizontal\";\n    return {\n      [horz ? \"x\" : \"y\"]: offset2,\n      [horz ? \"y\" : \"x\"]: offset1\n    };\n  }\n  function getTextPosition() {\n    let transform2 = \"\";\n    let newtextAnchor = \"\";\n    let alignmentBaseline = \"middle\";\n    if (angle !== 0) {\n      transform2 = `rotate(${angle})`;\n      newtextAnchor = \"end\";\n    } else {\n      const align2 = getAlign();\n      if (orientation === \"horizontal\") {\n        newtextAnchor = align2 === \"center\" ? \"middle\" : align2 === \"start\" ? \"end\" : \"start\";\n        if (position === \"start\") {\n          alignmentBaseline = \"baseline\";\n        } else if (position === \"end\") {\n          alignmentBaseline = \"hanging\";\n        }\n      } else {\n        alignmentBaseline = align2 === \"center\" ? \"middle\" : align2 === \"start\" ? \"baseline\" : \"hanging\";\n        if (position === \"start\") {\n          newtextAnchor = \"end\";\n        } else if (position === \"end\") {\n          newtextAnchor = \"start\";\n        } else {\n          newtextAnchor = \"middle\";\n        }\n      }\n    }\n    return {\n      transform: transform2,\n      textAnchor: textAnchor || newtextAnchor,\n      alignmentBaseline\n    };\n  }\n  const {\n    x,\n    y\n  } = getOffset();\n  const textPosition = getTextPosition();\n  const titleHover = typeof formatTooltip === \"function\" ? formatTooltip(fullText) : fullText;\n  return /* @__PURE__ */jsxs(\"g\", {\n    transform: `translate(${x}, ${y})`,\n    fontSize,\n    fontFamily,\n    children: [/* @__PURE__ */jsx(\"title\", {\n      children: titleHover\n    }), /* @__PURE__ */jsx(\"text\", {\n      ...textPosition,\n      fill,\n      className,\n      children: text\n    })]\n  });\n};\nLinearAxisTickLabel.defaultProps = {\n  fill: \"#8F979F\",\n  fontSize: 11,\n  fontFamily: \"sans-serif\",\n  rotation: true,\n  padding: 5,\n  align: \"center\"\n};\nconst LinearAxisTickLine = ({\n  size,\n  position,\n  orientation,\n  strokeColor,\n  strokeWidth,\n  className\n}) => {\n  const path2 = useMemo(() => {\n    const isVertical = orientation === \"vertical\";\n    const tickSize = size || 0;\n    const start2 = position === \"start\" ? tickSize * -1 : position === \"center\" ? tickSize * -0.5 : 0;\n    const end2 = start2 + tickSize;\n    return {\n      x1: isVertical ? end2 : 0,\n      x2: isVertical ? start2 : 0,\n      y1: isVertical ? 0 : start2,\n      y2: isVertical ? 0 : end2\n    };\n  }, [orientation, position, size]);\n  return /* @__PURE__ */jsx(\"line\", {\n    className,\n    strokeWidth,\n    stroke: strokeColor,\n    ...path2\n  });\n};\nLinearAxisTickLine.defaultProps = {\n  strokeColor: \"#8F979F\",\n  strokeWidth: 1,\n  size: 5\n};\nconst getNavigatorLanguage = () => {\n  if (typeof window === \"undefined\") {\n    return \"en\";\n  }\n  if (navigator.languages && navigator.languages.length) {\n    return navigator.languages[0];\n  }\n  if (navigator.userLanguage || navigator.language || navigator.browserLanguage) {\n    return \"en\";\n  }\n};\nconst locale = getNavigatorLanguage();\nconst options = {\n  year: \"numeric\",\n  month: \"numeric\",\n  day: \"numeric\",\n  hour12: true,\n  formatMatcher: \"best fit\"\n};\nfunction formatValue(value2) {\n  if (value2 !== void 0) {\n    if (value2 instanceof Date) {\n      return value2.toLocaleDateString(locale, options);\n    } else if (typeof value2 === \"number\") {\n      return value2.toLocaleString();\n    }\n    return value2;\n  }\n  return \"No value\";\n}\nfunction getAriaLabel(datapoint) {\n  const isArray = Array.isArray(datapoint);\n  if (isArray) {\n    return datapoint == null ? void 0 : datapoint.map(row => getAriaLabel(row)).join(\", \");\n  } else {\n    const key = (datapoint == null ? void 0 : datapoint.key) || (datapoint == null ? void 0 : datapoint.x);\n    const value2 = (datapoint == null ? void 0 : datapoint.data) || (datapoint == null ? void 0 : datapoint.y);\n    return `${key}: ${formatValue(value2)}`;\n  }\n}\nconst ONE_DAY = 60 * 60 * 24;\nconst DURATION_TICK_STEPS = [1e-3,\n// 1 ms\n5e-3,\n// 5 ms\n0.01,\n// 10 ms\n0.05,\n// 50 ms\n0.1,\n// 100 ms\n0.5,\n// 500 ms\n1,\n// 1 s\n5,\n// 5 s\n10,\n// 10 s\n15,\n// 15 s\n60,\n// 1 m\n60 * 15,\n// 15 m\n60 * 30,\n// 30 m\n60 * 60,\n// 1 h\n60 * 60 * 2,\n// 2 h\n60 * 60 * 4,\n// 4 h\n60 * 60 * 6,\n// 6 h\n60 * 60 * 8,\n// 8 h\n60 * 60 * 12,\n// 12 h\nONE_DAY\n// 24 h\n];\nfunction reduceTicks(ticks, maxTicks) {\n  if (ticks.length > maxTicks) {\n    const reduced = [];\n    const modulus = Math.floor(ticks.length / maxTicks);\n    for (let i = 0; i < ticks.length; i++) {\n      if (i % modulus === 0) {\n        reduced.push(ticks[i]);\n      }\n    }\n    ticks = reduced;\n  }\n  return ticks;\n}\nfunction getMaxTicks(size, dimension) {\n  const tickWidth = Math.max(size, 0);\n  return Math.floor(dimension / tickWidth);\n}\nfunction getDurationTicks(domain, maxTicks) {\n  const domainWidth = domain[1] - domain[0];\n  let tickStep = null;\n  for (const s of DURATION_TICK_STEPS) {\n    if (domainWidth / s < maxTicks) {\n      tickStep = s;\n      break;\n    }\n  }\n  if (tickStep === null) {\n    const numDayTicks = domainWidth / ONE_DAY;\n    const dayStep = Math.ceil(numDayTicks / maxTicks);\n    tickStep = ONE_DAY * dayStep;\n  }\n  const ticks = [domain[0]];\n  while (ticks[ticks.length - 1] + tickStep <= domain[1]) {\n    ticks.push(ticks[ticks.length - 1] + tickStep);\n  }\n  return ticks;\n}\nfunction getTicks(scale2, tickValues, type, maxTicks = 100, interval) {\n  let result;\n  if (tickValues) {\n    result = tickValues;\n  } else {\n    if (scale2.ticks) {\n      if (type === \"duration\") {\n        result = getDurationTicks(scale2.domain(), maxTicks);\n      } else if (interval) {\n        result = scale2.ticks(interval);\n      } else {\n        if (type === \"time\") {\n          result = scale2.ticks();\n          result = reduceTicks(result, maxTicks);\n        } else {\n          result = scale2.ticks(maxTicks);\n        }\n      }\n    } else {\n      tickValues = scale2.domain();\n      result = reduceTicks(tickValues, maxTicks);\n    }\n  }\n  return result;\n}\nconst cache = {};\nconst calculateDimensions = (text, fontFamily, fontSize) => {\n  const key = `${text}_${fontFamily}_${fontSize}`;\n  if (cache[key]) {\n    return cache[key];\n  }\n  if (typeof window === \"undefined\" || typeof document === \"undefined\") {\n    const height = parseInt(typeof fontSize === \"string\" ? fontSize : fontSize.toString(), 10);\n    const dimensions2 = {\n      height,\n      // 8 is an approximation of the width of a character\n      width: text.length * 8\n    };\n    cache[key] = dimensions2;\n    return dimensions2;\n  }\n  const element = document.createElement(\"div\");\n  element.style.fontFamily = fontFamily;\n  element.style.fontSize = typeof fontSize === \"string\" ? fontSize : `${fontSize}px`;\n  element.style.position = \"absolute\";\n  element.style.left = \"-9999px\";\n  element.style.whiteSpace = \"nowrap\";\n  element.style.height = \"auto\";\n  element.style.fontWeight = \"normal\";\n  element.style.lineHeight = \"normal\";\n  element.style.width = \"auto\";\n  element.style.wordBreak = \"normal\";\n  element.textContent = text;\n  document.body.appendChild(element);\n  const dimensions = {\n    height: element.offsetHeight,\n    width: element.offsetWidth\n  };\n  document.body.removeChild(element);\n  cache[key] = dimensions;\n  return dimensions;\n};\nconst LinearAxisTickSeries = ({\n  scale: scale2,\n  orientation,\n  height,\n  width,\n  label: label2,\n  tickSize,\n  tickValues,\n  interval,\n  line: line2,\n  axis\n}) => {\n  const getAdjustedScale = useCallback(() => {\n    if (scale2.bandwidth) {\n      let offset = scale2.bandwidth() / 2;\n      if (scale2.round()) {\n        offset = Math.round(offset);\n      }\n      return d => +scale2(d) + offset;\n    } else {\n      return d => +scale2(d);\n    }\n  }, [scale2]);\n  const getPosition = useCallback(scaledTick => {\n    if (orientation === \"horizontal\") {\n      return {\n        x: scaledTick,\n        y: 0\n      };\n    } else {\n      return {\n        x: 0,\n        y: scaledTick\n      };\n    }\n  }, [orientation]);\n  const getDimension2 = useCallback(() => {\n    return orientation === \"vertical\" ? height : width;\n  }, [height, orientation, width]);\n  const labelFormatFn = useMemo(() => {\n    if (label2 && label2.props.format) {\n      return label2.props.format;\n    } else if (scale2.tickFormat) {\n      return scale2.tickFormat.apply(scale2, [5]);\n    } else {\n      return v => formatValue(v);\n    }\n  }, [label2, scale2]);\n  const ticks = useMemo(() => {\n    const dimension = getDimension2();\n    const maxTicks = getMaxTicks(tickSize, dimension);\n    const ticks2 = getTicks(scale2, tickValues, axis.type, maxTicks, interval);\n    const adjustedScale = getAdjustedScale();\n    const format = labelFormatFn;\n    const midpoint = dimension / 2;\n    return ticks2.map(tick => {\n      const fullText = format(tick);\n      const scaledTick = adjustedScale(tick);\n      const position = getPosition(scaledTick);\n      const text = ellipsize(fullText, 18);\n      const size = label2 ? calculateDimensions(text, label2.props.fontFamily, label2.props.fontSize.toString()) : {};\n      return {\n        ...position,\n        ...size,\n        text,\n        fullText,\n        half: scaledTick === midpoint ? \"center\" : scaledTick < midpoint ? \"start\" : \"end\"\n      };\n    });\n  }, [axis.type, getAdjustedScale, getDimension2, getPosition, interval, label2, labelFormatFn, scale2, tickSize, tickValues]);\n  const angle = useMemo(() => {\n    if (!label2) {\n      return 0;\n    }\n    const labelProps = label2.props;\n    const dimension = getDimension2();\n    const maxTicksLength = max(ticks, tick => tick.width);\n    let angle2 = 0;\n    if (labelProps.rotation) {\n      if (labelProps.rotation === true) {\n        let baseWidth = maxTicksLength;\n        const maxBaseWidth = Math.floor(dimension / ticks.length);\n        while (baseWidth > maxBaseWidth && angle2 > -90) {\n          angle2 -= 30;\n          baseWidth = Math.cos(angle2 * (Math.PI / 180)) * maxTicksLength;\n        }\n      } else {\n        angle2 = labelProps.rotation;\n      }\n    }\n    return angle2;\n  }, [getDimension2, label2, ticks]);\n  return /* @__PURE__ */jsx(Fragment, {\n    children: ticks.map((tick, i) => /* @__PURE__ */jsxs(\"g\", {\n      transform: `translate(${tick.x}, ${tick.y})`,\n      children: [line2 && /* @__PURE__ */jsx(CloneElement, {\n        element: line2,\n        height,\n        width,\n        orientation\n      }), label2 && /* @__PURE__ */jsx(CloneElement, {\n        element: label2,\n        text: tick.text,\n        fullText: tick.fullText,\n        half: tick.half,\n        angle,\n        orientation,\n        line: line2\n      })]\n    }, i))\n  });\n};\nLinearAxisTickSeries.defaultProps = {\n  line: /* @__PURE__ */jsx(LinearAxisTickLine, {\n    height: 10,\n    width: 10,\n    orientation: \"horizontal\",\n    position: \"center\"\n  }),\n  label: /* @__PURE__ */jsx(LinearAxisTickLabel, {\n    line: /* @__PURE__ */jsx(LinearAxisTickLine, {\n      orientation: \"horizontal\",\n      position: \"center\",\n      height: 5,\n      width: 5\n    }),\n    text: \"\",\n    fullText: \"\",\n    angle: 0,\n    orientation: \"horizontal\",\n    half: \"start\",\n    position: \"center\"\n  }),\n  tickSize: 30\n};\nconst LinearXAxisTickLabel = props => /* @__PURE__ */jsx(LinearAxisTickLabel, {\n  ...props\n});\nLinearXAxisTickLabel.defaultProps = {\n  ...LinearAxisTickLabel.defaultProps,\n  rotation: true,\n  position: \"end\",\n  align: \"center\"\n};\nconst LinearXAxisTickLine = props => /* @__PURE__ */jsx(LinearAxisTickLine, {\n  ...props\n});\nLinearXAxisTickLine.defaultProps = {\n  ...LinearAxisTickLine.defaultProps,\n  position: \"end\"\n};\nconst LinearXAxisTickSeries = props => /* @__PURE__ */jsx(LinearAxisTickSeries, {\n  ...props\n});\nLinearXAxisTickSeries.defaultProps = {\n  ...LinearAxisTickSeries.defaultProps,\n  tickSize: 75,\n  line: /* @__PURE__ */jsx(LinearXAxisTickLine, {}),\n  label: /* @__PURE__ */jsx(LinearXAxisTickLabel, {})\n};\nconst LinearXAxis = props => /* @__PURE__ */jsx(LinearAxis, {\n  ...props\n});\nLinearXAxis.defaultProps = {\n  ...LinearAxis.defaultProps,\n  position: \"end\",\n  roundDomains: false,\n  scaled: false,\n  type: \"value\",\n  orientation: \"horizontal\",\n  tickSeries: /* @__PURE__ */jsx(LinearXAxisTickSeries, {})\n};\nconst LinearYAxisTickLabel = props => /* @__PURE__ */jsx(LinearAxisTickLabel, {\n  ...props\n});\nLinearYAxisTickLabel.defaultProps = {\n  ...LinearAxisTickLabel.defaultProps,\n  rotation: false,\n  position: \"start\",\n  align: \"center\"\n};\nconst LinearYAxisTickLine = props => /* @__PURE__ */jsx(LinearAxisTickLine, {\n  ...props\n});\nLinearYAxisTickLine.defaultProps = {\n  ...LinearAxisTickLine.defaultProps,\n  position: \"start\"\n};\nconst LinearYAxisTickSeries = props => /* @__PURE__ */jsx(LinearAxisTickSeries, {\n  ...props\n});\nLinearYAxisTickSeries.defaultProps = {\n  ...LinearAxisTickSeries.defaultProps,\n  tickSize: 30,\n  line: /* @__PURE__ */jsx(LinearYAxisTickLine, {}),\n  label: /* @__PURE__ */jsx(LinearYAxisTickLabel, {})\n};\nconst LinearYAxis = props => /* @__PURE__ */jsx(LinearAxis, {\n  ...props\n});\nLinearYAxis.defaultProps = {\n  ...LinearAxis.defaultProps,\n  orientation: \"vertical\",\n  scaled: false,\n  roundDomains: false,\n  type: \"value\",\n  position: \"start\",\n  tickSeries: /* @__PURE__ */jsx(LinearYAxisTickSeries, {})\n};\nconst isAxisVisible = axis => !!axis.tickSeries.props.label || !!axis.tickSeries.props.line;\nconst RadialAxisTickLine = ({\n  stroke,\n  size,\n  position,\n  innerRadius,\n  outerRadius\n}) => {\n  const x1 = position === \"outside\" ? size : -(outerRadius - innerRadius);\n  return /* @__PURE__ */jsx(\"line\", {\n    x1,\n    x2: 0,\n    stroke,\n    style: {\n      pointerEvents: \"none\"\n    }\n  });\n};\nRadialAxisTickLine.defaultProps = {\n  stroke: \"rgba(113, 128, 141, .5)\",\n  size: 10,\n  position: \"inside\"\n};\nconst rad2deg = angle => angle * 180 / Math.PI;\nconst RadialAxisTickLabel = ({\n  point: point2,\n  autoRotate,\n  rotation,\n  padding,\n  data,\n  fill,\n  fontFamily,\n  fontSize,\n  format,\n  lineSize,\n  index,\n  formatTooltip,\n  ...rest\n}) => {\n  const {\n    transform: transform2,\n    textAnchor\n  } = useMemo(() => {\n    let textAnchor2;\n    let transform22;\n    if (autoRotate) {\n      if (rotation >= 85 && rotation <= 95 || rotation <= -85 && rotation >= -95 || rotation >= 265 && rotation <= 275 || rotation <= -265 && rotation >= -275) {\n        textAnchor2 = \"middle\";\n      } else if (rotation < -85 && rotation > -265 || rotation > 95 && rotation < 265) {\n        textAnchor2 = \"end\";\n      } else {\n        textAnchor2 = \"start\";\n      }\n      transform22 = `rotate(${90 - rad2deg(point2)}, ${padding}, 0)`;\n    } else {\n      const shouldRotate = rotation && (rotation > 100 || rotation < -100);\n      const rotate = shouldRotate ? 180 : 0;\n      const translate2 = shouldRotate ? -30 : 0;\n      textAnchor2 = shouldRotate ? \"end\" : \"start\";\n      transform22 = `rotate(${rotate}) translate(${translate2})`;\n    }\n    return {\n      transform: transform22,\n      textAnchor: textAnchor2\n    };\n  }, [autoRotate, padding, point2, rotation]);\n  const text = format ? format(data, index) : formatValue(data);\n  const titleHover = typeof formatTooltip === \"function\" ? formatTooltip(data, index) : text;\n  return /* @__PURE__ */jsxs(\"g\", {\n    transform: transform2,\n    children: [/* @__PURE__ */jsx(\"title\", {\n      children: titleHover\n    }), /* @__PURE__ */jsx(\"text\", {\n      dy: \"0.35em\",\n      x: lineSize + 5,\n      textAnchor,\n      fill,\n      fontFamily,\n      fontSize,\n      ...rest,\n      children: text\n    })]\n  });\n};\nRadialAxisTickLabel.defaultProps = {\n  fill: \"#71808d\",\n  fontSize: 11,\n  padding: 15,\n  fontFamily: \"sans-serif\",\n  autoRotate: true,\n  startAngle: 0,\n  endAngle: 2 * Math.PI\n};\nconst RadialAxisTick = ({\n  line: line2,\n  label: label2,\n  scale: scale2,\n  outerRadius,\n  data,\n  index,\n  padding,\n  innerRadius,\n  startAngle,\n  endAngle\n}) => {\n  const point2 = scale2(data);\n  const rotation = point2 * 180 / Math.PI - 90;\n  const transform2 = `rotate(${rotation}) translate(${outerRadius + padding},0)`;\n  const lineSize = line2 ? line2.props.size : 0;\n  return /* @__PURE__ */jsxs(\"g\", {\n    transform: transform2,\n    children: [line2 && /* @__PURE__ */jsx(CloneElement, {\n      element: line2,\n      innerRadius,\n      outerRadius\n    }), label2 && /* @__PURE__ */jsx(CloneElement, {\n      element: label2,\n      index,\n      point: point2,\n      rotation,\n      lineSize,\n      data,\n      startAngle,\n      endAngle\n    })]\n  });\n};\nRadialAxisTick.defaultProps = {\n  outerRadius: 0,\n  padding: 0,\n  line: /* @__PURE__ */jsx(RadialAxisTickLine, {}),\n  label: /* @__PURE__ */jsx(RadialAxisTickLabel, {}),\n  startAngle: 0,\n  endAngle: 2 * Math.PI\n};\nconst RadialAxisTickSeries = ({\n  scale: scale2,\n  count,\n  outerRadius,\n  tick,\n  tickValues,\n  innerRadius,\n  interval,\n  type,\n  startAngle,\n  endAngle\n}) => {\n  const ticks = getTicks(scale2, tickValues, type, count, interval || count);\n  return /* @__PURE__ */jsx(Fragment, {\n    children: ticks.map((data, i) => {\n      const tickElement = typeof tick === \"function\" ? tick({\n        index: i\n      }) : tick;\n      return /* @__PURE__ */jsx(CloneElement, {\n        element: tickElement,\n        index: i,\n        scale: scale2,\n        data,\n        innerRadius,\n        outerRadius,\n        startAngle,\n        endAngle\n      }, i);\n    })\n  });\n};\nRadialAxisTickSeries.defaultProps = {\n  count: 12,\n  type: \"time\",\n  tick: /* @__PURE__ */jsx(RadialAxisTick, {}),\n  startAngle: 0,\n  endAngle: 2 * Math.PI\n};\nconst RadialAxisArc = ({\n  index,\n  stroke,\n  strokeDasharray,\n  scale: scale2,\n  startAngle,\n  endAngle\n}) => {\n  var _a, _b, _c, _d;\n  const r = scale2(index);\n  const strokeColor = typeof stroke === \"string\" ? stroke : stroke(index);\n  const strokeDash = typeof strokeDasharray === \"string\" ? strokeDasharray : strokeDasharray(index);\n  const isFullCircle = Math.abs(endAngle - startAngle) >= 2 * Math.PI;\n  const x = arc()({\n    innerRadius: r,\n    outerRadius: r,\n    startAngle,\n    endAngle\n  });\n  const REGEX = /(-?\\d+\\.?\\d*,-?\\d+\\.?\\d*A-?\\d+\\.?\\d*,-?\\d+\\.?\\d*)/gm;\n  const matches = x.match(REGEX);\n  const start2 = (_b = (_a = matches == null ? void 0 : matches[0]) == null ? void 0 : _a.split(\"A\", 2)) == null ? void 0 : _b[0];\n  const end2 = (_d = (_c = matches == null ? void 0 : matches[1]) == null ? void 0 : _c.split(\"A\", 2)) == null ? void 0 : _d[0];\n  const d = x + ` M ${start2} L 0,0 M ${end2} L 0,0`;\n  return /* @__PURE__ */jsx(Fragment$1, {\n    children: isFullCircle ? /* @__PURE__ */jsx(\"circle\", {\n      fill: \"none\",\n      strokeDasharray: strokeDash,\n      stroke: strokeColor,\n      style: {\n        pointerEvents: \"none\"\n      },\n      cx: \"0\",\n      cy: \"0\",\n      r\n    }) : /* @__PURE__ */jsx(\"path\", {\n      d,\n      fill: \"none\",\n      strokeDasharray: strokeDash,\n      stroke: strokeColor,\n      style: {\n        pointerEvents: \"none\"\n      }\n    })\n  });\n};\nRadialAxisArc.defaultProps = {\n  stroke: \"#71808d\",\n  strokeDasharray: \"1,4\",\n  startAngle: 0,\n  endAngle: 2 * Math.PI\n};\nconst getPointsForLevels = ({\n  count,\n  outerRadius,\n  ticks,\n  arcs\n}) => {\n  const levels = [];\n  const polyangle = Math.PI * 2 / ticks;\n  for (const level of arcs) {\n    const hyp = level / count * outerRadius;\n    const points = [];\n    for (let vertex = 0; vertex < ticks; vertex++) {\n      const theta = vertex * polyangle;\n      points.push({\n        x: hyp * Math.sin(Math.PI - theta),\n        y: hyp * Math.cos(Math.PI - theta)\n      });\n    }\n    levels.push([...points, points[0]]);\n  }\n  return levels;\n};\nconst RadialAxisArcSeries = ({\n  count,\n  innerRadius,\n  outerRadius,\n  line: line2,\n  arc: arc2,\n  tickValues,\n  startAngle,\n  endAngle\n}) => {\n  const scale2 = scaleLinear().domain([0, count]).range([innerRadius, outerRadius]);\n  const arcs = scale2.ticks(count);\n  const points = getPointsForLevels({\n    count,\n    outerRadius,\n    ticks: tickValues.length,\n    arcs\n  });\n  return /* @__PURE__ */jsxs(Fragment$1, {\n    children: [line2 && /* @__PURE__ */jsx(Fragment$1, {\n      children: points.map((d, i) => /* @__PURE__ */jsx(CloneElement, {\n        element: line2,\n        data: d,\n        index: i\n      }, i))\n    }), arc2 && /* @__PURE__ */jsx(Fragment$1, {\n      children: arcs.map(d => /* @__PURE__ */jsx(CloneElement, {\n        element: arc2,\n        index: d,\n        scale: scale2,\n        startAngle,\n        endAngle\n      }, d))\n    })]\n  });\n};\nRadialAxisArcSeries.defaultProps = {\n  type: \"arc\",\n  count: 12,\n  arc: /* @__PURE__ */jsx(RadialAxisArc, {}),\n  startAngle: 0,\n  endAngle: 2 * Math.PI\n};\nconst RadialAxisArcLine = ({\n  data,\n  stroke,\n  index\n}) => {\n  const lineGenerator = line$1().x(d2 => d2.x).y(d2 => d2.y);\n  const d = lineGenerator(data);\n  const strokeColor = typeof stroke === \"string\" ? stroke : stroke(index);\n  return /* @__PURE__ */jsx(\"path\", {\n    d,\n    stroke: strokeColor,\n    fill: \"none\",\n    style: {\n      pointerEvents: \"none\"\n    }\n  });\n};\nRadialAxisArcLine.defaultProps = {\n  stroke: \"#71808d\"\n};\nconst humanFormatScale = new humanFormat.Scale({\n  k: 1e3,\n  M: 1e6,\n  B: 1e9\n});\nconst humanFormatMillionScale = new humanFormat.Scale({\n  M: 1,\n  B: 1e3,\n  T: 1e6\n});\nconst ONE_MILLION = 1e6;\nconst ONE_BILLION = 1e9;\nconst humanFormatBigInteger = bigInteger => {\n  if (bigInteger.greater(ONE_BILLION)) {\n    return humanFormat(bigInteger.divide(ONE_MILLION).toJSNumber(), {\n      scale: humanFormatMillionScale\n    });\n  }\n  return humanFormat(bigInteger.toJSNumber(), {\n    scale: humanFormatScale\n  });\n};\nconst bigIntegerToLocaleString = bigInteger => {\n  let i = 0;\n  let formattedString = \"\";\n  for (const c of bigInteger.toString().split(\"\").reverse()) {\n    if (i > 0 && i % 3 === 0) {\n      formattedString = \",\" + formattedString;\n    }\n    formattedString = c + formattedString;\n    i++;\n  }\n  return formattedString;\n};\nfunction parseMargins(margins) {\n  let top = 0;\n  let right = 0;\n  let bottom = 0;\n  let left = 0;\n  if (Array.isArray(margins)) {\n    if (margins.length === 2) {\n      top = margins[0];\n      bottom = margins[0];\n      left = margins[1];\n      right = margins[1];\n    } else if (margins.length === 4) {\n      top = margins[0];\n      right = margins[1];\n      bottom = margins[2];\n      left = margins[3];\n    }\n  } else if (margins !== void 0) {\n    top = margins;\n    right = margins;\n    bottom = margins;\n    left = margins;\n  }\n  return {\n    top,\n    right,\n    bottom,\n    left\n  };\n}\nfunction calculateMarginOffsets(height, width, margins) {\n  const {\n    left,\n    right,\n    bottom,\n    top\n  } = margins;\n  const newHeight = height - top - bottom;\n  const newWidth = width - left - right;\n  return {\n    height: newHeight,\n    width: newWidth\n  };\n}\nfunction getDimension({\n  xOffset,\n  yOffset,\n  height,\n  width,\n  margins\n}) {\n  const parsedMargins = parseMargins(margins);\n  const marginDims = calculateMarginOffsets(height, width, parsedMargins);\n  const chartWidth = marginDims.width - xOffset;\n  const chartHeight = marginDims.height - yOffset;\n  return {\n    xOffset,\n    yOffset,\n    height,\n    width,\n    chartWidth,\n    chartHeight,\n    xMargin: xOffset + parsedMargins.left,\n    yMargin: parsedMargins.top\n  };\n}\nfunction extent(data, attr) {\n  const accessor = (val, fn) => {\n    if (Array.isArray(val.data)) {\n      return fn(val.data, vv => vv[attr]);\n    }\n    return val[attr];\n  };\n  const minVal = min(data, d => accessor(d, min));\n  const maxVal = max(data, d => accessor(d, max));\n  return [minVal, maxVal];\n}\nfunction getYDomain({\n  data,\n  scaled = false,\n  isDiverging = false\n}) {\n  const [startY, endY] = extent(data, \"y\");\n  const [startY1, endY1] = extent(data, \"y1\");\n  if (startY < 0 || isDiverging) {\n    const posStart = -startY;\n    const maxNum = Math.max(posStart, endY);\n    return [-maxNum, maxNum];\n  }\n  if (scaled) {\n    return [startY1, endY1];\n  }\n  return [0, endY1];\n}\nfunction getXDomain({\n  data,\n  scaled = false,\n  isDiverging = false\n}) {\n  const startX0 = extent(data, \"x0\")[0];\n  const endX1 = extent(data, \"x1\")[1];\n  if (typeof startX0 === \"number\" && typeof endX1 === \"number\") {\n    if (startX0 < 0 || isDiverging) {\n      const posStart = -startX0;\n      const maxNum = Math.max(posStart, endX1);\n      return [-maxNum, maxNum];\n    }\n    if (!scaled) {\n      return [0, endX1];\n    }\n  }\n  return [startX0, endX1];\n}\nfunction interpolate(type) {\n  if (type === \"smooth\") {\n    return curveMonotoneX;\n  } else if (type === \"step\") {\n    return curveStep;\n  } else {\n    return curveLinear;\n  }\n}\nconst scaleBandInvert = (scale2, round = false) => {\n  const domain = scale2.domain();\n  const paddingOuter = scale2(domain[0]);\n  const eachBand = scale2.step();\n  const [, end2] = scale2.range();\n  return offset => {\n    let band = Math.min((offset - paddingOuter) / eachBand, domain.length - 0.01);\n    if (band < 0 && Math.abs(band) > domain.length - 1) {\n      band = Math.floor(Math.abs(band)) * -1;\n    }\n    let index = round ? Math.round(band) % domain.length : Math.floor(band) % domain.length;\n    if (end2 === 0) {\n      index = index * -1;\n    }\n    return domain[Math.max(0, Math.min(index, domain.length - 1))];\n  };\n};\nconst getClosestContinousScalePoint = ({\n  pos,\n  scale: scale2,\n  data,\n  attr = \"x\",\n  roundDown = false\n}) => {\n  const domain = scale2.invert(pos);\n  const bisect = bisector(d => {\n    return attr === \"i\" ? d[attr] + 1 : d[attr];\n  }).right;\n  const index = bisect(data, domain);\n  const minIndex = Math.max(0, index - 1);\n  const before = data[minIndex];\n  if (roundDown) {\n    return before;\n  }\n  const maxIndex2 = Math.min(data.length - 1, index);\n  const after = data[maxIndex2];\n  let beforeVal = before[attr];\n  let afterVal = after[attr];\n  beforeVal = domain - beforeVal;\n  afterVal = afterVal - domain;\n  return beforeVal < afterVal ? before : after;\n};\nconst getClosestBandScalePoint = ({\n  pos,\n  scale: scale2,\n  data,\n  roundClosest = false\n}) => {\n  const domain = scale2.domain();\n  let prop;\n  if (scale2.mariemkoInvert) {\n    prop = scale2.mariemkoInvert(pos);\n  } else {\n    prop = scaleBandInvert(scale2, roundClosest)(pos);\n  }\n  const idx = domain.indexOf(prop);\n  return data[idx];\n};\nconst getParentSVG = event => {\n  let node2 = event.target.ownerSVGElement;\n  if (node2) {\n    while (node2.ownerSVGElement) {\n      node2 = node2.ownerSVGElement;\n    }\n  }\n  return node2;\n};\nconst getPositionForTarget = ({\n  target,\n  clientX,\n  clientY\n}) => {\n  const rect = target.getBoundingClientRect();\n  return {\n    x: clientX - ((rect == null ? void 0 : rect.left) || 0) - target.clientLeft,\n    y: clientY - ((rect == null ? void 0 : rect.top) || 0) - target.clientTop\n  };\n};\nconst getPointFromMatrix = (event, matrix) => {\n  const parent = getParentSVG(event);\n  if (!parent) {\n    return null;\n  }\n  const {\n    top,\n    left\n  } = parent.getBoundingClientRect();\n  const x = event.clientX - left;\n  const y = event.clientY - top;\n  return applyToPoint(inverse(matrix), {\n    x,\n    y\n  });\n};\nconst getLimitMatrix = (height, width, matrix) => applyToPoints(matrix, [{\n  x: 0,\n  y: 0\n}, {\n  x: width,\n  y: height\n}]);\nconst constrainMatrix = (height, width, matrix) => {\n  const [min2, max2] = getLimitMatrix(height, width, matrix);\n  if (max2.x < width || max2.y < height) {\n    return true;\n  }\n  if (min2.x > 0 || min2.y > 0) {\n    return true;\n  }\n  return false;\n};\nconst lessThanScaleFactorMin = (value2, scaleFactor) => value2.scaleFactorMin && value2.d * scaleFactor <= value2.scaleFactorMin;\nconst moreThanScaleFactorMax = (value2, scaleFactor) => value2.scaleFactorMax && value2.d * scaleFactor >= value2.scaleFactorMax;\nconst isZoomLevelGoingOutOfBounds = (value2, scaleFactor) => {\n  const a = lessThanScaleFactorMin(value2, scaleFactor) && scaleFactor < 1;\n  const b = moreThanScaleFactorMax(value2, scaleFactor) && scaleFactor > 1;\n  return a || b;\n};\nfunction toggleTextSelection(allowSelection) {\n  const style = allowSelection ? \"\" : \"none\";\n  [\"-webkit-touch-callout\", \"-webkit-user-select\", \"-khtml-user-select\", \"-moz-user-select\", \"-ms-user-select\", \"user-select\"].forEach(prop => document.body.style[prop] = style);\n}\nfunction calculateShowStroke(current, data) {\n  const i = data.indexOf(current);\n  let showLine = false;\n  const prev = data[i - 1];\n  if (i > 0 && prev.y) {\n    showLine = true;\n  }\n  const cur = data[i];\n  if (cur.y) {\n    showLine = true;\n  }\n  const next = data[i + 1];\n  if (i < data.length - 1 && next.y) {\n    showLine = true;\n  }\n  return showLine;\n}\nconst getDegrees = radians => radians / Math.PI * 180 - 90;\nconst functionProps = (prop, val, data) => {\n  if (typeof val === \"function\") {\n    return val(data);\n  } else if (prop === \"className\") {\n    return classNames(val);\n  } else if (val !== void 0 || val !== null) {\n    return val;\n  }\n  return {};\n};\nconst constructFunctionProps = (props, data) => ({\n  className: functionProps(\"className\", props.className, data),\n  style: functionProps(\"style\", props.style, data)\n});\nfunction uniqueBy(data, ...accessors) {\n  const result = [];\n  const ittr = (arr, depth) => {\n    for (const a of arr) {\n      const acc = accessors[depth];\n      if (acc === void 0) {\n        throw new Error(`Accessor not found for depth: ${depth}`);\n      }\n      const val = acc(a);\n      if (Array.isArray(val)) {\n        ittr(val, depth + 1);\n      } else if (!result.includes(val)) {\n        result.push(val);\n      }\n    }\n  };\n  ittr(data, 0);\n  return result;\n}\nfunction wrapText({\n  key,\n  x = 0,\n  size,\n  paddingY,\n  wrap = true,\n  paddingX,\n  width,\n  height,\n  fontFamily,\n  fontSize,\n  visibility = \"auto\"\n}) {\n  size = size || calculateDimensions(key, fontFamily, fontSize);\n  const words = key.toString().split(/\\s+/);\n  if (words.length > 1 && size.width > width) {\n    let rows = [];\n    let maxWidth = 0;\n    let maxHeight = 0;\n    let curText = \"\";\n    let currWidth = 0;\n    let nextText = \"\";\n    let nextWidth = 0;\n    for (const word of words) {\n      nextText = curText === \"\" ? word : `${curText} ${word}`;\n      nextWidth = calculateDimensions(nextText, fontFamily, fontSize).width;\n      if (nextWidth <= width - (paddingX ? 2 * paddingX : 0)) {\n        curText = nextText;\n        currWidth = nextWidth;\n      } else {\n        rows.push(curText);\n        maxWidth = Math.max(maxWidth, currWidth);\n        curText = word;\n        currWidth = calculateDimensions(curText, fontFamily, fontSize).width;\n      }\n    }\n    rows.push(curText);\n    maxHeight = rows.length * size.height;\n    if (visibility !== \"always\") {\n      if (height && maxHeight >= height - (paddingY ? 2 * paddingY : 0)) {\n        return null;\n      }\n      if (width && maxWidth >= width - (paddingX ? 2 * paddingX : 0)) {\n        return null;\n      }\n    }\n    if (!wrap && rows.length > 1) {\n      return rows[0];\n    }\n    return rows.map((r, i) => /* @__PURE__ */jsx(\"tspan\", {\n      dominantBaseline: \"alphabetic\",\n      style: {\n        baselineShift: \"0%\"\n      },\n      dy: i > 0 ? size.height : height ? size.height / 2 - 5 : -maxHeight / 2 + size.height,\n      x,\n      children: r\n    }, i));\n  }\n  if (visibility !== \"always\") {\n    if (height && size.height + paddingY >= height) {\n      return null;\n    }\n    if (width && size.width + paddingX >= width) {\n      return null;\n    }\n  }\n  return /* @__PURE__ */jsx(\"tspan\", {\n    dominantBaseline: \"alphabetic\",\n    style: {\n      baselineShift: \"0%\"\n    },\n    dy: size.height / 2 - 5,\n    x,\n    children: key\n  });\n}\nconst RadialAxis = ({\n  arcs,\n  ticks,\n  xScale,\n  height,\n  width,\n  innerRadius,\n  type,\n  startAngle,\n  endAngle\n}) => {\n  const outerRadius = Math.min(height, width) / 2;\n  const tickValues = getTicks(xScale, ticks.props.tickValues, type, ticks.props.count, ticks.props.interval || ticks.props.count);\n  return /* @__PURE__ */jsxs(Fragment, {\n    children: [arcs && /* @__PURE__ */jsx(CloneElement, {\n      element: arcs,\n      outerRadius,\n      innerRadius,\n      tickValues,\n      startAngle,\n      endAngle\n    }), ticks && /* @__PURE__ */jsx(CloneElement, {\n      element: ticks,\n      scale: xScale,\n      type,\n      innerRadius,\n      outerRadius,\n      startAngle,\n      endAngle\n    })]\n  });\n};\nRadialAxis.defaultProps = {\n  innerRadius: 10,\n  type: \"value\",\n  arcs: /* @__PURE__ */jsx(RadialAxisArcSeries, {}),\n  ticks: /* @__PURE__ */jsx(RadialAxisTickSeries, {}),\n  startAngle: 0,\n  endAngle: 2 * Math.PI\n};\nconst Move = props => {\n  let started = false;\n  let deltaX = 0;\n  let deltaY = 0;\n  let prevXPosition = 0;\n  let prevYPosition = 0;\n  const rqf = useRef();\n  useEffect(() => {\n    return () => {\n      cancelAnimationFrame(rqf.current);\n      disposeHandlers();\n    };\n  }, []);\n  const disposeHandlers = () => {\n    window.removeEventListener(\"mousemove\", onMouseMove);\n    window.removeEventListener(\"mouseup\", onMouseUp);\n    window.removeEventListener(\"touchmove\", onTouchMove);\n    window.removeEventListener(\"touchend\", onTouchEnd);\n    setCursor(false);\n    disableText(true);\n  };\n  const disableText = shouldDisable => {\n    if (props.disableText) {\n      toggleTextSelection(shouldDisable);\n    }\n  };\n  const setCursor = set => {\n    let {\n      cursor\n    } = props;\n    if (cursor) {\n      if (!set) {\n        cursor = \"inherit\";\n      }\n      document.body.style[\"cursor\"] = cursor;\n    }\n  };\n  const checkThreshold = () => {\n    const {\n      threshold\n    } = props;\n    return !started && (Math.abs(deltaX) > threshold || Math.abs(deltaY) > threshold);\n  };\n  const getTouchCoords = event => {\n    const {\n      clientX,\n      clientY\n    } = event.touches[0];\n    return {\n      clientX,\n      clientY\n    };\n  };\n  const onMouseDown = event => {\n    const {\n      preventRightClick,\n      disabled\n    } = props;\n    const shouldCancel = event.nativeEvent.which === 3 && preventRightClick;\n    if (shouldCancel || disabled) {\n      return;\n    }\n    event.preventDefault();\n    event.stopPropagation();\n    started = false;\n    window.addEventListener(\"mousemove\", onMouseMove);\n    window.addEventListener(\"mouseup\", onMouseUp);\n  };\n  const onMouseMove = event => {\n    event.preventDefault();\n    event.stopPropagation();\n    const {\n      movementX,\n      movementY\n    } = event;\n    let localDeltaX = deltaX + movementX;\n    let localDeltaY = deltaY + movementY;\n    if (checkThreshold()) {\n      disableText(true);\n      setCursor(true);\n      localDeltaX = 0;\n      localDeltaY = 0;\n      started = true;\n      props.onMoveStart({\n        nativeEvent: event,\n        type: \"mouse\"\n      });\n    } else {\n      rqf.current = requestAnimationFrame(() => {\n        props.onMove({\n          nativeEvent: event,\n          type: \"mouse\",\n          x: localDeltaX,\n          y: localDeltaY\n        });\n      });\n    }\n    deltaX = localDeltaX;\n    deltaY = localDeltaY;\n  };\n  const onMouseUp = event => {\n    event.preventDefault();\n    event.stopPropagation();\n    disposeHandlers();\n    if (started) {\n      props.onMoveEnd({\n        nativeEvent: event,\n        type: \"mouse\"\n      });\n    } else {\n      props.onMoveCancel({\n        nativeEvent: event,\n        type: \"mouse\"\n      });\n    }\n  };\n  const onTouchStart = event => {\n    const {\n      disabled\n    } = props;\n    if (disabled || event.touches.length !== 1) {\n      return;\n    }\n    event.preventDefault();\n    event.stopPropagation();\n    started = false;\n    prevXPosition = event.touches[0].clientX;\n    prevYPosition = event.touches[0].clientY;\n    window.addEventListener(\"touchmove\", onTouchMove);\n    window.addEventListener(\"touchend\", onTouchEnd);\n  };\n  const onTouchMove = event => {\n    event.preventDefault();\n    event.stopPropagation();\n    const {\n      clientX,\n      clientY\n    } = getTouchCoords(event);\n    let localDeltaX = clientX - prevXPosition;\n    let localDeltaY = clientY - prevYPosition;\n    localDeltaX = localDeltaX + localDeltaX;\n    localDeltaY = localDeltaY + localDeltaY;\n    if (checkThreshold()) {\n      disableText(true);\n      setCursor(true);\n      localDeltaX = 0;\n      localDeltaY = 0;\n      started = true;\n      props.onMoveStart({\n        // TODO: Come back and clean this up...\n        nativeEvent: {\n          ...event,\n          clientX,\n          clientY\n        },\n        type: \"touch\"\n      });\n    } else {\n      rqf.current = requestAnimationFrame(() => {\n        props.onMove({\n          // TODO: Come back and clean this up...\n          nativeEvent: {\n            ...event,\n            clientX,\n            clientY\n          },\n          type: \"touch\",\n          x: localDeltaX,\n          y: localDeltaY\n        });\n      });\n    }\n    prevXPosition = clientX;\n    prevYPosition = clientY;\n  };\n  const onTouchEnd = event => {\n    event.preventDefault();\n    event.stopPropagation();\n    disposeHandlers();\n    if (started) {\n      props.onMoveEnd({\n        nativeEvent: event,\n        type: \"touch\"\n      });\n    } else {\n      props.onMoveCancel({\n        nativeEvent: event,\n        type: \"touch\"\n      });\n    }\n  };\n  return Children.map(props.children, child => cloneElement(child, {\n    ...child.props,\n    onMouseDown: e => {\n      onMouseDown(e);\n      if (child.props.onMouseDown) {\n        child.props.onMouseDown(e);\n      }\n    },\n    onTouchStart: e => {\n      onTouchStart(e);\n      if (child.props.onTouchStart) {\n        child.props.onTouchStart(e);\n      }\n    }\n  }));\n};\nMove.defaultProps = {\n  preventRightClick: true,\n  disableText: true,\n  threshold: 0,\n  onMoveStart: () => void 0,\n  onMove: () => void 0,\n  onMoveEnd: () => void 0,\n  onMoveCancel: () => void 0\n};\nconst handle = \"_handle_bk7m7_1\";\nconst dragging = \"_dragging_bk7m7_6\";\nconst dot = \"_dot_bk7m7_10\";\nconst line = \"_line_bk7m7_14\";\nconst css$s = {\n  handle,\n  dragging,\n  dot,\n  line\n};\nconst BrushHandle = props => {\n  const {\n    height,\n    onHandleDrag\n  } = props;\n  const [isDragging, setIsDragging] = useState(false);\n  return /* @__PURE__ */jsx(Move, {\n    cursor: \"ew-resize\",\n    onMoveStart: () => setIsDragging(true),\n    onMove: ({\n      x\n    }) => onHandleDrag(x),\n    onMoveEnd: () => setIsDragging(false),\n    children: /* @__PURE__ */jsxs(\"g\", {\n      children: [/* @__PURE__ */jsx(\"line\", {\n        className: css$s.line,\n        y1: \"0\",\n        y2: height,\n        x1: \"5\",\n        x2: \"5\"\n      }), /* @__PURE__ */jsx(\"rect\", {\n        className: classNames(css$s.handle, {\n          [css$s.dragging]: isDragging\n        }),\n        height: height - 10,\n        style: {\n          cursor: \"ew-resize\"\n        },\n        width: 8,\n        y: \"5\",\n        y1: height - 5\n      }), /* @__PURE__ */jsx(\"g\", {\n        transform: `translate(-1, ${height / 2 - 10})`,\n        style: {\n          pointerEvents: \"none\"\n        },\n        children: range(5).map(i => /* @__PURE__ */jsx(\"circle\", {\n          cy: i * 5,\n          cx: \"5\",\n          r: \".5\",\n          className: css$s.dot\n        }, i))\n      })]\n    })\n  });\n};\nBrushHandle.defaultProps = {};\nconst slice = \"_slice_1knu8_1\";\nconst unsliced = \"_unsliced_1knu8_5\";\nconst css$r = {\n  slice,\n  unsliced\n};\nconst BrushSlice = props => {\n  const {\n    height,\n    start: start2,\n    end: end2,\n    width,\n    onBrushChange\n  } = props;\n  const [isDragging, setIsDragging] = useState(false);\n  const sliceWidth = Math.max(end2 - start2, 0);\n  const endSliceWidth = Math.max(width - end2, 0);\n  const hasNoSlice = start2 === 0 && end2 === width;\n  const onMoveStart = useCallback(() => {\n    const hasNoSlice2 = start2 === 0 && end2 === width;\n    if (!hasNoSlice2) {\n      setIsDragging(true);\n    }\n  }, [end2, start2, width]);\n  const onMove = useCallback(({\n    x\n  }) => {\n    const startUpdated = start2 + x;\n    const endUpdated = end2 + x;\n    if (startUpdated >= 0 && endUpdated <= width) {\n      onBrushChange({\n        start: startUpdated,\n        end: endUpdated\n      });\n    }\n  }, [start2, end2, width, onBrushChange]);\n  const onHandleDrag = useCallback((direction, deltaX) => {\n    const startUpdated = direction === \"start\" ? start2 + deltaX : start2;\n    const endUpdated = direction !== \"start\" ? end2 + deltaX : end2;\n    onBrushChange({\n      start: startUpdated,\n      end: endUpdated\n    });\n  }, [end2, onBrushChange, start2]);\n  return /* @__PURE__ */jsxs(Fragment, {\n    children: [/* @__PURE__ */jsx(\"rect\", {\n      className: css$r.unsliced,\n      height,\n      width: start2\n    }), /* @__PURE__ */jsx(\"rect\", {\n      transform: `translate(${end2}, 0)`,\n      className: css$r.unsliced,\n      height,\n      width: endSliceWidth\n    }), /* @__PURE__ */jsxs(\"g\", {\n      transform: `translate(${start2}, 0)`,\n      children: [/* @__PURE__ */jsx(Move, {\n        cursor: \"grabbing\",\n        onMoveStart,\n        onMove,\n        onMoveEnd: () => setIsDragging(false),\n        children: /* @__PURE__ */jsx(\"rect\", {\n          className: css$r.slice,\n          height,\n          width: sliceWidth,\n          style: {\n            cursor: isDragging ? \"grabbing\" : \"grab\",\n            opacity: hasNoSlice ? 0 : 0.1,\n            pointerEvents: !hasNoSlice ? \"initial\" : \"none\"\n          }\n        })\n      }), /* @__PURE__ */jsx(\"g\", {\n        transform: \"translate(-4, 0)\",\n        children: /* @__PURE__ */jsx(BrushHandle, {\n          height,\n          onHandleDrag: deltaX => onHandleDrag(\"start\", deltaX)\n        })\n      }), /* @__PURE__ */jsx(\"g\", {\n        transform: `translate(${sliceWidth - 5}, 0)`,\n        children: /* @__PURE__ */jsx(BrushHandle, {\n          height,\n          onHandleDrag: deltaX => onHandleDrag(\"end\", deltaX)\n        })\n      })]\n    })]\n  });\n};\nBrushSlice.defaultProps = {};\nconst Brush = props => {\n  const {\n    children,\n    disabled,\n    height,\n    width,\n    start: startProp,\n    end: endProp,\n    onBrushChange\n  } = props;\n  const [isSlicing, setIsSlicing] = useState(false);\n  const [initial, setInitial] = useState();\n  const [range2, setRange] = useState({\n    start: props.start || 0,\n    end: props.end || props.width\n  });\n  const {\n    start: start2,\n    end: end2\n  } = range2;\n  const ref = useRef();\n  const ensurePositionInBounds = useCallback((newStart, newEnd) => {\n    let startUpdated = newStart;\n    let endUpdated = newEnd;\n    if (startUpdated === void 0 || startUpdated <= 0) {\n      startUpdated = 0;\n    }\n    if (end2 === void 0) {\n      endUpdated = width;\n    }\n    if (startUpdated > endUpdated) {\n      startUpdated = start2;\n    }\n    if (endUpdated < startUpdated) {\n      endUpdated = end2;\n    }\n    if (endUpdated >= width) {\n      endUpdated = width;\n    }\n    return {\n      start: startUpdated,\n      end: endUpdated\n    };\n  }, [end2, start2, width]);\n  const getPositionsForPanEvent = useCallback(event => {\n    const eventObj = {\n      target: ref.current,\n      clientX: event.clientX,\n      clientY: event.clientY\n    };\n    return getPositionForTarget(eventObj);\n  }, []);\n  const getStartEnd = useCallback(event => {\n    const {\n      x\n    } = getPositionsForPanEvent(event);\n    if (x < initial) {\n      return ensurePositionInBounds(x, initial);\n    } else {\n      return ensurePositionInBounds(initial, x);\n    }\n  }, [ensurePositionInBounds, getPositionsForPanEvent, initial]);\n  const onMoveStart = useCallback(event => {\n    if (!disabled) {\n      const positions = getPositionsForPanEvent(event.nativeEvent);\n      setIsSlicing(true);\n      setInitial(positions.x);\n    }\n  }, [disabled, getPositionsForPanEvent]);\n  const onMove = useCallback(event => {\n    if (!disabled) {\n      const {\n        start: start22,\n        end: end22\n      } = getStartEnd(event.nativeEvent);\n      if (onBrushChange) {\n        onBrushChange({\n          start: start22,\n          end: end22\n        });\n      }\n      setRange({\n        start: start22,\n        end: end22\n      });\n    }\n  }, [disabled, getStartEnd, onBrushChange]);\n  const onMoveEnd = useCallback(() => {\n    setIsSlicing(false);\n  }, []);\n  const onMoveCancel = useCallback(() => {\n    const val = {\n      start: 0,\n      end: width\n    };\n    setRange(val);\n    if (onBrushChange) {\n      onBrushChange(val);\n    }\n  }, [onBrushChange, width]);\n  const onSliceChange = useCallback(event => {\n    const val = ensurePositionInBounds(event.start, event.end);\n    setRange(state => ({\n      ...state,\n      ...val\n    }));\n    if (onBrushChange) {\n      onBrushChange(val);\n    }\n  }, [ensurePositionInBounds, onBrushChange]);\n  useEffect(() => {\n    if (end2 === width) {\n      setRange(prev => ({\n        ...prev,\n        end: width\n      }));\n    }\n  }, [end2, width]);\n  useEffect(() => {\n    if (!isSlicing) {\n      const startUpdated = startProp !== start2;\n      const endUpdated = endProp !== end2;\n      if (startUpdated || endUpdated) {\n        setRange(ensurePositionInBounds(start2, end2));\n      }\n    }\n  }, [end2, endProp, ensurePositionInBounds, isSlicing, start2, startProp]);\n  return /* @__PURE__ */jsx(Move, {\n    cursor: \"crosshair\",\n    onMoveStart: bind(onMoveStart, void 0),\n    onMove: bind(onMove, void 0),\n    onMoveEnd: bind(onMoveEnd, void 0),\n    onMoveCancel: bind(onMoveCancel, void 0),\n    children: /* @__PURE__ */jsxs(\"g\", {\n      style: {\n        pointerEvents: isSlicing ? \"none\" : \"auto\",\n        cursor: disabled ? \"\" : \"crosshair\"\n      },\n      children: [children, !disabled && /* @__PURE__ */jsxs(Fragment$1, {\n        children: [/* @__PURE__ */jsx(\"rect\", {\n          ref,\n          height,\n          width,\n          opacity: 0\n        }), start2 !== void 0 && end2 !== void 0 && /* @__PURE__ */jsx(BrushSlice, {\n          start: start2,\n          end: end2,\n          height,\n          width,\n          onBrushChange: bind(onSliceChange, void 0)\n        })]\n      })]\n    })\n  });\n};\nconst ChartBrush = props => {\n  const {\n    disabled,\n    domain,\n    scale: scale2,\n    onBrushChange,\n    width,\n    children\n  } = props;\n  const getBrushOffset = useCallback(() => {\n    let start2;\n    let end2;\n    if (!disabled && domain) {\n      start2 = scale2(domain[0]);\n      end2 = scale2(domain[1]);\n    }\n    return {\n      start: start2,\n      end: end2\n    };\n  }, [disabled, domain, scale2]);\n  const onBrushChangeHandler = useCallback(event => {\n    if (onBrushChange) {\n      let domain2;\n      if (event.start !== void 0 && event.end !== void 0 && (event.start !== 0 || event.end !== width)) {\n        if (scale2.invert) {\n          const start2 = scale2.invert(event.start);\n          const end2 = scale2.invert(event.end);\n          domain2 = [start2, end2];\n        } else {\n          const band = scale2.step();\n          const start2 = Math.ceil((event.start - band / 2) / band);\n          const end2 = Math.ceil((event.end - band / 2) / band);\n          domain2 = [scale2.domain()[start2], scale2.domain()[end2]];\n        }\n      }\n      onBrushChange({\n        domain: domain2\n      });\n    }\n  }, [onBrushChange, scale2, width]);\n  return /* @__PURE__ */jsx(Brush, {\n    ...props,\n    ...getBrushOffset(),\n    onBrushChange: onBrushChangeHandler,\n    children\n  });\n};\nChartBrush.defaultProps = {};\nconst ChartContext = createContext({});\nconst {\n  Provider: ChartProvider,\n  Consumer: ChartConsumer\n} = ChartContext;\nconst useChart = () => {\n  const context = useContext(ChartContext);\n  if (context === void 0) {\n    throw new Error(\"`useChart` hook must be used within a `ChartProvider`\");\n  }\n  return context;\n};\nconst container$3 = \"_container_1u3dt_1\";\nconst svg = \"_svg_1u3dt_30\";\nconst css$q = {\n  container: container$3,\n  svg\n};\nconst ChartContainer = ({\n  className,\n  children,\n  center,\n  centerX,\n  centerY,\n  style,\n  margins,\n  containerClassName,\n  xAxisVisible,\n  yAxisVisible,\n  id,\n  ...rest\n}) => {\n  const curId = useId(id);\n  const [xAxisSized, setXAxisSized] = useState(false);\n  const [yAxisSized, setYAxisSized] = useState(false);\n  const [xOffset, setXOffset] = useState(0);\n  const [yOffset, setYOffset] = useState(0);\n  const {\n    observe,\n    width,\n    height\n  } = useDimensions();\n  const chartSized = useMemo(() => {\n    if (!height || !width) {\n      return false;\n    }\n    if (xAxisVisible && !xAxisSized) {\n      return false;\n    }\n    if (yAxisVisible && !yAxisSized) {\n      return false;\n    }\n    return true;\n  }, [height, width, xAxisSized, xAxisVisible, yAxisVisible, yAxisSized]);\n  const onUpdateAxes = useCallback((orientation, event) => {\n    if (orientation === \"horizontal\") {\n      setXAxisSized(true);\n    } else {\n      setYAxisSized(true);\n    }\n    if (event.height) {\n      setYOffset(event.height);\n    }\n    if (event.width) {\n      setXOffset(event.width);\n    }\n  }, []);\n  const childProps = useMemo(() => ({\n    chartSized,\n    id: curId,\n    updateAxes: onUpdateAxes,\n    yAxisSized,\n    xAxisSized,\n    ...getDimension({\n      margins,\n      height,\n      width,\n      yOffset,\n      xOffset\n    })\n  }), [chartSized, curId, onUpdateAxes, yAxisSized, xAxisSized, margins, height, width, yOffset, xOffset]);\n  const translateX = center || centerX ? width / 2 : childProps.xMargin;\n  const translateY = center || centerY ? height / 2 : childProps.yMargin;\n  const styleHeight = rest.height !== void 0 && rest.height !== null ? rest.height : \"100%\";\n  const styleWidth = rest.width !== void 0 && rest.width !== null ? rest.width : \"100%\";\n  return /* @__PURE__ */jsx(\"div\", {\n    ref: observe,\n    style: {\n      height: styleHeight,\n      width: styleWidth\n    },\n    className: classNames(containerClassName, css$q.container),\n    ...rest,\n    children: /* @__PURE__ */jsx(ChartProvider, {\n      value: childProps,\n      children: height > 0 && width > 0 && /* @__PURE__ */jsx(\"svg\", {\n        width,\n        height,\n        className: classNames(css$q.svg, className),\n        style,\n        tabIndex: 0,\n        children: /* @__PURE__ */jsx(\"g\", {\n          transform: `translate(${translateX}, ${translateY})`,\n          children: children(childProps)\n        })\n      })\n    })\n  });\n};\nfunction normalizeValue(value2, maxBigInt) {\n  if (bigInt.isInstance(value2)) {\n    if (maxBigInt.greater(1e6)) {\n      const divideBy = maxBigInt.divide(1e6);\n      return value2.divide(divideBy).toJSNumber();\n    } else {\n      return value2.toJSNumber();\n    }\n  } else {\n    return value2;\n  }\n}\nfunction normalizeValueForFormatting(value2) {\n  if (bigInt.isInstance(value2)) {\n    return bigIntegerToLocaleString(value2);\n  }\n  return value2;\n}\nfunction getMaxBigIntegerForNested(series) {\n  let maxBigInteger = bigInt.one;\n  for (const group of series) {\n    const maxBigIntegerForGroup = getMaxBigIntegerForShallow(group.data);\n    if (maxBigIntegerForGroup.greater(maxBigInteger)) {\n      maxBigInteger = maxBigIntegerForGroup;\n    }\n  }\n  return maxBigInteger;\n}\nfunction getMaxBigIntegerForShallow(series) {\n  let maxBigInteger = bigInt.one;\n  for (const point2 of series) {\n    if (bigInt.isInstance(point2.data)) {\n      const bigInteger = point2.data;\n      if (bigInteger.greater(maxBigInteger)) {\n        maxBigInteger = bigInteger;\n      }\n    }\n  }\n  return maxBigInteger;\n}\nfunction buildNestedChartData(series, sort = false, direction = \"vertical\") {\n  let result = [];\n  const maxBigInteger = getMaxBigIntegerForNested(series);\n  const isVertical = direction === \"vertical\";\n  for (const point2 of series) {\n    for (const nestedPoint of point2.data) {\n      const key = normalizeValueForFormatting(point2.key);\n      let idx = result.findIndex(r => {\n        const left = r.key;\n        if (left instanceof Date && key instanceof Date) {\n          return left.getTime() === key.getTime();\n        }\n        return left === key;\n      });\n      if (idx === -1) {\n        result.push({\n          key,\n          metadata: point2.metadata,\n          data: []\n        });\n        idx = result.length - 1;\n      }\n      const x = normalizeValue(isVertical ? nestedPoint.key : nestedPoint.data, maxBigInteger);\n      const y = normalizeValue(isVertical ? nestedPoint.data : nestedPoint.key, maxBigInteger);\n      result[idx].data.push({\n        key,\n        value: normalizeValueForFormatting(nestedPoint.data),\n        metadata: nestedPoint.metadata,\n        id: point2.id,\n        x,\n        x0: isVertical ? x : 0,\n        x1: x,\n        y,\n        y0: isVertical ? 0 : y,\n        y1: y\n      });\n    }\n  }\n  if (sort) {\n    result = result.sort((a, b) => {\n      const aMax = median(a.data, d => d.y);\n      const bMax = median(b.data, d => d.y);\n      return aMax < bMax ? 1 : -1;\n    });\n  }\n  return result;\n}\nfunction addToChartType(a, b) {\n  if (bigInt.isInstance(a) && bigInt.isInstance(b)) {\n    return a.add(b);\n  } else if (a instanceof Date && typeof b === \"number\") {\n    return new Date(a.valueOf() + b);\n  } else if (typeof a === \"number\" && typeof b === \"number\") {\n    return a + b;\n  } else {\n    throw new Error(\"Invalid types to addToChartTypes\");\n  }\n}\nfunction buildShallowChartData(series, direction = \"vertical\", binSize = void 0) {\n  const result = [];\n  const maxBigInteger = getMaxBigIntegerForShallow(series);\n  const isVertical = direction === \"vertical\";\n  for (const point2 of series) {\n    const isTuple = Array.isArray(point2.data);\n    let k1 = point2.key;\n    if (binSize) {\n      k1 = addToChartType(point2.key, binSize);\n    }\n    const props = {\n      k0: normalizeValue(point2.key, maxBigInteger),\n      k1: normalizeValue(k1, maxBigInteger),\n      v0: normalizeValue(isTuple ? point2.data[0] : 0, maxBigInteger),\n      v1: normalizeValue(isTuple ? point2.data[1] : point2.data, maxBigInteger)\n    };\n    const xProp = isVertical ? \"k\" : \"v\";\n    const yProp = isVertical ? \"v\" : \"k\";\n    result.push({\n      key: normalizeValueForFormatting(props.k0),\n      value: normalizeValueForFormatting(props.v1),\n      metadata: point2.metadata,\n      id: point2.id,\n      x: props[`${xProp}1`],\n      x0: props[`${xProp}0`],\n      x1: props[`${xProp}1`],\n      y: props[`${yProp}1`],\n      y0: props[`${yProp}0`],\n      y1: props[`${yProp}1`]\n    });\n  }\n  return result;\n}\nfunction buildBins(xScale, thresholds, data) {\n  const layout2 = histogram().value(d => d.x).domain(xScale.domain()).thresholds(xScale.ticks(thresholds));\n  const bins = layout2(data);\n  return bins.map(bin => ({\n    x0: bin.x0,\n    x1: bin.x1,\n    y: bin.length,\n    y0: 0,\n    y1: bin.length\n  }));\n}\nfunction transformDataToStack$1(data) {\n  const result = [];\n  const maxBigInteger = getMaxBigIntegerForNested(data);\n  for (const category of data) {\n    for (const value2 of category.data) {\n      let idx = result.findIndex(r => {\n        if (r.x instanceof Date && category.key instanceof Date) {\n          return r.x.getTime() === category.key.getTime();\n        }\n        return r.x === category.key;\n      });\n      if (idx === -1) {\n        result.push({\n          metadata: category.metadata,\n          x: category.key,\n          formattedValues: {}\n        });\n        idx = result.length - 1;\n      }\n      result[idx].metadata = value2.metadata;\n      result[idx][value2.key] = normalizeValue(value2.data, maxBigInteger);\n      result[idx].formattedValues[value2.key] = normalizeValueForFormatting(value2.data);\n    }\n  }\n  return result;\n}\nfunction transformStackToData$1(stackData, direction = \"vertical\") {\n  const result = [];\n  const isVertical = direction === \"vertical\";\n  for (const category of stackData) {\n    for (const point2 of category) {\n      const key = point2.data.x;\n      let idx = result.findIndex(r => {\n        if (r.key instanceof Date && key instanceof Date) {\n          return r.key.getTime() === key.getTime();\n        }\n        return r.key === key;\n      });\n      if (idx === -1) {\n        result.push({\n          key,\n          data: []\n        });\n        idx = result.length - 1;\n      }\n      const categoryKey = category.key;\n      const y = point2.data[categoryKey];\n      const [y0, y1] = point2;\n      result[idx].data.push({\n        metadata: point2.data.metadata,\n        key,\n        x: isVertical ? categoryKey : y1,\n        x0: isVertical ? categoryKey : y0,\n        x1: isVertical ? categoryKey : y1,\n        y: isVertical ? y : categoryKey,\n        y0: isVertical ? y0 : categoryKey,\n        y1: isVertical ? y1 : categoryKey,\n        value: point2.data.formattedValues[categoryKey]\n      });\n    }\n  }\n  return result;\n}\nfunction buildBarStackData(data = [], offset = \"default\", direction = \"vertical\") {\n  const keys = uniqueBy(data, d => d.data, d => d.key);\n  const stackData = transformDataToStack$1(data);\n  let stackFn = stack();\n  if (offset === \"expand\") {\n    stackFn = stackFn.offset(stackOffsetExpand);\n  } else if (offset === \"diverging\") {\n    stackFn = stackFn.offset(stackOffsetDiverging);\n  }\n  const result = stackFn.keys(keys)(stackData);\n  return transformStackToData$1(result, direction);\n}\nfunction buildMarimekkoData(data = []) {\n  const result = buildBarStackData(data, \"expand\");\n  const sums = {};\n  let totalSum = 0;\n  for (const series of result) {\n    const sum = series.data.reduce((acc, cur) => acc + cur.y, 0);\n    sums[series.key] = sum;\n    totalSum += sum;\n  }\n  let prev = 0;\n  for (const series of result) {\n    const x0 = prev;\n    const x1 = prev + sums[series.key] / totalSum;\n    prev = x1;\n    for (const point2 of series.data) {\n      point2.x0 = x0;\n      point2.x1 = x1;\n    }\n  }\n  return result;\n}\nfunction transformDataToStack(data) {\n  const result = [];\n  const maxBigInteger = getMaxBigIntegerForNested(data);\n  for (const category of data) {\n    for (const value2 of category.data) {\n      let idx = result.findIndex(r => {\n        if (r.x instanceof Date && value2.key instanceof Date) {\n          return r.x.getTime() === value2.key.getTime();\n        }\n        return r.x === value2.key;\n      });\n      if (idx === -1) {\n        result.push({\n          x: value2.key,\n          formattedValues: {}\n        });\n        idx = result.length - 1;\n      }\n      result[idx][category.key] = normalizeValue(value2.data, maxBigInteger);\n      result[idx].formattedValues[category.key] = normalizeValueForFormatting(value2.data);\n    }\n  }\n  return result;\n}\nfunction transformStackToData(stackData) {\n  const result = [];\n  for (const category of stackData) {\n    const series = [];\n    for (const point2 of category) {\n      const [y0, y1] = point2;\n      const x = point2.data.x;\n      series.push({\n        key: category.key,\n        x,\n        x0: x,\n        x1: x,\n        y: y1 - y0,\n        y0,\n        y1,\n        value: point2.data.formattedValues[category.key]\n      });\n    }\n    result.push({\n      key: category.key,\n      data: series\n    });\n  }\n  return result;\n}\nfunction buildStackData(data, normalized = false) {\n  const keys = uniqueBy(data, d => d.key);\n  const stackData = transformDataToStack(data);\n  const stackFn = !normalized ? stack() : stack().offset(stackOffsetExpand);\n  const result = stackFn.keys(keys)(stackData);\n  return transformStackToData(result);\n}\nconst buildWaterfall = (series, direction = \"vertical\", binSize = void 0) => {\n  const data = buildShallowChartData(series, direction, binSize);\n  const isVertical = direction === \"vertical\";\n  const v = isVertical ? \"y\" : \"x\";\n  let cumulative = 0;\n  for (const point2 of data) {\n    point2[`${v}0`] = cumulative;\n    cumulative += point2[v];\n    point2[`${v}1`] = cumulative;\n    point2[v] = cumulative;\n  }\n  return data;\n};\nclass Pan extends Component {\n  constructor() {\n    super(...arguments);\n    this.prevXPosition = 0;\n    this.prevYPosition = 0;\n    this.started = false;\n    this.deltaX = 0;\n    this.deltaY = 0;\n    this.childRef = createRef();\n    this.onMouseDown = event => {\n      if (this.props.disabled) {\n        return;\n      }\n      if (event.which === 3) {\n        return;\n      }\n      if (!this.props.globalPanning && event.target && !event.target.classList.contains(\"pan-container\")) {\n        return;\n      }\n      event.preventDefault();\n      event.stopPropagation();\n      toggleTextSelection(false);\n      this.started = false;\n      window.addEventListener(\"mousemove\", this.onMouseMove);\n      window.addEventListener(\"mouseup\", this.onMouseUp);\n    };\n    this.onMouseMove = event => {\n      event.preventDefault();\n      event.stopPropagation();\n      this.deltaX = this.deltaX + event.movementX;\n      this.deltaY = this.deltaY + event.movementY;\n      if (this.checkThreshold()) {\n        if (this.props.cursor) {\n          document.body.style[\"cursor\"] = this.props.cursor;\n        }\n        this.deltaX = 0;\n        this.deltaY = 0;\n        this.started = true;\n        this.onPanStart(event, \"mouse\");\n      } else {\n        this.pan(event.movementX, event.movementY, event, \"mouse\");\n      }\n    };\n    this.onMouseUp = event => {\n      event.preventDefault();\n      event.stopPropagation();\n      this.disposeHandlers();\n      toggleTextSelection(true);\n      if (this.started) {\n        this.onPanEnd(event, \"mouse\");\n      } else {\n        this.props.onPanCancel({\n          nativeEvent: event,\n          source: \"mouse\"\n        });\n      }\n    };\n    this.onTouchStart = event => {\n      if (this.props.disabled) {\n        return;\n      }\n      if (event.touches.length !== 1) {\n        return;\n      }\n      event.preventDefault();\n      event.stopPropagation();\n      toggleTextSelection(false);\n      this.started = false;\n      this.prevXPosition = event.touches[0].clientX;\n      this.prevYPosition = event.touches[0].clientY;\n      window.addEventListener(\"touchmove\", this.onTouchMove);\n      window.addEventListener(\"touchend\", this.onTouchEnd);\n    };\n    this.onTouchMove = event => {\n      event.preventDefault();\n      event.stopPropagation();\n      const x = event.touches[0].clientX;\n      const y = event.touches[0].clientY;\n      const deltaX = x - this.prevXPosition;\n      const deltaY = y - this.prevYPosition;\n      this.deltaX = this.deltaX + deltaX;\n      this.deltaY = this.deltaY + deltaY;\n      if (this.checkThreshold()) {\n        this.deltaX = 0;\n        this.deltaY = 0;\n        this.started = true;\n        this.onPanStart(event, \"touch\");\n      } else {\n        const contrained = this.pan(deltaX, deltaY, event, \"touch\");\n        if (!contrained) {\n          this.prevXPosition = x;\n          this.prevYPosition = y;\n        }\n      }\n    };\n    this.onTouchEnd = event => {\n      event.preventDefault();\n      event.stopPropagation();\n      this.disposeHandlers();\n      toggleTextSelection(true);\n      if (this.started) {\n        this.onPanEnd(event, \"touch\");\n      } else {\n        this.props.onPanCancel({\n          nativeEvent: event,\n          source: \"touch\"\n        });\n      }\n    };\n  }\n  componentDidMount() {\n    if (this.childRef.current) {\n      this.childRef.current.addEventListener(\"mousedown\", this.onMouseDown, {\n        passive: false\n      });\n      this.childRef.current.addEventListener(\"touchstart\", this.onTouchStart, {\n        passive: false\n      });\n    }\n  }\n  componentWillUnmount() {\n    this.disposeHandlers();\n    if (this.childRef.current) {\n      this.childRef.current.removeEventListener(\"mousedown\", this.onMouseDown);\n      this.childRef.current.removeEventListener(\"touchstart\", this.onTouchStart);\n    }\n  }\n  disposeHandlers() {\n    window.removeEventListener(\"mousemove\", this.onMouseMove);\n    window.removeEventListener(\"mouseup\", this.onMouseUp);\n    window.removeEventListener(\"touchmove\", this.onTouchMove);\n    window.removeEventListener(\"touchend\", this.onTouchEnd);\n    document.body.style[\"cursor\"] = \"inherit\";\n    toggleTextSelection(true);\n  }\n  checkThreshold() {\n    const {\n      threshold\n    } = this.props;\n    return !this.started && (Math.abs(this.deltaX) > threshold || Math.abs(this.deltaY) > threshold);\n  }\n  onPanStart(nativeEvent, source) {\n    this.props.onPanStart({\n      nativeEvent,\n      source\n    });\n  }\n  onPanMove(x, y, source, nativeEvent) {\n    this.props.onPanMove({\n      source,\n      nativeEvent,\n      x,\n      y\n    });\n  }\n  onPanEnd(nativeEvent, source) {\n    const {\n      onPanEnd\n    } = this.props;\n    onPanEnd({\n      nativeEvent,\n      source\n    });\n  }\n  pan(x, y, nativeEvent, source) {\n    const {\n      scale: scale2,\n      constrain,\n      width,\n      height,\n      matrix\n    } = this.props;\n    const newMatrix = smoothMatrix(transform(matrix, translate(x / scale2, y / scale2)), 100);\n    const shouldConstrain = constrain && constrainMatrix(height, width, newMatrix);\n    if (!shouldConstrain) {\n      this.onPanMove(newMatrix.e, newMatrix.f, source, nativeEvent);\n    }\n    return shouldConstrain;\n  }\n  render() {\n    return /* @__PURE__ */jsx(\"g\", {\n      ref: this.childRef,\n      children: this.props.children\n    });\n  }\n}\nPan.defaultProps = {\n  x: 0,\n  y: 0,\n  disabled: false,\n  scale: 1,\n  threshold: 10,\n  globalPanning: true,\n  onPanStart: () => void 0,\n  onPanMove: () => void 0,\n  onPanEnd: () => void 0,\n  onPanCancel: () => void 0\n};\nconst getMidpoint = (pointA, pointB) => ({\n  x: (pointA.x + pointB.x) / 2,\n  y: (pointA.y + pointB.y) / 2\n});\nconst getDistanceBetweenPoints = (pointA, pointB) => Math.sqrt(Math.pow(pointB.y - pointA.y, 2) + Math.pow(pointB.x - pointA.x, 2));\nfunction getTouchPoints(event, node2) {\n  const {\n    left,\n    top\n  } = node2.getBoundingClientRect();\n  const [pointA, pointB] = [...event.touches].map(touch => ({\n    x: touch.clientX - Math.round(left),\n    y: touch.clientY - Math.round(top)\n  }));\n  const distance = getDistanceBetweenPoints(pointA, pointB);\n  const midpoint = getMidpoint(pointA, pointB);\n  return {\n    pointA,\n    pointB,\n    distance,\n    midpoint\n  };\n}\nclass Zoom extends Component {\n  constructor() {\n    super(...arguments);\n    this.childRef = createRef();\n    this.onMouseWheel = event => {\n      const {\n        disableMouseWheel,\n        requireZoomModifier,\n        matrix,\n        onZoomEnd\n      } = this.props;\n      if (disableMouseWheel) {\n        return false;\n      }\n      const hasModifier = event.metaKey || event.ctrlKey;\n      if (requireZoomModifier && !hasModifier) {\n        return false;\n      }\n      event.preventDefault();\n      event.stopPropagation();\n      const point2 = getPointFromMatrix(event, matrix);\n      if (point2) {\n        const {\n          x,\n          y\n        } = point2;\n        const step = this.getStep(event.deltaY);\n        this.scale(x, y, step, event);\n        clearTimeout(this.timeout);\n        this.timeout = setTimeout(() => onZoomEnd(), 500);\n      }\n    };\n    this.onTouchStart = event => {\n      if (event.touches.length === 2) {\n        event.preventDefault();\n        event.stopPropagation();\n        toggleTextSelection(false);\n        this.firstTouch = getTouchPoints(event, this.childRef.current);\n        this.lastDistance = this.firstTouch.distance;\n        window.addEventListener(\"touchmove\", this.onTouchMove);\n        window.addEventListener(\"touchend\", this.onTouchEnd);\n      }\n    };\n    this.onTouchMove = event => {\n      if (event.touches.length === 2) {\n        event.preventDefault();\n        event.stopPropagation();\n        const {\n          distance\n        } = getTouchPoints(event, this.childRef.current);\n        const distanceFactor = distance / this.lastDistance;\n        const point2 = applyToPoint(inverse(this.props.matrix), {\n          x: this.firstTouch.midpoint.x,\n          y: this.firstTouch.midpoint.y\n        });\n        if (point2.x && point2.y) {\n          const outside = this.scale(point2.x, point2.y, distanceFactor, event);\n          if (!outside) {\n            this.lastDistance = distance;\n          }\n        }\n      }\n    };\n    this.onTouchEnd = event => {\n      event.preventDefault();\n      event.stopPropagation();\n      window.removeEventListener(\"touchmove\", this.onTouchMove);\n      window.removeEventListener(\"touchend\", this.onTouchEnd);\n      toggleTextSelection(true);\n      this.props.onZoomEnd();\n    };\n  }\n  componentDidMount() {\n    const {\n      disabled,\n      disableMouseWheel\n    } = this.props;\n    const ref = this.childRef.current;\n    if (!disabled && ref) {\n      if (!disableMouseWheel) {\n        ref.addEventListener(\"mousewheel\", this.onMouseWheel, {\n          passive: false\n        });\n      }\n      ref.addEventListener(\"touchstart\", this.onTouchStart, {\n        passive: false\n      });\n    }\n  }\n  componentWillUnmount() {\n    window.removeEventListener(\"touchmove\", this.onTouchMove);\n    window.removeEventListener(\"touchend\", this.onTouchEnd);\n    cancelAnimationFrame(this.rqf);\n    clearTimeout(this.timeout);\n    const ref = this.childRef.current;\n    if (ref) {\n      ref.removeEventListener(\"mousewheel\", this.onMouseWheel);\n      ref.removeEventListener(\"touchstart\", this.onTouchStart);\n    }\n    toggleTextSelection(true);\n  }\n  getStep(delta) {\n    const {\n      scaleFactor\n    } = this.props;\n    return -delta > 0 ? scaleFactor + 1 : 1 - scaleFactor;\n  }\n  scale(x, y, step, nativeEvent) {\n    const {\n      minZoom,\n      maxZoom,\n      onZoom,\n      matrix\n    } = this.props;\n    const outside = isZoomLevelGoingOutOfBounds({\n      d: matrix.a,\n      scaleFactorMin: minZoom,\n      scaleFactorMax: maxZoom\n    }, step);\n    if (!outside) {\n      const newMatrix = smoothMatrix(transform(matrix, translate(x, y), scale(step, step), translate(-x, -y)), 100);\n      this.rqf = requestAnimationFrame(() => {\n        onZoom({\n          scale: newMatrix.a,\n          x: newMatrix.e,\n          y: newMatrix.f,\n          nativeEvent\n        });\n      });\n    }\n    return outside;\n  }\n  render() {\n    const {\n      style,\n      children\n    } = this.props;\n    return /* @__PURE__ */jsx(\"g\", {\n      ref: this.childRef,\n      style,\n      children\n    });\n  }\n}\nZoom.defaultProps = {\n  x: 0,\n  y: 0,\n  scale: 1,\n  scaleFactor: 0.1,\n  minZoom: 1,\n  maxZoom: 10\n};\nconst container$2 = \"_container_19vag_1\";\nconst horizontal$2 = \"_horizontal_19vag_5\";\nconst vertical$2 = \"_vertical_19vag_10\";\nconst css$p = {\n  container: container$2,\n  horizontal: horizontal$2,\n  vertical: vertical$2\n};\nconst DiscreteLegend = ({\n  entries,\n  orientation,\n  style,\n  className\n}) => /* @__PURE__ */jsx(\"div\", {\n  className: classNames(css$p.container, className, {\n    [css$p.horizontal]: orientation === \"horizontal\",\n    [css$p.vertical]: orientation === \"vertical\"\n  }),\n  style,\n  children: entries.map((entry2, index) => /* @__PURE__ */jsx(CloneElement, {\n    element: entry2,\n    orientation\n  }, `dle-${index}`))\n});\nDiscreteLegend.defaultProps = {\n  orientation: \"vertical\"\n};\nconst symbol = \"_symbol_f5unn_1\";\nconst css$o = {\n  symbol\n};\nconst DiscreteLegendSymbol = ({\n  className,\n  color\n}) => /* @__PURE__ */jsx(\"div\", {\n  className: classNames(css$o.symbol, className),\n  style: {\n    background: color\n  }\n});\nconst entry = \"_entry_1493o_1\";\nconst vertical$1 = \"_vertical_1493o_8\";\nconst label$3 = \"_label_1493o_20\";\nconst horizontal$1 = \"_horizontal_1493o_30\";\nconst css$n = {\n  entry,\n  vertical: vertical$1,\n  label: label$3,\n  horizontal: horizontal$1\n};\nconst DiscreteLegendEntry = ({\n  label: label2,\n  symbol: symbol2,\n  title,\n  className,\n  color,\n  style,\n  orientation,\n  onMouseEnter,\n  onMouseLeave,\n  onClick\n}) => /* @__PURE__ */jsxs(\"div\", {\n  title,\n  className: classNames(css$n.entry, className, {\n    [css$n.vertical]: orientation === \"vertical\",\n    [css$n.horizontal]: orientation === \"horizontal\"\n  }),\n  onClick,\n  onMouseEnter,\n  onMouseLeave,\n  style,\n  children: [/* @__PURE__ */jsx(CloneElement, {\n    element: symbol2,\n    color\n  }), /* @__PURE__ */jsx(\"span\", {\n    className: css$n.label,\n    children: label2\n  })]\n});\nDiscreteLegendEntry.defaultProps = {\n  symbol: /* @__PURE__ */jsx(DiscreteLegendSymbol, {}),\n  orientation: \"horizontal\"\n};\nconst container$1 = \"_container_1gnp9_1\";\nconst vertical = \"_vertical_1gnp9_5\";\nconst start = \"_start_1gnp9_9\";\nconst end = \"_end_1gnp9_10\";\nconst gradient = \"_gradient_1gnp9_16\";\nconst horizontal = \"_horizontal_1gnp9_22\";\nconst css$m = {\n  container: container$1,\n  vertical,\n  start,\n  end,\n  gradient,\n  horizontal\n};\nconst SequentialLegend = ({\n  className,\n  gradientClassName,\n  style,\n  data,\n  colorScheme = [\"rgba(28, 107, 86, 0.5)\", \"#2da283\"],\n  orientation = \"orientation\"\n}) => {\n  const color = chroma.scale(colorScheme).colors(10).reverse().map((c, i) => `${c} ${i * 10}%`).join(\",\");\n  const [end2, start2] = useMemo(() => extent$1(uniqueBy(data, d => d.data, d => d.data)), [data]);\n  const gradientDir = orientation === \"vertical\" ? \"\" : \"to left,\";\n  return /* @__PURE__ */jsxs(\"div\", {\n    style,\n    className: classNames(css$m.container, className, {\n      [css$m.vertical]: orientation === \"vertical\",\n      [css$m.horizontal]: orientation === \"horizontal\"\n    }),\n    children: [/* @__PURE__ */jsx(\"div\", {\n      className: css$m.start,\n      children: formatValue(start2)\n    }), /* @__PURE__ */jsx(\"div\", {\n      className: classNames(css$m.gradient, gradientClassName),\n      style: {\n        background: `linear-gradient(${gradientDir}${color})`\n      }\n    }), /* @__PURE__ */jsx(\"div\", {\n      className: css$m.end,\n      children: formatValue(end2)\n    })]\n  });\n};\nSequentialLegend.defaultProps = {\n  colorScheme: [\"rgba(28, 107, 86, 0.5)\", \"#2da283\"],\n  orientation: \"vertical\"\n};\nconst gridLine = \"_gridLine_5yx3q_1\";\nconst css$l = {\n  gridLine\n};\nconst Gridline = ({\n  strokeWidth,\n  direction,\n  className,\n  strokeColor,\n  data,\n  height,\n  width,\n  scale: scale2,\n  strokeDasharray\n}) => {\n  const coords = useMemo(() => {\n    const pos = scale2(data);\n    if (direction === \"x\") {\n      return {\n        x1: pos,\n        x2: pos,\n        y1: 0,\n        y2: height\n      };\n    } else {\n      return {\n        y1: pos,\n        y2: pos,\n        x1: 0,\n        x2: width\n      };\n    }\n  }, [direction, data, height, width, scale2]);\n  return /* @__PURE__ */jsx(\"line\", {\n    ...coords,\n    className: classNames(css$l.gridLine, className),\n    strokeDasharray,\n    strokeWidth,\n    stroke: strokeColor,\n    fill: \"none\"\n  });\n};\nGridline.defaultProps = {\n  strokeWidth: 1,\n  strokeDasharray: \"2 5\",\n  direction: \"all\",\n  strokeColor: \"rgba(153, 153, 153, 0.5)\"\n};\nconst GridlineSeries = ({\n  line: line2,\n  stripe,\n  yScale,\n  xScale,\n  yAxis,\n  xAxis,\n  height,\n  width\n}) => {\n  const shouldRenderY = direction => direction === \"all\" || direction === \"y\";\n  const shouldRenderX = direction => direction === \"all\" || direction === \"x\";\n  const {\n    yAxisGrid,\n    xAxisGrid\n  } = useMemo(() => {\n    return {\n      yAxisGrid: getTicks(yScale, yAxis.tickSeries.props.tickValues, yAxis.type, getMaxTicks(yAxis.tickSeries.props.tickSize, height), yAxis.tickSeries.props.interval),\n      xAxisGrid: getTicks(xScale, xAxis.tickSeries.props.tickValues, xAxis.type, getMaxTicks(xAxis.tickSeries.props.tickSize, width), xAxis.tickSeries.props.interval)\n    };\n  }, [height, width, xAxis, yAxis, yScale, xScale]);\n  const renderGroup = useCallback((element, grid, scale2, direction, type) => {\n    return grid.map((point2, index) => /* @__PURE__ */jsx(Fragment, {\n      children: /* @__PURE__ */jsx(CloneElement, {\n        element,\n        index,\n        scale: scale2,\n        data: point2,\n        height,\n        width,\n        direction\n      })\n    }, `${type}-${direction}-${index}`));\n  }, [height, width]);\n  const renderSeries = useCallback((yAxisGrid2, xAxisGrid2, element, type) => {\n    return /* @__PURE__ */jsxs(Fragment, {\n      children: [shouldRenderY(element.props.direction) && renderGroup(element, yAxisGrid2, yScale, \"y\", type), shouldRenderX(element.props.direction) && renderGroup(element, xAxisGrid2, xScale, \"x\", type)]\n    });\n  }, [renderGroup, xScale, yScale]);\n  return /* @__PURE__ */jsxs(\"g\", {\n    style: {\n      pointerEvents: \"none\"\n    },\n    children: [line2 && renderSeries(yAxisGrid, xAxisGrid, line2, \"line\"), stripe && renderSeries(yAxisGrid, xAxisGrid, stripe, \"stripe\")]\n  });\n};\nGridlineSeries.defaultProps = {\n  line: /* @__PURE__ */jsx(Gridline, {\n    direction: \"all\"\n  }),\n  stripe: null\n};\nconst gridStripe = \"_gridStripe_xcrvl_1\";\nconst css$k = {\n  gridStripe\n};\nconst GridStripe = ({\n  fill,\n  className,\n  position,\n  data,\n  height,\n  width,\n  scale: scale2,\n  index\n}) => {\n  const coords = useMemo(() => {\n    const pos = scale2(data);\n    const stripeFill = index % 2 ? \"none\" : fill;\n    const dim = scale2.bandwidth();\n    if (position === \"vertical\") {\n      return {\n        y: 0,\n        x: pos,\n        height,\n        width: dim,\n        fill: stripeFill\n      };\n    } else {\n      return {\n        y: pos,\n        x: 0,\n        height: dim,\n        width,\n        fill: stripeFill\n      };\n    }\n  }, [scale2, data, index, height, width, fill, position]);\n  return /* @__PURE__ */jsx(\"rect\", {\n    className: classNames(css$k.gridStripe, className),\n    ...coords\n  });\n};\nGridStripe.defaultProps = {\n  fill: \"#393c3e\"\n};\nconst markLine = \"_markLine_1sfls_1\";\nconst css$j = {\n  markLine\n};\nconst MarkLine = ({\n  pointX,\n  height,\n  strokeWidth = 1,\n  strokeColor = \"#eee\"\n}) => /* @__PURE__ */jsx(\"line\", {\n  stroke: strokeColor,\n  strokeWidth,\n  y1: \"0\",\n  vectorEffect: \"non-scaling-stroke\",\n  y2: height,\n  x1: pointX,\n  x2: pointX,\n  className: css$j.markLine\n});\nconst GradientStop = ({\n  color,\n  offset,\n  stopOpacity = 1\n}) => /* @__PURE__ */jsx(\"stop\", {\n  offset,\n  stopOpacity,\n  stopColor: color\n});\nconst Gradient = ({\n  id,\n  color,\n  direction,\n  stops\n}) => {\n  if (direction === \"radial\") {\n    return /* @__PURE__ */jsx(\"radialGradient\", {\n      id,\n      children: stops.map((stop, index) => /* @__PURE__ */jsx(CloneElement, {\n        element: stop,\n        color: stop.props.color || color\n      }, `gradient-${index}`))\n    });\n  }\n  const pos = direction === \"vertical\" ? {\n    x1: \"10%\",\n    x2: \"10%\",\n    y1: \"100%\",\n    y2: \"0%\"\n  } : {\n    y1: \"0%\",\n    y2: \"0%\",\n    x1: \"0%\",\n    x2: \"100%\"\n  };\n  return /* @__PURE__ */jsx(\"linearGradient\", {\n    spreadMethod: \"pad\",\n    id,\n    ...pos,\n    children: stops.map((stop, index) => /* @__PURE__ */jsx(CloneElement, {\n      element: stop,\n      color: stop.props.color || color\n    }, `gradient-${index}`))\n  });\n};\nGradient.defaultProps = {\n  direction: \"vertical\",\n  stops: [/* @__PURE__ */jsx(GradientStop, {\n    offset: \"0%\",\n    stopOpacity: 0.3\n  }, \"start\"), /* @__PURE__ */jsx(GradientStop, {\n    offset: \"80%\",\n    stopOpacity: 1\n  }, \"stop\")]\n};\nconst RadialGradient = ({\n  id,\n  color,\n  radius = \"30%\",\n  stops = [/* @__PURE__ */jsx(GradientStop, {\n    offset: \"0%\",\n    stopOpacity: 0.2\n  }, \"start\"), /* @__PURE__ */jsx(GradientStop, {\n    offset: \"80%\",\n    stopOpacity: 0.7\n  }, \"stop\")]\n}) => /* @__PURE__ */jsx(\"radialGradient\", {\n  id,\n  cx: 0,\n  cy: 0,\n  r: radius,\n  gradientUnits: \"userSpaceOnUse\",\n  children: stops.map((stop, index) => /* @__PURE__ */jsx(CloneElement, {\n    element: stop,\n    color\n  }, `gradient-${index}`))\n});\nconst Mask = ({\n  id,\n  fill\n}) => /* @__PURE__ */jsx(\"mask\", {\n  id,\n  children: /* @__PURE__ */jsx(\"rect\", {\n    x: \"0\",\n    y: \"0\",\n    width: \"100%\",\n    height: \"100%\",\n    fill\n  })\n});\nconst Stripes = ({\n  id,\n  fill\n}) => /* @__PURE__ */jsx(\"pattern\", {\n  id,\n  width: \"4\",\n  height: \"4\",\n  patternUnits: \"userSpaceOnUse\",\n  patternTransform: \"rotate(45)\",\n  children: /* @__PURE__ */jsx(\"rect\", {\n    className: \"area-stripe\",\n    width: \"1\",\n    height: \"4\",\n    fill\n  })\n});\nconst label$2 = \"_label_uiu20_1\";\nconst value = \"_value_uiu20_7\";\nconst subValue = \"_subValue_uiu20_13\";\nconst subValueColor = \"_subValueColor_uiu20_18\";\nconst subValueName = \"_subValueName_uiu20_25\";\nconst css$i = {\n  label: label$2,\n  value,\n  subValue,\n  subValueColor,\n  subValueName\n};\nconst TooltipTemplate = ({\n  value: value2,\n  color,\n  className\n}) => {\n  if (!value2) {\n    return null;\n  }\n  const renderValues = (data, index) => {\n    const fill = color(data, index);\n    return /* @__PURE__ */jsxs(\"span\", {\n      className: css$i.subValue,\n      children: [/* @__PURE__ */jsx(\"span\", {\n        className: css$i.subValueColor,\n        style: {\n          backgroundColor: fill\n        }\n      }), /* @__PURE__ */jsxs(\"span\", {\n        className: css$i.subValueName,\n        children: [formatValue(data.key || data.x), \":\"]\n      }), /* @__PURE__ */jsx(\"span\", {\n        children: formatValue(data.value || data.y)\n      })]\n    });\n  };\n  const renderMultiple = value22 => {\n    const excessCount = value22.data.length - 15;\n    const pagedValues = value22.data.slice(0, 15);\n    return /* @__PURE__ */jsxs(Fragment, {\n      children: [pagedValues.map((point2, i) => /* @__PURE__ */jsx(Fragment, {\n        children: renderValues(point2, i)\n      }, i)), excessCount > 0 && /* @__PURE__ */jsxs(\"div\", {\n        children: [\"...\", excessCount, \" more...\"]\n      })]\n    });\n  };\n  const isMultiple = Array.isArray(value2.data);\n  return /* @__PURE__ */jsxs(\"div\", {\n    className,\n    role: \"tooltip\",\n    children: [/* @__PURE__ */jsx(\"div\", {\n      className: css$i.label,\n      children: formatValue(value2.x)\n    }), /* @__PURE__ */jsxs(\"div\", {\n      className: css$i.value,\n      children: [isMultiple && renderMultiple(value2), !isMultiple && /* @__PURE__ */jsx(Fragment, {\n        children: formatValue(value2.value || value2.y)\n      })]\n    })]\n  });\n};\nconst base = \"_base_b22et_1\";\nconst disablePointer = \"_disablePointer_b22et_10\";\nconst css$h = {\n  base,\n  disablePointer\n};\nconst tooltipTheme = {\n  base: css$h.base,\n  disablePointer: css$h.disablePointer\n};\nconst ChartTooltip = ({\n  content,\n  value: value2,\n  data,\n  color,\n  ...rest\n}) => /* @__PURE__ */jsx(Tooltip, {\n  theme: tooltipTheme,\n  ...rest,\n  content: () => {\n    if (!value2 && !data) {\n      return null;\n    }\n    return typeof content === \"function\" ? content(data || value2, color) : cloneElement(content, {\n      ...content.props,\n      value: value2,\n      color\n    });\n  }\n});\nChartTooltip.defaultProps = {\n  content: /* @__PURE__ */jsx(TooltipTemplate, {})\n};\nconst TooltipArea = forwardRef(({\n  children,\n  inverse: inverse2,\n  tooltip: tooltip2,\n  disabled,\n  color,\n  isRadial,\n  isContinous,\n  width,\n  height,\n  xScale,\n  yScale,\n  onValueEnter,\n  data,\n  isHorizontal,\n  innerRadius,\n  outerRadius,\n  placement: placementProp,\n  onValueLeave,\n  startAngle,\n  endAngle\n}, childRef) => {\n  const [visible, setVisible] = useState();\n  const [placement, setPlacement] = useState();\n  const [value2, setValue] = useState();\n  const [offsetX, setOffsetX] = useState();\n  const [offsetY, setOffsetY] = useState();\n  const [prevX, setPrevX] = useState();\n  const [prevY, setPrevY] = useState();\n  const ref = useRef();\n  const fullCircleref = useRef(null);\n  const isFullCircle = Math.abs(endAngle - startAngle) >= 2 * Math.PI;\n  const range2 = Math.abs(endAngle - startAngle);\n  const rotationFactor = 0.5;\n  const getXCoord = useCallback((x, y) => {\n    if (isRadial) {\n      const outerRadiusNew = outerRadius || Math.min(width, height) / 2;\n      let rad = Math.atan2(y - outerRadiusNew, x - outerRadiusNew) + rotationFactor * Math.PI;\n      rad = (rad - startAngle) % (2 * Math.PI);\n      if (rad < 0) {\n        rad += Math.PI * 2;\n      }\n      const scale2 = scaleLinear().domain([0, range2]).range([startAngle, endAngle]);\n      rad = scale2(rad);\n      return rad;\n    }\n    return x;\n  }, [endAngle, height, isRadial, outerRadius, range2, startAngle, width]);\n  const transformData = useCallback(series => {\n    const result = [];\n    if (inverse2) {\n      for (const point2 of series) {\n        const seriesPoint = point2;\n        if (Array.isArray(seriesPoint.data)) {\n          for (const nestedPoint of seriesPoint.data) {\n            const right = nestedPoint.x;\n            let idx = result.findIndex(r => {\n              const left = r.x;\n              if (left instanceof Date && right instanceof Date) {\n                return left.getTime() === right.getTime();\n              }\n              return left === right;\n            });\n            if (idx === -1) {\n              result.push({\n                x: nestedPoint.x,\n                data: []\n              });\n              idx = result.length - 1;\n            }\n            const data2 = result[idx].data;\n            if (Array.isArray(data2)) {\n              data2.push(nestedPoint);\n            }\n          }\n        } else {\n          result.push(point2);\n        }\n      }\n    } else {\n      for (const point2 of series) {\n        const nestedPoint = point2;\n        if (Array.isArray(nestedPoint.data)) {\n          result.push({\n            ...nestedPoint,\n            x: nestedPoint.key,\n            data: nestedPoint.data.map(d => ({\n              ...d,\n              key: !isHorizontal ? d.x : d.y,\n              value: !isHorizontal ? d.y : d.x\n            }))\n          });\n        } else {\n          const shallowPoint = point2;\n          result.push({\n            ...shallowPoint,\n            // Histograms special logic...\n            x: shallowPoint.key === void 0 ? shallowPoint.x0 : point2.key,\n            y: shallowPoint.value === void 0 ? shallowPoint.y : shallowPoint.value\n          });\n        }\n      }\n    }\n    return result;\n  }, [inverse2, isHorizontal]);\n  const onMouseMove = useCallback(event => {\n    const transformed = transformData(data);\n    let newPlacement = placementProp;\n    if (!placementProp) {\n      if (isHorizontal) {\n        newPlacement = \"right\";\n      } else {\n        newPlacement = \"top\";\n      }\n    }\n    let target = fullCircleref.current || ref.current;\n    const {\n      y,\n      x\n    } = getPositionForTarget({\n      target,\n      // Manually pass the x/y from the event\n      clientX: event.clientX,\n      clientY: event.clientY\n    });\n    let keyScale;\n    let valueScale;\n    let coord;\n    let attr = \"x\";\n    if (isHorizontal) {\n      keyScale = yScale;\n      valueScale = xScale;\n      coord = y;\n    } else {\n      coord = getXCoord(x, y);\n      keyScale = xScale;\n      valueScale = yScale;\n    }\n    if (typeof transformed[0].i === \"number\") {\n      attr = \"i\";\n    }\n    const newValue = keyScale.invert ? getClosestContinousScalePoint({\n      pos: coord,\n      scale: keyScale,\n      data: transformed,\n      attr,\n      roundDown: !isContinous\n    }) : getClosestBandScalePoint({\n      pos: coord,\n      scale: keyScale,\n      data: transformed,\n      attr,\n      roundClosest: isRadial\n    });\n    if (!isEqual(newValue, value2) && newValue) {\n      const pointX = keyScale(newValue.x);\n      let pointY = valueScale(newValue.y);\n      let marginX = 0;\n      let marginY = 0;\n      if (isNaN(pointY)) {\n        pointY = height / 2;\n        marginX = 10;\n        if (!placement) {\n          newPlacement = \"right\";\n        }\n      } else {\n        marginY = -10;\n      }\n      if (pointX === prevX && pointY === prevY) {\n        return;\n      }\n      setPrevX(pointX);\n      setPrevY(pointY);\n      const target2 = event.target;\n      const {\n        top,\n        left\n      } = target2.getBoundingClientRect();\n      let offsetX2 = 0;\n      let offsetY2 = 0;\n      if (isRadial) {\n        const outerRadius2 = Math.min(width, height) / 2;\n        offsetX2 = pointY * Math.cos(pointX - rotationFactor * Math.PI) + outerRadius2;\n        offsetY2 = pointY * Math.sin(pointX - rotationFactor * Math.PI) + outerRadius2;\n      } else {\n        offsetX2 = pointX;\n        offsetY2 = pointY;\n      }\n      offsetX2 += left + marginX;\n      offsetY2 += top + marginY;\n      setPlacement(newPlacement);\n      setVisible(true);\n      setValue(newValue);\n      setOffsetX(offsetX2);\n      setOffsetY(offsetY2);\n      onValueEnter({\n        visible: true,\n        value: newValue,\n        pointY,\n        pointX,\n        offsetX: offsetX2,\n        offsetY: offsetY2,\n        nativeEvent: event\n      });\n    }\n  }, [data, getXCoord, height, isContinous, isHorizontal, isRadial, onValueEnter, placement, placementProp, prevX, prevY, transformData, value2, width, xScale, yScale]);\n  const onMouseLeave = useCallback(() => {\n    setPrevX(void 0);\n    setPrevY(void 0);\n    setValue(void 0);\n    setVisible(false);\n    onValueLeave();\n  }, [onValueLeave]);\n  useImperativeHandle(childRef, () => ({\n    triggerMouseMove(e) {\n      onMouseMove(e);\n    }\n  }));\n  const tooltipReference = useMemo(() => ({\n    width: 4,\n    height: 4,\n    top: offsetY,\n    left: offsetX\n  }), [offsetX, offsetY]);\n  const renderRadial = useCallback(() => {\n    const innerRadiusNew = innerRadius || 0;\n    const outerRadiusNew = outerRadius || Math.min(width, height) / 2;\n    const d = arc()({\n      innerRadius: innerRadiusNew,\n      outerRadius: outerRadiusNew,\n      startAngle: isFullCircle ? 0 : startAngle,\n      endAngle: isFullCircle ? 2 * Math.PI : endAngle\n    });\n    const fullCircle = arc()({\n      innerRadius: innerRadiusNew,\n      outerRadius: outerRadiusNew,\n      startAngle: 0,\n      endAngle: 2 * Math.PI\n    });\n    return /* @__PURE__ */jsxs(Fragment$1, {\n      children: [/* @__PURE__ */jsx(\"path\", {\n        d: fullCircle,\n        opacity: \"0\",\n        cursor: \"auto\",\n        ref: fullCircleref\n      }), /* @__PURE__ */jsx(\"path\", {\n        d,\n        opacity: \"0\",\n        cursor: \"auto\",\n        ref,\n        onMouseMove\n      })]\n    });\n  }, [endAngle, height, innerRadius, isFullCircle, onMouseMove, outerRadius, startAngle, width]);\n  const renderLinear = useCallback(() => {\n    return /* @__PURE__ */jsx(\"rect\", {\n      height,\n      ref,\n      width,\n      opacity: 0,\n      cursor: \"auto\",\n      onMouseMove\n    });\n  }, [height, onMouseMove, width]);\n  return /* @__PURE__ */jsxs(Fragment, {\n    children: [disabled && children, !disabled && /* @__PURE__ */jsxs(\"g\", {\n      onMouseLeave,\n      ref: childRef,\n      children: [isRadial && renderRadial(), !isRadial && renderLinear(), /* @__PURE__ */jsx(CloneElement, {\n        element: tooltip2,\n        visible,\n        placement,\n        modifiers: {\n          offset: {\n            offset: \"0, 15px\"\n          }\n        },\n        reference: tooltipReference,\n        color,\n        value: value2\n      }), children]\n    })]\n  });\n});\nTooltipArea.defaultProps = {\n  isRadial: false,\n  isContinous: true,\n  tooltip: /* @__PURE__ */jsx(ChartTooltip, {}),\n  inverse: true,\n  onValueEnter: () => void 0,\n  onValueLeave: () => void 0,\n  startAngle: 0,\n  endAngle: 2 * Math.PI\n};\nconst ZoomPan = ({\n  height,\n  width,\n  children,\n  disabled,\n  pannable,\n  maxZoom,\n  minZoom,\n  zoomable,\n  scale: scale2,\n  x,\n  y,\n  disableMouseWheel,\n  constrain,\n  zoomStep,\n  onPanCancel,\n  requireZoomModifier,\n  globalPanning,\n  onPanStart,\n  onZoomPan,\n  onPanMove,\n  onPanEnd,\n  onZoom,\n  onZoomEnd\n}) => {\n  const zoomRef = useRef();\n  const panRef = useRef();\n  const [isZooming, setIsZooming] = useState();\n  const [isPanning, setIsPanning] = useState();\n  const [matrix, setMatrix] = useState(identity());\n  useEffect(() => {\n    const newMatrix = transform(fromDefinition([{\n      type: \"translate\",\n      tx: x,\n      ty: y\n    }, {\n      type: \"scale\",\n      sx: scale2,\n      sy: scale2\n    }]));\n    if (!isEqual(newMatrix, matrix)) {\n      setMatrix(newMatrix);\n    }\n  }, [x, y, scale2, matrix]);\n  const onPanStartHandler = useCallback(event => {\n    setIsPanning(true);\n    onPanStart(event);\n  }, [onPanStart]);\n  const onPanMoveHandler = useCallback(event => {\n    onZoomPan({\n      scale: scale2,\n      x: event.x,\n      y: event.y,\n      type: \"pan\",\n      nativeEvent: event.nativeEvent\n    });\n    onPanMove(event);\n  }, [onPanMove, onZoomPan, scale2]);\n  const onPanEndHandler = useCallback(event => {\n    setIsPanning(false);\n    onPanEnd(event);\n  }, [onPanEnd]);\n  const onZoomHandler = useCallback(event => {\n    onZoomPan({\n      x: event.x,\n      y: event.y,\n      scale: event.scale,\n      nativeEvent: event.nativeEvent,\n      type: \"zoom\"\n    });\n    onZoom(event);\n  }, [onZoom, onZoomPan]);\n  const onZoomEndHandler = useCallback(() => {\n    setIsZooming(false);\n    onZoomEnd();\n  }, [onZoomEnd]);\n  const cursor = pannable ? \"move\" : \"auto\";\n  const selection = isZooming || isPanning ? \"none\" : \"auto\";\n  const matrixObj = fromObject(matrix);\n  return /* @__PURE__ */jsx(Pan, {\n    x,\n    y,\n    scale: scale2,\n    matrix: matrixObj,\n    constrain,\n    height,\n    width,\n    disabled: !pannable || disabled,\n    ref: panRef,\n    globalPanning,\n    onPanStart: bind(onPanStartHandler),\n    onPanMove: bind(onPanMoveHandler),\n    onPanEnd: bind(onPanEndHandler),\n    onPanCancel,\n    children: /* @__PURE__ */jsxs(Zoom, {\n      ref: zoomRef,\n      disabled: !zoomable || disabled,\n      scaleFactor: zoomStep,\n      disableMouseWheel,\n      maxZoom,\n      minZoom,\n      scale: scale2,\n      x,\n      y,\n      style: {\n        cursor\n      },\n      requireZoomModifier,\n      matrix,\n      onZoom: bind(onZoomHandler),\n      onZoomEnd: bind(onZoomEndHandler),\n      children: [!disabled && /* @__PURE__ */jsx(\"rect\", {\n        height,\n        width,\n        opacity: 0,\n        className: \"pan-container\"\n      }), /* @__PURE__ */jsx(\"g\", {\n        style: {\n          pointerEvents: selection,\n          userSelect: selection\n        },\n        children\n      })]\n    })\n  });\n};\nZoomPan.defaultProps = {\n  maxZoom: 10,\n  minZoom: 0,\n  zoomStep: 0.1,\n  pannable: true,\n  zoomable: true,\n  constrain: true,\n  height: 0,\n  width: 0,\n  x: 0,\n  y: 0,\n  scale: 1,\n  globalPanning: true,\n  onPanStart: () => void 0,\n  onPanMove: () => void 0,\n  onPanEnd: () => void 0,\n  onPanCancel: () => void 0,\n  onZoom: () => void 0,\n  onZoomEnd: () => void 0\n};\nfunction getXScale({\n  type,\n  roundDomains,\n  data,\n  width,\n  domain,\n  padding,\n  scaled,\n  isMultiSeries = false,\n  isDiverging = false\n}) {\n  let scale2;\n  if (type === \"time\" || type === \"duration\" || type === \"value\") {\n    if (type === \"time\") {\n      scale2 = scaleTime().rangeRound([0, width]);\n    } else {\n      scale2 = scaleLinear().rangeRound([0, width]);\n    }\n    scale2 = scale2.domain(domain || getXDomain({\n      data,\n      scaled,\n      isDiverging\n    }));\n  } else {\n    if (!domain) {\n      if (isMultiSeries) {\n        domain = uniqueBy(data, d => d.key);\n      } else {\n        domain = uniqueBy(data, d => d.x);\n      }\n    }\n    scale2 = scaleBand().rangeRound([0, width]).padding(padding || 0).domain(domain);\n  }\n  return roundDomains ? scale2.nice() : scale2;\n}\nfunction getYScale({\n  type,\n  height,\n  data,\n  domain,\n  roundDomains = false,\n  scaled = false,\n  padding = 0,\n  isMultiSeries = false,\n  isDiverging = false\n}) {\n  let scale2;\n  if (type === \"time\" || type === \"value\" || type === \"duration\") {\n    scale2 = scaleLinear().range([height, 0]).domain(domain || getYDomain({\n      data,\n      scaled,\n      isDiverging\n    }));\n  } else {\n    if (!domain) {\n      if (isMultiSeries) {\n        domain = uniqueBy(data, d => d.key);\n      } else {\n        domain = uniqueBy(data, d => d.y);\n      }\n    }\n    scale2 = scaleBand().rangeRound([height, 0]).padding(padding).domain(domain);\n  }\n  return roundDomains ? scale2.nice() : scale2;\n}\nconst getMarimekkoScale = (width, roundDomains) => {\n  const scale2 = scaleLinear().rangeRound([0, width]);\n  return roundDomains ? scale2.nice() : scale2;\n};\nconst getMarimekkoGroupScale = ({\n  data,\n  width,\n  valueScale,\n  padding\n}) => {\n  const domain = uniqueBy(data, d => d.key);\n  const barCount = data.length;\n  const widthMinusPadding = width - padding * (barCount - 1);\n  const xMultiplier = widthMinusPadding / width;\n  const getXRange = series => {\n    const [val] = series.data;\n    const x0 = valueScale(val.x0);\n    const x1 = valueScale(val.x1);\n    return {\n      x0,\n      x1\n    };\n  };\n  const scale2 = arg => {\n    let result = 0;\n    const index = data.findIndex(d => d.key === arg);\n    const series = data[index];\n    if (series && series.data && series.data.length) {\n      const {\n        x1,\n        x0\n      } = getXRange(series);\n      result = (x1 - x0) / 2 + x0;\n      if (padding) {\n        result = result * xMultiplier + index * padding;\n      }\n    }\n    return result;\n  };\n  scale2.range = () => [0, width];\n  scale2.domain = () => domain;\n  scale2.mariemkoInvert = offset => {\n    let found;\n    for (let i = 0; i < domain.length; i++) {\n      const attr = domain[i];\n      const series = data[i];\n      const {\n        x1,\n        x0\n      } = getXRange(series);\n      if (offset >= x0 - padding / 2 && offset <= x1 - padding / 2) {\n        found = attr;\n        break;\n      }\n    }\n    return found;\n  };\n  return scale2;\n};\nfunction getGroupScale({\n  dimension,\n  padding,\n  data,\n  direction = \"vertical\"\n}) {\n  const domain = uniqueBy(data, d => d.key);\n  const spacing = domain.length / (dimension / padding + 1);\n  const range2 = direction === \"vertical\" ? [0, dimension] : [dimension, 0];\n  return scaleBand().rangeRound(range2).paddingInner(spacing).paddingOuter(spacing / 2).domain(domain);\n}\nfunction getInnerScale({\n  groupScale,\n  padding,\n  data,\n  prop = \"x\"\n}) {\n  const dimension = groupScale.bandwidth();\n  const domain = uniqueBy(data, d => d.data, d => d[prop]);\n  const spacing = domain.length / (dimension / padding + 1);\n  return scaleBand().rangeRound([0, dimension]).paddingInner(spacing).domain(domain);\n}\nconst getRadialYScale = (innerRadius, outerRadius, domain) => {\n  if (domain[0] === 0 && domain[1] === 0) {\n    domain = [0, 1];\n  }\n  const y = scaleLinear().range([innerRadius * innerRadius, outerRadius * outerRadius]).domain(domain);\n  const yScale = Object.assign(d => Math.sqrt(y(d)), y);\n  return yScale;\n};\nconst ChartZoomPan = ({\n  data,\n  height,\n  children,\n  disabled,\n  domain,\n  width,\n  axisType,\n  roundDomains,\n  onZoomPan,\n  ...rest\n}) => {\n  const onZoomPanHandler = useCallback(event => {\n    const can = event.type === \"zoom\" || event.type === \"pan\" && event.scale > 1;\n    if (can) {\n      const scale2 = getXScale({\n        width,\n        type: axisType,\n        roundDomains,\n        data\n      });\n      const newScale = scale2.copy().domain(scale2.range().map(x => (x - event.x) / event.scale).map(scale2.clamp(true).invert, event.x));\n      onZoomPan({\n        domain: newScale.domain(),\n        isZoomed: event.scale !== 1\n      });\n    }\n  }, [axisType, data, onZoomPan, roundDomains, width]);\n  const zoomOffset = useMemo(() => {\n    let zoomOffset2 = {\n      scale: void 0,\n      x: void 0\n    };\n    if (!disabled && domain) {\n      const xScale = getXScale({\n        width,\n        type: axisType,\n        roundDomains,\n        data\n      });\n      let offset = xScale(domain[0]);\n      const endOffset = xScale(domain[1]);\n      const scale2 = width / (endOffset - offset);\n      offset = offset * scale2;\n      zoomOffset2 = {\n        scale: scale2,\n        x: -offset\n      };\n    }\n    return zoomOffset2;\n  }, [axisType, data, disabled, domain, roundDomains, width]);\n  return /* @__PURE__ */jsx(ZoomPan, {\n    ...rest,\n    scale: zoomOffset.scale,\n    x: zoomOffset.x,\n    height,\n    width,\n    pannable: zoomOffset.scale > 1,\n    onZoomPan: onZoomPanHandler,\n    children\n  });\n};\nChartZoomPan.defaultProps = {\n  onZoomPan: () => void 0\n};\nconst DEFAULT_TRANSITION = {\n  type: \"spring\",\n  velocity: 5,\n  damping: 20,\n  // https://github.com/framer/motion/issues/1513#issuecomment-1121133717\n  restDelta: 0.01,\n  restSpeed: 0.01\n};\nconst MotionPath = ({\n  custom,\n  transition,\n  ...rest\n}) => {\n  const d = useMotionValue(custom.exit.d);\n  const spring = useSpring(0, DEFAULT_TRANSITION);\n  useEffect(() => {\n    const interpolator = interpolate$1(d.get(), custom.enter.d);\n    const prevSpring = spring.get();\n    spring.set(prevSpring + 1);\n    return spring.on(\"change\", v => d.set(interpolator(v - prevSpring)));\n  }, [custom.enter.d, custom.exit.d, d, spring]);\n  const {\n    d: enterD,\n    ...enterRest\n  } = custom.enter;\n  const {\n    d: exitD,\n    ...exitRest\n  } = custom.exit;\n  return /* @__PURE__ */jsx(motion.path, {\n    ...rest,\n    initial: exitRest,\n    exit: exitRest,\n    animate: enterRest,\n    transition,\n    d: transition.type !== false ? d : enterD\n  });\n};\nconst schemes = {\n  cybertron: chroma.scale([\"#2d60e8\", \"#26efb5\"]).correctLightness().colors(8),\n  ...chroma.brewer\n};\nfunction isColorSchemeStyleArray(colorScheme) {\n  return Array.isArray(colorScheme) && typeof colorScheme[0] === \"object\";\n}\nconst rangeHelper = (point2, attribute) => point2.map((r, i) => {\n  if (r) {\n    if (r[attribute] !== void 0) {\n      return r[attribute];\n    } else if (r.data && r.data[attribute] !== void 0) {\n      return r.data[attribute];\n    }\n  }\n  return i;\n});\nconst getColor = props => {\n  let {\n    point: point2,\n    colorScheme,\n    attribute,\n    index,\n    data,\n    active,\n    isMultiSeries,\n    domain,\n    key,\n    scale: scale2\n  } = {\n    attribute: \"key\",\n    isMultiSeries: false,\n    scale: scaleOrdinal,\n    ...props\n  };\n  if (typeof colorScheme === \"string\" && schemes[colorScheme]) {\n    colorScheme = schemes[colorScheme];\n  }\n  if (Array.isArray(colorScheme)) {\n    if (!domain) {\n      if (isMultiSeries && Array.isArray(data)) {\n        const maxIdx = maxIndex(data, d => d.data.length);\n        const maxVal = data[maxIdx];\n        data = maxVal.data;\n      }\n      domain = rangeHelper(data, attribute);\n    }\n    key = key !== void 0 ? key : point2[attribute];\n    return scale2(colorScheme).domain(domain)(key);\n  } else if (typeof colorScheme === \"function\") {\n    return colorScheme(point2, index, active);\n  } else {\n    return colorScheme;\n  }\n};\nconst getValueScale = (data, colorScheme, emptyColor, selections) => {\n  const valueDomain = extent$1(uniqueBy(data, d => d.data, d => d.value));\n  return point2 => {\n    if ((point2 == null ? void 0 : point2.value) === void 0 || (point2 == null ? void 0 : point2.value) === null) {\n      return emptyColor;\n    }\n    return getColor({\n      scale: scaleQuantile,\n      domain: valueDomain,\n      key: point2.value,\n      colorScheme,\n      point: point2,\n      active: selections\n    });\n  };\n};\nconst getColorSchemeStyles = (point2, valueScales) => Array.from(valueScales).reduce((acc, [key, valueScale]) => {\n  return {\n    ...acc,\n    [key]: valueScale(point2)\n  };\n}, {});\nconst getColorSchemeForProperty = (colorScheme, colorSchemeProperty) => colorScheme.map(schemeItem => schemeItem == null ? void 0 : schemeItem[colorSchemeProperty]);\nconst createColorSchemeValueScales = (data, colorScheme, emptyColor, selections) => {\n  const valueScales = /* @__PURE__ */new Map();\n  if (isColorSchemeStyleArray(colorScheme)) {\n    const colorSchemeProperties = [...new Set(colorScheme.flatMap(Object.keys))];\n    colorSchemeProperties.forEach(key => {\n      const valueScale = getValueScale(data, getColorSchemeForProperty(colorScheme, key), emptyColor, selections);\n      valueScales.set(key, valueScale);\n    });\n  } else {\n    valueScales.set(\"fill\", getValueScale(data, colorScheme, emptyColor, selections));\n  }\n  return valueScales;\n};\nconst COUNT_DEFAULTS = {\n  from: 0,\n  duration: 1,\n  delay: 0,\n  format: true,\n  decimalPlaces: 0\n};\nconst useCount = ({\n  from,\n  to,\n  duration,\n  delay,\n  prefix,\n  suffix,\n  decimalPlaces,\n  format\n}) => {\n  const nodeRef = useRef(null);\n  from = from || COUNT_DEFAULTS.from;\n  duration = duration || COUNT_DEFAULTS.duration;\n  delay = delay || COUNT_DEFAULTS.delay;\n  format = format || COUNT_DEFAULTS.format;\n  decimalPlaces = decimalPlaces || COUNT_DEFAULTS.decimalPlaces;\n  useEffect(() => {\n    const node2 = nodeRef.current;\n    const controls = animate(from, to, {\n      duration,\n      delay,\n      onUpdate(value2) {\n        let formatted = value2;\n        if (decimalPlaces) {\n          formatted = Number(value2.toFixed(decimalPlaces));\n        } else {\n          formatted = Number(value2.toFixed(0));\n        }\n        if (format) {\n          formatted = formatted.toLocaleString();\n        }\n        if (node2) {\n          if (prefix) {\n            formatted = `${prefix}${formatted}`;\n          }\n          if (suffix) {\n            formatted = `${formatted}${suffix}`;\n          }\n          node2.textContent = formatted;\n        }\n      }\n    });\n    return () => controls.stop();\n  }, [from, to, duration, delay, decimalPlaces, format, prefix, suffix]);\n  return nodeRef;\n};\nconst Count = ({\n  className,\n  ...rest\n}) => {\n  const ref = useCount(rest);\n  return /* @__PURE__ */jsx(\"span\", {\n    ref,\n    className\n  });\n};\nCount.defaultProps = {\n  from: 0,\n  duration: 1,\n  delay: 0,\n  localize: true,\n  decimalPlaces: 0\n};\nconst LinearValueMarker = ({\n  color,\n  value: value2,\n  className,\n  thickness = 1,\n  size,\n  direction = \"horizontal\"\n}) => {\n  const coordinates = direction === \"horizontal\" ? {\n    x1: 0,\n    y1: value2,\n    x2: size,\n    y2: value2\n  } : {\n    x1: value2,\n    y1: 0,\n    x2: value2,\n    y2: size\n  };\n  return /* @__PURE__ */jsx(\"line\", {\n    className,\n    stroke: color,\n    strokeWidth: thickness,\n    ...coordinates\n  });\n};\nconst RadialValueMarker = ({\n  color,\n  value: value2,\n  className,\n  thickness = 1\n}) => /* @__PURE__ */jsx(\"circle\", {\n  className,\n  cx: 0,\n  cy: 0,\n  r: value2,\n  fill: \"none\",\n  stroke: color,\n  strokeWidth: thickness\n});\nconst inactive$1 = \"_inactive_jp2yc_1\";\nconst hidden$1 = \"_hidden_jp2yc_5\";\nconst css$g = {\n  inactive: inactive$1,\n  hidden: hidden$1\n};\nconst generateGlowStyles = ({\n  glow,\n  colorSchemeColor\n}) => {\n  if (!glow) return {};\n  let {\n    x = 0,\n    y = 0,\n    blur = 5,\n    color = colorSchemeColor || \"rgb(255, 255, 255, 0.25)\",\n    opacity = 1\n  } = glow;\n  color = chroma(color).alpha(opacity).css();\n  return blur ? {\n    filter: `drop-shadow(${x}px ${y}px ${blur}px ${color})`\n  } : {};\n};\nconst ScatterPoint = ({\n  symbol: symbol2,\n  index,\n  id,\n  data,\n  xScale,\n  yScale,\n  active,\n  tooltip: tooltip2,\n  cursor,\n  size,\n  glow,\n  color,\n  animated,\n  onClick,\n  onMouseEnter,\n  onMouseLeave,\n  visible,\n  ...rest\n}) => {\n  const rectRef = useRef(null);\n  const [tooltipVisible, setTooltipVisible] = useState(false);\n  const extras = useMemo(() => constructFunctionProps(rest, data), [rest, data]);\n  const r = useMemo(() => typeof size === \"function\" ? size(data) : size, [size, data]);\n  const renderedSymbol = useMemo(() => symbol2 ? symbol2(data) : null, [data, symbol2]);\n  const transitionProps = useMemo(() => animated ? {\n    ...DEFAULT_TRANSITION,\n    delay: index * 5e-3\n  } : {\n    type: false,\n    delay: 0\n  }, [index, animated]);\n  const enterProps = useMemo(() => {\n    let cy = yScale(data.y1);\n    if (yScale.bandwidth) {\n      const width = yScale.bandwidth();\n      cy = cy + width / 2;\n    }\n    return {\n      x: xScale(data.x),\n      y: cy\n    };\n  }, [data, yScale]);\n  const exitProps = useMemo(() => {\n    const [yStartDomain] = yScale.domain();\n    return {\n      y: yScale(yStartDomain),\n      x: xScale(data.x)\n    };\n  }, [data, yScale]);\n  const fill = useMemo(() => getColor({\n    colorScheme: color,\n    index,\n    point: data\n  }), [data, color, index]);\n  const key = `symbol-${id}-${identifier(`${data.id}`)}`;\n  const ariaLabelData = useMemo(() => getAriaLabel(data), [data]);\n  const isVisible = visible ? visible == null ? void 0 : visible(data, index) : active;\n  return /* @__PURE__ */jsxs(Fragment, {\n    children: [/* @__PURE__ */jsx(\"g\", {\n      ref: rectRef,\n      className: classNames({\n        [css$g.inactive]: !active,\n        [css$g.hidden]: !isVisible\n      }),\n      onMouseEnter: () => {\n        setTooltipVisible(true);\n        onMouseEnter(data);\n      },\n      onMouseLeave: () => {\n        setTooltipVisible(false);\n        onMouseLeave(data);\n      },\n      onClick: () => onClick(data),\n      tabIndex: 0,\n      \"aria-label\": ariaLabelData,\n      role: \"graphics-document\",\n      children: symbol2 ? /* @__PURE__ */jsx(motion.g, {\n        ...extras,\n        initial: {\n          translateX: exitProps.x,\n          translateY: exitProps.y,\n          opacity: 0\n        },\n        animate: {\n          translateX: enterProps.x,\n          translateY: enterProps.y,\n          opacity: 1\n        },\n        exit: {\n          translateX: exitProps.x,\n          translateY: exitProps.y,\n          opacity: 0\n        },\n        transition: transitionProps,\n        children: renderedSymbol\n      }, key) : /* @__PURE__ */jsx(motion.circle, {\n        className: extras.className,\n        style: {\n          ...extras.style,\n          ...generateGlowStyles({\n            glow\n          }),\n          cursor\n        },\n        fill,\n        initial: {\n          cx: exitProps.x,\n          cy: exitProps.y,\n          r,\n          opacity: 0\n        },\n        animate: {\n          cx: enterProps.x,\n          cy: enterProps.y,\n          opacity: 1,\n          r\n        },\n        exit: {\n          cx: exitProps.x,\n          cy: exitProps.y,\n          r,\n          opacity: 0\n        },\n        transition: transitionProps\n      }, key)\n    }), tooltip2 && !tooltip2.props.disabled && /* @__PURE__ */jsx(CloneElement, {\n      element: tooltip2,\n      visible: tooltipVisible,\n      reference: rectRef,\n      value: data\n    })]\n  });\n};\nScatterPoint.defaultProps = {\n  active: true,\n  tooltip: /* @__PURE__ */jsx(ChartTooltip, {}),\n  cursor: \"pointer\",\n  size: 4,\n  color: schemes.cybertron[0],\n  animated: true,\n  onClick: () => void 0,\n  onMouseEnter: () => void 0,\n  onMouseLeave: () => void 0\n};\nconst PADDING$1 = 25;\nconst HALF_PADDING$1 = PADDING$1 / 2;\nconst ScatterSeries = ({\n  data,\n  height,\n  width,\n  id,\n  isZoomed,\n  activeIds,\n  point: point2,\n  valueMarkers,\n  xScale,\n  yScale,\n  ...rest\n}) => {\n  const renderPoint = useCallback((pointData, index) => {\n    let pointId;\n    if (pointData.id) {\n      pointId = pointData.id;\n    }\n    const key = identifier(`${pointId || index}`);\n    const active = !(activeIds && activeIds.length) || activeIds.includes(pointId);\n    return /* @__PURE__ */jsx(CloneElement, {\n      element: point2,\n      xScale,\n      yScale,\n      ...rest,\n      id,\n      data: pointData,\n      index,\n      active\n    }, key);\n  }, [activeIds, point2, yScale, rest, id]);\n  const renderValueMarkers = useCallback(() => /* @__PURE__ */jsx(Fragment$1, {\n    children: (valueMarkers == null ? void 0 : valueMarkers.length) && valueMarkers.map(marker2 => {\n      var _a;\n      const isVertical = ((_a = marker2 == null ? void 0 : marker2.props) == null ? void 0 : _a.direction) === \"vertical\";\n      const size = isVertical ? height : width;\n      const value2 = isVertical ? xScale(marker2.props.value) : yScale(marker2.props.value);\n      return /* @__PURE__ */jsx(CloneElement, {\n        element: marker2,\n        size,\n        value: value2\n      }, marker2.key);\n    })\n  }), [valueMarkers, width, yScale]);\n  return /* @__PURE__ */jsxs(Fragment, {\n    children: [/* @__PURE__ */jsx(\"defs\", {\n      children: /* @__PURE__ */jsx(\"clipPath\", {\n        id: `${id}-path`,\n        children: /* @__PURE__ */jsx(\"rect\", {\n          width: isZoomed ? width : width + PADDING$1,\n          height: height + PADDING$1,\n          x: isZoomed ? 0 : -HALF_PADDING$1,\n          y: -HALF_PADDING$1\n        })\n      })\n    }), renderValueMarkers(), /* @__PURE__ */jsx(\"g\", {\n      clipPath: `url(#${id}-path)`,\n      children: data.map(renderPoint)\n    })]\n  });\n};\nScatterSeries.defaultProps = {\n  point: /* @__PURE__ */jsx(ScatterPoint, {})\n};\nconst scatterPlot = \"_scatterPlot_gc5eo_1\";\nconst css$f = {\n  scatterPlot\n};\nconst ScatterPlot = ({\n  id,\n  width,\n  height,\n  margins,\n  className,\n  series,\n  xAxis,\n  yAxis,\n  data,\n  gridlines,\n  containerClassName,\n  brush,\n  zoomPan,\n  secondaryAxis\n}) => {\n  const zoomControlled = useMemo(() => {\n    var _a, _b;\n    return (\n      // eslint-disable-next-line\n      !((_b = (_a = zoomPan == null ? void 0 : zoomPan.props) == null ? void 0 : _a.domain) == null ? void 0 : _b.hasOwnProperty(\"domain\"))\n    );\n  }, [zoomPan]);\n  const timeout = useRef(null);\n  const [preventAnimation, setPreventAnimation] = useState(false);\n  const [zoomDomain, setZoomDomain] = useState(null);\n  const [isZoomed, setIsZoomed] = useState(false);\n  const aggregatedData = useMemo(() => buildShallowChartData(data), [data]);\n  const getScales = useCallback((chartHeight, chartWidth) => {\n    const yScale = getYScale({\n      roundDomains: yAxis.props.roundDomains,\n      type: yAxis.props.type,\n      height: chartHeight,\n      data: aggregatedData,\n      domain: yAxis.props.domain\n    });\n    const xScale = getXScale({\n      width: chartWidth,\n      type: xAxis.props.type,\n      roundDomains: xAxis.props.roundDomains,\n      data: aggregatedData,\n      domain: zoomDomain || xAxis.props.domain\n    });\n    return {\n      yScale,\n      xScale\n    };\n  }, [yAxis, xAxis, aggregatedData, zoomDomain]);\n  const onZoomPan = useCallback(event => {\n    if (zoomControlled) {\n      setPreventAnimation(true);\n      setZoomDomain(event.domain);\n      setIsZoomed(event.isZoomed);\n      clearTimeout(timeout.current);\n      timeout.current = setTimeout(() => setPreventAnimation(true), 500);\n    }\n  }, [zoomControlled]);\n  const renderChart = useCallback(({\n    chartHeight,\n    chartWidth,\n    id: id2,\n    updateAxes,\n    chartSized\n  }) => {\n    const {\n      yScale,\n      xScale\n    } = getScales(chartHeight, chartWidth);\n    const animated = preventAnimation === true ? false : series.props.animated;\n    const disableBrush = aggregatedData.length <= 1;\n    return /* @__PURE__ */jsxs(Fragment, {\n      children: [chartSized && gridlines && /* @__PURE__ */jsx(CloneElement, {\n        element: gridlines,\n        height: chartHeight,\n        width: chartWidth,\n        yScale,\n        xScale,\n        yAxis: yAxis.props,\n        xAxis: xAxis.props\n      }), /* @__PURE__ */jsx(CloneElement, {\n        element: xAxis,\n        height: chartHeight,\n        width: chartWidth,\n        scale: xScale,\n        visibility: chartSized ? \"visible\" : \"hidden\",\n        onDimensionsChange: e => updateAxes(\"horizontal\", e)\n      }), /* @__PURE__ */jsx(CloneElement, {\n        element: yAxis,\n        height: chartHeight,\n        width: chartWidth,\n        scale: yScale,\n        visibility: chartSized ? \"visible\" : \"hidden\",\n        onDimensionsChange: e => updateAxes(\"vertical\", e)\n      }), secondaryAxis && secondaryAxis.map((axis, i) => /* @__PURE__ */jsx(CloneElement, {\n        element: axis,\n        height: chartHeight,\n        width: chartWidth,\n        visibility: chartSized ? \"visible\" : \"hidden\",\n        onDimensionsChange: e => updateAxes(\"horizontal\", e)\n      }, i)), chartSized && /* @__PURE__ */jsx(CloneElement, {\n        disabled: disableBrush,\n        element: brush,\n        height: chartHeight,\n        width: chartWidth,\n        scale: xScale,\n        children: /* @__PURE__ */jsx(CloneElement, {\n          element: zoomPan,\n          onZoomPan,\n          height: chartHeight,\n          width: chartWidth,\n          axisType: xAxis.props.type,\n          roundDomains: xAxis.props.roundDomains,\n          data: aggregatedData,\n          domain: zoomDomain,\n          children: /* @__PURE__ */jsx(CloneElement, {\n            element: series,\n            id: `area-series-${id2}`,\n            data: aggregatedData,\n            height: chartHeight,\n            width: chartWidth,\n            yScale,\n            xScale,\n            isZoomed,\n            animated\n          })\n        })\n      })]\n    });\n  }, [getScales, preventAnimation, series, gridlines, yAxis, xAxis, secondaryAxis, brush, zoomPan, onZoomPan, aggregatedData, zoomDomain, isZoomed]);\n  return /* @__PURE__ */jsx(ChartContainer, {\n    id,\n    width,\n    height,\n    containerClassName,\n    margins,\n    xAxisVisible: isAxisVisible(xAxis.props),\n    yAxisVisible: isAxisVisible(yAxis.props),\n    className: classNames(css$f.scatterPlot, className),\n    children: renderChart\n  });\n};\nScatterPlot.defaultProps = {\n  data: [],\n  xAxis: /* @__PURE__ */jsx(LinearXAxis, {\n    type: \"time\"\n  }),\n  yAxis: /* @__PURE__ */jsx(LinearYAxis, {\n    type: \"value\"\n  }),\n  series: /* @__PURE__ */jsx(ScatterSeries, {}),\n  gridlines: /* @__PURE__ */jsx(GridlineSeries, {}),\n  brush: null,\n  zoomPan: null\n};\nconst point = \"_point_u68jv_1\";\nconst css$e = {\n  point\n};\nconst PointSeries = ({\n  data,\n  xScale,\n  yScale,\n  animated,\n  point: point2,\n  color,\n  height,\n  width,\n  id,\n  activeValues,\n  show\n}) => {\n  const getIsVisible = useCallback((point22, index) => {\n    const isActive = activeValues && point22 && isEqual(activeValues.x, point22.x);\n    if (show === \"hover\") {\n      return isActive;\n    } else if (show === \"first\") {\n      if (activeValues) {\n        return isActive;\n      } else {\n        return index === 0;\n      }\n    } else if (show === \"last\") {\n      if (activeValues) {\n        return isActive;\n      } else {\n        return index === data.length - 1;\n      }\n    }\n    return show;\n  }, [activeValues, data.length, show]);\n  return /* @__PURE__ */jsx(ScatterSeries, {\n    height,\n    width,\n    id,\n    animated,\n    data,\n    xScale,\n    yScale,\n    point: /* @__PURE__ */jsx(CloneElement, {\n      element: point2,\n      color,\n      className: css$e.point,\n      size: 4,\n      tooltip: null,\n      visible: getIsVisible\n    })\n  });\n};\nPointSeries.defaultProps = {\n  show: \"hover\",\n  point: /* @__PURE__ */jsx(ScatterPoint, {})\n};\nconst Area = ({\n  id,\n  gradient: gradient2,\n  glow,\n  mask,\n  data,\n  color,\n  index,\n  total,\n  xScale,\n  yScale,\n  animated,\n  interpolation,\n  ...rest\n}) => {\n  const stroke = color(data, index);\n  const coords = useMemo(() => {\n    return data.map(item2 => ({\n      x: xScale(item2.x),\n      x1: xScale(item2.x) - xScale(item2.x1),\n      y: yScale(item2.y),\n      y0: yScale(item2.y0),\n      y1: yScale(item2.y1)\n    }));\n  }, [data, xScale, yScale]);\n  const getAreaPath = useCallback(d => {\n    if (d.length === 1 && total === 1) {\n      const [point2] = d;\n      const midpoint = point2.x;\n      d = [{\n        ...point2\n      }, {\n        ...point2\n      }];\n      const [start2, end2] = d;\n      start2.x = 0;\n      end2.x = midpoint * 2;\n    }\n    const fn = area().x(d2 => d2.x).y0(d2 => d2.y0).y1(d2 => d2.y1).curve(interpolate(interpolation));\n    return fn(d);\n  }, [interpolation, total]);\n  const enter = useMemo(() => {\n    const areaPath = getAreaPath(coords);\n    return {\n      d: areaPath === null ? void 0 : areaPath\n    };\n  }, [coords, getAreaPath]);\n  const exit = useMemo(() => {\n    const maxY = Math.max(...yScale.range());\n    const coords2 = data.map(item2 => ({\n      x: xScale(item2.x),\n      x1: 0,\n      y: 0,\n      y1: maxY,\n      y0: maxY\n    }));\n    const areaPath = getAreaPath(coords2);\n    return {\n      d: areaPath === null ? void 0 : areaPath\n    };\n  }, [data, getAreaPath, xScale, yScale]);\n  const fill = useMemo(() => {\n    if (mask) {\n      return `url(#mask-pattern-${id})`;\n    } else {\n      if (gradient2) {\n        return `url(#gradient-${id})`;\n      }\n      return \"\";\n    }\n  }, [gradient2, id, mask]);\n  const transition = useMemo(() => {\n    if (animated) {\n      return {\n        ...DEFAULT_TRANSITION,\n        delay: index * 0.05\n      };\n    } else {\n      return {\n        type: false,\n        delay: 0\n      };\n    }\n  }, [animated, index]);\n  const renderArea = useCallback(() => {\n    const maskPath = mask ? `url(#mask-${id})` : \"\";\n    const extras = constructFunctionProps(rest, data);\n    return /* @__PURE__ */jsx(MotionPath, {\n      ...extras,\n      pointerEvents: \"none\",\n      mask: maskPath,\n      fill,\n      transition,\n      custom: {\n        enter,\n        exit\n      },\n      style: {\n        ...extras.style,\n        ...generateGlowStyles({\n          glow,\n          colorSchemeColor: stroke\n        })\n      }\n    });\n  }, [data, enter, exit, fill, glow, id, mask, rest, stroke, transition]);\n  return /* @__PURE__ */jsxs(Fragment, {\n    children: [renderArea(), mask && /* @__PURE__ */jsxs(Fragment, {\n      children: [/* @__PURE__ */jsx(Mask, {\n        id: `mask-${id}`,\n        fill: `url(#gradient-${id})`\n      }), /* @__PURE__ */jsx(CloneElement, {\n        element: mask,\n        id: `mask-pattern-${id}`,\n        fill: stroke\n      })]\n    }), gradient2 && /* @__PURE__ */jsx(CloneElement, {\n      element: gradient2,\n      id: `gradient-${id}`,\n      color: stroke\n    })]\n  });\n};\nArea.defaultProps = {\n  gradient: /* @__PURE__ */jsx(Gradient, {}),\n  interpolation: \"linear\"\n};\nconst Line = ({\n  id,\n  width,\n  data,\n  color,\n  index,\n  strokeWidth,\n  hasArea,\n  animated,\n  yScale,\n  xScale,\n  showZeroStroke,\n  interpolation,\n  gradient: gradient2,\n  glow,\n  ...rest\n}) => {\n  const [pathLength, setPathLength] = useState(null);\n  const ghostPathRef = useRef(null);\n  useEffect(() => {\n    if (ghostPathRef.current) {\n      setPathLength(ghostPathRef.current.getTotalLength());\n    }\n  }, [data, xScale, yScale, width]);\n  const getLinePath = useCallback(point2 => {\n    const fn = line$1().x(d => d.x).y(d => d.y1).defined(d => showZeroStroke || calculateShowStroke(d, point2)).curve(interpolate(interpolation));\n    return fn(point2);\n  }, [interpolation, showZeroStroke]);\n  const transition = useMemo(() => {\n    if (animated) {\n      return {\n        ...DEFAULT_TRANSITION,\n        delay: hasArea ? 0 : index * 0.05\n      };\n    } else {\n      return {\n        type: false,\n        delay: 0\n      };\n    }\n  }, [animated, hasArea, index]);\n  const coords = useMemo(() => {\n    return data.map(item2 => ({\n      x: xScale(item2.x),\n      x1: xScale(item2.x) - xScale(item2.x1),\n      y: yScale(item2.y),\n      y0: yScale(item2.y0),\n      y1: yScale(item2.y1)\n    }));\n  }, [data, xScale, yScale]);\n  const enter = useMemo(() => {\n    const linePath = getLinePath(coords);\n    let strokeDasharray = \"\";\n    if (!hasArea && pathLength !== null) {\n      strokeDasharray = `${pathLength} ${pathLength}`;\n    }\n    return {\n      d: linePath === null ? void 0 : linePath,\n      strokeDashoffset: 0,\n      strokeDasharray\n    };\n  }, [coords, getLinePath, hasArea, pathLength]);\n  const exit = useMemo(() => {\n    let newCoords = coords;\n    if (hasArea) {\n      const maxY = Math.max(...yScale.range());\n      newCoords = data.map(item2 => ({\n        x: xScale(item2.x),\n        x1: 0,\n        y: maxY,\n        y1: maxY,\n        y0: maxY\n      }));\n    }\n    const linePath = getLinePath(newCoords);\n    let strokeDasharray = \"\";\n    let strokeDashoffset = 0;\n    if (!hasArea && pathLength !== null) {\n      strokeDasharray = `${pathLength} ${pathLength}`;\n      strokeDashoffset = pathLength;\n    }\n    return {\n      d: linePath === null ? void 0 : linePath,\n      strokeDasharray,\n      strokeDashoffset\n    };\n  }, [coords, data, getLinePath, hasArea, pathLength, xScale, yScale]);\n  const stroke = color(data, index);\n  const extras = constructFunctionProps(rest, data);\n  const showLine = hasArea || pathLength !== null;\n  const strokeFill = useMemo(() => {\n    if (gradient2) {\n      return `url(#gradient-${id})`;\n    }\n    return stroke;\n  }, [gradient2, id]);\n  if (hasArea) {\n    delete enter.strokeDashoffset;\n    delete exit.strokeDashoffset;\n  }\n  return /* @__PURE__ */jsxs(Fragment, {\n    children: [showLine && /* @__PURE__ */jsx(MotionPath, {\n      ...extras,\n      pointerEvents: \"none\",\n      stroke: strokeFill,\n      strokeWidth,\n      fill: \"none\",\n      transition,\n      custom: {\n        enter,\n        exit\n      },\n      style: {\n        ...extras.style,\n        ...generateGlowStyles({\n          glow,\n          colorSchemeColor: strokeFill\n        })\n      }\n    }), !hasArea && /* @__PURE__ */jsx(\"path\", {\n      opacity: \"0\",\n      d: enter.d,\n      ref: ghostPathRef,\n      pointerEvents: \"none\"\n    }), gradient2 && /* @__PURE__ */jsx(CloneElement, {\n      element: gradient2,\n      id: `gradient-${id}`,\n      color: stroke\n    })]\n  });\n};\nLine.defaultProps = {\n  showZeroStroke: true,\n  strokeWidth: 3\n};\nconst PADDING = 25;\nconst HALF_PADDING = PADDING / 2;\nconst AreaSeries = ({\n  data,\n  height,\n  id,\n  width,\n  isZoomed,\n  tooltip: tooltip2,\n  xScale,\n  yScale,\n  type,\n  markLine: markLine2,\n  symbols,\n  animated,\n  area: area2,\n  interpolation,\n  line: line2,\n  colorScheme,\n  valueMarkers\n}) => {\n  const [activeValues, setActiveValues] = useState(null);\n  const [activePoint, setActivePoint] = useState(null);\n  const onValueEnter = useCallback(event => {\n    setActivePoint(event.pointX);\n    setActiveValues(event.value);\n  }, []);\n  const onValueLeave = useCallback(() => {\n    setActivePoint(void 0);\n    setActiveValues(void 0);\n  }, []);\n  const isMulti = type === \"grouped\" || type === \"stacked\" || type === \"stackedNormalized\";\n  const getPointColor = useCallback((point2, index) => {\n    var _a;\n    const key = Array.isArray(point2) ? (_a = point2 == null ? void 0 : point2[0]) == null ? void 0 : _a.key : point2 == null ? void 0 : point2.key;\n    return getColor({\n      data,\n      colorScheme,\n      active: activeValues,\n      point: point2,\n      index,\n      key\n    });\n  }, [activeValues, colorScheme, data]);\n  const renderArea = useCallback((data2, index = 0, total = 1) => /* @__PURE__ */jsxs(Fragment, {\n    children: [line2 && /* @__PURE__ */jsx(CloneElement, {\n      element: line2,\n      xScale,\n      yScale,\n      data: data2,\n      width,\n      index,\n      hasArea: area2 !== null,\n      animated,\n      interpolation,\n      color: getPointColor\n    }), area2 && /* @__PURE__ */jsx(CloneElement, {\n      element: area2,\n      id: `${id}-area-${index}`,\n      xScale,\n      yScale,\n      data: data2,\n      index,\n      total,\n      animated,\n      interpolation,\n      color: getPointColor\n    })]\n  }), [animated, area2, getPointColor, id, interpolation, line2, width, xScale, yScale]);\n  const renderSymbols = useCallback((data2, index = 0) => {\n    const visible = symbols !== null;\n    const activeSymbols = symbols && symbols.props.activeValues || activeValues;\n    const isAnimated = area2 !== void 0 && animated && !activeSymbols;\n    return /* @__PURE__ */jsx(Fragment, {\n      children: visible && /* @__PURE__ */jsx(CloneElement, {\n        element: symbols,\n        id,\n        height,\n        width,\n        activeValues: activeSymbols,\n        xScale,\n        yScale,\n        index,\n        data: data2,\n        animated: isAnimated,\n        color: () => getPointColor(data2, index)\n      }, `point-series-${id}`)\n    });\n  }, [activeValues, animated, area2, getPointColor, height, id, symbols, width, xScale, yScale]);\n  const renderMarkLine = useCallback(() => /* @__PURE__ */jsx(Fragment$1, {\n    children: activeValues && markLine2 && /* @__PURE__ */jsx(CloneElement, {\n      element: markLine2,\n      height,\n      pointX: activePoint\n    })\n  }), [activePoint, activeValues, height, markLine2]);\n  const renderSingleSeries = useCallback(data2 => /* @__PURE__ */jsxs(Fragment, {\n    children: [renderArea(data2), renderMarkLine(), renderSymbols(data2)]\n  }), [renderArea, renderMarkLine, renderSymbols]);\n  const renderMultiSeries = useCallback(data2 => /* @__PURE__ */jsxs(Fragment, {\n    children: [data2.map((point2, index) => /* @__PURE__ */jsx(Fragment, {\n      children: renderArea(point2.data, index, data2.length)\n    }, identifier(`${point2.key}`))).reverse(), renderMarkLine(), data2.map((point2, index) => /* @__PURE__ */jsx(Fragment, {\n      children: renderSymbols(point2.data, index)\n    }, identifier(`${point2.key}`))).reverse()]\n  }), [renderArea, renderMarkLine, renderSymbols]);\n  const renderValueMarkers = useCallback(() => /* @__PURE__ */jsx(Fragment$1, {\n    children: (valueMarkers == null ? void 0 : valueMarkers.length) && valueMarkers.map(marker2 => {\n      var _a;\n      const isVertical = ((_a = marker2 == null ? void 0 : marker2.props) == null ? void 0 : _a.direction) === \"vertical\";\n      const size = isVertical ? height : width;\n      const value2 = isVertical ? xScale(marker2.props.value) : yScale(marker2.props.value);\n      return /* @__PURE__ */jsx(CloneElement, {\n        element: marker2,\n        size,\n        value: value2\n      }, marker2.key);\n    })\n  }), [valueMarkers, width, yScale]);\n  return /* @__PURE__ */jsxs(Fragment, {\n    children: [/* @__PURE__ */jsx(\"defs\", {\n      children: /* @__PURE__ */jsx(\"clipPath\", {\n        id: `${id}-path`,\n        children: /* @__PURE__ */jsx(\"rect\", {\n          width: isZoomed ? width : width + PADDING,\n          height: height + PADDING,\n          x: isZoomed ? 0 : -HALF_PADDING,\n          y: -HALF_PADDING\n        })\n      })\n    }), /* @__PURE__ */jsx(CloneElement, {\n      element: tooltip2,\n      xScale,\n      yScale,\n      data,\n      height,\n      width,\n      color: getPointColor,\n      onValueEnter,\n      onValueLeave,\n      children: /* @__PURE__ */jsxs(\"g\", {\n        clipPath: `url(#${id}-path)`,\n        children: [isMulti && renderMultiSeries(data), !isMulti && renderSingleSeries(data), renderValueMarkers()]\n      })\n    })]\n  });\n};\nAreaSeries.defaultProps = {\n  colorScheme: \"cybertron\",\n  animated: true,\n  interpolation: \"linear\",\n  type: \"standard\",\n  line: /* @__PURE__ */jsx(Line, {}),\n  area: /* @__PURE__ */jsx(Area, {}),\n  markLine: /* @__PURE__ */jsx(MarkLine, {}),\n  tooltip: /* @__PURE__ */jsx(TooltipArea, {}),\n  symbols: /* @__PURE__ */jsx(PointSeries, {})\n};\nconst StackedNormalizedAreaSeries = ({\n  type,\n  symbols,\n  ...rest\n}) => /* @__PURE__ */jsx(AreaSeries, {\n  ...rest,\n  type: \"stackedNormalized\",\n  symbols: symbols && /* @__PURE__ */jsx(CloneElement, {\n    element: symbols,\n    ...symbols.props,\n    point: /* @__PURE__ */jsx(CloneElement, {\n      element: symbols.props.point,\n      ...symbols.props.point.props,\n      tooltip: null\n    })\n  })\n});\nStackedNormalizedAreaSeries.defaultProps = {\n  ...AreaSeries.defaultProps,\n  type: \"stackedNormalized\",\n  tooltip: /* @__PURE__ */jsx(TooltipArea, {\n    tooltip: /* @__PURE__ */jsx(ChartTooltip, {\n      content: (series, color) => {\n        if (!series) {\n          return null;\n        }\n        const value2 = {\n          ...series,\n          data: series.data.map(d => ({\n            ...d,\n            value: `${formatValue(d.value)}  ${formatValue(Math.floor((d.y1 - d.y0) * 100))}%`\n          }))\n        };\n        return /* @__PURE__ */jsx(TooltipTemplate, {\n          color,\n          value: value2\n        });\n      }\n    })\n  })\n};\nconst StackedAreaSeries = ({\n  type,\n  symbols,\n  ...rest\n}) => /* @__PURE__ */jsx(AreaSeries, {\n  ...rest,\n  type: \"stacked\",\n  symbols: symbols && /* @__PURE__ */jsx(CloneElement, {\n    element: symbols,\n    ...symbols.props,\n    point: /* @__PURE__ */jsx(CloneElement, {\n      element: symbols.props.point,\n      ...symbols.props.point.props,\n      tooltip: null\n    })\n  })\n});\nStackedAreaSeries.defaultProps = {\n  ...AreaSeries.defaultProps,\n  type: \"stacked\"\n};\nconst areaChart = \"_areaChart_yyojn_1\";\nconst css$d = {\n  areaChart\n};\nconst AreaChart = ({\n  xAxis,\n  yAxis,\n  id,\n  data,\n  width,\n  height,\n  margins,\n  className,\n  containerClassName,\n  series,\n  gridlines,\n  brush,\n  zoomPan,\n  secondaryAxis\n}) => {\n  const zoom = zoomPan ? zoomPan.props : {};\n  const [zoomDomain, setZoomDomain] = useState(zoom.domain);\n  const [preventAnimation, setPreventAnimation] = useState(false);\n  const [isZoomed, setIsZoomed] = useState(!!zoom.domain);\n  const [zoomControlled] = useState(!zoom.hasOwnProperty(\"domain\"));\n  const timeoutRef = useRef(null);\n  const seriesType = series.props.type;\n  const isMultiSeries = seriesType === \"stacked\" || seriesType === \"stackedNormalized\" || seriesType === \"grouped\";\n  const animated = preventAnimation === true ? false : series.props.animated;\n  useEffect(() => {\n    if (zoomPan) {\n      const zoom2 = zoomPan.props;\n      if (!zoomControlled && zoom2.domain !== zoomDomain) {\n        setZoomDomain(zoom2.domain);\n        setIsZoomed(!!zoom2.domain);\n      }\n    }\n  }, [zoomControlled, zoomDomain, zoomPan]);\n  const aggregatedData = useMemo(() => {\n    if (seriesType === \"stacked\" || seriesType === \"stackedNormalized\") {\n      return buildStackData(data, seriesType === \"stackedNormalized\");\n    } else if (seriesType === \"grouped\") {\n      return buildNestedChartData(data, true);\n    } else {\n      return buildShallowChartData(data);\n    }\n  }, [data, seriesType]);\n  const getScales = useCallback((chartWidth, chartHeight) => {\n    const xScale = getXScale({\n      width: chartWidth,\n      type: xAxis.props.type,\n      roundDomains: xAxis.props.roundDomains,\n      data: aggregatedData,\n      domain: zoomDomain || xAxis.props.domain,\n      isMultiSeries\n    });\n    const yScale = getYScale({\n      roundDomains: yAxis.props.roundDomains,\n      type: yAxis.props.type,\n      height: chartHeight,\n      data: aggregatedData,\n      domain: yAxis.props.domain,\n      isMultiSeries\n    });\n    return {\n      xScale,\n      yScale\n    };\n  }, [aggregatedData, isMultiSeries, xAxis.props.domain, xAxis.props.roundDomains, xAxis.props.type, yAxis.props.domain, yAxis.props.roundDomains, yAxis.props.type, zoomDomain]);\n  const onZoomPan = useCallback(event => {\n    if (zoomControlled) {\n      setZoomDomain(event.domain);\n      setIsZoomed(event.isZoomed);\n      setPreventAnimation(true);\n      clearTimeout(timeoutRef.current);\n      timeoutRef.current = setTimeout(() => setPreventAnimation(false));\n    }\n  }, [zoomControlled]);\n  const renderChart = useCallback(({\n    chartHeight,\n    chartWidth,\n    id: id2,\n    updateAxes,\n    chartSized\n  }) => {\n    const {\n      xScale,\n      yScale\n    } = getScales(chartWidth, chartHeight);\n    const disableBrush = aggregatedData.length <= 1;\n    return /* @__PURE__ */jsxs(Fragment, {\n      children: [chartSized && gridlines && /* @__PURE__ */jsx(CloneElement, {\n        element: gridlines,\n        height: chartHeight,\n        width: chartWidth,\n        yScale,\n        xScale,\n        yAxis: yAxis.props,\n        xAxis: xAxis.props\n      }), /* @__PURE__ */jsx(CloneElement, {\n        element: xAxis,\n        height: chartHeight,\n        width: chartWidth,\n        scale: xScale,\n        visibility: chartSized ? \"visible\" : \"hidden\",\n        onDimensionsChange: event => updateAxes(\"horizontal\", event)\n      }), /* @__PURE__ */jsx(CloneElement, {\n        element: yAxis,\n        height: chartHeight,\n        width: chartWidth,\n        scale: yScale,\n        visibility: chartSized ? \"visible\" : \"hidden\",\n        onDimensionsChange: event => updateAxes(\"vertical\", event)\n      }), secondaryAxis && secondaryAxis.map((axis, i) => /* @__PURE__ */jsx(CloneElement, {\n        element: axis,\n        height: chartHeight,\n        width: chartWidth,\n        visibility: chartSized ? \"visible\" : \"hidden\",\n        onDimensionsChange: event => updateAxes(\"horizontal\", event)\n      }, i)), chartSized && /* @__PURE__ */jsx(CloneElement, {\n        disabled: disableBrush,\n        element: brush,\n        height: chartHeight,\n        width: chartWidth,\n        scale: xScale,\n        children: /* @__PURE__ */jsx(CloneElement, {\n          element: zoomPan,\n          onZoomPan,\n          height: chartHeight,\n          width: chartWidth,\n          axisType: xAxis.props.type,\n          roundDomains: xAxis.props.roundDomains,\n          data: aggregatedData,\n          domain: zoomDomain,\n          children: /* @__PURE__ */jsx(CloneElement, {\n            element: series,\n            id: `area-series-${id2}`,\n            data: aggregatedData,\n            height: chartHeight,\n            width: chartWidth,\n            yScale,\n            xScale,\n            isZoomed,\n            animated\n          })\n        })\n      })]\n    });\n  }, [aggregatedData, animated, brush, getScales, gridlines, isZoomed, onZoomPan, secondaryAxis, series, xAxis, yAxis, zoomDomain, zoomPan]);\n  return /* @__PURE__ */jsx(ChartContainer, {\n    id,\n    width,\n    height,\n    margins,\n    containerClassName,\n    xAxisVisible: isAxisVisible(xAxis.props),\n    yAxisVisible: isAxisVisible(yAxis.props),\n    className: classNames(css$d.areaChart, className, series.type),\n    children: renderChart\n  });\n};\nAreaChart.defaultProps = {\n  data: [],\n  xAxis: /* @__PURE__ */jsx(LinearXAxis, {\n    type: \"time\"\n  }),\n  yAxis: /* @__PURE__ */jsx(LinearYAxis, {\n    type: \"value\"\n  }),\n  series: /* @__PURE__ */jsx(AreaSeries, {}),\n  gridlines: /* @__PURE__ */jsx(GridlineSeries, {}),\n  brush: null,\n  zoomPan: null\n};\nconst StackedAreaChart = props => /* @__PURE__ */jsx(AreaChart, {\n  ...props\n});\nStackedAreaChart.defaultProps = {\n  series: /* @__PURE__ */jsx(StackedAreaSeries, {})\n};\nconst StackedNormalizedAreaChart = props => /* @__PURE__ */jsx(AreaChart, {\n  ...props\n});\nStackedNormalizedAreaChart.defaultProps = {\n  series: /* @__PURE__ */jsx(StackedNormalizedAreaSeries, {}),\n  yAxis: /* @__PURE__ */jsx(LinearYAxis, {\n    type: \"value\",\n    tickSeries: /* @__PURE__ */jsx(LinearYAxisTickSeries, {\n      label: /* @__PURE__ */jsx(LinearYAxisTickLabel, {\n        rotation: false,\n        format: data => `${data * 100}%`\n      })\n    })\n  })\n};\nconst Bar = ({\n  activeBrightness,\n  id,\n  gradient: gradient2,\n  data,\n  barIndex,\n  color,\n  yScale,\n  barCount,\n  glow,\n  xScale,\n  groupIndex,\n  minHeight,\n  rangeLines,\n  animated,\n  active,\n  type,\n  tooltip: tooltip2,\n  layout: layout2,\n  mask,\n  label: label2,\n  cursor,\n  rx,\n  ry,\n  isCategorical,\n  className,\n  style,\n  width,\n  padding,\n  guide,\n  xScale1,\n  onMouseEnter,\n  onClick,\n  onMouseMove,\n  onMouseLeave\n}) => {\n  const isVertical = useMemo(() => layout2 === \"vertical\", [layout2]);\n  const rect = useRef(null);\n  const [internalActive, setInternalActive] = useState(active);\n  const calculateLinearScalePadding = useCallback((scale22, offset, size) => {\n    const totalSize = scale22.range()[1];\n    const sizeMinusPadding = totalSize - padding * (barCount - 1);\n    const multiplier = sizeMinusPadding / totalSize;\n    offset = offset * multiplier + groupIndex * padding;\n    size = size * multiplier;\n    return {\n      size,\n      offset\n    };\n  }, [barCount, groupIndex, padding]);\n  const getExit = useCallback(({\n    x,\n    y,\n    width: width2,\n    height\n  }) => {\n    let newX = isVertical ? x : Math.min(...xScale.range());\n    let newY = isVertical ? Math.max(...yScale.range()) : y;\n    const newHeight = isVertical ? 0 : height;\n    const newWidth = isVertical ? width2 : 0;\n    if (type === \"stackedDiverging\") {\n      if (isVertical) {\n        newY = newY / 2;\n      } else {\n        newX = newX / 2;\n      }\n    }\n    return {\n      x: newX,\n      y: newY,\n      height: newHeight,\n      width: newWidth\n    };\n  }, [isVertical, type, xScale, yScale]);\n  const getKeyCoords = useCallback((v, v0, v1, scale22, sizeOverride, isCategorical2, padding2) => {\n    let offset;\n    let size;\n    if (isCategorical2) {\n      if (scale22.bandwidth) {\n        offset = scale22(v);\n        size = scale22.bandwidth();\n        if (sizeOverride) {\n          if (offset) {\n            offset = offset + size / 2 - sizeOverride / 2;\n          } else {\n            offset = size / 2 - sizeOverride / 2;\n          }\n          size = sizeOverride;\n        }\n      } else {\n        if (sizeOverride) {\n          throw new Error(\"Not a valid option for this scale type\");\n        }\n        offset = scale22(v0);\n        size = scale22(v1 - v0);\n        if (padding2) {\n          const calc = calculateLinearScalePadding(scale22, offset, size);\n          offset = calc.offset;\n          size = calc.size;\n        }\n      }\n    } else {\n      if (sizeOverride) {\n        throw new Error(\"Not a valid option for this scale type\");\n      }\n      const c0 = scale22(v0);\n      const c1 = scale22(v1);\n      const delta = c1 - c0;\n      offset = c0;\n      size = Math.max(delta - 1, 0);\n    }\n    return {\n      offset: isNaN(offset) ? 0 : offset,\n      size: isNaN(size) ? 0 : size\n    };\n  }, [calculateLinearScalePadding]);\n  const getValueCoords = useCallback((v0, v1, scale22) => {\n    const c0 = scale22(v0);\n    const c1 = scale22(v1);\n    const size = Math.abs(c0 - c1);\n    const minSize = Math.max(minHeight || 0, size);\n    const offset = Math.min(c0, c1);\n    return {\n      offset: isNaN(offset) ? 0 : offset,\n      size: isNaN(minSize) ? 0 : minSize\n    };\n  }, [minHeight]);\n  const getCoords = useCallback(data2 => {\n    let newYScale = yScale;\n    let newXScale = xScale;\n    if (xScale1) {\n      if (isVertical) {\n        newXScale = xScale1;\n      } else {\n        newYScale = xScale1;\n      }\n    }\n    if (isVertical) {\n      const xCoords = getKeyCoords(data2.x, data2.x0, data2.x1, newXScale, width, isCategorical, padding);\n      const yCoords = getValueCoords(data2.y0, data2.y1, newYScale);\n      return {\n        x: xCoords.offset,\n        width: xCoords.size,\n        y: yCoords.offset,\n        height: yCoords.size\n      };\n    } else {\n      const yCoords = getKeyCoords(data2.y, data2.y0, data2.y1, newYScale, width, isCategorical, padding);\n      const xCoords = getValueCoords(data2.x0, data2.x1, newXScale);\n      return {\n        x: xCoords.offset,\n        width: xCoords.size,\n        y: yCoords.offset,\n        height: yCoords.size\n      };\n    }\n  }, [getKeyCoords, getValueCoords, isCategorical, isVertical, padding, width, xScale, xScale1, yScale]);\n  const onMouseEnterInternal = useCallback(event => {\n    if (tooltip2) {\n      setInternalActive(true);\n    }\n    onMouseEnter == null ? void 0 : onMouseEnter({\n      value: data,\n      nativeEvent: event\n    });\n  }, [data, onMouseEnter, tooltip2]);\n  const onMouseLeaveInternal = useCallback(event => {\n    if (tooltip2) {\n      setInternalActive(false);\n    }\n    onMouseLeave == null ? void 0 : onMouseLeave({\n      value: data,\n      nativeEvent: event\n    });\n  }, [data, onMouseLeave, tooltip2]);\n  const onMouseClick = useCallback(event => {\n    onClick == null ? void 0 : onClick({\n      value: data,\n      nativeEvent: event\n    });\n  }, [data, onClick]);\n  const getFill = useCallback(color2 => {\n    if (mask) {\n      return `url(#mask-pattern-${id})`;\n    } else {\n      if (gradient2) {\n        return `url(#gradient-${id})`;\n      }\n      return color2;\n    }\n  }, [gradient2, id, mask]);\n  const tooltipData = useMemo(() => {\n    const xAttr = isCategorical ? \"x\" : \"x0\";\n    let x = data[xAttr];\n    if (data.x0 < 0) {\n      x = data.x0;\n    }\n    const matches = isVertical ? data.key && data.key !== x : data.key && data.key !== data.y;\n    if (matches) {\n      x = `${data.key}  ${x}`;\n    }\n    return {\n      y: data.y,\n      x\n    };\n  }, [data, isCategorical, isVertical]);\n  const ariaLabelData = useMemo(() => getAriaLabel(tooltipData), [tooltipData]);\n  const getTransition = useCallback(index2 => {\n    if (animated) {\n      let delay = 0;\n      if (layout2 === \"vertical\") {\n        delay = index2 / barCount * 0.5;\n      } else {\n        delay = (barCount - index2) / barCount * 0.5;\n      }\n      return {\n        ...DEFAULT_TRANSITION,\n        delay\n      };\n    } else {\n      return {\n        type: false,\n        delay: 0\n      };\n    }\n  }, [animated, barCount, layout2]);\n  const renderBar = useCallback((currentColorShade2, coords2, index2) => {\n    const maskPath = mask ? `url(#mask-${id})` : \"\";\n    const fill = getFill(currentColorShade2);\n    const initialExit = getExit(coords2);\n    const extras = constructFunctionProps({\n      className,\n      style\n    }, data);\n    const transition = getTransition(index2);\n    const initial = {\n      ...initialExit,\n      attrX: initialExit.x,\n      attrY: initialExit.y,\n      fill\n    };\n    delete initial.x;\n    delete initial.y;\n    const animate2 = {\n      ...coords2,\n      attrX: coords2.x,\n      attrY: coords2.y,\n      fill\n    };\n    delete animate2.x;\n    delete animate2.y;\n    return /* @__PURE__ */jsx(\"g\", {\n      ref: rect,\n      children: /* @__PURE__ */jsx(motion.rect, {\n        className: classNames(extras.className),\n        style: {\n          ...extras.style,\n          ...generateGlowStyles({\n            glow,\n            colorSchemeColor: currentColorShade2\n          }),\n          cursor\n        },\n        mask: maskPath,\n        rx,\n        ry,\n        initial,\n        animate: animate2,\n        exit: initial,\n        transition,\n        onMouseEnter: onMouseEnterInternal,\n        onMouseLeave: onMouseLeaveInternal,\n        onClick: onMouseClick,\n        onMouseMove,\n        tabIndex: 0,\n        \"aria-label\": ariaLabelData,\n        role: \"graphics-document\"\n      })\n    });\n  }, [className, cursor, data, getExit, getFill, getTransition, glow, id, mask, onMouseClick, onMouseEnterInternal, onMouseLeaveInternal, onMouseMove, rx, ry, style, tooltipData]);\n  const renderGuideBar = useCallback(() => {\n    if (!guide) {\n      return null;\n    }\n    if (type === \"stacked\" && barIndex !== 0) {\n      return null;\n    }\n    if (type === \"stackedNormalized\" || type === \"marimekko\") {\n      console.error(\"Guide bars are not supported for these chart types\");\n      return null;\n    }\n    const valueScale = isVertical ? yScale : xScale;\n    const [start2, end2] = valueScale.domain();\n    const attr = isVertical ? \"y\" : \"x\";\n    const attrStart = type === \"stackedDiverging\" ? \"0\" : \"1\";\n    const endPoint = type === \"stackedDiverging\" ? start2 : end2;\n    const startPoint = type === \"stackedDiverging\" && data[attr] > 0 ? end2 : endPoint;\n    const coords2 = getCoords({\n      ...data,\n      [attr]: endPoint,\n      [`${attr}${attrStart}`]: startPoint\n    });\n    return /* @__PURE__ */jsx(CloneElement, {\n      element: guide,\n      ...coords2,\n      active\n    });\n  }, [active, barIndex, data, getCoords, guide, isVertical, type, xScale, yScale]);\n  const isActive = tooltip2 ? internalActive : active;\n  const stroke = color(data, barIndex);\n  const coords = getCoords(data);\n  const currentColorShade = active ? chroma(stroke).brighten(activeBrightness).hex() : stroke;\n  const rangeLineColor = rangeLines && rangeLines.props.color || stroke;\n  const rangeLineColorShade = active ? chroma(rangeLineColor).brighten(activeBrightness) : rangeLineColor;\n  const index = groupIndex !== void 0 ? groupIndex : barIndex;\n  const scale2 = isVertical ? yScale : xScale;\n  const barLabel = isVertical ? tooltipData.y : tooltipData.x;\n  const placement = layout2 === \"vertical\" ? \"top\" : \"right\";\n  return /* @__PURE__ */jsxs(Fragment, {\n    children: [renderGuideBar(), renderBar(currentColorShade, coords, index), rangeLines && /* @__PURE__ */jsx(CloneElement, {\n      element: rangeLines,\n      ...coords,\n      index,\n      data,\n      scale: scale2,\n      color: rangeLineColorShade,\n      barCount,\n      animated,\n      layout: layout2,\n      type\n    }), mask && /* @__PURE__ */jsxs(Fragment, {\n      children: [/* @__PURE__ */jsx(Mask, {\n        id: `mask-${id}`,\n        fill: `url(#gradient-${id})`\n      }), /* @__PURE__ */jsx(CloneElement, {\n        element: mask,\n        id: `mask-pattern-${id}`,\n        fill: stroke\n      })]\n    }), gradient2 && /* @__PURE__ */jsx(CloneElement, {\n      element: gradient2,\n      id: `gradient-${id}`,\n      direction: layout2,\n      color: currentColorShade\n    }), label2 && /* @__PURE__ */jsx(CloneElement, {\n      element: label2,\n      ...coords,\n      text: formatValue(barLabel),\n      index,\n      data,\n      scale: scale2,\n      fill: label2.props.fill || currentColorShade,\n      barCount,\n      animated,\n      layout: layout2,\n      type\n    }), tooltip2 && /* @__PURE__ */jsx(CloneElement, {\n      element: tooltip2,\n      visible: !!isActive,\n      reference: rect,\n      color,\n      value: tooltipData,\n      placement: tooltip2.props.placement || placement,\n      data\n    })]\n  });\n};\nBar.defaultProps = {\n  activeBrightness: 0.5,\n  rx: 0,\n  ry: 0,\n  cursor: \"auto\",\n  rangeLines: null,\n  label: null,\n  tooltip: null,\n  layout: \"vertical\",\n  guide: null,\n  gradient: /* @__PURE__ */jsx(Gradient, {})\n};\nconst BarSeries = ({\n  data,\n  tooltip: tooltip2,\n  xScale,\n  yScale,\n  height,\n  width,\n  colorScheme,\n  xScale1,\n  bar: bar2,\n  padding,\n  animated,\n  isCategorical,\n  layout: layout2,\n  type,\n  id,\n  valueMarkers\n}) => {\n  const ref = useRef(null);\n  const [activeValues, setActiveValues] = useState(null);\n  const isVertical = useMemo(() => layout2 === \"vertical\", [layout2]);\n  const isMultiSeries = useMemo(() => {\n    return type === \"grouped\" || type === \"stacked\" || type === \"marimekko\" || type === \"stackedNormalized\" || type === \"stackedDiverging\";\n  }, [type]);\n  const getTransform = useCallback(data2 => {\n    let xPos = 0;\n    let yPos = 0;\n    if (type !== \"marimekko\") {\n      if (layout2 === \"vertical\") {\n        const val = xScale(data2.key);\n        xPos = val;\n      } else {\n        const val = yScale(data2.key);\n        yPos = val;\n      }\n    }\n    return `translate(${xPos}, ${yPos})`;\n  }, [layout2, type, xScale, yScale]);\n  const getBarColor = useCallback((point2, index) => {\n    let key = \"key\";\n    if (isMultiSeries) {\n      if (layout2 === \"vertical\") {\n        key = \"x\";\n      } else {\n        key = \"y\";\n      }\n    }\n    if (point2[key] === void 0) {\n      key = \"x0\";\n    }\n    return getColor({\n      colorScheme,\n      point: point2,\n      index,\n      data,\n      isMultiSeries,\n      attribute: key\n    });\n  }, [colorScheme, data, isMultiSeries, layout2]);\n  const onMouseMove = useCallback(event => {\n    var _a;\n    (_a = ref.current) == null ? void 0 : _a.triggerMouseMove(event);\n  }, []);\n  const onValueEnter = useCallback(event => {\n    setActiveValues(event.value);\n  }, []);\n  const onValueLeave = useCallback(() => {\n    setActiveValues(null);\n  }, []);\n  const renderBar = useCallback((data2, barIndex, barCount, groupIndex) => {\n    const active = activeValues && activeValues.x === data2.key;\n    let newYScale = yScale;\n    let newXScale = xScale;\n    if (xScale1) {\n      if (isVertical) {\n        newXScale = xScale1;\n      } else {\n        newYScale = xScale1;\n      }\n    }\n    let key = barIndex.toString();\n    if (data2.key) {\n      key = `${data2.key.toString()}-${groupIndex}-${data2.x}`;\n    }\n    let barElements = Array.isArray(bar2) ? bar2[barIndex] : bar2;\n    if (!bar2) {\n      barElements = /* @__PURE__ */jsx(Bar, {});\n    }\n    return /* @__PURE__ */jsx(Fragment, {\n      children: /* @__PURE__ */jsx(CloneElement, {\n        element: barElements,\n        id: `${id}-bar-${groupIndex}-${barIndex}`,\n        animated,\n        active,\n        xScale: newXScale,\n        xScale1,\n        yScale: newYScale,\n        padding,\n        barCount,\n        groupIndex,\n        barIndex,\n        data: data2,\n        isCategorical,\n        color: getBarColor,\n        layout: layout2,\n        type,\n        onMouseMove\n      })\n    }, key);\n  }, [activeValues, animated, bar2, getBarColor, id, isCategorical, isVertical, layout2, onMouseMove, padding, type, xScale, xScale1, yScale]);\n  const renderBarGroup = useCallback((data2, barCount, groupIndex) => {\n    return /* @__PURE__ */jsx(Fragment, {\n      children: data2.map((barData, barIndex) => renderBar(barData, barIndex, barCount, groupIndex))\n    });\n  }, [renderBar]);\n  const renderValueMarkers = useCallback(() => /* @__PURE__ */jsx(Fragment$1, {\n    children: (valueMarkers == null ? void 0 : valueMarkers.length) && valueMarkers.map(marker2 => /* @__PURE__ */jsx(CloneElement, {\n      element: marker2,\n      size: layout2 === \"vertical\" ? width : height,\n      value: layout2 === \"vertical\" ? yScale(marker2.props.value) : xScale(marker2.props.value),\n      isHorizontal: layout2 === \"vertical\"\n    }, marker2.key))\n  }), [height, layout2, valueMarkers, width, xScale, yScale]);\n  return /* @__PURE__ */jsxs(CloneElement, {\n    element: tooltip2,\n    childRef: ref,\n    xScale,\n    yScale,\n    data,\n    height,\n    width,\n    inverse: false,\n    isHorizontal: layout2 === \"horizontal\",\n    color: getBarColor,\n    onValueEnter,\n    onValueLeave,\n    isContinous: false,\n    children: [isMultiSeries && data.map((groupData, index) => /* @__PURE__ */jsx(\"g\", {\n      transform: getTransform(groupData),\n      children: renderBarGroup(groupData.data, data.length, index)\n    }, `bar-group-${index}`)), !isMultiSeries && renderBarGroup(data, data.length), renderValueMarkers()]\n  });\n};\nBarSeries.defaultProps = {\n  type: \"standard\",\n  padding: 0.1,\n  groupPadding: 16,\n  animated: true,\n  tooltip: /* @__PURE__ */jsx(TooltipArea, {\n    tooltip: /* @__PURE__ */jsx(ChartTooltip, {\n      followCursor: true,\n      modifiers: {\n        offset: \"5px, 5px\"\n      }\n    })\n  }),\n  colorScheme: \"cybertron\",\n  bar: /* @__PURE__ */jsx(Bar, {}),\n  layout: \"vertical\"\n};\nconst RangeLines = ({\n  layout: layout2,\n  color,\n  x,\n  y,\n  scale: scale2,\n  type,\n  height,\n  position,\n  strokeWidth,\n  width,\n  animated,\n  index,\n  barCount,\n  data\n}) => {\n  const isVertical = useMemo(() => layout2 === \"vertical\", [layout2]);\n  const rangeLineHeight = useMemo(() => Math.min(strokeWidth, isVertical ? height : width), [height, isVertical, strokeWidth, width]);\n  const [newWidth, newHeight] = useMemo(() => [isVertical ? width : rangeLineHeight, isVertical ? rangeLineHeight : height], [height, isVertical, rangeLineHeight, width]);\n  const enterProps = useMemo(() => {\n    let newY = y;\n    let newX = x;\n    const isTop = position === \"top\";\n    const direction = isVertical ? data.y < 0 && isTop ? \"bottom\" : position : data.x0 < 0 && isTop ? \"bottom\" : position;\n    if (isVertical) {\n      if (direction === \"top\") {\n        newY = y;\n      } else {\n        newY = y + height - rangeLineHeight;\n      }\n    } else {\n      if (direction === \"top\") {\n        newX = x + width - rangeLineHeight;\n      } else {\n        newX = x;\n      }\n    }\n    return {\n      x: newX,\n      y: newY,\n      opacity: 1\n    };\n  }, [data.x0, data.y, height, isVertical, position, rangeLineHeight, width, x, y]);\n  const exitProps = useMemo(() => {\n    let newY = y;\n    let newX = x;\n    if (isVertical) {\n      const maxY = Math.max(...scale2.range());\n      if (position === \"top\") {\n        newY = maxY;\n      } else {\n        newY = maxY + height - rangeLineHeight;\n      }\n    } else {\n      const minX = Math.min(...scale2.range());\n      if (position === \"top\") {\n        newX = minX;\n      } else {\n        newX = minX + width - rangeLineHeight;\n      }\n    }\n    if (type === \"stackedDiverging\") {\n      if (isVertical) {\n        newY = newY / 2;\n      } else {\n        newX = newX / 2;\n      }\n    }\n    return {\n      y: newY,\n      x: newX,\n      opacity: 0\n    };\n  }, [height, isVertical, position, rangeLineHeight, scale2, type, width, x, y]);\n  const delay = useMemo(() => {\n    let delay2 = 0;\n    if (animated) {\n      if (layout2 === \"vertical\") {\n        return index / barCount * 0.5;\n      } else {\n        return (barCount - index) / barCount * 0.5;\n      }\n    }\n    return delay2;\n  }, [animated, barCount, index, layout2]);\n  const initial = useMemo(() => {\n    const r = {\n      ...exitProps,\n      attrX: exitProps.x,\n      attrY: exitProps.y\n    };\n    delete r.x;\n    delete r.y;\n    return r;\n  }, [exitProps]);\n  const animate2 = useMemo(() => {\n    const r = {\n      ...enterProps,\n      attrX: enterProps.x,\n      attrY: enterProps.y\n    };\n    delete r.x;\n    delete r.y;\n    return r;\n  }, [enterProps]);\n  return /* @__PURE__ */jsx(motion.rect, {\n    pointerEvents: \"none\",\n    fill: color,\n    width: newWidth,\n    height: newHeight,\n    initial,\n    animate: animate2,\n    exit: initial,\n    transition: {\n      ...DEFAULT_TRANSITION,\n      delay\n    }\n  });\n};\nRangeLines.defaultProps = {\n  position: \"top\",\n  strokeWidth: 1,\n  layout: \"vertical\"\n};\nconst StackedBarSeries = props => /* @__PURE__ */jsx(BarSeries, {\n  type: \"stackedNormalized\",\n  ...props\n});\nStackedBarSeries.defaultProps = {\n  ...BarSeries.defaultProps,\n  type: \"stacked\",\n  bar: /* @__PURE__ */jsx(Bar, {\n    gradient: /* @__PURE__ */jsx(Gradient, {\n      stops: [/* @__PURE__ */jsx(GradientStop, {\n        offset: \"5%\",\n        stopOpacity: 0.1\n      }, \"start\"), /* @__PURE__ */jsx(GradientStop, {\n        offset: \"90%\",\n        stopOpacity: 0.7\n      }, \"stop\")]\n    }),\n    rangeLines: /* @__PURE__ */jsx(RangeLines, {\n      position: \"top\",\n      strokeWidth: 3\n    })\n  })\n};\nconst StackedNormalizedBarSeries = props => /* @__PURE__ */jsx(BarSeries, {\n  type: \"stackedNormalized\",\n  ...props\n});\nStackedNormalizedBarSeries.defaultProps = {\n  ...BarSeries.defaultProps,\n  type: \"stackedNormalized\",\n  tooltip: /* @__PURE__ */jsx(TooltipArea, {\n    tooltip: /* @__PURE__ */jsx(ChartTooltip, {\n      followCursor: true,\n      modifiers: {\n        offset: \"5px, 5px\"\n      },\n      content: (point2, color) => {\n        point2.data = point2.data.map(d => {\n          const start2 = isNaN(d.y0) ? d.x0 : d.y0;\n          const end2 = isNaN(d.y1) ? d.x1 : d.y1;\n          return {\n            ...d,\n            value: `${formatValue(Math.floor((end2 - start2) * 100))}%`\n          };\n        });\n        return /* @__PURE__ */jsx(TooltipTemplate, {\n          value: point2,\n          color\n        });\n      }\n    })\n  }),\n  bar: /* @__PURE__ */jsx(Bar, {\n    gradient: /* @__PURE__ */jsx(Gradient, {\n      stops: [/* @__PURE__ */jsx(GradientStop, {\n        offset: \"5%\",\n        stopOpacity: 0.1\n      }, \"start\"), /* @__PURE__ */jsx(GradientStop, {\n        offset: \"90%\",\n        stopOpacity: 0.7\n      }, \"stop\")]\n    }),\n    rangeLines: /* @__PURE__ */jsx(RangeLines, {\n      position: \"top\",\n      strokeWidth: 3\n    })\n  })\n};\nconst MarimekkoBarSeries = props => /* @__PURE__ */jsx(BarSeries, {\n  type: \"marimekko\",\n  ...props\n});\nMarimekkoBarSeries.defaultProps = {\n  ...BarSeries.defaultProps,\n  type: \"marimekko\",\n  padding: 10,\n  tooltip: /* @__PURE__ */jsx(TooltipArea, {\n    tooltip: /* @__PURE__ */jsx(ChartTooltip, {\n      followCursor: true,\n      modifiers: {\n        offset: \"5px, 5px\"\n      },\n      content: (point2, color) => {\n        const data = {\n          ...point2,\n          data: point2.data.map(d => ({\n            ...d,\n            value: `${formatValue(d.value)}  ${formatValue(Math.floor((d.y1 - d.y0) * 100))}%`\n          }))\n        };\n        return /* @__PURE__ */jsx(TooltipTemplate, {\n          value: data,\n          color\n        });\n      }\n    })\n  }),\n  bar: /* @__PURE__ */jsx(Bar, {\n    padding: 10,\n    gradient: /* @__PURE__ */jsx(Gradient, {\n      stops: [/* @__PURE__ */jsx(GradientStop, {\n        offset: \"5%\",\n        stopOpacity: 0.1\n      }, \"start\"), /* @__PURE__ */jsx(GradientStop, {\n        offset: \"90%\",\n        stopOpacity: 0.7\n      }, \"stop\")]\n    }),\n    rangeLines: /* @__PURE__ */jsx(RangeLines, {\n      position: \"top\",\n      strokeWidth: 3\n    })\n  })\n};\nconst BarLabel = ({\n  fontSize,\n  fontFamily,\n  fill,\n  layout: layout2,\n  className,\n  text,\n  x,\n  y,\n  height,\n  position,\n  width,\n  data,\n  padding,\n  scale: scale2,\n  type,\n  animated,\n  index,\n  barCount\n}) => {\n  const isVertical = useMemo(() => layout2 === \"vertical\", [layout2]);\n  const textAnchor = isVertical ? \"middle\" : \"start\";\n  const enterProps = useMemo(() => {\n    let newY = y;\n    let newX = x;\n    const isTop = position === \"top\";\n    const direction = isVertical ? data.y < 0 && isTop ? \"bottom\" : position : data.x0 < 0 && isTop ? \"bottom\" : position;\n    if (isVertical) {\n      if (direction === \"top\") {\n        newY = y - padding;\n      } else if (direction === \"center\") {\n        newY = y + height / 2;\n      } else if (direction === \"bottom\") {\n        newY = y + height - padding;\n      }\n      newX = newX + width / 2;\n    } else {\n      if (direction === \"top\") {\n        newX = x + width + padding;\n      } else if (direction === \"center\") {\n        newX = x + width / 2;\n      } else if (direction === \"bottom\") {\n        newX = x + padding;\n      }\n      newY = newY + height / 2;\n    }\n    return {\n      translateX: newX,\n      translateY: newY,\n      opacity: 1\n    };\n  }, [data.x0, data.y, height, isVertical, padding, position, width, x, y]);\n  const exitProps = useMemo(() => {\n    let newY = y;\n    let newX = x;\n    if (isVertical) {\n      const maxY = Math.max(...scale2.range());\n      if (position === \"top\") {\n        newY = maxY;\n      } else {\n        newY = maxY + height + padding;\n      }\n      newX = newX + width / 2;\n    } else {\n      const minX = Math.min(...scale2.range());\n      if (position === \"top\") {\n        newX = minX;\n      } else {\n        newX = minX + width + padding;\n      }\n      newY = newY + height / 2;\n    }\n    if (type === \"stackedDiverging\") {\n      if (isVertical) {\n        newY = newY / 2;\n      } else {\n        newX = newX / 2;\n      }\n    }\n    return {\n      translateY: newY,\n      translateX: newX,\n      opacity: 0\n    };\n  }, [height, isVertical, padding, position, scale2, type, width, x, y]);\n  const delay = useMemo(() => {\n    let delay2 = 0;\n    if (animated) {\n      if (layout2 === \"vertical\") {\n        return index / barCount * 0.5;\n      } else {\n        return (barCount - index) / barCount * 0.5;\n      }\n    }\n    return delay2;\n  }, [animated, barCount, index, layout2]);\n  return /* @__PURE__ */jsx(motion.g, {\n    initial: exitProps,\n    animate: enterProps,\n    exit: exitProps,\n    transition: {\n      ...DEFAULT_TRANSITION,\n      delay\n    },\n    fontSize,\n    fontFamily,\n    children: /* @__PURE__ */jsx(\"text\", {\n      fill,\n      className,\n      textAnchor,\n      children: text\n    })\n  });\n};\nBarLabel.defaultProps = {\n  position: \"top\",\n  layout: \"vertical\",\n  fontSize: 13,\n  padding: 5,\n  fontFamily: \"sans-serif\",\n  fill: \"#000\"\n};\nconst HistogramBarSeries = ({\n  type,\n  ...rest\n}) => /* @__PURE__ */jsx(BarSeries, {\n  ...rest\n});\nHistogramBarSeries.defaultProps = {\n  ...BarSeries.defaultProps,\n  colorScheme: schemes.cybertron[0],\n  tooltip: /* @__PURE__ */jsx(TooltipArea, {\n    tooltip: /* @__PURE__ */jsx(ChartTooltip, {\n      followCursor: true,\n      modifiers: {\n        offset: \"5px, 5px\"\n      },\n      content: (point2, color) => {\n        const data = {\n          ...point2,\n          x: `${formatValue(point2.x0)} - ${formatValue(point2.x1)}`,\n          value: point2.y\n        };\n        return /* @__PURE__ */jsx(TooltipTemplate, {\n          value: data,\n          color\n        });\n      }\n    })\n  })\n};\nconst GuideBar = ({\n  active,\n  opacity = 0.15,\n  ...rest\n}) => {\n  const {\n    x,\n    y,\n    ...other\n  } = rest;\n  return /* @__PURE__ */jsx(motion.rect, {\n    ...other,\n    pointerEvents: \"none\",\n    initial: \"hidden\",\n    animate: active ? \"visible\" : \"hidden\",\n    variants: {\n      hidden: {\n        opacity: 0,\n        attrX: x,\n        attrY: y\n      },\n      visible: {\n        opacity,\n        attrX: x,\n        attrY: y\n      }\n    }\n  });\n};\nGuideBar.defaultProps = {\n  fill: \"#eee\",\n  opacity: 0.15\n};\nconst barChart = \"_barChart_sfjii_1\";\nconst stackedNormalized = \"_stackedNormalized_sfjii_4\";\nconst stacked = \"_stacked_sfjii_4\";\nconst marimekko = \"_marimekko_sfjii_6\";\nconst css$c = {\n  barChart,\n  stackedNormalized,\n  stacked,\n  marimekko\n};\nconst BarChart = ({\n  id,\n  width,\n  height,\n  margins,\n  className,\n  data,\n  xAxis,\n  yAxis,\n  series,\n  brush,\n  gridlines,\n  secondaryAxis,\n  containerClassName\n}) => {\n  const isVertical = useMemo(() => series.props.layout === \"vertical\", [series]);\n  const keyAxis = useMemo(() => isVertical ? xAxis : yAxis, [yAxis, xAxis, isVertical]);\n  const isDiverging = useMemo(() => series.props.type === \"stackedDiverging\", [series.props.type]);\n  const getMarimekkoGroupScales = useCallback((aggregatedData, axis, width2) => {\n    const keyScale = getMarimekkoScale(width2, axis.props.roundDomains);\n    const groupScale = getMarimekkoGroupScale({\n      width: width2,\n      padding: series.props.padding,\n      data: aggregatedData,\n      valueScale: keyScale\n    });\n    return {\n      keyScale,\n      groupScale\n    };\n  }, [series.props.padding]);\n  const getMultiGroupScales = useCallback((aggregatedData, height2, width2) => {\n    const {\n      groupPadding,\n      layout: layout2\n    } = series.props;\n    const groupScale = getGroupScale({\n      dimension: isVertical ? width2 : height2,\n      direction: layout2,\n      padding: groupPadding,\n      data: aggregatedData\n    });\n    const keyScale = getInnerScale({\n      groupScale,\n      padding: series.props.padding,\n      data: aggregatedData,\n      prop: isVertical ? \"x\" : \"y\"\n    });\n    return {\n      groupScale,\n      keyScale\n    };\n  }, [isVertical, series.props]);\n  const getKeyScale = useCallback((aggregatedData, axis, isMultiSeries, width2) => {\n    return getXScale({\n      width: width2,\n      type: axis.props.type,\n      roundDomains: axis.props.roundDomains,\n      data: aggregatedData,\n      padding: series.props.padding,\n      domain: axis.props.domain,\n      isMultiSeries,\n      isDiverging\n    });\n  }, [isDiverging, series]);\n  const getValueScale2 = useCallback((aggregatedData, axis, isMultiSeries, height2) => {\n    return getYScale({\n      roundDomains: axis.props.roundDomains,\n      padding: series.props.padding,\n      type: axis.props.type,\n      height: height2,\n      data: aggregatedData,\n      domain: axis.props.domain,\n      isMultiSeries,\n      isDiverging\n    });\n  }, [isDiverging, series]);\n  const getScalesAndData = useCallback((chartHeight, chartWidth) => {\n    const {\n      type,\n      layout: layout2\n    } = series.props;\n    const isMarimekko = type === \"marimekko\";\n    const isGrouped = type === \"grouped\";\n    const isStacked = type === \"stacked\" || type === \"stackedNormalized\" || type === \"stackedDiverging\";\n    const isMultiSeries = isGrouped || isStacked;\n    let aggregatedData;\n    if (isStacked) {\n      let distroType = \"default\";\n      if (type === \"stackedNormalized\") {\n        distroType = \"expand\";\n      } else if (type === \"stackedDiverging\") {\n        distroType = \"diverging\";\n      }\n      aggregatedData = buildBarStackData(data, distroType, layout2);\n    } else if (type === \"waterfall\") {\n      aggregatedData = buildWaterfall(data, layout2, series.props.binSize);\n    } else if (isMarimekko) {\n      aggregatedData = buildMarimekkoData(data);\n    } else if (isGrouped) {\n      aggregatedData = buildNestedChartData(data, false, layout2);\n    } else {\n      aggregatedData = buildShallowChartData(data, layout2, series.props.binSize);\n    }\n    let yScale;\n    let xScale;\n    let xScale1;\n    if (isVertical) {\n      if (isGrouped) {\n        const {\n          keyScale,\n          groupScale\n        } = getMultiGroupScales(aggregatedData, chartHeight, chartWidth);\n        xScale = groupScale;\n        xScale1 = keyScale;\n      } else if (isMarimekko) {\n        const {\n          keyScale,\n          groupScale\n        } = getMarimekkoGroupScales(aggregatedData, xAxis, chartWidth);\n        xScale = groupScale;\n        xScale1 = keyScale;\n      } else {\n        xScale = getKeyScale(aggregatedData, xAxis, isMultiSeries, chartWidth);\n      }\n      yScale = getValueScale2(aggregatedData, yAxis, isMultiSeries, chartHeight);\n    } else {\n      if (isGrouped) {\n        const {\n          keyScale,\n          groupScale\n        } = getMultiGroupScales(aggregatedData, chartHeight, chartWidth);\n        yScale = groupScale;\n        xScale1 = keyScale;\n        xScale = getKeyScale(aggregatedData, xAxis, isMultiSeries, chartWidth);\n      } else if (isMarimekko) {\n        throw new Error(\"Marimekko is currently not supported for horizontal layouts\");\n      } else {\n        xScale = getKeyScale(aggregatedData, xAxis, isMultiSeries, chartWidth);\n        yScale = getValueScale2(aggregatedData, yAxis, isMultiSeries, chartHeight);\n      }\n    }\n    return {\n      xScale,\n      xScale1,\n      yScale,\n      aggregatedData\n    };\n  }, [getKeyScale, data, getMarimekkoGroupScales, getMultiGroupScales, getValueScale2, isVertical, series.props, xAxis, yAxis]);\n  const renderChart = useCallback(containerProps => {\n    const {\n      chartHeight,\n      chartWidth,\n      id: id2,\n      updateAxes,\n      chartSized\n    } = containerProps;\n    const {\n      xScale,\n      xScale1,\n      yScale,\n      aggregatedData\n    } = getScalesAndData(chartHeight, chartWidth);\n    const isCategorical = keyAxis.props.type === \"category\";\n    const disableBrush = aggregatedData.length <= 1;\n    return /* @__PURE__ */jsxs(Fragment, {\n      children: [chartSized && gridlines && /* @__PURE__ */jsx(CloneElement, {\n        element: gridlines,\n        height: chartHeight,\n        width: chartWidth,\n        yScale,\n        xScale,\n        yAxis: yAxis.props,\n        xAxis: xAxis.props\n      }), /* @__PURE__ */jsx(CloneElement, {\n        element: xAxis,\n        height: chartHeight,\n        width: chartWidth,\n        scale: xScale,\n        visibility: chartSized ? \"visible\" : \"hidden\",\n        onDimensionsChange: event => updateAxes(isVertical ? \"horizontal\" : \"vertical\", event)\n      }), /* @__PURE__ */jsx(CloneElement, {\n        element: yAxis,\n        height: chartHeight,\n        width: chartWidth,\n        scale: yScale,\n        visibility: chartSized ? \"visible\" : \"hidden\",\n        onDimensionsChange: event => updateAxes(isVertical ? \"vertical\" : \"horizontal\", event)\n      }), secondaryAxis && secondaryAxis.map((axis, i) => /* @__PURE__ */jsx(CloneElement, {\n        element: axis,\n        height: chartHeight,\n        width: chartWidth,\n        visibility: chartSized ? \"visible\" : \"hidden\",\n        onDimensionsChange: event => updateAxes(\"horizontal\", event)\n      }, i)), chartSized && /* @__PURE__ */jsx(CloneElement, {\n        disabled: disableBrush,\n        element: brush,\n        height: chartHeight,\n        width: chartWidth,\n        scale: xScale,\n        children: /* @__PURE__ */jsx(CloneElement, {\n          element: series,\n          id: `bar-series-${id2}`,\n          data: aggregatedData,\n          height: chartHeight,\n          width: chartWidth,\n          isCategorical,\n          xScale,\n          xScale1,\n          yScale\n        })\n      })]\n    });\n  }, [brush, getScalesAndData, gridlines, isVertical, keyAxis, secondaryAxis, series, xAxis, yAxis]);\n  return /* @__PURE__ */jsx(ChartContainer, {\n    id,\n    width,\n    height,\n    margins,\n    containerClassName,\n    xAxisVisible: isAxisVisible(xAxis.props),\n    yAxisVisible: isAxisVisible(yAxis.props),\n    className: classNames(css$c.barChart, className, css$c[series.props.type]),\n    children: renderChart\n  });\n};\nBarChart.defaultProps = {\n  data: [],\n  xAxis: /* @__PURE__ */jsx(LinearXAxis, {\n    type: \"category\",\n    tickSeries: /* @__PURE__ */jsx(LinearXAxisTickSeries, {\n      tickSize: 20\n    })\n  }),\n  yAxis: /* @__PURE__ */jsx(LinearYAxis, {\n    type: \"value\"\n  }),\n  series: /* @__PURE__ */jsx(BarSeries, {}),\n  gridlines: /* @__PURE__ */jsx(GridlineSeries, {}),\n  brush: null\n};\nconst MarimekkoChart = props => /* @__PURE__ */jsx(BarChart, {\n  ...props\n});\nMarimekkoChart.defaultProps = {\n  series: /* @__PURE__ */jsx(MarimekkoBarSeries, {}),\n  xAxis: /* @__PURE__ */jsx(LinearXAxis, {\n    type: \"category\",\n    tickSeries: /* @__PURE__ */jsx(LinearXAxisTickSeries, {\n      tickSize: 15\n    })\n  }),\n  yAxis: /* @__PURE__ */jsx(LinearYAxis, {\n    type: \"value\",\n    tickSeries: /* @__PURE__ */jsx(LinearYAxisTickSeries, {\n      label: /* @__PURE__ */jsx(LinearYAxisTickLabel, {\n        rotation: false,\n        format: data => `${data * 100}%`\n      })\n    })\n  })\n};\nconst StackedBarChart = props => /* @__PURE__ */jsx(BarChart, {\n  ...props\n});\nStackedBarChart.defaultProps = {\n  series: /* @__PURE__ */jsx(StackedBarSeries, {})\n};\nconst StackedNormalizedBarChart = props => /* @__PURE__ */jsx(BarChart, {\n  ...props\n});\nStackedNormalizedBarChart.defaultProps = {\n  series: /* @__PURE__ */jsx(StackedNormalizedBarSeries, {}),\n  yAxis: /* @__PURE__ */jsx(LinearYAxis, {\n    type: \"value\",\n    tickSeries: /* @__PURE__ */jsx(LinearYAxisTickSeries, {\n      label: /* @__PURE__ */jsx(LinearYAxisTickLabel, {\n        rotation: false,\n        format: data => `${data * 100}%`\n      })\n    })\n  })\n};\nconst HistogramBarChart = props => /* @__PURE__ */jsx(BarChart, {\n  ...props\n});\nHistogramBarChart.defaultProps = {\n  series: /* @__PURE__ */jsx(HistogramBarSeries, {})\n};\nconst LineSeries = props => /* @__PURE__ */jsx(AreaSeries, {\n  ...props\n});\nLineSeries.defaultProps = {\n  ...AreaSeries.defaultProps,\n  area: null,\n  line: /* @__PURE__ */jsx(Line, {\n    strokeWidth: 3\n  })\n};\nconst LineChart = props => /* @__PURE__ */jsx(AreaChart, {\n  ...props\n});\nLineChart.defaultProps = {\n  ...AreaChart.defaultProps,\n  series: /* @__PURE__ */jsx(LineSeries, {})\n};\nconst Map$1 = ({\n  id,\n  width,\n  height,\n  margins,\n  className,\n  containerClassName,\n  markers,\n  data,\n  fill,\n  projection = \"mercator\"\n}) => {\n  const getProjection = useCallback(({\n    chartWidth,\n    chartHeight\n  }) => {\n    if (projection === \"natural-earth\") {\n      return geoNaturalEarth1().fitSize([chartWidth, chartHeight], data).center([0, 0]);\n    }\n    return geoMercator().fitSize([chartWidth, chartHeight], data).center([0, 35]);\n  }, [data, projection]);\n  const renderMarker = useCallback((marker2, index, projection2) => {\n    const position = projection2(marker2.props.coordinates);\n    if (!position) {\n      console.warn(`Position for ${marker2.props.coordinates.toString()} not found.`);\n      return null;\n    }\n    return /* @__PURE__ */jsx(CloneElement, {\n      element: marker2,\n      cx: position[0],\n      cy: position[1],\n      index\n    });\n  }, []);\n  const renderCountry = useCallback((point2, index, path2) => {\n    if (point2.id === \"010\") {\n      return null;\n    }\n    return /* @__PURE__ */jsx(\"path\", {\n      d: path2(point2),\n      fill\n    }, `path-${index}`);\n  }, [fill]);\n  const renderChart = useCallback(containerProps => {\n    if (!data) {\n      return null;\n    }\n    const geoProjection = getProjection(containerProps);\n    const path2 = geoPath().projection(geoProjection);\n    return /* @__PURE__ */jsxs(motion.g, {\n      initial: {\n        opacity: 0\n      },\n      animate: {\n        opacity: 1\n      },\n      children: [data.features.map((point2, index) => renderCountry(point2, index, path2)), markers && markers.map((marker2, index) => /* @__PURE__ */jsx(Fragment, {\n        children: renderMarker(marker2, index, geoProjection)\n      }, `marker-${index}`))]\n    });\n  }, [data, getProjection, markers, renderCountry, renderMarker]);\n  return /* @__PURE__ */jsx(ChartContainer, {\n    id,\n    width,\n    height,\n    margins,\n    containerClassName,\n    xAxisVisible: false,\n    yAxisVisible: false,\n    className,\n    children: props => renderChart(props)\n  });\n};\nMap$1.defaultProps = {\n  fill: \"rgba(255, 255, 255, 0.3)\"\n};\nconst marker = \"_marker_agib4_1\";\nconst css$b = {\n  marker\n};\nconst modifiers$1 = {\n  offset: {\n    offset: \"0, 3px\"\n  }\n};\nconst MapMarker = ({\n  size = 3,\n  index,\n  tooltip: tooltip2,\n  cx,\n  cy,\n  onClick = () => void 0\n}) => {\n  const ref = useRef(null);\n  const [active, setActive] = useState(false);\n  const ariaLabelData = useMemo(() => typeof tooltip2 === \"string\" ? tooltip2 : \"map marker\", [tooltip2]);\n  return /* @__PURE__ */jsxs(Fragment, {\n    children: [/* @__PURE__ */jsx(motion.circle, {\n      initial: {\n        opacity: 0,\n        scale: 0.02\n      },\n      animate: {\n        opacity: 1,\n        scale: 1\n      },\n      transition: {\n        delay: index * 0.3\n      },\n      ref,\n      className: css$b.marker,\n      cx,\n      cy,\n      r: size,\n      onMouseEnter: () => setActive(true),\n      onMouseLeave: () => setActive(false),\n      onClick,\n      tabIndex: 0,\n      \"aria-label\": ariaLabelData,\n      role: \"graphics-document\"\n    }), tooltip2 && /* @__PURE__ */jsx(Tooltip, {\n      theme: tooltipTheme,\n      visible: active,\n      reference: ref,\n      modifiers: modifiers$1,\n      content: tooltip2\n    })]\n  });\n};\nconst useInterpolate$1 = ({\n  data,\n  animated,\n  arc: arc2\n}) => {\n  const exit = useMemo(() => {\n    const startAngle = data.startAngle;\n    const endAngle = animated ? startAngle : data.endAngle;\n    return {\n      ...data,\n      startAngle,\n      endAngle\n    };\n  }, [data, animated]);\n  const prevData = useRef(exit);\n  const d = useMotionValue(exit);\n  const spring = useSpring(0, DEFAULT_TRANSITION);\n  useEffect(() => {\n    const interpolator = interpolate$1(prevData.current, data);\n    const prevSpring = spring.get();\n    spring.set(prevSpring + 1);\n    return spring.on(\"change\", v => {\n      const newData = interpolator(v - prevSpring);\n      prevData.current = newData;\n      d.set(arc2(newData));\n    });\n  }, [arc2, d, data, exit, spring]);\n  return d;\n};\nconst useHoverIntent = ({\n  sensitivity = 7,\n  interval = 50,\n  timeout = 10,\n  disabled,\n  onPointerOver,\n  onPointerOut\n}) => {\n  const mouseOver = useRef(false);\n  const timer = useRef(null);\n  const state = useRef(0);\n  const coords = useRef({\n    x: null,\n    y: null,\n    px: null,\n    py: null\n  });\n  const onMouseMove = useCallback(event => {\n    coords.current.x = event.clientX;\n    coords.current.y = event.clientY;\n  }, []);\n  const comparePosition = useCallback(event => {\n    timer.current = clearTimeout(timer.current);\n    const {\n      px,\n      x,\n      py,\n      y\n    } = coords.current;\n    if (Math.abs(px - x) + Math.abs(py - y) < sensitivity) {\n      state.current = 1;\n      onPointerOver(event);\n    } else {\n      coords.current.px = x;\n      coords.current.py = y;\n      timer.current = setTimeout(() => comparePosition(event), interval);\n    }\n  }, [interval, onPointerOver, sensitivity]);\n  const cleanup = useCallback(() => {\n    clearTimeout(timer.current);\n    document.removeEventListener(\"mousemove\", onMouseMove, false);\n  }, [onMouseMove]);\n  const pointerOver = useCallback(event => {\n    if (!disabled) {\n      mouseOver.current = true;\n      cleanup();\n      if (state.current !== 1) {\n        coords.current.px = event.nativeEvent.x;\n        coords.current.py = event.nativeEvent.y;\n        document.addEventListener(\"mousemove\", onMouseMove, false);\n        timer.current = setTimeout(() => comparePosition(event), timeout);\n      }\n    }\n  }, [cleanup, comparePosition, disabled, onMouseMove, timeout]);\n  const delay = useCallback(event => {\n    timer.current = clearTimeout(timer.current);\n    state.current = 0;\n    onPointerOut(event);\n  }, [onPointerOut]);\n  const pointerOut = useCallback(event => {\n    mouseOver.current = false;\n    cleanup();\n    if (state.current === 1) {\n      timer.current = setTimeout(() => delay(event), timeout);\n    }\n  }, [cleanup, delay, timeout]);\n  return {\n    pointerOver,\n    pointerOut\n  };\n};\nconst PieArc = ({\n  id,\n  color,\n  data,\n  arc: arc2,\n  cursor,\n  animated,\n  gradient: gradient2,\n  disabled,\n  onClick,\n  onMouseEnter,\n  onMouseLeave,\n  tooltip: tooltip2\n}) => {\n  var _a;\n  const arcRef = useRef(null);\n  const d = useInterpolate$1({\n    animated,\n    arc: arc2,\n    data\n  });\n  const [active, setActive] = useState(false);\n  const fill = useMemo(() => active ? chroma(color).brighten(0.5) : color, [color, active]);\n  const {\n    pointerOut,\n    pointerOver\n  } = useHoverIntent({\n    onPointerOver: event => {\n      if (!disabled) {\n        setActive(true);\n        onMouseEnter == null ? void 0 : onMouseEnter({\n          value: data.data,\n          nativeEvent: event\n        });\n      }\n    },\n    onPointerOut: event => {\n      if (!disabled) {\n        setActive(false);\n        onMouseLeave == null ? void 0 : onMouseLeave({\n          value: data.data,\n          nativeEvent: event\n        });\n      }\n    }\n  });\n  const internalFill = useMemo(() => {\n    if (gradient2) {\n      return `url(#gradient-${id})`;\n    }\n    return color;\n  }, [gradient2, id, color]);\n  const tooltipData = useMemo(() => ({\n    y: data.data.data,\n    x: data.data.key\n  }), [data]);\n  const ariaLabelData = useMemo(() => getAriaLabel(tooltipData), [tooltipData]);\n  return /* @__PURE__ */jsxs(\"g\", {\n    ref: arcRef,\n    tabIndex: 0,\n    \"aria-label\": ariaLabelData,\n    role: \"graphics-document\",\n    children: [/* @__PURE__ */jsx(motion.path, {\n      role: \"graphics-symbol\",\n      d,\n      style: {\n        cursor\n      },\n      fill: internalFill,\n      onPointerOver: pointerOver,\n      onPointerOut: pointerOut,\n      onClick: event => {\n        if (!disabled) {\n          onClick == null ? void 0 : onClick({\n            value: data.data,\n            nativeEvent: event\n          });\n        }\n      }\n    }), gradient2 && /* @__PURE__ */jsx(CloneElement, {\n      element: gradient2,\n      id: `gradient-${id}`,\n      direction: \"horizontal\",\n      color: fill\n    }), !((_a = tooltip2 == null ? void 0 : tooltip2.props) == null ? void 0 : _a.disabled) && /* @__PURE__ */jsx(CloneElement, {\n      element: tooltip2,\n      visible: !!active,\n      reference: arcRef,\n      value: tooltipData\n    })]\n  });\n};\nPieArc.defaultProps = {\n  cursor: \"initial\",\n  animated: true,\n  disabled: false,\n  tooltip: /* @__PURE__ */jsx(ChartTooltip, {})\n};\nfunction findBreakPoint([startX, startY], [endX, endY]) {\n  let breakPoint = [0, 0];\n  const breakPointCondition = (endY - startY) * Math.sign(startY) >= 0;\n  if (breakPointCondition) {\n    let scale2 = Math.abs(endY / startY) || 1;\n    const minScale = 1;\n    const maxScale = Math.abs(endX / startX) || 1;\n    scale2 = Math.max(Math.min(maxScale, scale2), minScale);\n    breakPoint = [startX * scale2, endY];\n  } else {\n    let scale2 = 0.85;\n    const minScale = Math.abs(startX / endX) || 1;\n    const maxScale = 1;\n    scale2 = Math.max(Math.min(maxScale, scale2), minScale);\n    breakPoint = [endX * scale2, startY];\n  }\n  return breakPoint;\n}\nconst getTextAnchor = ({\n  startAngle,\n  endAngle\n}) =>\n// we could also use the sign of position[0]\nstartAngle + (endAngle - startAngle) / 2 < Math.PI ? \"start\" : \"end\";\nconst PieArcLabel = ({\n  centroid,\n  data,\n  lineStroke,\n  padding,\n  fontSize,\n  fontFill,\n  format,\n  fontFamily,\n  position,\n  outerRadius,\n  width,\n  height\n}) => {\n  const textAnchor = getTextAnchor(data);\n  const text = format ? format({\n    ...data.data,\n    textAnchor\n  }) : formatValue(data.data.key);\n  const [posX, posY] = position;\n  const minRadius = outerRadius + 4;\n  const startPoint = centroid(data);\n  const innerPoint = arc().innerRadius(minRadius).outerRadius(minRadius).centroid(data);\n  const breakPoint = findBreakPoint(innerPoint, position);\n  return /* @__PURE__ */jsxs(motion.g, {\n    initial: {\n      opacity: 0\n    },\n    animate: {\n      opacity: 1\n    },\n    exit: {\n      opacity: 0\n    },\n    transition: {\n      duration: 0.1\n    },\n    children: [typeof text === \"string\" ? /* @__PURE__ */jsxs(Fragment$1, {\n      children: [/* @__PURE__ */jsx(\"title\", {\n        children: text\n      }), /* @__PURE__ */jsx(\"text\", {\n        dy: padding,\n        fill: fontFill,\n        fontSize,\n        fontFamily,\n        textAnchor,\n        style: {\n          shapeRendering: \"crispEdges\",\n          transform: `translate3d(${posX}px,${posY}px, 0)`\n        },\n        children: text\n      })]\n    }) : /* @__PURE__ */jsx(\"foreignObject\", {\n      width,\n      height,\n      style: {\n        transform: `translate3d(${textAnchor === \"start\" ? posX : posX - width}px,${posY - height / 2}px, 0)`,\n        color: fontFill,\n        fontFamily,\n        fontSize\n      },\n      children: text\n    }), /* @__PURE__ */jsx(\"polyline\", {\n      fill: \"none\",\n      stroke: lineStroke,\n      points: `${startPoint},${innerPoint},${breakPoint},${position}`\n    })]\n  });\n};\nPieArcLabel.defaultProps = {\n  format: void 0,\n  lineStroke: \"rgba(127,127,127,0.5)\",\n  fontFill: \"#8F979F\",\n  fontSize: 11,\n  fontFamily: \"sans-serif\",\n  padding: \".35em\",\n  height: 11\n};\nconst factor = 1.2;\nconst midAngle = d => d.startAngle + (d.endAngle - d.startAngle) / 2;\nconst labelVisible = arc2 => arc2.endAngle - arc2.startAngle > Math.PI / 30;\nfunction shouldDisplayLabel(displayAllLabels, arcData) {\n  return displayAllLabels || labelVisible(arcData);\n}\nfunction calculateOuterRadius(outerRadius, data, point2, explode) {\n  if (!explode || data === void 0) {\n    return outerRadius;\n  }\n  const maxVal = max(data, d => d.value);\n  return outerRadius * point2.value / maxVal;\n}\nfunction calculateCentroid(data, innerRadius, outerRadius, explode) {\n  return point2 => {\n    const newOuter = calculateOuterRadius(outerRadius, data, point2, explode);\n    return arc().innerRadius(innerRadius).outerRadius(newOuter).centroid(point2);\n  };\n}\nfunction calculateRadius(height, width, label2, arcWidth, doughnut) {\n  const minDimension = Math.min(width, height);\n  let outerRadius = minDimension / 2;\n  let labelWidth = 0;\n  if (label2) {\n    labelWidth = label2.props.width;\n    if (labelWidth) {\n      const outerArcRadius = width / 2 - labelWidth;\n      outerRadius = Math.min(outerArcRadius / factor, height / 2);\n    } else {\n      outerRadius = minDimension / 3;\n      labelWidth = width / 2 - outerRadius * factor;\n    }\n  }\n  const innerRadius = doughnut ? outerRadius * (1 - arcWidth) : 0;\n  return {\n    outerRadius,\n    innerRadius,\n    labelWidth\n  };\n}\nfunction calculateInnerArc(data, innerRadius, outerRadius, cornerRadius, padAngle, padRadius, explode) {\n  return point2 => {\n    const newOuter = calculateOuterRadius(outerRadius, data, point2, explode);\n    return arc().innerRadius(innerRadius).outerRadius(newOuter).cornerRadius(cornerRadius).padRadius(padRadius).padAngle(padAngle)(point2);\n  };\n}\nfunction calculateLabelPositions(data, outerRadius, minDistance, cornerRadius, padAngle, padRadius, displayAllLabels) {\n  const outerArcRadius = outerRadius * factor;\n  const outerArc = arc().innerRadius(outerArcRadius).outerRadius(outerArcRadius).cornerRadius(cornerRadius).padAngle(padAngle).padRadius(padRadius);\n  const positions = data.map(d => {\n    if (!shouldDisplayLabel(displayAllLabels, d)) {\n      return null;\n    }\n    const pos = outerArc.centroid(d);\n    pos[0] = outerArcRadius * (midAngle(d) < Math.PI ? 1 : -1);\n    return pos;\n  });\n  for (let i = 0; i < data.length - 1; i++) {\n    if (!positions[i]) {\n      continue;\n    }\n    const [aPosX, aPosY] = positions[i];\n    for (let j = i + 1; j < data.length; j++) {\n      if (!positions[j]) {\n        continue;\n      }\n      const [bPosX, bPosY] = positions[j];\n      if (bPosX * aPosX > 0) {\n        const overlap = minDistance - Math.abs(bPosY - aPosY);\n        if (overlap > 0) {\n          positions[j][1] += Math.sign(bPosX) * overlap;\n        }\n      }\n    }\n  }\n  return positions;\n}\nconst PieArcSeries = ({\n  doughnut,\n  arcWidth,\n  label: label2,\n  colorScheme,\n  width,\n  displayAllLabels,\n  height,\n  explode,\n  id,\n  animated,\n  cornerRadius,\n  padAngle,\n  padRadius,\n  arc: arc2,\n  data\n}) => {\n  const {\n    outerRadius,\n    innerRadius,\n    labelWidth\n  } = calculateRadius(height, width, label2, arcWidth, doughnut);\n  const innerArc = calculateInnerArc(data, innerRadius, outerRadius, cornerRadius, padAngle, padRadius, explode);\n  const positions = label2 ? calculateLabelPositions(data, outerRadius,\n  // 4 is for vertical margins between labels\n  label2.props.height + 4, cornerRadius, padAngle, padRadius, displayAllLabels) : [];\n  const centroid = calculateCentroid(data, innerRadius, outerRadius, explode);\n  function renderItem(arcData, index) {\n    const safeKey = identifier(arcData.data.key.toString());\n    const color = getColor({\n      data,\n      colorScheme,\n      point: arcData.data,\n      index\n    });\n    return /* @__PURE__ */jsxs(Fragment, {\n      children: [positions[index] && /* @__PURE__ */jsx(CloneElement, {\n        id,\n        element: label2,\n        data: arcData,\n        centroid,\n        outerRadius,\n        width: labelWidth,\n        position: positions[index]\n      }), /* @__PURE__ */jsx(CloneElement, {\n        element: arc2,\n        id: `${id}-arc-${safeKey}`,\n        data: arcData,\n        animated,\n        arc: innerArc,\n        color\n      })]\n    }, safeKey);\n  }\n  return /* @__PURE__ */jsx(Fragment$1, {\n    children: data.map(renderItem)\n  });\n};\nPieArcSeries.defaultProps = {\n  animated: true,\n  colorScheme: \"cybertron\",\n  innerRadius: 0,\n  cornerRadius: 0,\n  padAngle: 0,\n  padRadius: 0,\n  explode: false,\n  displayAllLabels: false,\n  arcWidth: 0.25,\n  label: /* @__PURE__ */jsx(PieArcLabel, {}),\n  arc: /* @__PURE__ */jsx(PieArc, {})\n};\nconst PieChart = ({\n  id,\n  width,\n  height,\n  className,\n  containerClassName,\n  displayAllLabels,\n  data = [],\n  margins,\n  series\n}) => {\n  const newId = useId(id);\n  const internalData = useMemo(() => {\n    const pieLayout = pie().value(d => Number(d.data));\n    if (!series.props.explode) {\n      pieLayout.sort(null);\n    }\n    return pieLayout(data);\n  }, [data, series]);\n  const renderSeries = useCallback(({\n    chartWidth,\n    chartHeight\n  }) => {\n    return /* @__PURE__ */jsx(CloneElement, {\n      element: series,\n      id: newId,\n      data: internalData,\n      height: chartHeight,\n      width: chartWidth,\n      displayAllLabels\n    });\n  }, [displayAllLabels, internalData, newId, series]);\n  return /* @__PURE__ */jsx(ChartContainer, {\n    id,\n    width,\n    height,\n    margins,\n    containerClassName,\n    xAxisVisible: false,\n    yAxisVisible: false,\n    center: true,\n    className: classNames(className),\n    children: renderSeries\n  });\n};\nPieChart.defaultProps = {\n  margins: 10,\n  series: /* @__PURE__ */jsx(PieArcSeries, {})\n};\nconst DEFAULT_COLOR = \"rgba(255, 255, 255, 0.2)\";\nconst LABEL_PADDING_PERCENT = 0.1;\nconst JUSTIFICATION = {\n  justify: sankeyJustify,\n  center: sankeyCenter,\n  left: sankeyLeft,\n  right: sankeyRight\n};\nconst Sankey = ({\n  width,\n  height,\n  margins,\n  className,\n  animated,\n  links,\n  justification,\n  nodeWidth,\n  nodePadding,\n  labelPosition,\n  nodeSort,\n  colorScheme,\n  nodes,\n  containerClassName,\n  ...rest\n}) => {\n  const id = useId(rest.id);\n  const [activeNodes, setActiveNodes] = useState([]);\n  const [activeLinks, setActiveLinks] = useState([]);\n  const getNodeColor = useCallback((node2, index) => {\n    if (colorScheme) {\n      return getColor({\n        data: nodes,\n        colorScheme,\n        point: nodes[index],\n        index\n      });\n    } else {\n      return node2.props.color;\n    }\n  }, [colorScheme, nodes]);\n  const onNodeActive = useCallback(node2 => {\n    const activeNodes2 = [node2];\n    const activeLinks2 = [];\n    if (node2.sourceLinks) {\n      activeLinks2.push(...node2.sourceLinks);\n      node2.sourceLinks.forEach(sourceLink => {\n        const sourceLinkTarget = sourceLink.target;\n        if (sourceLinkTarget.index !== node2.index) {\n          activeNodes2.push(sourceLinkTarget);\n        }\n      });\n    }\n    if (node2.targetLinks) {\n      activeLinks2.push(...node2.targetLinks);\n      node2.targetLinks.forEach(targetLink => {\n        const targetLinkSource = targetLink.source;\n        if (targetLinkSource.index !== node2.index) {\n          activeNodes2.push(targetLinkSource);\n        }\n      });\n    }\n    setActiveNodes(activeNodes2);\n    setActiveLinks(activeLinks2);\n  }, []);\n  const onLinkActive = useCallback(link2 => {\n    const activeNodes2 = [link2.source, link2.target];\n    const activeLinks2 = [link2];\n    setActiveNodes(activeNodes2);\n    setActiveLinks(activeLinks2);\n  }, []);\n  const onInactive = useCallback(() => {\n    setActiveNodes([]);\n    setActiveLinks([]);\n  }, []);\n  const nodeMap = useMemo(() => {\n    const nodeMap2 = /* @__PURE__ */new Map();\n    nodes.forEach(node2 => node2 && nodeMap2.set(node2.props.title, node2));\n    return nodeMap2;\n  }, [nodes]);\n  const renderNode = useCallback((computedNode, index, chartWidth, node2) => {\n    const active = activeNodes.some(node22 => node22.index === computedNode.index);\n    const disabled = activeNodes.length > 0 && !active;\n    const labelPadding = labelPosition === \"outside\" ? LABEL_PADDING_PERCENT : 0;\n    return /* @__PURE__ */jsx(CloneElement, {\n      element: node2,\n      active,\n      animated,\n      disabled,\n      chartWidth,\n      onMouseEnter: () => onNodeActive(computedNode),\n      onMouseLeave: () => onInactive(),\n      labelPosition,\n      labelPadding,\n      ...computedNode\n    }, `node-${index}`);\n  }, [activeNodes, animated, onInactive, onNodeActive, labelPosition]);\n  const renderLink = useCallback((computedLink, index) => {\n    const active = activeLinks.some(link2 => link2.index === computedLink.index);\n    const disabled = activeLinks.length > 0 && !active;\n    return /* @__PURE__ */jsx(CloneElement, {\n      element: links[index],\n      active,\n      animated,\n      chartId: `sankey-${id}`,\n      disabled,\n      ...computedLink,\n      onMouseEnter: () => onLinkActive(computedLink),\n      onMouseLeave: () => onInactive()\n    }, `link-${index}`);\n  }, [activeLinks, id, animated, links, onInactive, onLinkActive]);\n  const getNodesAndLinks = useCallback((chartWidth, chartHeight) => {\n    const labelPadding = labelPosition === \"outside\" ? LABEL_PADDING_PERCENT : 0;\n    const padding = labelPadding * chartWidth;\n    const sankeyChart = sankey().extent([[1 + padding, 1], [chartWidth - padding, chartHeight]]).nodeWidth(nodeWidth).nodePadding(nodePadding).nodeSort(nodeSort).nodeAlign(JUSTIFICATION[justification]).nodeId(node2 => node2.id || node2.index);\n    const nodesCopy = nodes.map((node2, index) => ({\n      id: node2.props.id,\n      title: node2.props.title,\n      color: getNodeColor(node2, index)\n    }));\n    const linksCopy = links.map(link2 => ({\n      source: link2.props.source,\n      target: link2.props.target,\n      value: link2.props.value\n    }));\n    const {\n      nodes: sankeyNodes,\n      links: sankeyLinks\n    } = sankeyChart({\n      nodes: nodesCopy,\n      links: linksCopy\n    });\n    return {\n      sankeyNodes,\n      sankeyLinks\n    };\n  }, [getNodeColor, nodeSort, justification, links, nodePadding, nodeWidth, nodes, labelPosition]);\n  const renderChart = useCallback(({\n    id: id2,\n    chartWidth,\n    chartHeight,\n    chartSized\n  }) => {\n    if (!chartSized) {\n      return null;\n    }\n    const {\n      sankeyNodes,\n      sankeyLinks\n    } = getNodesAndLinks(chartWidth, chartHeight);\n    return /* @__PURE__ */jsxs(Fragment, {\n      children: [sankeyLinks.map((link2, index) => renderLink(link2, index)), sankeyNodes.map((node2, index) => renderNode(node2, index, chartWidth, nodeMap.get(node2.title)))]\n    }, \"group\");\n  }, [getNodesAndLinks, nodeMap, renderLink, renderNode]);\n  return /* @__PURE__ */jsx(ChartContainer, {\n    id,\n    width,\n    containerClassName,\n    height,\n    margins,\n    className,\n    children: renderChart\n  });\n};\nSankey.defaultProps = {\n  animated: true,\n  justification: \"justify\",\n  nodeWidth: 15,\n  nodePadding: 10,\n  nodePosition: \"inside\"\n};\nconst label$1 = \"_label_qd893_1\";\nconst css$a = {\n  label: label$1\n};\nconst LABEL_PADDING = 5;\nconst LABEL_TRUNCATE_LENGTH = 10;\nconst SankeyLabel = ({\n  active,\n  chartWidth,\n  className,\n  nodeWidth,\n  disabled,\n  fill,\n  format,\n  node: node2,\n  position,\n  opacity,\n  padding,\n  visible,\n  ellipsis,\n  labelPadding\n}) => {\n  const x0 = (node2 == null ? void 0 : node2.x0) || 0;\n  const x1 = (node2 == null ? void 0 : node2.x1) || 0;\n  const y0 = (node2 == null ? void 0 : node2.y0) || 0;\n  const y1 = (node2 == null ? void 0 : node2.y1) || 0;\n  const paddedWidth = nodeWidth + LABEL_PADDING;\n  const width = chartWidth || 0;\n  const showRightSide = x0 < width / 2;\n  let x = showRightSide ? x1 + paddedWidth : x0 - paddedWidth;\n  const y = (y1 + y0) / 2;\n  let textAnchor = showRightSide ? \"start\" : \"end\";\n  if (position === \"outside\") {\n    textAnchor = showRightSide ? \"end\" : \"start\";\n    x = showRightSide ? x1 - paddedWidth : x0 + paddedWidth;\n  }\n  if (!visible || !node2) {\n    return null;\n  }\n  let truncatedTitle = \"\";\n  if (ellipsis === \"auto\") {\n    const avaialableWidth = showRightSide ? x : width - x;\n    truncatedTitle = ellipsize(node2.title, Math.min(LABEL_TRUNCATE_LENGTH, avaialableWidth / (labelPadding * 100)));\n  } else if (ellipsis === \"none\") {\n    truncatedTitle = node2.title;\n  } else {\n    truncatedTitle = ellipsize(node2.title, ellipsis);\n  }\n  return /* @__PURE__ */jsx(\"text\", {\n    className: classNames(css$a.label, className),\n    x,\n    y,\n    dy: \"0.35em\",\n    textAnchor,\n    fill,\n    opacity: opacity(active, disabled),\n    style: {\n      padding\n    },\n    children: typeof format === \"function\" ? format({\n      x,\n      y,\n      textAnchor,\n      node: node2\n    }) : truncatedTitle\n  });\n};\nSankeyLabel.defaultProps = {\n  active: false,\n  fill: \"#fff\",\n  position: \"inside\",\n  opacity: (active, disabled) => active ? 1 : disabled ? 0.2 : 0.9,\n  visible: true,\n  ellipsis: \"auto\"\n};\nconst link = \"_link_1oi50_1\";\nconst tooltip$1 = \"_tooltip_1oi50_7\";\nconst tooltipLabel$1 = \"_tooltipLabel_1oi50_11\";\nconst tooltipValue$1 = \"_tooltipValue_1oi50_18\";\nconst css$9 = {\n  link,\n  tooltip: tooltip$1,\n  tooltipLabel: tooltipLabel$1,\n  tooltipValue: tooltipValue$1\n};\nconst SankeyLink = ({\n  gradient: gradient2,\n  index,\n  source,\n  target,\n  tooltip: tooltip2,\n  chartId,\n  value: value2,\n  active,\n  className,\n  disabled,\n  opacity,\n  style,\n  width,\n  color,\n  y0,\n  y1,\n  onClick,\n  onMouseEnter,\n  onMouseLeave\n}) => {\n  var _a;\n  const linkSource = source;\n  const linkTarget = target;\n  const [hovered, setHovered] = useState(false);\n  const linkRef = useRef(null);\n  const getLink = useCallback(() => {\n    return {\n      index,\n      y0,\n      y1,\n      value: value2,\n      width,\n      source,\n      target\n    };\n  }, [index, source, target, value2, width, y0, y1]);\n  const stroke = useMemo(() => {\n    if (gradient2) {\n      return `url(#${chartId}-gradient-${index})`;\n    } else if (color) {\n      return color;\n    }\n    return DEFAULT_COLOR;\n  }, [chartId, gradient2, index, color]);\n  const enterProps = useMemo(() => {\n    const path2 = sankeyLinkHorizontal();\n    const d = path2(getLink());\n    const strokeWidth = Math.max(1, width);\n    return {\n      d,\n      strokeWidth\n    };\n  }, [getLink, width]);\n  const exitProps = useMemo(() => {\n    const path2 = sankeyLinkHorizontal();\n    const d = path2({\n      ...getLink(),\n      width: 0\n    });\n    return {\n      d,\n      strokeWidth: 0\n    };\n  }, [getLink]);\n  const renderTooltipContent = useCallback(() => {\n    return /* @__PURE__ */jsxs(\"div\", {\n      className: css$9.tooltip,\n      children: [/* @__PURE__ */jsx(\"div\", {\n        className: css$9.tooltipLabel,\n        children: `${source.title}  ${target.title}`\n      }), /* @__PURE__ */jsx(\"div\", {\n        className: css$9.tooltipValue,\n        children: formatValue(value2)\n      })]\n    });\n  }, [source, target, value2]);\n  const {\n    pointerOut,\n    pointerOver\n  } = useHoverIntent({\n    onPointerOver: event => {\n      setHovered(true);\n      onMouseEnter == null ? void 0 : onMouseEnter(event);\n    },\n    onPointerOut: event => {\n      setHovered(false);\n      onMouseLeave == null ? void 0 : onMouseLeave(event);\n    }\n  });\n  const ariaLabelData = useMemo(() => `${source.title}  ${target.title}: ${formatValue(value2)}`, [source, target, value2]);\n  return /* @__PURE__ */jsxs(Fragment, {\n    children: [gradient2 && /* @__PURE__ */jsxs(\"linearGradient\", {\n      id: `${chartId}-gradient-${index}`,\n      gradientUnits: \"userSpaceOnUse\",\n      x1: linkSource.x1,\n      x2: linkTarget.x0,\n      children: [/* @__PURE__ */jsx(\"stop\", {\n        offset: \"0%\",\n        stopColor: linkSource.color\n      }), /* @__PURE__ */jsx(\"stop\", {\n        offset: \"100%\",\n        stopColor: linkTarget.color\n      })]\n    }), /* @__PURE__ */jsx(\"g\", {\n      ref: linkRef,\n      children: /* @__PURE__ */jsx(motion.path, {\n        className: classNames(css$9.link, className),\n        style,\n        initial: exitProps,\n        animate: enterProps,\n        exit: exitProps,\n        transition: {\n          duration: 0.5\n        },\n        stroke,\n        strokeOpacity: opacity(active, disabled),\n        onClick,\n        onPointerOver: pointerOver,\n        onPointerOut: pointerOut,\n        \"aria-label\": ariaLabelData,\n        role: \"graphics-document\"\n      }, `sankey-link-${enterProps.d}-${index}`)\n    }), !((_a = tooltip2 == null ? void 0 : tooltip2.props) == null ? void 0 : _a.disabled) && /* @__PURE__ */jsx(CloneElement, {\n      content: renderTooltipContent,\n      element: tooltip2,\n      visible: hovered,\n      reference: linkRef\n    })]\n  });\n};\nSankeyLink.defaultProps = {\n  active: false,\n  animated: true,\n  disabled: false,\n  gradient: true,\n  opacity: (active, disabled) => active ? 0.5 : disabled ? 0.1 : 0.35,\n  tooltip: /* @__PURE__ */jsx(Tooltip, {\n    theme: tooltipTheme,\n    followCursor: true,\n    modifiers: {\n      offset: {\n        offset: \"0, 5px\"\n      }\n    }\n  }),\n  width: 0\n};\nconst node = \"_node_oqk6h_1\";\nconst tooltip = \"_tooltip_oqk6h_5\";\nconst tooltipLabel = \"_tooltipLabel_oqk6h_10\";\nconst tooltipValue = \"_tooltipValue_oqk6h_17\";\nconst css$8 = {\n  node,\n  tooltip,\n  tooltipLabel,\n  tooltipValue\n};\nconst SankeyNode = ({\n  active,\n  chartWidth,\n  label: label2,\n  labelPosition,\n  labelPadding,\n  tooltip: tooltip2,\n  title,\n  value: value2,\n  className,\n  color,\n  disabled,\n  index,\n  opacity,\n  style,\n  width,\n  x0,\n  x1,\n  y0,\n  y1,\n  id,\n  sourceLinks,\n  targetLinks,\n  onClick,\n  onMouseEnter,\n  onMouseLeave\n}) => {\n  var _a;\n  const node2 = {\n    id,\n    title,\n    color,\n    sourceLinks,\n    targetLinks,\n    value: value2,\n    index,\n    x0,\n    x1,\n    y0,\n    y1\n  };\n  const nodeWidth = width || (x1 && x0 && x1 - x0 > 0 ? x1 - x0 : 0);\n  const nodeHeight = y1 && y0 && y1 - y0 > 0 ? y1 - y0 : 0;\n  const [hovered, setHovered] = useState(false);\n  const rectRef = useRef(null);\n  const renderTooltipContent = useCallback(() => {\n    return /* @__PURE__ */jsxs(\"div\", {\n      className: css$8.tooltip,\n      children: [/* @__PURE__ */jsx(\"div\", {\n        className: css$8.tooltipLabel,\n        children: title\n      }), /* @__PURE__ */jsx(\"div\", {\n        className: css$8.tooltipValue,\n        children: formatValue(value2)\n      })]\n    });\n  }, [title, value2]);\n  const {\n    pointerOut,\n    pointerOver\n  } = useHoverIntent({\n    onPointerOver: event => {\n      setHovered(true);\n      onMouseEnter == null ? void 0 : onMouseEnter(event);\n    },\n    onPointerOut: event => {\n      setHovered(false);\n      onMouseLeave == null ? void 0 : onMouseLeave(event);\n    }\n  });\n  const ariaLabelData = useMemo(() => `${title}: ${formatValue(value2)}`, [title, value2]);\n  return /* @__PURE__ */jsxs(Fragment, {\n    children: [/* @__PURE__ */jsx(motion.g, {\n      ref: rectRef,\n      tabIndex: 0,\n      \"aria-label\": ariaLabelData,\n      role: \"graphics-document\",\n      children: /* @__PURE__ */jsx(motion.rect, {\n        className: classNames(css$8.node, className),\n        fillOpacity: opacity(active, disabled),\n        style,\n        width: nodeWidth,\n        height: nodeHeight,\n        fill: color,\n        initial: {\n          opacity: 0,\n          attrX: x0,\n          attrY: y0\n        },\n        animate: {\n          opacity: 1,\n          attrX: x0,\n          attrY: y0\n        },\n        exit: {\n          opacity: 0,\n          attrX: x0,\n          attrY: y0\n        },\n        transition: {\n          duration: 0.1\n        },\n        onClick,\n        onPointerOver: pointerOver,\n        onPointerOut: pointerOut\n      }, `sankey-node-${x0}-${x1}-${y0}-${y1}-${index}`)\n    }), label2 !== null && /* @__PURE__ */jsx(CloneElement, {\n      active,\n      element: label2,\n      disabled,\n      chartWidth,\n      nodeWidth,\n      node: node2,\n      position: labelPosition,\n      labelPadding\n    }), !((_a = tooltip2 == null ? void 0 : tooltip2.props) == null ? void 0 : _a.disabled) && /* @__PURE__ */jsx(CloneElement, {\n      content: renderTooltipContent,\n      element: tooltip2,\n      visible: hovered,\n      reference: rectRef\n    })]\n  });\n};\nSankeyNode.defaultProps = {\n  active: false,\n  animated: true,\n  color: DEFAULT_COLOR,\n  disabled: false,\n  label: /* @__PURE__ */jsx(SankeyLabel, {}),\n  opacity: (active, disabled) => active ? 1 : disabled ? 0.2 : 0.9,\n  tooltip: /* @__PURE__ */jsx(Tooltip, {\n    theme: tooltipTheme,\n    followCursor: true,\n    modifiers: {\n      offset: {\n        offset: \"0, 5px\"\n      }\n    }\n  })\n};\nconst SparklineChart = props => /* @__PURE__ */jsx(LineChart, {\n  ...props\n});\nSparklineChart.defaultProps = {\n  gridlines: null,\n  series: /* @__PURE__ */jsx(AreaSeries, {\n    symbols: /* @__PURE__ */jsx(PointSeries, {\n      show: \"hover\"\n    }),\n    interpolation: \"smooth\",\n    markLine: null,\n    area: null,\n    line: /* @__PURE__ */jsx(Line, {\n      strokeWidth: 2\n    })\n  }),\n  yAxis: /* @__PURE__ */jsx(LinearYAxis, {\n    scaled: true,\n    type: \"value\",\n    axisLine: null,\n    tickSeries: /* @__PURE__ */jsx(LinearYAxisTickSeries, {\n      line: null,\n      label: null\n    })\n  }),\n  xAxis: /* @__PURE__ */jsx(LinearXAxis, {\n    type: \"time\",\n    scaled: true,\n    axisLine: null,\n    tickSeries: /* @__PURE__ */jsx(LinearXAxisTickSeries, {\n      line: null,\n      label: null\n    })\n  })\n};\nconst AreaSparklineChart = props => /* @__PURE__ */jsx(AreaChart, {\n  ...props\n});\nAreaSparklineChart.defaultProps = {\n  gridlines: null,\n  series: /* @__PURE__ */jsx(AreaSeries, {\n    symbols: /* @__PURE__ */jsx(PointSeries, {\n      show: \"hover\"\n    }),\n    interpolation: \"smooth\",\n    markLine: null,\n    area: /* @__PURE__ */jsx(Area, {\n      mask: /* @__PURE__ */jsx(Stripes, {}),\n      gradient: /* @__PURE__ */jsx(Gradient, {\n        stops: [/* @__PURE__ */jsx(GradientStop, {\n          offset: \"10%\",\n          stopOpacity: 0\n        }, \"start\"), /* @__PURE__ */jsx(GradientStop, {\n          offset: \"80%\",\n          stopOpacity: 1\n        }, \"stop\")]\n      })\n    }),\n    line: /* @__PURE__ */jsx(Line, {\n      strokeWidth: 3\n    })\n  }),\n  yAxis: /* @__PURE__ */jsx(LinearYAxis, {\n    type: \"value\",\n    scaled: true,\n    axisLine: null,\n    tickSeries: /* @__PURE__ */jsx(LinearYAxisTickSeries, {\n      line: null,\n      label: null\n    })\n  }),\n  xAxis: /* @__PURE__ */jsx(LinearXAxis, {\n    type: \"time\",\n    scaled: true,\n    axisLine: null,\n    tickSeries: /* @__PURE__ */jsx(LinearXAxisTickSeries, {\n      line: null,\n      label: null\n    })\n  })\n};\nconst BarSparklineChart = props => /* @__PURE__ */jsx(BarChart, {\n  ...props\n});\nBarSparklineChart.defaultProps = {\n  gridlines: null,\n  series: /* @__PURE__ */jsx(BarSeries, {\n    colorScheme: schemes.cybertron[0]\n  }),\n  yAxis: /* @__PURE__ */jsx(LinearYAxis, {\n    type: \"value\",\n    axisLine: null,\n    tickSeries: /* @__PURE__ */jsx(LinearYAxisTickSeries, {\n      line: null,\n      label: null\n    })\n  }),\n  xAxis: /* @__PURE__ */jsx(LinearXAxis, {\n    type: \"category\",\n    axisLine: null,\n    tickSeries: /* @__PURE__ */jsx(LinearXAxisTickSeries, {\n      line: null,\n      label: null\n    })\n  })\n};\nconst SonarChart = props => /* @__PURE__ */jsx(StackedBarChart, {\n  ...props,\n  margins: 0,\n  gridlines: null,\n  series: /* @__PURE__ */jsx(StackedBarSeries, {\n    type: \"stackedDiverging\",\n    colorScheme: \"rgb(17, 207, 247)\",\n    tooltip: /* @__PURE__ */jsx(TooltipArea, {\n      tooltip: /* @__PURE__ */jsx(ChartTooltip, {\n        followCursor: true,\n        modifiers: {\n          offset: \"5px, 5px\"\n        },\n        content: (data, color) => /* @__PURE__ */jsx(TooltipTemplate, {\n          color,\n          value: {\n            x: formatValue(data.x),\n            y: `${formatValue(Math.abs(data.data[0].y))}`\n          }\n        })\n      })\n    }),\n    bar: [/* @__PURE__ */jsx(Bar, {\n      width: 1,\n      rangeLines: null,\n      minHeight: 1,\n      gradient: /* @__PURE__ */jsx(Gradient, {\n        stops: [/* @__PURE__ */jsx(GradientStop, {\n          offset: \"5%\",\n          stopOpacity: 0.7\n        }, \"start\"), /* @__PURE__ */jsx(GradientStop, {\n          offset: \"90%\",\n          stopOpacity: 1\n        }, \"stop\")]\n      })\n    }, \"first\"), /* @__PURE__ */jsx(Bar, {\n      width: 1,\n      rangeLines: null,\n      minHeight: 1,\n      gradient: /* @__PURE__ */jsx(Gradient, {\n        stops: [/* @__PURE__ */jsx(GradientStop, {\n          offset: \"5%\",\n          stopOpacity: 1\n        }, \"stop\"), /* @__PURE__ */jsx(GradientStop, {\n          offset: \"90%\",\n          stopOpacity: 0.7\n        }, \"start\")]\n      })\n    }, \"second\")]\n  }),\n  yAxis: /* @__PURE__ */jsx(LinearYAxis, {\n    type: \"value\",\n    axisLine: null,\n    tickSeries: /* @__PURE__ */jsx(LinearYAxisTickSeries, {\n      line: null,\n      label: null\n    })\n  }),\n  xAxis: /* @__PURE__ */jsx(LinearXAxis, {\n    type: \"category\",\n    axisLine: null,\n    tickSeries: /* @__PURE__ */jsx(LinearXAxisTickSeries, {\n      line: null,\n      label: null\n    })\n  })\n});\nconst RadialArea = ({\n  id,\n  data,\n  className,\n  yScale,\n  color,\n  animated,\n  index,\n  outerRadius,\n  xScale,\n  innerRadius,\n  interpolation,\n  gradient: gradient2,\n  isClosedCurve\n}) => {\n  const transition = useMemo(() => animated ? {\n    ...DEFAULT_TRANSITION,\n    delay: index * 0.05\n  } : {\n    type: false,\n    delay: 0\n  }, [animated, index]);\n  const getFill = useCallback(c => {\n    if (!gradient2) {\n      return c;\n    }\n    return `url(#${id}-gradient)`;\n  }, [id, gradient2]);\n  const getPath = useCallback(d => {\n    const curve = interpolation === \"smooth\" ? isClosedCurve ? curveCardinalClosed : curveCardinal : isClosedCurve ? curveLinearClosed : curveLinear;\n    const radialFn = radialArea().angle(dd => xScale(dd.x)).innerRadius(_ => innerRadius).outerRadius(d2 => yScale(d2.y)).curve(curve);\n    return radialFn(d);\n  }, [interpolation, isClosedCurve, xScale, innerRadius, yScale]);\n  const enter = useMemo(() => ({\n    d: getPath(data),\n    opacity: 1\n  }), [data, getPath]);\n  const exit = useMemo(() => {\n    const [yStart] = yScale.domain();\n    return {\n      d: getPath(data.map(d => ({\n        ...d,\n        y: yStart\n      }))),\n      opacity: 0\n    };\n  }, [data, getPath, yScale]);\n  const fill = color(data, 0);\n  return /* @__PURE__ */jsxs(Fragment, {\n    children: [/* @__PURE__ */jsx(MotionPath, {\n      custom: {\n        enter,\n        exit\n      },\n      transition,\n      pointerEvents: \"none\",\n      className,\n      fill: getFill(color)\n    }), gradient2 && /* @__PURE__ */jsx(CloneElement, {\n      element: gradient2,\n      id: `${id}-gradient`,\n      radius: outerRadius,\n      color: fill\n    })]\n  });\n};\nRadialArea.defaultProps = {\n  gradient: /* @__PURE__ */jsx(RadialGradient, {}),\n  isClosedCurve: true\n};\nconst RadialLine = ({\n  xScale,\n  yScale,\n  className,\n  index,\n  hasArea,\n  color,\n  data,\n  interpolation,\n  strokeWidth,\n  animated,\n  isClosedCurve\n}) => {\n  const fill = color(data, index);\n  const getPath = useCallback(preData => {\n    const curve = interpolation === \"smooth\" ? isClosedCurve ? curveCardinalClosed : curveCardinal : isClosedCurve ? curveLinearClosed : curveLinear;\n    const radialFn = radialLine().angle(d => xScale(d.x)).radius(d => yScale(d.y)).curve(curve);\n    return radialFn(preData);\n  }, [interpolation, isClosedCurve, xScale, yScale]);\n  const transition = useMemo(() => animated ? {\n    ...DEFAULT_TRANSITION,\n    delay: hasArea ? 0 : index * 0.05\n  } : {\n    type: false,\n    delay: 0\n  }, [animated, index, hasArea]);\n  const enter = useMemo(() => ({\n    d: getPath(data),\n    opacity: 1\n  }), [data, getPath]);\n  const exit = useMemo(() => {\n    const [yStart] = yScale.domain();\n    return {\n      d: getPath(data.map(d => ({\n        ...d,\n        y: yStart\n      }))),\n      opacity: 0\n    };\n  }, [data, yScale, getPath]);\n  return /* @__PURE__ */jsx(MotionPath, {\n    custom: {\n      enter,\n      exit\n    },\n    transition,\n    className,\n    pointerEvents: \"none\",\n    stroke: fill,\n    fill: \"none\",\n    strokeWidth\n  });\n};\nRadialLine.defaultProps = {\n  strokeWidth: 2,\n  animated: true,\n  isClosedCurve: true\n};\nconst RadialScatterPlot = ({\n  id,\n  width,\n  height,\n  margins,\n  className,\n  containerClassName,\n  innerRadius,\n  series,\n  axis,\n  data\n}) => {\n  const getScales = useCallback((aggregatedData, outer, inner) => {\n    let xScale;\n    if ((axis == null ? void 0 : axis.props.type) === \"category\") {\n      const xDomain = uniqueBy(aggregatedData, dd => dd.x);\n      xScale = scaleBand().range([0, 2 * Math.PI]).domain(xDomain);\n    } else {\n      const xDomain = getXDomain({\n        data: aggregatedData\n      });\n      xScale = scaleTime().range([0, 2 * Math.PI]).domain(xDomain);\n    }\n    const yDomain = getYDomain({\n      data: aggregatedData,\n      scaled: false\n    });\n    const yScale = getRadialYScale(inner, outer, yDomain);\n    return {\n      yScale,\n      xScale\n    };\n  }, []);\n  const renderChart = useCallback(containerProps => {\n    const {\n      chartWidth,\n      chartHeight,\n      id: id2\n    } = containerProps;\n    const outerRadius = Math.min(chartWidth, chartHeight) / 2;\n    const aggregatedData = buildShallowChartData(data);\n    const {\n      yScale,\n      xScale\n    } = getScales(aggregatedData, outerRadius, innerRadius);\n    return /* @__PURE__ */jsxs(Fragment, {\n      children: [axis && /* @__PURE__ */jsx(CloneElement, {\n        element: axis,\n        xScale,\n        height: chartHeight,\n        width: chartWidth,\n        innerRadius\n      }), /* @__PURE__ */jsx(CloneElement, {\n        element: series,\n        id: id2,\n        data: aggregatedData,\n        xScale,\n        yScale\n      })]\n    });\n  }, [data, getScales, innerRadius, series, axis]);\n  return /* @__PURE__ */jsx(ChartContainer, {\n    id,\n    containerClassName,\n    width,\n    height,\n    margins,\n    xAxisVisible: false,\n    yAxisVisible: false,\n    center: true,\n    className,\n    children: renderChart\n  });\n};\nconst inactive = \"_inactive_kwc4n_1\";\nconst hidden = \"_hidden_kwc4n_6\";\nconst css$7 = {\n  inactive,\n  hidden\n};\nconst RadialScatterPoint = ({\n  size,\n  data,\n  color,\n  index,\n  symbol: symbol2,\n  active,\n  tooltip: tooltip2,\n  yScale,\n  xScale,\n  animated,\n  className,\n  visible,\n  ...rest\n}) => {\n  const ref = useRef(null);\n  const [hovered, setHovered] = useState(false);\n  function onMouseEnter(event) {\n    setHovered(true);\n    rest.onMouseEnter({\n      value: data,\n      nativeEvent: event\n    });\n  }\n  function onMouseLeave(event) {\n    setHovered(false);\n    rest.onMouseLeave({\n      value: data,\n      nativeEvent: event\n    });\n  }\n  function onClick(event) {\n    rest.onClick({\n      value: data,\n      nativeEvent: event\n    });\n  }\n  function getTranslate(data2) {\n    const fn = radialLine().radius(d => yScale(d.y)).angle(d => xScale(d.x));\n    const path2 = fn([data2]);\n    if (path2) {\n      const [translateX, translateY] = path2.slice(1).slice(0, -1).split(\",\");\n      return {\n        translateX: parseFloat(translateX),\n        translateY: parseFloat(translateY)\n      };\n    }\n  }\n  function getTransition() {\n    if (animated) {\n      return {\n        ...DEFAULT_TRANSITION,\n        delay: index * 5e-3\n      };\n    } else {\n      return {\n        type: false,\n        delay: 0\n      };\n    }\n  }\n  const fill = typeof color === \"function\" ? color(data, index) : color;\n  const transform2 = getTranslate(data);\n  const sizeVal = typeof size === \"function\" ? size(data) : size;\n  const transition = getTransition();\n  const [yStart] = yScale.domain();\n  const exitTransform = getTranslate({\n    ...data,\n    y: yStart\n  });\n  const ariaLabelData = useMemo(() => getAriaLabel(data), [data]);\n  const isVisible = visible ? visible == null ? void 0 : visible(data, index) : active;\n  return /* @__PURE__ */jsxs(Fragment, {\n    children: [/* @__PURE__ */jsxs(motion.g, {\n      initial: {\n        ...exitTransform,\n        opacity: 0\n      },\n      animate: {\n        ...transform2,\n        opacity: 1\n      },\n      exit: {\n        ...exitTransform,\n        opacity: 0\n      },\n      transition,\n      ref,\n      onMouseEnter,\n      onMouseLeave,\n      onClick,\n      className: classNames(className, {\n        [css$7.inactive]: !active,\n        [css$7.hidden]: !isVisible\n      }),\n      tabIndex: 0,\n      \"aria-label\": ariaLabelData,\n      role: \"graphics-document\",\n      children: [symbol2 && symbol2(data), !symbol2 && /* @__PURE__ */jsx(\"circle\", {\n        r: sizeVal,\n        fill\n      })]\n    }), tooltip2 && /* @__PURE__ */jsx(CloneElement, {\n      element: tooltip2,\n      visible: hovered,\n      reference: ref,\n      value: data\n    })]\n  });\n};\nRadialScatterPoint.defaultProps = {\n  size: 3,\n  color: schemes.cybertron[0],\n  tooltip: /* @__PURE__ */jsx(ChartTooltip, {}),\n  active: true,\n  onClick: () => void 0,\n  onMouseEnter: () => void 0,\n  onMouseLeave: () => void 0\n};\nconst RadialScatterSeries = ({\n  data,\n  point: point2,\n  xScale,\n  yScale,\n  animated,\n  activeIds,\n  show = true,\n  valueMarkers\n}) => {\n  const [internalActiveIds, setInternalActiveIds] = useState(activeIds);\n  useEffect(() => {\n    setInternalActiveIds(activeIds || []);\n  }, [activeIds]);\n  const onMouseEnter = useCallback(({\n    value: value2\n  }) => {\n    if (!activeIds) {\n      setInternalActiveIds([value2.id]);\n    }\n  }, [activeIds]);\n  const onMouseLeave = useCallback(() => {\n    if (!activeIds) {\n      setInternalActiveIds([]);\n    }\n  }, [activeIds]);\n  const isVisible = useCallback(() => show, [show]);\n  const renderPoint = useCallback((d, index) => {\n    var _a;\n    let dataId;\n    if (d.id) {\n      dataId = d.id;\n    } else {\n      console.warn(\"No 'id' property provided for scatter point; provide one via 'id'.\");\n    }\n    const key = identifier(`${dataId || index}`);\n    const active = !(internalActiveIds && internalActiveIds.length) || internalActiveIds.includes(dataId);\n    const pointVisible = (_a = point2.props) == null ? void 0 : _a.visible;\n    return /* @__PURE__ */createElement(CloneElement, {\n      ...(pointVisible ? {} : {\n        visible: isVisible\n      }),\n      element: point2,\n      key,\n      data: d,\n      index,\n      active,\n      xScale,\n      yScale,\n      animated,\n      onMouseEnter,\n      onMouseLeave\n    });\n  }, [isVisible, point2, internalActiveIds, xScale, yScale, animated, onMouseEnter, onMouseLeave]);\n  const renderValueMarkers = useCallback(() => /* @__PURE__ */jsx(Fragment$1, {\n    children: (valueMarkers == null ? void 0 : valueMarkers.length) && valueMarkers.map(marker2 => /* @__PURE__ */jsx(CloneElement, {\n      element: marker2,\n      value: yScale(marker2.props.value)\n    }, marker2.key))\n  }), [valueMarkers, yScale]);\n  return /* @__PURE__ */jsxs(Fragment, {\n    children: [renderValueMarkers(), data.map(renderPoint)]\n  });\n};\nRadialScatterSeries.defaultProps = {\n  point: /* @__PURE__ */jsx(RadialScatterPoint, {}),\n  animated: true\n};\nconst RadialPointSeries = ({\n  data,\n  xScale,\n  yScale,\n  animated,\n  color,\n  activeValues,\n  show,\n  point: point2\n}) => {\n  const isVisible = useCallback((point22, index) => {\n    const isActive = activeValues && point22 && isEqual(activeValues.x, point22.x);\n    if (show === \"hover\") {\n      return isActive;\n    } else if (show === \"first\") {\n      if (activeValues) {\n        return isActive;\n      } else {\n        return index === 0;\n      }\n    } else if (show === \"last\") {\n      if (activeValues) {\n        return isActive;\n      } else {\n        return index === data.length - 1;\n      }\n    }\n    return show;\n  }, [data, activeValues, show]);\n  return /* @__PURE__ */jsx(RadialScatterSeries, {\n    animated,\n    data,\n    xScale,\n    yScale,\n    point: /* @__PURE__ */jsx(CloneElement, {\n      element: point2,\n      color,\n      tooltip: null,\n      visible: isVisible\n    })\n  });\n};\nRadialPointSeries.defaultProps = {\n  show: \"hover\",\n  type: \"standard\",\n  point: /* @__PURE__ */jsx(RadialScatterPoint, {})\n};\nconst RadialAreaSeries = ({\n  area: area2,\n  line: line2,\n  symbols,\n  tooltip: tooltip2,\n  xScale,\n  yScale,\n  data,\n  id,\n  animated,\n  width,\n  height,\n  innerRadius,\n  outerRadius,\n  type,\n  colorScheme,\n  interpolation,\n  startAngle,\n  endAngle,\n  isClosedCurve,\n  valueMarkers\n}) => {\n  const [activeValues, setActiveValues] = useState(null);\n  const isMulti = type === \"grouped\";\n  const getColorForPoint = useCallback((point2, index) => {\n    var _a;\n    const key = Array.isArray(point2) ? (_a = point2 == null ? void 0 : point2[0]) == null ? void 0 : _a.key : point2 == null ? void 0 : point2.key;\n    return getColor({\n      colorScheme,\n      data,\n      index,\n      point: point2,\n      key\n    });\n  }, [colorScheme, data]);\n  const renderArea = useCallback((point2, index = 0) => /* @__PURE__ */jsxs(Fragment$1, {\n    children: [area2 && /* @__PURE__ */jsx(CloneElement, {\n      element: area2,\n      id: `${id}-radial-area-${index}`,\n      xScale,\n      yScale,\n      animated,\n      color: getColorForPoint,\n      index,\n      data: point2,\n      interpolation,\n      outerRadius,\n      innerRadius,\n      isClosedCurve\n    }), line2 && /* @__PURE__ */jsx(CloneElement, {\n      element: line2,\n      xScale,\n      yScale,\n      hasArea: area2 !== null,\n      index,\n      animated,\n      interpolation,\n      color: getColorForPoint,\n      data: point2,\n      isClosedCurve\n    })]\n  }), [animated, area2, getColorForPoint, id, innerRadius, interpolation, isClosedCurve, line2, outerRadius, xScale, yScale]);\n  const renderSymbols = useCallback((data2, index = 0) => {\n    const activeSymbols = symbols && symbols.props.activeValues || activeValues;\n    const isAnimated = area2 !== void 0 && animated && !activeSymbols;\n    return /* @__PURE__ */jsx(CloneElement, {\n      element: symbols,\n      activeValues,\n      xScale,\n      index,\n      yScale,\n      data: data2,\n      animated: isAnimated,\n      color: getColorForPoint\n    });\n  }, [activeValues, animated, area2, getColorForPoint, symbols, xScale, yScale]);\n  const renderSingleSeries = useCallback(points => /* @__PURE__ */jsxs(Fragment, {\n    children: [renderArea(points), symbols && renderSymbols(points)]\n  }), [renderArea, renderSymbols, symbols]);\n  const renderMultiSeries = useCallback(points => /* @__PURE__ */jsxs(Fragment, {\n    children: [points.map((point2, index) => /* @__PURE__ */jsx(Fragment, {\n      children: renderArea(point2.data, index)\n    }, `${point2.key.toString()}`)).reverse(), points.map((point2, index) => /* @__PURE__ */jsx(Fragment, {\n      children: renderSymbols(point2.data, index)\n    }, `${point2.key.toString()}`)).reverse()]\n  }), [renderArea, renderSymbols]);\n  const renderValueMarkers = useCallback(() => /* @__PURE__ */jsx(Fragment$1, {\n    children: (valueMarkers == null ? void 0 : valueMarkers.length) && valueMarkers.map(marker2 => /* @__PURE__ */jsx(CloneElement, {\n      element: marker2,\n      value: yScale(marker2.props.value)\n    }, marker2.key))\n  }), [valueMarkers, yScale]);\n  return /* @__PURE__ */jsx(CloneElement, {\n    element: tooltip2,\n    xScale,\n    yScale,\n    data,\n    height,\n    width,\n    isRadial: true,\n    innerRadius,\n    outerRadius,\n    color: getColorForPoint,\n    onValueEnter: event => setActiveValues(event.value),\n    onValueLeave: () => setActiveValues(null),\n    startAngle,\n    endAngle,\n    children: /* @__PURE__ */jsxs(\"g\", {\n      clipPath: `url(#${id}-path)`,\n      children: [isMulti && renderMultiSeries(data), !isMulti && renderSingleSeries(data), renderValueMarkers()]\n    })\n  });\n};\nRadialAreaSeries.defaultProps = {\n  colorScheme: schemes.cybertron,\n  interpolation: \"smooth\",\n  type: \"standard\",\n  animated: true,\n  area: /* @__PURE__ */jsx(RadialArea, {}),\n  line: /* @__PURE__ */jsx(RadialLine, {}),\n  symbols: /* @__PURE__ */jsx(RadialPointSeries, {}),\n  tooltip: /* @__PURE__ */jsx(TooltipArea, {}),\n  startAngle: 0,\n  endAngle: 2 * Math.PI,\n  isClosedCurve: true\n};\nconst RadialAreaChart = ({\n  id,\n  width,\n  height,\n  className,\n  data,\n  containerClassName,\n  innerRadius,\n  series,\n  axis,\n  margins,\n  startAngle,\n  endAngle,\n  isClosedCurve\n}) => {\n  const getXScale2 = useCallback(points => {\n    const isFullCircle = Math.abs(endAngle - startAngle) >= 2 * Math.PI;\n    let xScale;\n    if ((axis == null ? void 0 : axis.props.type) === \"category\") {\n      const isMultiSeries = series.props.type === \"grouped\";\n      let xDomain;\n      if (isMultiSeries) {\n        xDomain = uniqueBy(points, dd => dd.data, dd => dd.x);\n      } else {\n        xDomain = uniqueBy(points, dd => dd.x);\n      }\n      if (isFullCircle) {\n        xScale = scaleBand().range([0, 2 * Math.PI]).domain(xDomain);\n      } else {\n        xScale = scalePoint().range([startAngle, endAngle]).domain(xDomain);\n      }\n    } else {\n      const xDomain = getXDomain({\n        data: points\n      });\n      xScale = scaleTime().range([startAngle, endAngle]).domain(xDomain);\n    }\n    return xScale;\n  }, [axis == null ? void 0 : axis.props.type, endAngle, series.props.type, startAngle]);\n  const getScales = useCallback((preData, outerRadius, innerRadius2) => {\n    const isMultiSeries = series.props.type === \"grouped\";\n    let d;\n    if (isMultiSeries) {\n      d = buildNestedChartData(preData, true);\n    } else {\n      d = buildShallowChartData(preData);\n    }\n    const xScale = getXScale2(d);\n    const yDomain = getYDomain({\n      data: d,\n      scaled: false\n    });\n    const yScale = getRadialYScale(innerRadius2, outerRadius, yDomain);\n    return {\n      yScale,\n      xScale,\n      result: d\n    };\n  }, [getXScale2, series.props.type]);\n  const renderChart = useCallback(containerProps => {\n    const {\n      chartWidth,\n      chartHeight,\n      id: id2\n    } = containerProps;\n    const outerRadius = Math.min(chartWidth, chartHeight) / 2;\n    const {\n      yScale,\n      xScale,\n      result\n    } = getScales(data, outerRadius, innerRadius);\n    return /* @__PURE__ */jsxs(Fragment, {\n      children: [axis && /* @__PURE__ */jsx(CloneElement, {\n        element: axis,\n        xScale,\n        height: chartHeight,\n        width: chartWidth,\n        innerRadius,\n        startAngle,\n        endAngle\n      }), /* @__PURE__ */jsx(CloneElement, {\n        element: series,\n        id: id2,\n        data: result,\n        xScale,\n        yScale,\n        height: chartHeight,\n        width: chartWidth,\n        outerRadius,\n        innerRadius,\n        startAngle,\n        endAngle,\n        isClosedCurve\n      })]\n    });\n  }, [getScales, data, innerRadius, axis, startAngle, endAngle, series, isClosedCurve]);\n  return /* @__PURE__ */jsx(ChartContainer, {\n    id,\n    width,\n    height,\n    containerClassName,\n    margins,\n    xAxisVisible: false,\n    yAxisVisible: false,\n    center: true,\n    className,\n    children: renderChart\n  });\n};\nRadialAreaChart.defaultProps = {\n  innerRadius: 0.1,\n  series: /* @__PURE__ */jsx(RadialAreaSeries, {}),\n  axis: /* @__PURE__ */jsx(RadialAxis, {}),\n  margins: 75,\n  startAngle: 0,\n  endAngle: 2 * Math.PI,\n  isClosedCurve: true\n};\nconst pi = Math.PI,\n  tau = 2 * pi,\n  epsilon = 1e-6,\n  tauEpsilon = tau - epsilon;\nfunction append(strings) {\n  this._ += strings[0];\n  for (let i = 1, n = strings.length; i < n; ++i) {\n    this._ += arguments[i] + strings[i];\n  }\n}\nfunction appendRound(digits) {\n  let d = Math.floor(digits);\n  if (!(d >= 0)) throw new Error(`invalid digits: ${digits}`);\n  if (d > 15) return append;\n  const k = 10 ** d;\n  return function (strings) {\n    this._ += strings[0];\n    for (let i = 1, n = strings.length; i < n; ++i) {\n      this._ += Math.round(arguments[i] * k) / k + strings[i];\n    }\n  };\n}\nclass Path {\n  constructor(digits) {\n    this._x0 = this._y0 =\n    // start of current subpath\n    this._x1 = this._y1 = null;\n    this._ = \"\";\n    this._append = digits == null ? append : appendRound(digits);\n  }\n  moveTo(x, y) {\n    this._append`M${this._x0 = this._x1 = +x},${this._y0 = this._y1 = +y}`;\n  }\n  closePath() {\n    if (this._x1 !== null) {\n      this._x1 = this._x0, this._y1 = this._y0;\n      this._append`Z`;\n    }\n  }\n  lineTo(x, y) {\n    this._append`L${this._x1 = +x},${this._y1 = +y}`;\n  }\n  quadraticCurveTo(x1, y1, x, y) {\n    this._append`Q${+x1},${+y1},${this._x1 = +x},${this._y1 = +y}`;\n  }\n  bezierCurveTo(x1, y1, x2, y2, x, y) {\n    this._append`C${+x1},${+y1},${+x2},${+y2},${this._x1 = +x},${this._y1 = +y}`;\n  }\n  arcTo(x1, y1, x2, y2, r) {\n    x1 = +x1, y1 = +y1, x2 = +x2, y2 = +y2, r = +r;\n    if (r < 0) throw new Error(`negative radius: ${r}`);\n    let x0 = this._x1,\n      y0 = this._y1,\n      x21 = x2 - x1,\n      y21 = y2 - y1,\n      x01 = x0 - x1,\n      y01 = y0 - y1,\n      l01_2 = x01 * x01 + y01 * y01;\n    if (this._x1 === null) {\n      this._append`M${this._x1 = x1},${this._y1 = y1}`;\n    } else if (!(l01_2 > epsilon)) ;else if (!(Math.abs(y01 * x21 - y21 * x01) > epsilon) || !r) {\n      this._append`L${this._x1 = x1},${this._y1 = y1}`;\n    } else {\n      let x20 = x2 - x0,\n        y20 = y2 - y0,\n        l21_2 = x21 * x21 + y21 * y21,\n        l20_2 = x20 * x20 + y20 * y20,\n        l21 = Math.sqrt(l21_2),\n        l01 = Math.sqrt(l01_2),\n        l = r * Math.tan((pi - Math.acos((l21_2 + l01_2 - l20_2) / (2 * l21 * l01))) / 2),\n        t01 = l / l01,\n        t21 = l / l21;\n      if (Math.abs(t01 - 1) > epsilon) {\n        this._append`L${x1 + t01 * x01},${y1 + t01 * y01}`;\n      }\n      this._append`A${r},${r},0,0,${+(y01 * x20 > x01 * y20)},${this._x1 = x1 + t21 * x21},${this._y1 = y1 + t21 * y21}`;\n    }\n  }\n  arc(x, y, r, a0, a1, ccw) {\n    x = +x, y = +y, r = +r, ccw = !!ccw;\n    if (r < 0) throw new Error(`negative radius: ${r}`);\n    let dx = r * Math.cos(a0),\n      dy = r * Math.sin(a0),\n      x0 = x + dx,\n      y0 = y + dy,\n      cw = 1 ^ ccw,\n      da = ccw ? a0 - a1 : a1 - a0;\n    if (this._x1 === null) {\n      this._append`M${x0},${y0}`;\n    } else if (Math.abs(this._x1 - x0) > epsilon || Math.abs(this._y1 - y0) > epsilon) {\n      this._append`L${x0},${y0}`;\n    }\n    if (!r) return;\n    if (da < 0) da = da % tau + tau;\n    if (da > tauEpsilon) {\n      this._append`A${r},${r},0,1,${cw},${x - dx},${y - dy}A${r},${r},0,1,${cw},${this._x1 = x0},${this._y1 = y0}`;\n    } else if (da > epsilon) {\n      this._append`A${r},${r},0,${+(da >= pi)},${cw},${this._x1 = x + r * Math.cos(a1)},${this._y1 = y + r * Math.sin(a1)}`;\n    }\n  }\n  rect(x, y, w, h) {\n    this._append`M${this._x0 = this._x1 = +x},${this._y0 = this._y1 = +y}h${w = +w}v${+h}h${-w}Z`;\n  }\n  toString() {\n    return this._;\n  }\n}\nfunction path() {\n  return new Path();\n}\npath.prototype = Path.prototype;\nconst MotionBar = ({\n  custom,\n  transition,\n  arc: arc2,\n  ...rest\n}) => {\n  const d = useMotionValue(\"\");\n  const currentYRef = useRef(custom.exit.y);\n  const spring = useSpring(0, DEFAULT_TRANSITION);\n  useEffect(() => {\n    const interpolator = interpolate$1(currentYRef.current, custom.enter.y);\n    const prevSpring = spring.get();\n    let timeoutId;\n    if (transition == null ? void 0 : transition.delay) {\n      timeoutId = setTimeout(() => {\n        spring.set(prevSpring + 1);\n      }, transition.delay * 1e3);\n    } else {\n      spring.set(prevSpring + 1);\n    }\n    const unsubscribe = spring.onChange(v => {\n      currentYRef.current = interpolator(v - prevSpring);\n      d.set(arc2({\n        ...custom.enter,\n        y: currentYRef.current\n      }));\n    });\n    return () => {\n      if (timeoutId) {\n        clearTimeout(timeoutId);\n      }\n      unsubscribe();\n    };\n  }, [arc2, custom.enter, d, spring, transition.delay]);\n  const {\n    d: enterD,\n    ...enterRest\n  } = custom.enter;\n  const {\n    d: exitD,\n    ...exitRest\n  } = custom.exit;\n  return /* @__PURE__ */jsx(motion.path, {\n    ...rest,\n    initial: exitRest,\n    exit: exitRest,\n    animate: enterRest,\n    transition,\n    d: transition.type !== false ? d : enterD,\n    tabIndex: 0\n  });\n};\nconst RadialGuideBar = ({\n  active,\n  path: path2,\n  fill = \"#eee\",\n  opacity = 0.2\n}) => /* @__PURE__ */jsx(motion.path, {\n  d: path2,\n  fill,\n  pointerEvents: \"none\",\n  initial: \"hidden\",\n  animate: active ? \"visible\" : \"hidden\",\n  variants: {\n    hidden: {\n      opacity: 0\n    },\n    visible: {\n      opacity\n    }\n  }\n});\nRadialGuideBar.defaultProps = {\n  fill: \"#eee\",\n  opacity: 0.2\n};\nconst RadialBar = ({\n  animated,\n  innerRadius,\n  xScale,\n  yScale,\n  curved,\n  id,\n  gradient: gradient2,\n  barCount,\n  innerBarCount,\n  groupIndex,\n  className,\n  data,\n  active,\n  guide,\n  index,\n  color,\n  onClick,\n  onMouseEnter,\n  onMouseLeave\n}) => {\n  const previousEnter = useRef(null);\n  const fill = color(data, index);\n  const currentColorShade = active ? chroma(fill).brighten(0.5) : fill;\n  const transition = useMemo(() => {\n    if (animated) {\n      return {\n        ...DEFAULT_TRANSITION,\n        delay: index / barCount * 0.9\n      };\n    } else {\n      return {\n        type: false,\n        delay: 0\n      };\n    }\n  }, [animated, barCount, index]);\n  const getFill = useCallback(color2 => {\n    if (!gradient2) {\n      return color2;\n    }\n    return `url(#${id}-gradient)`;\n  }, [gradient2, id]);\n  const getArc = useCallback(data2 => {\n    const outerRadius = yScale(data2.y);\n    if (curved) {\n      const startAngle = xScale(data2.x);\n      const endAngle = startAngle + xScale.bandwidth();\n      const arcFn = arc().innerRadius(innerRadius).outerRadius(outerRadius).startAngle(startAngle).endAngle(endAngle).padAngle(0.01).padRadius(innerRadius);\n      return arcFn(data2);\n    } else {\n      const isMultiSeries = groupIndex !== void 0;\n      const xScaleDomain = xScale.domain();\n      const xScaleRange = xScale.range();\n      const isFullCircle = Math.abs(xScaleRange[1] - xScaleRange[0]) >= 2 * Math.PI;\n      let xScaleBandwidth;\n      let rotateMid;\n      let startAngle;\n      let endAngle;\n      if (isFullCircle) {\n        xScaleBandwidth = xScale.bandwidth();\n        rotateMid = isMultiSeries && xScaleBandwidth ? xScaleBandwidth / 2 : 0;\n        startAngle = xScale(data2.x) - Math.PI * 0.5 - rotateMid;\n        endAngle = startAngle + xScaleBandwidth;\n      } else {\n        xScaleBandwidth = scaleBand().domain(xScaleDomain).range(xScaleRange).bandwidth();\n        rotateMid = isMultiSeries && xScaleBandwidth ? xScaleBandwidth / 2 : 0;\n        if (index === 0) {\n          startAngle = xScale(data2.x) - Math.PI * 0.5;\n          endAngle = startAngle + xScaleBandwidth - rotateMid;\n        } else if (index === barCount - 1) {\n          endAngle = xScaleRange[1] - Math.PI * 0.5;\n          startAngle = endAngle - xScaleBandwidth + rotateMid;\n        } else {\n          startAngle = xScale(data2.x) - Math.PI * 0.5 - rotateMid;\n          endAngle = startAngle + xScaleBandwidth;\n        }\n      }\n      const innerAngleDistance = endAngle - startAngle;\n      const arcLength = innerRadius * innerAngleDistance;\n      const outerAngleDistance = arcLength / outerRadius;\n      const halfAngleDistanceDelta = (innerAngleDistance - outerAngleDistance) / 2;\n      const innerDiff = innerAngleDistance / innerBarCount;\n      const innerStart = isMultiSeries ? startAngle + groupIndex * innerDiff : startAngle;\n      const innerEnd = isMultiSeries ? innerStart + innerDiff : endAngle;\n      const outerDiff = outerAngleDistance / innerBarCount;\n      const halfAngleDiffDistanceDelta = isMultiSeries ? (innerDiff - outerDiff) / 2 : halfAngleDistanceDelta;\n      const pathFn = path();\n      pathFn.arc(0, 0, innerRadius, innerStart, innerEnd);\n      pathFn.arc(0, 0, outerRadius, innerEnd - halfAngleDiffDistanceDelta, innerStart + halfAngleDiffDistanceDelta, true);\n      return pathFn.toString();\n    }\n  }, [barCount, curved, groupIndex, index, innerBarCount, innerRadius, xScale, yScale]);\n  const renderBar = useCallback(color2 => {\n    const fill2 = getFill(color2);\n    const prev = previousEnter.current ? {\n      ...previousEnter.current\n    } : void 0;\n    previousEnter.current = {\n      ...data\n    };\n    const [yStart, yEnd] = yScale.domain();\n    const exit = {\n      ...data,\n      y: yStart\n    };\n    const guidePath = getArc({\n      ...data,\n      y: yEnd\n    });\n    return /* @__PURE__ */jsxs(Fragment, {\n      children: [guide && /* @__PURE__ */jsx(CloneElement, {\n        element: guide,\n        active,\n        path: guidePath\n      }), /* @__PURE__ */jsx(MotionBar, {\n        arc: getArc,\n        custom: {\n          enter: data,\n          exit,\n          previousEnter: prev\n        },\n        transition,\n        fill: fill2,\n        className,\n        onMouseEnter: event => onMouseEnter == null ? void 0 : onMouseEnter({\n          value: data,\n          nativeEvent: event\n        }),\n        onMouseLeave: event => onMouseLeave == null ? void 0 : onMouseLeave({\n          value: data,\n          nativeEvent: event\n        }),\n        onClick: event => onClick == null ? void 0 : onClick({\n          value: data,\n          nativeEvent: event\n        })\n      })]\n    });\n  }, [active, className, data, getArc, getFill, guide, onClick, onMouseEnter, onMouseLeave, transition, yScale]);\n  return /* @__PURE__ */jsxs(Fragment, {\n    children: [renderBar(currentColorShade), gradient2 && /* @__PURE__ */jsx(Gradient, {\n      id: `${id}-gradient`,\n      color: currentColorShade\n    })]\n  });\n};\nRadialBar.defaultProps = {\n  gradient: true,\n  curved: false,\n  guide: /* @__PURE__ */jsx(RadialGuideBar, {}),\n  onClick: () => void 0,\n  onMouseEnter: () => void 0,\n  onMouseLeave: () => void 0\n};\nconst RadialBarSeries = ({\n  data,\n  id,\n  innerRadius,\n  outerRadius,\n  xScale,\n  yScale,\n  height,\n  width,\n  tooltip: tooltip2,\n  colorScheme,\n  bar: bar2,\n  animated,\n  startAngle,\n  endAngle,\n  type,\n  valueMarkers\n}) => {\n  const [activeValues, setActiveValues] = useState(null);\n  const isMultiSeries = useMemo(() => type === \"grouped\", [type]);\n  const renderBar = useCallback((point2, innerBarCount, index, barCount, groupIndex) => {\n    const active = activeValues && data && isEqual(activeValues.x, point2.x);\n    return /* @__PURE__ */jsx(Fragment, {\n      children: /* @__PURE__ */jsx(CloneElement, {\n        element: bar2,\n        id: `radialbar-${id}-${index}`,\n        index,\n        data: point2,\n        xScale,\n        active,\n        yScale,\n        innerRadius,\n        color: point22 => getColor({\n          data,\n          point: point22,\n          index: 0,\n          colorScheme\n        }),\n        barCount,\n        innerBarCount,\n        groupIndex,\n        animated,\n        startAngle,\n        endAngle\n      })\n    }, index);\n  }, [activeValues, animated, bar2, colorScheme, data, endAngle, id, innerRadius, startAngle, xScale, yScale]);\n  const renderBarGroup = useCallback((data2, innerBarCount, barCount, groupIndex) => {\n    return /* @__PURE__ */jsx(Fragment, {\n      children: data2.map((barData, barIndex) => renderBar(barData, innerBarCount, barIndex, barCount, groupIndex))\n    });\n  }, [renderBar]);\n  const renderValueMarkers = useCallback(() => /* @__PURE__ */jsx(Fragment$1, {\n    children: (valueMarkers == null ? void 0 : valueMarkers.length) && valueMarkers.map(marker2 => /* @__PURE__ */jsx(CloneElement, {\n      element: marker2,\n      value: yScale(marker2.props.value)\n    }, marker2.key))\n  }), [valueMarkers, yScale]);\n  return /* @__PURE__ */jsxs(CloneElement, {\n    element: tooltip2,\n    xScale,\n    yScale,\n    data,\n    height,\n    width,\n    isRadial: true,\n    innerRadius,\n    outerRadius,\n    onValueEnter: event => setActiveValues(event.value),\n    onValueLeave: () => setActiveValues(null),\n    color: (point2, index) => getColor({\n      data,\n      point: point2,\n      index,\n      colorScheme\n    }),\n    startAngle,\n    endAngle,\n    children: [isMultiSeries ? data.map((groupData, index) => /* @__PURE__ */jsx(\"g\", {\n      children: renderBarGroup(groupData.data, data.length, groupData.data.length, index)\n    }, `bar-group-${index}`)) : renderBarGroup(data, 1, data.length), renderValueMarkers()]\n  });\n};\nRadialBarSeries.defaultProps = {\n  colorScheme: schemes.cybertron[0],\n  tooltip: /* @__PURE__ */jsx(TooltipArea, {\n    tooltip: /* @__PURE__ */jsx(ChartTooltip, {\n      followCursor: true\n    })\n  }),\n  bar: /* @__PURE__ */jsx(RadialBar, {}),\n  animated: true,\n  startAngle: 0,\n  endAngle: 2 * Math.PI,\n  type: \"standard\"\n};\nconst RadialBarChart = ({\n  id,\n  width,\n  height,\n  margins,\n  className,\n  containerClassName,\n  data,\n  innerRadius,\n  series,\n  axis,\n  startAngle,\n  endAngle\n}) => {\n  const getXScale2 = useCallback(points => {\n    const isFullCircle = Math.abs(endAngle - startAngle) >= 2 * Math.PI;\n    let xScale;\n    if ((axis == null ? void 0 : axis.props.type) === \"category\") {\n      const isMultiSeries = series.props.type === \"grouped\";\n      let xDomain;\n      if (isMultiSeries) {\n        xDomain = uniqueBy(points, dd => dd.data, dd => dd.x);\n      } else {\n        xDomain = uniqueBy(points, dd => dd.x);\n      }\n      if (isFullCircle) {\n        xScale = scaleBand().range([0, 2 * Math.PI]).domain(xDomain);\n      } else {\n        xScale = scalePoint().range([startAngle, endAngle]).domain(xDomain);\n      }\n    } else {\n      const xDomain = uniqueBy(points, d => d.x);\n      xScale = scaleBand().range([startAngle, endAngle]).domain(xDomain);\n    }\n    return xScale;\n  }, [axis == null ? void 0 : axis.props.type, endAngle, series.props.type, startAngle]);\n  const getScales = useCallback((preData, innerRadius2, outerRadius) => {\n    const isMultiSeries = series.props.type === \"grouped\";\n    let newData;\n    if (isMultiSeries) {\n      newData = buildNestedChartData(preData, true);\n    } else {\n      newData = buildShallowChartData(preData);\n    }\n    const yDomain = getYDomain({\n      data: newData,\n      scaled: false\n    });\n    const yScale = getRadialYScale(innerRadius2, outerRadius, yDomain);\n    const xScale = getXScale2(newData);\n    return {\n      xScale,\n      yScale,\n      newData\n    };\n  }, [getXScale2, series.props.type]);\n  const renderChart = useCallback(({\n    chartWidth,\n    chartHeight,\n    id: id2\n  }) => {\n    const outerRadius = Math.min(chartWidth, chartHeight) / 2;\n    const {\n      yScale,\n      xScale,\n      newData\n    } = getScales(data, innerRadius, outerRadius);\n    return /* @__PURE__ */jsxs(Fragment, {\n      children: [axis && /* @__PURE__ */jsx(CloneElement, {\n        element: axis,\n        xScale,\n        height: chartHeight,\n        width: chartWidth,\n        innerRadius,\n        startAngle,\n        endAngle\n      }), /* @__PURE__ */jsx(CloneElement, {\n        element: series,\n        id: id2,\n        data: newData,\n        height: chartHeight,\n        width: chartWidth,\n        xScale,\n        yScale,\n        innerRadius,\n        outerRadius,\n        startAngle,\n        endAngle\n      })]\n    });\n  }, [axis, data, endAngle, getScales, innerRadius, series, startAngle]);\n  return /* @__PURE__ */jsx(ChartContainer, {\n    id,\n    width,\n    height,\n    margins,\n    xAxisVisible: false,\n    yAxisVisible: false,\n    center: true,\n    className,\n    containerClassName,\n    children: renderChart\n  });\n};\nRadialBarChart.defaultProps = {\n  innerRadius: 10,\n  margins: 75,\n  axis: /* @__PURE__ */jsx(RadialAxis, {}),\n  series: /* @__PURE__ */jsx(RadialBarSeries, {}),\n  startAngle: 0,\n  endAngle: 2 * Math.PI\n};\nconst RadialGaugeArc = ({\n  data,\n  gradient: gradient2,\n  startAngle,\n  id,\n  endAngle,\n  innerRadius,\n  outerRadius,\n  cornerRadius,\n  padAngle,\n  color,\n  animated,\n  disabled,\n  fill,\n  onClick,\n  onMouseEnter,\n  onMouseLeave,\n  tooltip: tooltip2\n}) => {\n  const arcGenerator = useMemo(() => {\n    return arc().innerRadius(innerRadius).outerRadius(outerRadius).cornerRadius(cornerRadius);\n  }, [innerRadius, outerRadius, cornerRadius]);\n  const arcElement = useMemo(() => {\n    const arcData = {\n      // @ts-ignore Data must be passed\n      data: data || {},\n      startAngle,\n      endAngle,\n      padAngle\n    };\n    return /* @__PURE__ */jsx(PieArc, {\n      id,\n      arc: arcGenerator,\n      data: arcData,\n      animated,\n      color,\n      gradient: gradient2,\n      disabled,\n      tooltip: tooltip2,\n      onClick,\n      onMouseEnter,\n      onMouseLeave\n    });\n  }, [id, arcGenerator, startAngle, endAngle, padAngle, data, animated, color, gradient2, disabled, tooltip2, onClick, onMouseEnter, onMouseLeave]);\n  return /* @__PURE__ */jsxs(\"g\", {\n    children: [fill && /* @__PURE__ */jsx(\"circle\", {\n      fill,\n      r: outerRadius\n    }), arcElement]\n  });\n};\nRadialGaugeArc.defaultProps = {\n  cornerRadius: 0,\n  padAngle: 0,\n  padRadius: 0,\n  color: \"#353d44\",\n  animated: true,\n  disabled: false,\n  tooltip: /* @__PURE__ */jsx(ChartTooltip, {})\n};\nconst valueLabel$2 = \"_valueLabel_1eyd5_1\";\nconst css$6 = {\n  valueLabel: valueLabel$2\n};\nconst RadialGaugeLabel = ({\n  data,\n  className,\n  offset,\n  onClick = () => void 0\n}) => {\n  const label2 = formatValue(data.key);\n  return /* @__PURE__ */jsx(\"text\", {\n    x: \"0\",\n    y: offset,\n    textAnchor: \"middle\",\n    alignmentBaseline: \"text-after-edge\",\n    onClick: nativeEvent => onClick({\n      data,\n      nativeEvent\n    }),\n    className: classNames(className, css$6.valueLabel),\n    children: label2\n  });\n};\nconst valueLabel$1 = \"_valueLabel_1h164_1\";\nconst css$5 = {\n  valueLabel: valueLabel$1\n};\nconst RadialGaugeValueLabel = ({\n  data,\n  className\n}) => {\n  const ref = useCount({\n    to: data.data\n  });\n  return /* @__PURE__ */jsx(\"text\", {\n    dy: \"-0.5em\",\n    x: \"0\",\n    y: \"15\",\n    textAnchor: \"middle\",\n    className: classNames(className, css$5.valueLabel),\n    ref\n  });\n};\nconst RadialGaugeOuterArc = props => /* @__PURE__ */jsx(RadialGaugeArc, {\n  ...props\n});\nRadialGaugeOuterArc.defaultProps = {\n  animated: false,\n  disabled: true\n};\nconst RadialGaugeSeries = ({\n  data,\n  scale: scale2,\n  startAngle,\n  endAngle,\n  arcWidth,\n  outerArc,\n  innerArc,\n  label: label2,\n  valueLabel: valueLabel2,\n  colorScheme,\n  id,\n  padding,\n  minGaugeWidth,\n  ...props\n}) => {\n  const {\n    columns,\n    width,\n    height,\n    xScale,\n    yScale\n  } = useMemo(() => {\n    let rows = 1;\n    let columns2 = data.length;\n    if (props.width / data.length < minGaugeWidth) {\n      while (props.width / columns2 < minGaugeWidth) {\n        rows += 1;\n        columns2 = Math.ceil(data.length / rows);\n      }\n    }\n    const xScale2 = scaleBand();\n    xScale2.domain(range(columns2));\n    xScale2.rangeRound([0, props.width], 0.1);\n    const yScale2 = scaleBand();\n    yScale2.domain(range(rows));\n    yScale2.rangeRound([0, props.height], 0.1);\n    return {\n      columns: columns2,\n      xScale: xScale2,\n      yScale: yScale2,\n      width: xScale2.bandwidth(),\n      height: yScale2.bandwidth()\n    };\n  }, [data.length, minGaugeWidth, props.height, props.width]);\n  const renderGauge = useCallback((point2, index) => {\n    var _a;\n    const dataEndAngle = scale2(point2.data);\n    const outerRadius = min([width - padding * 2, height - padding * 2]) / 2;\n    const innerRadius = outerRadius - arcWidth;\n    const labelOffset = height / 2;\n    const x = xScale(index % columns);\n    const y = yScale(Math.floor(index / columns));\n    const xOffset = x + width / 2;\n    const yOffset = y + height / 2;\n    const key = identifier((_a = point2.key) == null ? void 0 : _a.toLocaleString());\n    return /* @__PURE__ */jsxs(\"g\", {\n      transform: `translate(${xOffset}, ${yOffset})`,\n      children: [outerArc && cloneElement(outerArc, {\n        id: `${id}-${key}-outer`,\n        outerRadius,\n        innerRadius,\n        startAngle,\n        endAngle\n      }), innerArc && cloneElement(innerArc, {\n        id: `${id}-${key}-inner`,\n        outerRadius,\n        innerRadius,\n        startAngle,\n        endAngle: dataEndAngle,\n        data: point2,\n        color: getColor({\n          data,\n          colorScheme,\n          point: point2,\n          index\n        })\n      }), valueLabel2 && cloneElement(valueLabel2, {\n        data: point2\n      }), label2 && cloneElement(label2, {\n        data: point2,\n        offset: labelOffset\n      })]\n    }, key);\n  }, [id, arcWidth, colorScheme, columns, data, endAngle, height, innerArc, label2, outerArc, padding, scale2, startAngle, valueLabel2, width, xScale, yScale]);\n  return /* @__PURE__ */jsx(Fragment, {\n    children: data.map(renderGauge)\n  });\n};\nRadialGaugeSeries.defaultProps = {\n  arcWidth: 5,\n  outerArc: /* @__PURE__ */jsx(RadialGaugeOuterArc, {}),\n  innerArc: /* @__PURE__ */jsx(RadialGaugeArc, {}),\n  label: /* @__PURE__ */jsx(RadialGaugeLabel, {}),\n  valueLabel: /* @__PURE__ */jsx(RadialGaugeValueLabel, {}),\n  colorScheme: [\"#00ECB1\"],\n  padding: 20,\n  minGaugeWidth: 50\n};\nconst RadialGaugeStackedArc = ({\n  id,\n  data,\n  scale: scale2,\n  innerRadius,\n  outerRadius,\n  cornerRadius,\n  padAngle,\n  startAngle,\n  colorScheme,\n  ...restProps\n}) => {\n  const arcGenerator = useMemo(() => {\n    return arc().innerRadius(innerRadius).outerRadius(outerRadius).cornerRadius(cornerRadius);\n  }, [innerRadius, outerRadius, cornerRadius]);\n  const stackedArcs = useMemo(() => {\n    let prevEndAngle = startAngle;\n    function renderArc(point2, index) {\n      const value2 = point2.data;\n      const startArcAngle = prevEndAngle;\n      const endArcAngle = startArcAngle + scale2(value2) - startAngle;\n      prevEndAngle = endArcAngle;\n      const arcData = {\n        data: point2,\n        startAngle: startArcAngle,\n        endAngle: endArcAngle,\n        padAngle,\n        value: value2,\n        index\n      };\n      const color = getColor({\n        colorScheme,\n        data: [data],\n        point: point2,\n        index,\n        active: [data],\n        isMultiSeries: true\n      });\n      return /* @__PURE__ */createElement(PieArc, {\n        ...restProps,\n        id: point2.key.toLocaleString(),\n        key: point2.key.toLocaleString(),\n        arc: arcGenerator,\n        data: arcData,\n        color\n      });\n    }\n    return data.data.map(renderArc);\n  }, [arcGenerator, colorScheme, data, padAngle, restProps, scale2, startAngle]);\n  return /* @__PURE__ */jsx(\"g\", {\n    children: stackedArcs\n  }, id);\n};\nRadialGaugeStackedArc.defaultProps = {\n  cornerRadius: 0,\n  padAngle: 0,\n  padRadius: 0,\n  animated: true,\n  disabled: false,\n  tooltip: /* @__PURE__ */jsx(ChartTooltip, {})\n};\nconst stackedValueLabel = \"_stackedValueLabel_1w6zx_1\";\nconst css$4 = {\n  stackedValueLabel\n};\nconst StackedRadialGaugeValueLabel = ({\n  label: label2,\n  className,\n  yOffset\n}) => /* @__PURE__ */jsx(Fragment$1, {\n  children: label2 && /* @__PURE__ */jsx(\"text\", {\n    x: \"0\",\n    y: yOffset,\n    textAnchor: \"middle\",\n    alignmentBaseline: \"middle\",\n    className: classNames(className, css$4.stackedValueLabel),\n    children: label2\n  })\n});\nStackedRadialGaugeValueLabel.defaultProps = {\n  yOffset: 0\n};\nconst isChartNestedData = point2 => {\n  return Array.isArray(point2.data);\n};\nconst StackedRadialGaugeSeries = ({\n  data,\n  width,\n  height,\n  scale: scale2,\n  startAngle,\n  endAngle,\n  outerArc,\n  innerArc,\n  stackedInnerArc,\n  label: label2,\n  descriptionLabel,\n  colorScheme,\n  fillFactor,\n  arcPadding\n}) => {\n  const radius = Math.min(width, height) / 2;\n  const innerRadius = radius * (1 - Math.min(fillFactor, 1));\n  const rAxis = scaleBand().domain(range(data.length)).range([innerRadius, radius]).paddingInner(arcPadding);\n  const renderOuterArc = useCallback((outerRadius, innerRadius2) => {\n    return outerArc && cloneElement(outerArc, {\n      outerRadius,\n      innerRadius: innerRadius2,\n      startAngle,\n      endAngle\n    });\n  }, [outerArc, startAngle, endAngle]);\n  const renderInnerArc = useCallback((outerRadius, innerRadius2, dataEndAngle, point2, index) => {\n    const color = getColor({\n      data,\n      colorScheme,\n      point: point2,\n      index\n    });\n    return innerArc && cloneElement(innerArc, {\n      outerRadius,\n      innerRadius: innerRadius2,\n      startAngle,\n      endAngle: dataEndAngle,\n      data: point2,\n      color\n    });\n  }, [innerArc, startAngle, data, colorScheme]);\n  const renderStackedArc = useCallback((outerRadius, innerRadius2, point2, index) => {\n    return /* @__PURE__ */jsx(Fragment$1, {\n      children: stackedInnerArc && cloneElement(stackedInnerArc, {\n        outerRadius,\n        innerRadius: innerRadius2,\n        colorScheme,\n        startAngle,\n        scale: (scale2 == null ? void 0 : scale2[index]) ?? (scale2 == null ? void 0 : scale2[index]) ?? scale2,\n        data: point2\n      })\n    });\n  }, [stackedInnerArc, colorScheme, startAngle, scale2]);\n  const renderStackedGauges = useCallback((point2, index) => {\n    var _a, _b;\n    const outerRadius = rAxis(index);\n    const innerRadius2 = outerRadius - rAxis.bandwidth();\n    return /* @__PURE__ */jsxs(\"g\", {\n      children: [renderOuterArc(outerRadius, innerRadius2), isChartNestedData(point2) ? renderStackedArc(outerRadius, innerRadius2, point2, index) : renderInnerArc(outerRadius, innerRadius2, ((_a = scale2 == null ? void 0 : scale2[index]) == null ? void 0 : _a.call(scale2, point2.data)) ?? ((_b = scale2 == null ? void 0 : scale2[0]) == null ? void 0 : _b.call(scale2, point2.data)) ?? scale2(point2.data), point2, index)]\n    }, point2.key.toLocaleString());\n  }, [rAxis, renderOuterArc, renderStackedArc, renderInnerArc, scale2]);\n  return /* @__PURE__ */jsx(Fragment$1, {\n    children: /* @__PURE__ */jsxs(\"g\", {\n      transform: `translate(${width / 2}, ${height / 2})`,\n      children: [data.map(renderStackedGauges), descriptionLabel, label2]\n    })\n  });\n};\nStackedRadialGaugeSeries.defaultProps = {\n  outerArc: /* @__PURE__ */jsx(RadialGaugeArc, {\n    disabled: true,\n    animated: false\n  }),\n  innerArc: /* @__PURE__ */jsx(RadialGaugeArc, {\n    animated: true\n  }),\n  stackedInnerArc: /* @__PURE__ */jsx(RadialGaugeStackedArc, {\n    animated: true\n  }),\n  label: /* @__PURE__ */jsx(StackedRadialGaugeValueLabel, {}),\n  colorScheme: [\"#00ECB1\"],\n  fillFactor: 0.2,\n  arcPadding: 0.15\n};\nconst stackedDescriptionLabel = \"_stackedDescriptionLabel_1h95t_1\";\nconst css$3 = {\n  stackedDescriptionLabel\n};\nconst StackedRadialGaugeDescriptionLabel = ({\n  label: label2,\n  className,\n  yOffset\n}) => /* @__PURE__ */jsx(Fragment$1, {\n  children: label2 && /* @__PURE__ */jsx(\"text\", {\n    x: \"0\",\n    y: yOffset - 20,\n    textAnchor: \"middle\",\n    alignmentBaseline: \"middle\",\n    className: classNames(className, css$3.stackedDescriptionLabel),\n    children: label2\n  })\n});\nStackedRadialGaugeDescriptionLabel.defaultProps = {\n  yOffset: 0\n};\nconst RadialGauge = ({\n  id,\n  width,\n  height,\n  margins,\n  className,\n  data,\n  minValue,\n  maxValue,\n  startAngle,\n  endAngle,\n  series,\n  containerClassName\n}) => {\n  const newId = useId(id);\n  const renderSeries = useCallback(({\n    chartHeight,\n    chartWidth\n  }) => {\n    let scale2;\n    if (Array.isArray(maxValue)) {\n      scale2 = maxValue.map((max2, index) => scaleLinear().domain([(minValue == null ? void 0 : minValue[index]) ?? (minValue == null ? void 0 : minValue[0]) ?? minValue, max2]).range([startAngle, endAngle]));\n    } else if (Array.isArray(minValue)) {\n      scale2 = minValue.map((min2, index) => scaleLinear().domain([min2, (maxValue == null ? void 0 : maxValue[index]) ?? (maxValue == null ? void 0 : maxValue[0]) ?? maxValue]).range([startAngle, endAngle]));\n    } else {\n      scale2 = scaleLinear().domain([minValue, maxValue]).range([startAngle, endAngle]);\n    }\n    return cloneElement(series, {\n      id: newId,\n      scale: scale2,\n      data,\n      startAngle,\n      endAngle,\n      width: chartWidth,\n      height: chartHeight\n    });\n  }, [data, endAngle, maxValue, minValue, series, startAngle, newId]);\n  return /* @__PURE__ */jsx(ChartContainer, {\n    id,\n    width,\n    height,\n    margins,\n    xAxisVisible: false,\n    yAxisVisible: false,\n    className,\n    containerClassName,\n    children: renderSeries\n  });\n};\nRadialGauge.defaultProps = {\n  minValue: 0,\n  maxValue: 100,\n  startAngle: 0,\n  endAngle: Math.PI * 2,\n  series: /* @__PURE__ */jsx(RadialGaugeSeries, {})\n};\nconst cell = \"_cell_r3f8c_1\";\nconst css$2 = {\n  cell\n};\nconst modifiers = {\n  offset: {\n    offset: \"0, 3px\"\n  }\n};\nconst HeatmapCell = ({\n  rx,\n  ry,\n  cursor,\n  tooltip: tooltip2,\n  onClick,\n  onMouseEnter,\n  onMouseLeave,\n  data,\n  animated,\n  cellIndex,\n  cellCount,\n  fill,\n  stroke,\n  symbol: symbol2,\n  x,\n  y,\n  style,\n  className,\n  ...rest\n}) => {\n  const [active, setActive] = useState(false);\n  const rect = useRef(null);\n  const {\n    pointerOut,\n    pointerOver\n  } = useHoverIntent({\n    onPointerOver: event => {\n      setActive(true);\n      onMouseEnter({\n        value: data,\n        nativeEvent: event\n      });\n    },\n    onPointerOut: event => {\n      setActive(false);\n      onMouseLeave({\n        value: data,\n        nativeEvent: event\n      });\n    }\n  });\n  const onMouseClick = event => {\n    onClick({\n      value: data,\n      nativeEvent: event\n    });\n  };\n  const tooltipData = useMemo(() => ({\n    y: data.value,\n    x: `${data.key}  ${data.x}`,\n    data\n  }), [data]);\n  const transition = useMemo(() => {\n    if (animated) {\n      return {\n        ...DEFAULT_TRANSITION,\n        delay: cellIndex / cellCount * 5e-3\n      };\n    } else {\n      return {\n        type: false,\n        delay: 0\n      };\n    }\n  }, [animated, cellIndex, cellCount]);\n  const extras = constructFunctionProps({\n    style,\n    className\n  }, data);\n  const isTransparent = fill === \"transparent\";\n  const appliedStroke = active && !isTransparent ? chroma(stroke || fill).brighten(1) : stroke || fill;\n  const ariaLabelData = useMemo(() => getAriaLabel({\n    ...tooltipData,\n    data: null\n  }), [tooltipData]);\n  const renderedSymbol = useMemo(() => symbol2 ? symbol2(data) : null, [data, symbol2]);\n  return /* @__PURE__ */jsxs(Fragment, {\n    children: [/* @__PURE__ */jsx(\"g\", {\n      ref: rect,\n      children: renderedSymbol ? /* @__PURE__ */jsx(motion.g, {\n        ...rest,\n        fill,\n        stroke: appliedStroke,\n        style: {\n          ...extras.style,\n          cursor\n        },\n        className: extras == null ? void 0 : extras.className,\n        transform: `translate(${x}, ${y})`,\n        initial: {\n          opacity: 0\n        },\n        animate: {\n          opacity: 1\n        },\n        exit: {\n          opacity: 0\n        },\n        transition,\n        onPointerOver: pointerOver,\n        onPointerOut: pointerOut,\n        onClick: onMouseClick,\n        tabIndex: 0,\n        \"aria-label\": ariaLabelData,\n        role: \"graphics-document\",\n        children: renderedSymbol\n      }) : /* @__PURE__ */jsx(motion.rect, {\n        ...rest,\n        fill,\n        stroke: appliedStroke,\n        x,\n        y,\n        rx,\n        ry,\n        style: {\n          ...extras.style,\n          cursor\n        },\n        className: classNames(css$2.cell, extras.className),\n        initial: {\n          opacity: 0\n        },\n        animate: {\n          opacity: 1\n        },\n        exit: {\n          opacity: 0\n        },\n        transition,\n        onPointerOver: pointerOver,\n        onPointerOut: pointerOut,\n        onClick: onMouseClick,\n        tabIndex: 0,\n        \"aria-label\": ariaLabelData,\n        role: \"graphics-document\"\n      })\n    }), tooltip2 && !tooltip2.props.disabled && !isTransparent && /* @__PURE__ */jsx(CloneElement, {\n      element: tooltip2,\n      visible: active,\n      modifiers: tooltip2.props.modifiers || modifiers,\n      reference: rect,\n      value: tooltipData\n    })]\n  });\n};\nHeatmapCell.defaultProps = {\n  rx: 2,\n  ry: 2,\n  cursor: \"auto\",\n  tooltip: /* @__PURE__ */jsx(ChartTooltip, {}),\n  onClick: () => void 0,\n  onMouseEnter: () => void 0,\n  onMouseLeave: () => void 0\n};\nconst HeatmapSeries = ({\n  animated,\n  emptyColor,\n  colorScheme,\n  cell: cellElement,\n  xScale,\n  yScale,\n  data,\n  id,\n  selections\n}) => {\n  const valueScales = createColorSchemeValueScales(data, colorScheme, emptyColor, selections);\n  const height = yScale.bandwidth();\n  const width = xScale.bandwidth();\n  const cellCount = [...yScale.domain(), ...xScale.domain()].length;\n  const renderCell = ({\n    row,\n    cell: cell2,\n    rowIndex,\n    cellIndex,\n    width: width2,\n    height: height2,\n    cellCount: cellCount2\n  }) => {\n    const x = xScale(row.key);\n    const y = yScale(cell2.x);\n    const style = getColorSchemeStyles(cell2, valueScales);\n    return /* @__PURE__ */jsx(CloneElement, {\n      element: cellElement,\n      animated,\n      cellIndex: rowIndex + cellIndex,\n      cellCount: cellCount2,\n      x,\n      y,\n      fill: style == null ? void 0 : style.fill,\n      stroke: style == null ? void 0 : style.stroke,\n      width: width2,\n      height: height2,\n      data: cell2,\n      style\n    }, `${id}-${rowIndex}-${cellIndex}`);\n  };\n  return /* @__PURE__ */jsx(Fragment, {\n    children: data.map((row, rowIndex) => row.data.map((cell2, cellIndex) => renderCell({\n      height,\n      width,\n      cellCount,\n      row,\n      cell: cell2,\n      rowIndex,\n      cellIndex\n    })))\n  });\n};\nHeatmapSeries.defaultProps = {\n  padding: 0.1,\n  animated: true,\n  emptyColor: \"rgba(200,200,200,0.08)\",\n  colorScheme: [\"rgba(28, 107, 86, 0.5)\", \"#2da283\"],\n  cell: /* @__PURE__ */jsx(HeatmapCell, {})\n};\nconst Heatmap = ({\n  data,\n  margins,\n  series,\n  yAxis,\n  xAxis,\n  secondaryAxis,\n  id,\n  width,\n  height,\n  className,\n  containerClassName\n}) => {\n  const getScalesData = useCallback((chartHeight, chartWidth) => {\n    const nestedData = buildNestedChartData(data);\n    const xDomain = xAxis.props.domain || uniqueBy(nestedData, d => d.key);\n    const xScale = scaleBand().range([0, chartWidth]).domain(xDomain).paddingInner(series.props.padding || 0.1);\n    const yDomain = yAxis.props.domain || uniqueBy(nestedData, d => d.data, d => d.x);\n    const yScale = scaleBand().domain(yDomain).range([chartHeight, 0]).paddingInner(series.props.padding || 0.1);\n    return {\n      yScale,\n      xScale,\n      data: nestedData\n    };\n  }, [data, xAxis, yAxis, series]);\n  const renderChart = useCallback(containerProps => {\n    const {\n      chartWidth,\n      chartHeight,\n      updateAxes,\n      id: id2,\n      chartSized\n    } = containerProps;\n    const {\n      xScale,\n      yScale,\n      data: scalesData\n    } = getScalesData(chartHeight, chartWidth);\n    return /* @__PURE__ */jsxs(Fragment, {\n      children: [/* @__PURE__ */jsx(CloneElement, {\n        element: xAxis,\n        height: chartHeight,\n        width: chartWidth,\n        scale: xScale,\n        visibility: chartSized ? \"visible\" : \"hidden\",\n        onDimensionsChange: event => updateAxes(\"horizontal\", event)\n      }), /* @__PURE__ */jsx(CloneElement, {\n        element: yAxis,\n        height: chartHeight,\n        width: chartWidth,\n        scale: yScale,\n        visibility: chartSized ? \"visible\" : \"hidden\",\n        onDimensionsChange: event => updateAxes(\"vertical\", event)\n      }), secondaryAxis && secondaryAxis.map((axis, i) => /* @__PURE__ */jsx(CloneElement, {\n        element: axis,\n        height: chartHeight,\n        width: chartWidth,\n        visibility: chartSized ? \"visible\" : \"hidden\",\n        onDimensionsChange: event => updateAxes(\"horizontal\", event)\n      }, i)), chartSized && /* @__PURE__ */jsx(CloneElement, {\n        element: series,\n        id: `heat-series-${id2}`,\n        data: scalesData,\n        xScale,\n        yScale\n      })]\n    });\n  }, [getScalesData, secondaryAxis, series, xAxis, yAxis]);\n  return /* @__PURE__ */jsx(ChartContainer, {\n    id,\n    width,\n    height,\n    margins,\n    containerClassName,\n    xAxisVisible: isAxisVisible(xAxis.props),\n    yAxisVisible: isAxisVisible(yAxis.props),\n    className,\n    children: renderChart\n  });\n};\nHeatmap.defaultProps = {\n  data: [],\n  margins: 10,\n  series: /* @__PURE__ */jsx(HeatmapSeries, {\n    padding: 0.3\n  }),\n  yAxis: /* @__PURE__ */jsx(LinearYAxis, {\n    type: \"category\",\n    axisLine: null,\n    tickSeries: /* @__PURE__ */jsx(LinearYAxisTickSeries, {\n      line: null,\n      label: /* @__PURE__ */jsx(LinearYAxisTickLabel, {\n        padding: 5\n      })\n    })\n  }),\n  xAxis: /* @__PURE__ */jsx(LinearXAxis, {\n    type: \"category\",\n    axisLine: null,\n    tickSeries: /* @__PURE__ */jsx(LinearXAxisTickSeries, {\n      line: null,\n      label: /* @__PURE__ */jsx(LinearXAxisTickLabel, {\n        padding: 5\n      })\n    })\n  })\n};\nconst getFirstOfMonth = date => new Date(date.getFullYear(), date.getMonth(), 1);\nconst addWeeksToDate = (date, weeks) => {\n  const d = new Date(date.getTime());\n  d.setDate(d.getDate() + weeks * 7);\n  return d;\n};\nconst getStartOfDay = date => {\n  const d = new Date(date.getTime());\n  d.setHours(0, 0, 0, 0);\n  return d;\n};\nconst getNewDayFromDay = (date, num) => {\n  const d = new Date(date.getTime());\n  d.setDate(d.getDate() + num);\n  return d;\n};\nconst weekDays = (() => {\n  const base2 = new Date(Date.UTC(2017, 0, 2));\n  return range(7).map(() => {\n    const name = base2.toLocaleDateString(\"default\", {\n      weekday: \"short\"\n    });\n    base2.setDate(base2.getDate() + 1);\n    return name;\n  });\n})();\nconst buildDataScales = (rawData, view) => {\n  const startDate = min(rawData, d => d.key) || /* @__PURE__ */new Date();\n  const start2 = getFirstOfMonth(startDate);\n  const endDomain = view === \"year\" ? 53 : 5;\n  const end2 = addWeeksToDate(start2, endDomain);\n  const xDomainRange = view === \"year\" ? 53 : 5;\n  const yDomain = range(7).reverse();\n  const xDomain = range(xDomainRange);\n  const dates = rawData.filter(d => d.key.getTime() > start2.getTime() || d.key.getTime() < end2.getTime()).map(d => ({\n    key: getStartOfDay(d.key),\n    data: d.data\n  }));\n  const firstDayOfStart = start2.getDay();\n  const curDate = getNewDayFromDay(start2, -firstDayOfStart);\n  const rows = [];\n  for (let week = 0; week < xDomainRange; week++) {\n    const row = {\n      key: week,\n      data: []\n    };\n    for (let day = 0; day <= 6; day++) {\n      const dayValue = dates.find(d => d.key.getTime() === curDate.getTime());\n      row.data.push({\n        key: day,\n        data: (dayValue == null ? void 0 : dayValue.data) ?? void 0,\n        metadata: {\n          date: new Date(curDate.getTime()),\n          start: start2,\n          end: end2\n        }\n      });\n      curDate.setDate(curDate.getDate() + 1);\n    }\n    rows.push(row);\n  }\n  return {\n    data: rows,\n    yDomain,\n    xDomain,\n    start: start2\n  };\n};\nconst xAxisLabelFormat = start2 => weeks => addWeeksToDate(start2, weeks).toLocaleString(\"default\", {\n  month: \"long\"\n});\nconst CalendarHeatmap = ({\n  view,\n  data,\n  ...rest\n}) => {\n  const {\n    data: domainData,\n    yDomain,\n    xDomain,\n    start: start2\n  } = useMemo(() => buildDataScales(data, view), [data, view]);\n  const xTickValues = view === \"year\" ? void 0 : [1];\n  const yAxisLabelFormat = view === \"year\" ? d => weekDays[d] : () => null;\n  return /* @__PURE__ */jsx(Heatmap, {\n    ...rest,\n    data: domainData,\n    yAxis: /* @__PURE__ */jsx(LinearYAxis, {\n      type: \"category\",\n      axisLine: null,\n      domain: yDomain,\n      tickSeries: /* @__PURE__ */jsx(LinearYAxisTickSeries, {\n        tickSize: 20,\n        line: null,\n        label: /* @__PURE__ */jsx(LinearYAxisTickLabel, {\n          padding: 5,\n          format: yAxisLabelFormat\n        })\n      })\n    }),\n    xAxis: /* @__PURE__ */jsx(LinearXAxis, {\n      type: \"category\",\n      axisLine: null,\n      domain: xDomain,\n      tickSeries: /* @__PURE__ */jsx(LinearXAxisTickSeries, {\n        line: null,\n        tickValues: xTickValues,\n        label: /* @__PURE__ */jsx(LinearXAxisTickLabel, {\n          padding: 5,\n          align: \"end\",\n          format: xAxisLabelFormat(start2)\n        })\n      })\n    })\n  });\n};\nCalendarHeatmap.defaultProps = {\n  view: \"year\",\n  series: /* @__PURE__ */jsx(HeatmapSeries, {\n    padding: 0.3,\n    emptyColor: \"transparent\",\n    cell: /* @__PURE__ */jsx(HeatmapCell, {\n      tooltip: /* @__PURE__ */jsx(ChartTooltip, {\n        content: d => `${formatValue(d.data.metadata.date)}  ${formatValue(d.data.value)}`\n      })\n    })\n  })\n};\nconst LinearGaugeBar = props => /* @__PURE__ */jsx(Bar, {\n  ...props\n});\nLinearGaugeBar.defaultProps = {\n  tooltip: /* @__PURE__ */jsx(ChartTooltip, {\n    placement: \"top\",\n    content: data => /* @__PURE__ */jsx(TooltipTemplate, {\n      value: {\n        y: data.value,\n        x: data.y\n      }\n    })\n  })\n};\nconst LinearGaugeOuterBar = ({\n  height,\n  width,\n  fill,\n  ...rest\n}) => /* @__PURE__ */jsx(\"rect\", {\n  ...rest,\n  fill,\n  width: Math.max(width, 0),\n  height: Math.max(height, 0)\n});\nLinearGaugeOuterBar.defaultProps = {\n  fill: \"#484848\"\n};\nconst LinearGaugeSeries = ({\n  height,\n  width,\n  bar: bar2,\n  outerBar: outerBar2,\n  isMultiSeries,\n  ...rest\n}) => /* @__PURE__ */jsxs(Fragment, {\n  children: [!isMultiSeries && outerBar2 && /* @__PURE__ */jsx(CloneElement, {\n    element: outerBar2,\n    height,\n    width\n  }), /* @__PURE__ */jsx(BarSeries, {\n    ...rest,\n    layout: \"horizontal\",\n    tooltip: null,\n    bar: /* @__PURE__ */jsx(CloneElement, {\n      element: bar2\n    })\n  })]\n});\nLinearGaugeSeries.defaultProps = {\n  outerBar: /* @__PURE__ */jsx(LinearGaugeOuterBar, {}),\n  bar: /* @__PURE__ */jsx(LinearGaugeBar, {})\n};\nconst LinearGauge = ({\n  id,\n  width,\n  height,\n  margins,\n  className,\n  containerClassName,\n  series,\n  data,\n  minValue,\n  maxValue\n}) => {\n  const transformedData = useMemo(() => {\n    if (Array.isArray(data)) {\n      return buildBarStackData([{\n        key: \"default\",\n        data\n      }], \"expand\", \"horizontal\");\n    } else {\n      return buildShallowChartData([data], \"horizontal\");\n    }\n  }, [data]);\n  const getScales = useCallback((isMultiSeries, data2, width2, height2, minValue2, maxValue2) => {\n    const domain = !isMultiSeries ? [minValue2, maxValue2] : void 0;\n    const keyScale = getXScale({\n      width: width2,\n      type: \"value\",\n      data: data2,\n      domain,\n      isMultiSeries\n    });\n    const valueScale = getYScale({\n      type: \"category\",\n      height: height2,\n      data: data2,\n      isMultiSeries\n    });\n    return {\n      keyScale,\n      valueScale\n    };\n  }, []);\n  const renderChart = useCallback(({\n    chartHeight,\n    chartWidth,\n    id: id2,\n    chartSized\n  }) => {\n    const isMultiSeries = Array.isArray(data);\n    const type = isMultiSeries ? \"stackedNormalized\" : \"standard\";\n    const {\n      keyScale,\n      valueScale\n    } = getScales(isMultiSeries, transformedData, chartWidth, chartHeight, minValue, maxValue);\n    return /* @__PURE__ */jsx(Fragment, {\n      children: chartSized && /* @__PURE__ */jsx(CloneElement, {\n        element: series,\n        id: `linear-gauge-series-${id2}`,\n        data: transformedData,\n        isCategorical: true,\n        xScale: keyScale,\n        yScale: valueScale,\n        type,\n        height: chartHeight,\n        width: chartWidth,\n        isMultiSeries\n      })\n    });\n  }, [data, getScales, maxValue, minValue, series, transformedData]);\n  return /* @__PURE__ */jsx(ChartContainer, {\n    id,\n    width,\n    height,\n    margins,\n    className,\n    containerClassName,\n    children: renderChart\n  });\n};\nLinearGauge.defaultProps = {\n  minValue: 0,\n  maxValue: 100,\n  series: /* @__PURE__ */jsx(LinearGaugeSeries, {})\n};\nconst useInterpolate = ({\n  data,\n  animated\n}) => {\n  const transition = animated ? {\n    ...DEFAULT_TRANSITION\n  } : {\n    delay: 0,\n    type: false\n  };\n  const d = useMotionValue(data.path);\n  const spring = useSpring(0, {\n    stiffness: 300,\n    damping: 30\n  });\n  useEffect(() => {\n    const interpolator = interpolate$1(d.get(), data.path);\n    const prevSpring = spring.get();\n    spring.set(1 + prevSpring);\n    return spring.on(\"change\", v => d.set(interpolator(v - prevSpring)));\n  }, [d, data.path, spring]);\n  return {\n    transition,\n    d\n  };\n};\nconst VennArc = ({\n  data,\n  fill,\n  disabled,\n  animated,\n  stroke,\n  mask,\n  id,\n  style,\n  active,\n  inactiveStyle,\n  activeStyle,\n  initialStyle,\n  strokeWidth,\n  gradient: gradient2,\n  glow,\n  tooltip: tooltip2,\n  onClick,\n  onMouseEnter,\n  onMouseLeave\n}) => {\n  const [internalActive, setInternalActive] = useState(false);\n  const arcRef = useRef(null);\n  const {\n    transition,\n    d\n  } = useInterpolate({\n    animated,\n    data\n  });\n  const currentStyle = active ? activeStyle : active === null ? inactiveStyle : initialStyle;\n  const arcFill = gradient2 && !mask ? `url(#gradient-${id})` : mask ? `url(#mask-pattern-${id})` : fill;\n  const {\n    pointerOut,\n    pointerOver\n  } = useHoverIntent({\n    onPointerOver: event => {\n      if (!disabled) {\n        setInternalActive(true);\n        onMouseEnter == null ? void 0 : onMouseEnter({\n          value: data.data,\n          nativeEvent: event\n        });\n      }\n    },\n    onPointerOut: event => {\n      if (!disabled) {\n        setInternalActive(false);\n        onMouseLeave == null ? void 0 : onMouseLeave({\n          value: data.data,\n          nativeEvent: event\n        });\n      }\n    }\n  });\n  const tooltipData = useMemo(() => {\n    var _a, _b;\n    return {\n      y: data.data.size,\n      x: (_b = (_a = data.data) == null ? void 0 : _a.sets) == null ? void 0 : _b.join(\" | \")\n    };\n  }, [data]);\n  const ariaLabelData = useMemo(() => getAriaLabel(tooltipData), [tooltipData]);\n  return /* @__PURE__ */jsxs(\"g\", {\n    title: data.data.key,\n    onPointerOver: pointerOver,\n    onPointerOut: pointerOut,\n    onClick: event => {\n      if (!disabled) {\n        onClick == null ? void 0 : onClick({\n          value: data.data,\n          nativeEvent: event\n        });\n      }\n    },\n    tabIndex: 0,\n    \"aria-label\": ariaLabelData,\n    role: \"graphics-document\",\n    children: [/* @__PURE__ */jsx(motion.path, {\n      ref: arcRef,\n      fill: arcFill,\n      id: `${id}-arc`,\n      strokeWidth,\n      stroke,\n      transition,\n      d,\n      initial: initialStyle,\n      animate: currentStyle,\n      style: {\n        ...style,\n        ...generateGlowStyles({\n          glow,\n          colorSchemeColor: typeof stroke === \"string\" ? stroke : null\n        })\n      }\n    }), mask && /* @__PURE__ */jsxs(Fragment, {\n      children: [/* @__PURE__ */jsx(Mask, {\n        id: `mask-${id}`,\n        fill: `url(#gradient-${id})`\n      }), /* @__PURE__ */jsx(CloneElement, {\n        element: mask,\n        id: `mask-pattern-${id}`,\n        fill\n      })]\n    }), gradient2 && /* @__PURE__ */jsx(CloneElement, {\n      element: gradient2,\n      id: `gradient-${id}`,\n      color: fill\n    }), tooltip2 && !tooltip2.props.disabled && /* @__PURE__ */jsx(CloneElement, {\n      element: tooltip2,\n      visible: !!internalActive,\n      reference: arcRef,\n      value: tooltipData\n    })]\n  });\n};\nVennArc.defaultProps = {\n  active: false,\n  inactiveStyle: {\n    opacity: 0.3\n  },\n  activeStyle: {\n    opacity: 0.8\n  },\n  initialStyle: {\n    opacity: 0.6\n  },\n  strokeWidth: 3,\n  gradient: /* @__PURE__ */jsx(Gradient, {}),\n  tooltip: /* @__PURE__ */jsx(ChartTooltip, {}),\n  onClick: () => void 0,\n  onMouseEnter: () => void 0,\n  onMouseLeave: () => void 0\n};\nconst VennLabel = ({\n  data,\n  format,\n  id,\n  active,\n  labelType,\n  showAll,\n  wrap,\n  animated,\n  fill,\n  fontSize,\n  fontFamily\n}) => {\n  var _a, _b, _c, _d, _e;\n  if (!showAll && !((_a = data.arcs) == null ? void 0 : _a.filter(a => a.large).length)) {\n    return null;\n  }\n  const key = labelType === \"key\" ? (_c = (_b = data.data) == null ? void 0 : _b.sets) == null ? void 0 : _c.join(\" | \") : data.data.size;\n  const transition = animated ? DEFAULT_TRANSITION : {\n    delay: 0,\n    type: false\n  };\n  const text = wrap ? wrapText({\n    key,\n    x: data.text.x,\n    fontFamily,\n    fontSize,\n    width: (_e = (_d = data == null ? void 0 : data.circles) == null ? void 0 : _d[0]) == null ? void 0 : _e.radius\n  }) : key;\n  return /* @__PURE__ */jsx(motion.text, {\n    id: `${id}-text`,\n    fill,\n    pointerEvents: \"none\",\n    fontFamily,\n    fontSize,\n    initial: {\n      attrX: data.text.x,\n      attrY: data.text.y,\n      opacity: 1\n    },\n    animate: {\n      attrX: data.text.x,\n      attrY: data.text.y,\n      opacity: active === null ? 0.3 : 1\n    },\n    transition,\n    textAnchor: \"middle\",\n    children: format ? format(data) : text\n  });\n};\nVennLabel.defaultProps = {\n  labelType: \"key\",\n  showAll: false,\n  wrap: true,\n  animated: true,\n  fontSize: 11,\n  fontFamily: \"sans-serif\"\n};\nconst VennOuterLabel = ({\n  data,\n  format,\n  animated,\n  fill,\n  fontSize,\n  fontFamily\n}) => {\n  const transition = animated ? DEFAULT_TRANSITION : {\n    delay: 0,\n    type: false\n  };\n  const text = data.set.data.key;\n  const label2 = format ? format(data) : text;\n  const isElement = isValidElement(label2);\n  const showIcon = isElement && data.set.icon;\n  const pos = {\n    x: showIcon ? data.set.icon.x : data.set.text.x,\n    y: showIcon ? data.set.icon.y : data.set.text.y\n  };\n  return /* @__PURE__ */jsx(Fragment, {\n    children: isElement ? /* @__PURE__ */jsx(\"g\", {\n      style: {\n        transform: `translate(${pos.x}px, ${pos.y}px)`\n      },\n      children: label2\n    }) : /* @__PURE__ */jsx(motion.text, {\n      fill,\n      style: {\n        pointerEvents: \"none\",\n        fontFamily,\n        fontSize\n      },\n      textAnchor: data.set.align === \"middle\" ? \"center\" : data.set.align,\n      alignmentBaseline: data.set.verticalAlign,\n      initial: {\n        attrX: pos.x,\n        attrY: pos.y\n      },\n      animate: {\n        attrX: pos.x,\n        attrY: pos.y\n      },\n      transition,\n      children: label2\n    })\n  });\n};\nVennOuterLabel.defaultProps = {\n  animated: true,\n  fill: \"#000\",\n  fontSize: 14,\n  fontFamily: \"sans-serif\"\n};\nconst VennSeries = ({\n  data,\n  id,\n  selections,\n  animated,\n  disabled,\n  colorScheme,\n  outerLabel,\n  arc: arc2,\n  label: label2\n}) => {\n  const transition = animated ? DEFAULT_TRANSITION : {\n    type: false,\n    delay: 0\n  };\n  const [actives, setActives] = useState([]);\n  const [hovered, setHovered] = useState(null);\n  const onActivate = useCallback(point2 => {\n    setHovered(point2);\n    setActives(data.filter(d => {\n      var _a;\n      return ((_a = d.data) == null ? void 0 : _a.key.indexOf(point2)) > -1;\n    }).map(d => {\n      var _a;\n      return (_a = d.data) == null ? void 0 : _a.key;\n    }));\n  }, [data]);\n  const renderArc = useCallback((d, index) => {\n    var _a, _b;\n    const fill = getColor({\n      data,\n      colorScheme,\n      point: d.data,\n      index\n    });\n    const textFill = fill ? invert(chroma(fill).darken(0.5).hex(), true) : \"white\";\n    const arcFill = arc2.props.fill || fill;\n    const key = (_a = d == null ? void 0 : d.data) == null ? void 0 : _a.key;\n    const safeKey = identifier((_b = d.data) == null ? void 0 : _b.key);\n    const isSelected = selections == null ? void 0 : selections.includes(key);\n    const isHovered = hovered === key || isSelected;\n    const isActive = isSelected || actives.includes(key) || (actives.length > 0 ? null : false);\n    const getStrokeColor = () => {\n      if (typeof arc2.props.stroke === \"function\") {\n        return arc2.props.stroke(data, index, isActive, isHovered);\n      }\n      if (arc2.props.stroke !== void 0) {\n        return arc2.props.stroke;\n      }\n      return fill;\n    };\n    const stroke = getStrokeColor();\n    const arcStroke = stroke || chroma(arcFill).darken(isActive ? 0.8 : 0.5).hex();\n    return /* @__PURE__ */jsxs(Fragment, {\n      children: [/* @__PURE__ */jsx(CloneElement, {\n        element: arc2,\n        id: `${id}-${safeKey}`,\n        data: d,\n        fill: arcFill,\n        stroke: arcStroke,\n        disabled,\n        animated,\n        active: isActive,\n        onMouseEnter: () => onActivate(key),\n        onMouseLeave: () => {\n          setActives([]);\n          setHovered(null);\n        }\n      }), label2 && /* @__PURE__ */jsx(CloneElement, {\n        element: label2,\n        data: d,\n        id: `${id}-${safeKey}`,\n        active: isActive,\n        animated,\n        fill: textFill,\n        ...label2.props\n      }), d.set && outerLabel && /* @__PURE__ */jsx(CloneElement, {\n        element: outerLabel,\n        data: d,\n        animated\n      })]\n    }, safeKey);\n  }, [data, colorScheme, arc2, selections, hovered, actives, id, disabled, animated, label2, outerLabel, onActivate]);\n  const topArcs = useMemo(() => {\n    const result = [];\n    if (actives.length > 0) {\n      result.push(...actives.filter(s => s !== hovered));\n    }\n    if (selections == null ? void 0 : selections.length) {\n      result.push(...selections.filter(s => !actives.includes(s) && s !== hovered));\n    }\n    if (hovered) {\n      result.push(hovered);\n    }\n    return result;\n  }, [hovered, actives, selections]);\n  return /* @__PURE__ */jsxs(motion.g, {\n    initial: {\n      opacity: 0,\n      scale: 0\n    },\n    animate: {\n      opacity: 1,\n      scale: 1\n    },\n    transition,\n    children: [data.map(renderArc), topArcs.length > 0 && topArcs.map(a => /* @__PURE__ */jsx(\"use\", {\n      xlinkHref: `#${id}-${a}-arc`,\n      style: {\n        pointerEvents: \"none\"\n      }\n    }, a)), data.map((d, index) => {\n      var _a;\n      return /* @__PURE__ */jsx(\"use\", {\n        xlinkHref: `#${id}-${identifier((_a = d.data) == null ? void 0 : _a.key)}-text`,\n        style: {\n          pointerEvents: \"none\"\n        }\n      }, index);\n    })]\n  });\n};\nVennSeries.defaultProps = {\n  animated: true,\n  disabled: false,\n  colorScheme: \"cybertron\",\n  outerLabel: /* @__PURE__ */jsx(VennOuterLabel, {}),\n  arc: /* @__PURE__ */jsx(VennArc, {}),\n  label: /* @__PURE__ */jsx(VennLabel, {})\n};\nconst sets$5 = [];\nconst intersections$5 = [];\nconst bb$5 = {\n  x: 0,\n  y: 0,\n  width: 10,\n  height: 10\n};\nconst venn0 = {\n  sets: sets$5,\n  intersections: intersections$5,\n  bb: bb$5\n};\nconst sets$4 = [{\n  cx: 0,\n  cy: 0,\n  r: 5,\n  text: {\n    x: 3.5,\n    y: -4\n  },\n  align: \"start\",\n  verticalAlign: \"bottom\"\n}];\nconst intersections$4 = [{\n  sets: [0],\n  x1: 0,\n  y1: 5,\n  arcs: [{\n    mode: \"i\",\n    ref: 0,\n    x2: 0,\n    y2: -5,\n    sweep: false,\n    large: false\n  }, {\n    mode: \"i\",\n    ref: 0,\n    x2: 0,\n    y2: 5,\n    sweep: false,\n    large: false\n  }],\n  text: {\n    x: 0,\n    y: 0\n  }\n}];\nconst bb$4 = {\n  x: -5,\n  y: -5,\n  width: 10,\n  height: 10\n};\nconst venn1 = {\n  sets: sets$4,\n  intersections: intersections$4,\n  bb: bb$4\n};\nconst sets$3 = [{\n  cx: -4,\n  cy: 0,\n  r: 5,\n  text: {\n    x: -7.5,\n    y: 4\n  },\n  align: \"end\",\n  verticalAlign: \"top\"\n}, {\n  cx: 4,\n  cy: 0,\n  r: 5,\n  text: {\n    x: 7.5,\n    y: -4\n  },\n  align: \"start\",\n  verticalAlign: \"bottom\"\n}];\nconst intersections$3 = [{\n  sets: [0],\n  x1: 0,\n  y1: -3,\n  arcs: [{\n    mode: \"i\",\n    ref: 0,\n    x2: 0,\n    y2: 3,\n    sweep: false,\n    large: true\n  }, {\n    mode: \"o\",\n    ref: 1,\n    x2: 0,\n    y2: -3,\n    sweep: true,\n    large: false\n  }],\n  text: {\n    x: -4,\n    y: 0\n  }\n}, {\n  sets: [1],\n  x1: 0,\n  y1: 3,\n  arcs: [{\n    mode: \"i\",\n    ref: 1,\n    x2: 0,\n    y2: -3,\n    sweep: false,\n    large: true\n  }, {\n    mode: \"o\",\n    ref: 0,\n    x2: 0,\n    y2: 3,\n    sweep: true,\n    large: false\n  }],\n  text: {\n    x: 4,\n    y: 0\n  }\n}, {\n  sets: [0, 1],\n  x1: 0,\n  y1: 3,\n  arcs: [{\n    mode: \"i\",\n    ref: 0,\n    x2: 0,\n    y2: -3,\n    sweep: false,\n    large: false\n  }, {\n    mode: \"i\",\n    ref: 1,\n    x2: 0,\n    y2: 3,\n    sweep: false,\n    large: false\n  }],\n  text: {\n    x: 0,\n    y: 0\n  }\n}];\nconst bb$3 = {\n  x: -9,\n  y: -5,\n  width: 18,\n  height: 10\n};\nconst venn2 = {\n  sets: sets$3,\n  intersections: intersections$3,\n  bb: bb$3\n};\nconst sets$2 = [{\n  cx: -3.464,\n  cy: -2,\n  r: 5,\n  text: {\n    x: -7,\n    y: -6\n  },\n  align: \"end\"\n}, {\n  cx: 3.464,\n  cy: -2,\n  r: 5,\n  text: {\n    x: 7,\n    y: -6\n  },\n  align: \"start\"\n}, {\n  cx: 0,\n  cy: 4,\n  r: 5,\n  text: {\n    x: 4,\n    y: 7.5\n  },\n  align: \"start\",\n  verticalAlign: \"top\"\n}];\nconst intersections$2 = [{\n  sets: [0],\n  x1: -4.855,\n  y1: 2.803,\n  arcs: [{\n    mode: \"o\",\n    ref: 2,\n    x2: -1.39,\n    y2: -0.803,\n    sweep: true,\n    large: false\n  }, {\n    mode: \"o\",\n    ref: 1,\n    x2: 0,\n    y2: -5.606,\n    sweep: true,\n    large: false\n  }, {\n    mode: \"i\",\n    ref: 0,\n    x2: -4.855,\n    y2: 2.803,\n    sweep: false,\n    large: true\n  }],\n  text: {\n    x: -4.216,\n    y: -2.434\n  }\n}, {\n  sets: [1],\n  x1: 0,\n  y1: -5.606,\n  arcs: [{\n    mode: \"o\",\n    ref: 0,\n    x2: 1.39,\n    y2: -0.803,\n    sweep: true,\n    large: false\n  }, {\n    mode: \"o\",\n    ref: 2,\n    x2: 4.855,\n    y2: 2.803,\n    sweep: true,\n    large: false\n  }, {\n    mode: \"i\",\n    ref: 1,\n    x2: 0,\n    y2: -5.606,\n    sweep: false,\n    large: true\n  }],\n  text: {\n    x: 4.216,\n    y: -2.434\n  }\n}, {\n  sets: [2],\n  x1: -4.855,\n  y1: 2.803,\n  arcs: [{\n    mode: \"o\",\n    ref: 0,\n    x2: 0,\n    y2: 1.606,\n    sweep: false,\n    large: false\n  }, {\n    mode: \"o\",\n    ref: 1,\n    x2: 4.855,\n    y2: 2.803,\n    sweep: false,\n    large: false\n  }, {\n    mode: \"i\",\n    ref: 2,\n    x2: -4.855,\n    y2: 2.803,\n    sweep: true,\n    large: true\n  }],\n  text: {\n    x: 0,\n    y: 4.869\n  }\n}, {\n  sets: [0, 1],\n  x1: 0,\n  y1: -5.606,\n  arcs: [{\n    mode: \"i\",\n    ref: 1,\n    x2: -1.39,\n    y2: -0.803,\n    sweep: false,\n    large: false\n  }, {\n    mode: \"o\",\n    ref: 2,\n    x2: 1.39,\n    y2: -0.803,\n    sweep: true,\n    large: false\n  }, {\n    mode: \"i\",\n    ref: 0,\n    x2: 0,\n    y2: -5.606,\n    sweep: false,\n    large: false\n  }],\n  text: {\n    x: 0,\n    y: -2.404\n  }\n}, {\n  sets: [0, 2],\n  x1: -4.855,\n  y1: 2.803,\n  arcs: [{\n    mode: \"i\",\n    ref: 2,\n    x2: -1.39,\n    y2: -0.803,\n    sweep: true,\n    large: false\n  }, {\n    mode: \"o\",\n    ref: 1,\n    x2: 0,\n    y2: 1.606,\n    sweep: false,\n    large: false\n  }, {\n    mode: \"i\",\n    ref: 0,\n    x2: -4.855,\n    y2: 2.803,\n    sweep: true,\n    large: false\n  }],\n  text: {\n    x: -2.082,\n    y: 1.202\n  }\n}, {\n  sets: [1, 2],\n  x1: 4.855,\n  y1: 2.803,\n  arcs: [{\n    mode: \"i\",\n    ref: 2,\n    x2: 1.39,\n    y2: -0.803,\n    sweep: false,\n    large: false\n  }, {\n    mode: \"o\",\n    ref: 0,\n    x2: 0,\n    y2: 1.606,\n    sweep: true,\n    large: false\n  }, {\n    mode: \"i\",\n    ref: 1,\n    x2: 4.855,\n    y2: 2.803,\n    sweep: false,\n    large: false\n  }],\n  text: {\n    x: 2.082,\n    y: 1.202\n  }\n}, {\n  sets: [0, 1, 2],\n  x1: 1.39,\n  y1: -0.803,\n  arcs: [{\n    mode: \"i\",\n    ref: 0,\n    x2: 0,\n    y2: 1.606,\n    sweep: true,\n    large: false\n  }, {\n    mode: \"i\",\n    ref: 1,\n    x2: -1.39,\n    y2: -0.803,\n    sweep: true,\n    large: false\n  }, {\n    mode: \"i\",\n    ref: 2,\n    x2: 1.39,\n    y2: -0.803,\n    sweep: true,\n    large: false\n  }],\n  text: {\n    x: 0,\n    y: 0\n  }\n}];\nconst bb$2 = {\n  x: -8.464,\n  y: -7,\n  width: 16.928,\n  height: 16\n};\nconst venn3 = {\n  sets: sets$2,\n  intersections: intersections$2,\n  bb: bb$2\n};\nconst sets$1 = [{\n  cx: 0.439,\n  cy: -1.061,\n  rx: 2.5,\n  ry: 5,\n  rotation: 45,\n  text: {\n    x: 4.5,\n    y: -4.5\n  },\n  align: \"start\",\n  verticalAlign: \"bottom\"\n}, {\n  cx: 2.561,\n  cy: 1.061,\n  rx: 2.5,\n  ry: 5,\n  rotation: 45,\n  text: {\n    x: 4,\n    y: 3.75\n  },\n  align: \"start\",\n  verticalAlign: \"top\"\n}, {\n  cx: -2.561,\n  cy: 1.061,\n  rx: 2.5,\n  ry: 5,\n  rotation: -45,\n  text: {\n    x: -4,\n    y: 3.7\n  },\n  align: \"end\",\n  verticalAlign: \"top\"\n}, {\n  cx: -0.439,\n  cy: -1.061,\n  rx: 2.5,\n  ry: 5,\n  rotation: -45,\n  text: {\n    x: -4.5,\n    y: -4.5\n  },\n  align: \"end\",\n  verticalAlign: \"bottom\"\n}];\nconst intersections$1 = [{\n  sets: [0],\n  x1: 0,\n  y1: -3.94,\n  arcs: [{\n    ref: 0,\n    mode: \"i\",\n    x2: 4.328,\n    y2: -2.828,\n    sweep: true,\n    large: false\n  }, {\n    ref: 1,\n    mode: \"o\",\n    x2: 2.179,\n    y2: -1.858,\n    large: false\n  }, {\n    ref: 3,\n    mode: \"o\",\n    x2: 0,\n    y2: -3.94,\n    large: false\n  }],\n  text: {\n    x: 2.914,\n    y: -3.536\n  }\n}, {\n  sets: [1],\n  x1: 4.328,\n  y1: -2.828,\n  arcs: [{\n    ref: 1,\n    mode: \"i\",\n    x2: 0,\n    y2: 5.006,\n    sweep: true,\n    large: true\n  }, {\n    ref: 2,\n    mode: \"o\",\n    x2: 1.328,\n    y2: 2.828\n  }, {\n    ref: 3,\n    mode: \"o\",\n    x2: 3.108,\n    y2: -0.328\n  }, {\n    ref: 0,\n    mode: \"o\",\n    x2: 4.328,\n    y2: -2.828\n  }],\n  text: {\n    x: 5.036,\n    y: -1.414\n  }\n}, {\n  sets: [2],\n  x1: 0,\n  y1: 5.006,\n  arcs: [{\n    ref: 2,\n    mode: \"i\",\n    x2: -4.328,\n    y2: -2.828,\n    sweep: true,\n    large: true\n  }, {\n    ref: 3,\n    mode: \"o\",\n    x2: -3.108,\n    y2: -0.328\n  }, {\n    ref: 0,\n    mode: \"o\",\n    x2: -1.328,\n    y2: 2.828\n  }, {\n    ref: 1,\n    mode: \"o\",\n    x2: 0,\n    y2: 5.006\n  }],\n  text: {\n    x: -5.036,\n    y: -1.414\n  }\n}, {\n  sets: [3],\n  x1: -4.328,\n  y1: -2.828,\n  arcs: [{\n    ref: 3,\n    mode: \"i\",\n    x2: 0,\n    y2: -3.94,\n    sweep: true,\n    large: false\n  }, {\n    ref: 0,\n    mode: \"o\",\n    x2: -2.179,\n    y2: -1.858,\n    large: false\n  }, {\n    ref: 2,\n    mode: \"o\",\n    x2: -4.328,\n    y2: -2.828,\n    large: false\n  }],\n  text: {\n    x: -2.914,\n    y: -3.536\n  }\n}, {\n  sets: [0, 1],\n  x1: 4.328,\n  y1: -2.828,\n  arcs: [{\n    ref: 1,\n    mode: \"i\",\n    x2: 3.108,\n    y2: -0.328,\n    sweep: true,\n    large: false\n  }, {\n    ref: 3,\n    mode: \"o\",\n    x2: 2.179,\n    y2: -1.858,\n    sweep: false,\n    large: false\n  }, {\n    ref: 0,\n    mode: \"i\",\n    x2: 4.328,\n    y2: -2.828,\n    sweep: true,\n    large: false\n  }],\n  text: {\n    x: 3.205,\n    y: -1.672\n  }\n}, {\n  sets: [0, 2],\n  x1: -1.328,\n  y1: 2.828,\n  arcs: [{\n    ref: 0,\n    mode: \"i\",\n    x2: -3.108,\n    y2: -0.328,\n    sweep: true,\n    large: false\n  }, {\n    ref: 3,\n    mode: \"o\",\n    x2: -0.969,\n    y2: 1.755,\n    large: false\n  }, {\n    ref: 1,\n    mode: \"o\",\n    x2: -1.328,\n    y2: 2.828,\n    large: false\n  }],\n  text: {\n    x: -2.212,\n    y: 1.591\n  }\n}, {\n  sets: [0, 3],\n  x1: 0,\n  y1: -3.94,\n  arcs: [{\n    ref: 3,\n    mode: \"i\",\n    x2: 2.179,\n    y2: -1.858,\n    sweep: true,\n    large: false\n  }, {\n    ref: 1,\n    mode: \"o\",\n    x2: 0,\n    y2: 0.188,\n    sweep: false,\n    large: false\n  }, {\n    ref: 2,\n    mode: \"o\",\n    x2: -2.179,\n    y2: -1.858,\n    sweep: false,\n    large: false\n  }, {\n    ref: 0,\n    mode: \"i\",\n    x2: 0,\n    y2: -3.94,\n    sweep: true\n  }],\n  text: {\n    x: 0,\n    y: -1.87\n  }\n}, {\n  sets: [1, 2],\n  x1: 1.328,\n  y1: 2.828,\n  arcs: [{\n    ref: 2,\n    mode: \"i\",\n    x2: 0,\n    y2: 5.006,\n    sweep: true,\n    large: false\n  }, {\n    ref: 1,\n    mode: \"i\",\n    x2: -1.328,\n    y2: 2.828,\n    sweep: true,\n    large: false\n  }, {\n    ref: 0,\n    mode: \"o\",\n    x2: 0,\n    y2: 2.346,\n    large: false\n  }, {\n    ref: 3,\n    mode: \"o\",\n    x2: 1.328,\n    y2: 2.828\n  }],\n  text: {\n    x: 0,\n    y: 3.393\n  }\n}, {\n  sets: [1, 3],\n  x1: 3.108,\n  y1: -0.328,\n  arcs: [{\n    ref: 3,\n    mode: \"i\",\n    x2: 1.328,\n    y2: 2.828,\n    sweep: true,\n    large: false\n  }, {\n    ref: 2,\n    mode: \"o\",\n    x2: 0.969,\n    y2: 1.755,\n    large: false\n  }, {\n    ref: 1,\n    mode: \"i\",\n    x2: 3.108,\n    y2: -0.328,\n    large: false\n  }],\n  text: {\n    x: 2.212,\n    y: 1.591\n  }\n}, {\n  sets: [2, 3],\n  x1: -3.108,\n  y1: -0.328,\n  arcs: [{\n    ref: 3,\n    mode: \"i\",\n    x2: -4.328,\n    y2: -2.828,\n    sweep: true,\n    large: false\n  }, {\n    ref: 2,\n    mode: \"i\",\n    x2: -2.179,\n    y2: -1.858,\n    sweep: true,\n    large: false\n  }, {\n    ref: 0,\n    mode: \"o\",\n    x2: -3.108,\n    y2: -0.328,\n    large: false\n  }],\n  text: {\n    x: -3.205,\n    y: -1.672\n  }\n}, {\n  sets: [0, 1, 2],\n  x1: 0,\n  y1: 2.346,\n  arcs: [{\n    ref: 0,\n    mode: \"i\",\n    x2: -1.328,\n    y2: 2.828,\n    sweep: true,\n    large: false\n  }, {\n    ref: 1,\n    mode: \"i\",\n    x2: -0.969,\n    y2: 1.755,\n    sweep: true,\n    large: false\n  }, {\n    ref: 3,\n    mode: \"o\",\n    x2: 0,\n    y2: 2.346,\n    large: false\n  }],\n  text: {\n    x: -0.766,\n    y: 2.31\n  }\n}, {\n  sets: [0, 1, 3],\n  x1: 2.179,\n  y1: -1.858,\n  arcs: [{\n    ref: 3,\n    mode: \"i\",\n    x2: 3.108,\n    y2: -0.328,\n    sweep: true,\n    large: false\n  }, {\n    ref: 0,\n    mode: \"i\",\n    x2: 0.969,\n    y2: 1.755,\n    sweep: true,\n    large: false\n  }, {\n    ref: 2,\n    mode: \"o\",\n    x2: 0,\n    y2: 0.188,\n    sweep: false,\n    large: false\n  }, {\n    ref: 1,\n    mode: \"i\",\n    x2: 2.179,\n    y2: -1.858,\n    sweep: true\n  }],\n  text: {\n    x: 1.558,\n    y: -0.056\n  }\n}, {\n  sets: [0, 2, 3],\n  x1: -0.969,\n  y1: 1.755,\n  arcs: [{\n    ref: 3,\n    mode: \"i\",\n    x2: -3.108,\n    y2: -0.328,\n    sweep: true,\n    large: false\n  }, {\n    ref: 0,\n    mode: \"i\",\n    x2: -2.179,\n    y2: -1.858,\n    sweep: true,\n    large: false\n  }, {\n    ref: 2,\n    mode: \"i\",\n    x2: 0,\n    y2: 0.188,\n    sweep: true,\n    large: false\n  }, {\n    ref: 1,\n    mode: \"o\",\n    x2: -0.969,\n    y2: 1.755\n  }],\n  text: {\n    x: -1.558,\n    y: -0.056\n  }\n}, {\n  sets: [1, 2, 3],\n  x1: 1.328,\n  y1: 2.828,\n  arcs: [{\n    ref: 3,\n    mode: \"i\",\n    x2: 0,\n    y2: 2.346,\n    sweep: true,\n    large: false\n  }, {\n    ref: 0,\n    mode: \"o\",\n    x2: 0.969,\n    y2: 1.755,\n    sweep: false,\n    large: false\n  }, {\n    ref: 2,\n    mode: \"i\",\n    x2: 1.328,\n    y2: 2.828,\n    sweep: true,\n    large: false\n  }],\n  text: {\n    x: 0.766,\n    y: 2.31\n  }\n}, {\n  sets: [0, 1, 2, 3],\n  x1: 0,\n  y1: 0.188,\n  arcs: [{\n    ref: 2,\n    mode: \"i\",\n    x2: 0.969,\n    y2: 1.755,\n    sweep: true,\n    large: false\n  }, {\n    ref: 0,\n    mode: \"i\",\n    x2: 0,\n    y2: 2.346,\n    sweep: true,\n    large: false\n  }, {\n    ref: 3,\n    mode: \"i\",\n    x2: -0.969,\n    y2: 1.755,\n    sweep: true,\n    large: false\n  }, {\n    ref: 1,\n    mode: \"i\",\n    x2: 0,\n    y2: 0.188,\n    sweep: true\n  }],\n  text: {\n    x: 0,\n    y: 1.43\n  }\n}];\nconst bb$1 = {\n  x: -6.5,\n  y: -5,\n  width: 13,\n  height: 10\n};\nconst venn4 = {\n  sets: sets$1,\n  intersections: intersections$1,\n  bb: bb$1\n};\nconst sets = [{\n  cx: 0.5,\n  cy: -1,\n  rx: 2.5,\n  ry: 5,\n  rotation: 0,\n  text: {\n    x: 2.25,\n    y: -5\n  },\n  icon: {\n    x: 0,\n    y: -6.3\n  },\n  align: \"start\",\n  verticalAlign: \"bottom\"\n}, {\n  cx: 1.106,\n  cy: 0.167,\n  rx: 2.5,\n  ry: 5,\n  rotation: 72,\n  text: {\n    x: 4.5,\n    y: 1.5\n  },\n  icon: {\n    x: 6.2,\n    y: -1.9\n  },\n  align: \"start\",\n  verticalAlign: \"top\"\n}, {\n  cx: 0.183,\n  cy: 1.103,\n  rx: 2.5,\n  ry: 5,\n  rotation: 144,\n  icon: {\n    x: 3.2,\n    y: 6\n  },\n  text: {\n    x: 4,\n    y: 4\n  },\n  align: \"start\",\n  verticalAlign: \"bottom\"\n}, {\n  cx: -0.992,\n  cy: 0.515,\n  rx: 2.5,\n  ry: 5,\n  rotation: 216,\n  icon: {\n    x: -4.4,\n    y: 5.2\n  },\n  text: {\n    x: -4.7,\n    y: 2\n  },\n  align: \"end\",\n  verticalAlign: \"bottom\"\n}, {\n  cx: -0.797,\n  cy: -0.785,\n  rx: 2.5,\n  ry: 5,\n  rotation: 288,\n  icon: {\n    x: -6,\n    y: -2\n  },\n  text: {\n    x: -4,\n    y: -3.6\n  },\n  align: \"end\",\n  verticalAlign: \"bottom\"\n}];\nconst intersections = [{\n  sets: [0],\n  x1: -1.653,\n  y1: -3.541,\n  arcs: [{\n    ref: 0,\n    mode: \"i\",\n    x2: 2.857,\n    y2: -2.666,\n    sweep: true,\n    large: false\n  }, {\n    ref: 1,\n    mode: \"o\",\n    x2: 2.5,\n    y2: -2.648,\n    large: false\n  }, {\n    ref: 3,\n    mode: \"o\",\n    x2: -0.495,\n    y2: -3.303,\n    large: false\n  }, {\n    ref: 4,\n    mode: \"o\",\n    x2: -1.653,\n    y2: -3.541\n  }],\n  text: {\n    x: 0.5,\n    y: -5\n  }\n}, {\n  sets: [1],\n  x1: 2.857,\n  y1: -2.666,\n  arcs: [{\n    ref: 1,\n    mode: \"i\",\n    x2: 3.419,\n    y2: 1.893,\n    sweep: true,\n    large: false\n  }, {\n    ref: 2,\n    mode: \"o\",\n    x2: 3.291,\n    y2: 1.559,\n    large: false\n  }, {\n    ref: 4,\n    mode: \"o\",\n    x2: 2.988,\n    y2: -1.492,\n    large: false\n  }, {\n    ref: 0,\n    mode: \"o\",\n    x2: 2.857,\n    y2: -2.666\n  }],\n  text: {\n    x: 4.91,\n    y: -1.07\n  }\n}, {\n  sets: [2],\n  x1: 3.419,\n  y1: 1.893,\n  arcs: [{\n    ref: 2,\n    mode: \"i\",\n    x2: -0.744,\n    y2: 3.837,\n    sweep: true,\n    large: false\n  }, {\n    ref: 3,\n    mode: \"o\",\n    x2: -0.466,\n    y2: 3.612,\n    large: false\n  }, {\n    ref: 0,\n    mode: \"o\",\n    x2: 2.342,\n    y2: 2.381,\n    large: false\n  }, {\n    ref: 1,\n    mode: \"o\",\n    x2: 3.419,\n    y2: 1.893\n  }],\n  text: {\n    x: 2.534,\n    y: 4.339\n  }\n}, {\n  sets: [3],\n  x1: -0.744,\n  y1: 3.837,\n  arcs: [{\n    ref: 3,\n    mode: \"i\",\n    x2: -3.879,\n    y2: 0.478,\n    sweep: true,\n    large: false\n  }, {\n    ref: 4,\n    mode: \"o\",\n    x2: -3.579,\n    y2: 0.673,\n    large: false\n  }, {\n    ref: 1,\n    mode: \"o\",\n    x2: -1.54,\n    y2: 2.963,\n    large: false\n  }, {\n    ref: 2,\n    mode: \"o\",\n    x2: -0.744,\n    y2: 3.837\n  }],\n  text: {\n    x: -3.343,\n    y: 3.751\n  }\n}, {\n  sets: [4],\n  x1: -3.879,\n  y1: 0.478,\n  arcs: [{\n    ref: 4,\n    mode: \"i\",\n    x2: -1.653,\n    y2: -3.541,\n    sweep: true,\n    large: false\n  }, {\n    ref: 0,\n    mode: \"o\",\n    x2: -1.746,\n    y2: -3.196,\n    large: false\n  }, {\n    ref: 2,\n    mode: \"o\",\n    x2: -3.294,\n    y2: -0.549,\n    large: false\n  }, {\n    ref: 3,\n    mode: \"o\",\n    x2: -3.879,\n    y2: 0.478\n  }],\n  text: {\n    x: -4.601,\n    y: -2.021\n  }\n}, {\n  sets: [0, 1],\n  x1: 2.5,\n  y1: -2.648,\n  arcs: [{\n    ref: 1,\n    mode: \"i\",\n    x2: 2.857,\n    y2: -2.666,\n    sweep: true,\n    large: false\n  }, {\n    ref: 0,\n    mode: \"i\",\n    x2: 2.988,\n    y2: -1.492,\n    sweep: true,\n    large: false\n  }, {\n    ref: 4,\n    mode: \"o\",\n    x2: 2.572,\n    y2: -1.839,\n    large: false\n  }, {\n    ref: 3,\n    mode: \"o\",\n    x2: 2.5,\n    y2: -2.648\n  }],\n  text: {\n    x: 2.741,\n    y: -2.152\n  }\n}, {\n  sets: [0, 2],\n  x1: 2.342,\n  y1: 2.381,\n  arcs: [{\n    ref: 0,\n    mode: \"i\",\n    x2: -0.466,\n    y2: 3.612,\n    sweep: true,\n    large: false\n  }, {\n    ref: 3,\n    mode: \"o\",\n    x2: 0.257,\n    y2: 2.922,\n    large: false\n  }, {\n    ref: 1,\n    mode: \"o\",\n    x2: 2.342,\n    y2: 2.381,\n    large: false\n  }],\n  text: {\n    x: 0.5,\n    y: 3.5\n  }\n}, {\n  sets: [0, 3],\n  x1: -0.495,\n  y1: -3.303,\n  arcs: [{\n    ref: 3,\n    mode: \"i\",\n    x2: 2.5,\n    y2: -2.648,\n    sweep: true,\n    large: false\n  }, {\n    ref: 1,\n    mode: \"o\",\n    x2: 1.51,\n    y2: -2.515,\n    large: false\n  }, {\n    ref: 4,\n    mode: \"o\",\n    x2: -0.495,\n    y2: -3.303,\n    large: false\n  }],\n  text: {\n    x: 1.653,\n    y: -3.125\n  }\n}, {\n  sets: [0, 4],\n  x1: -1.653,\n  y1: -3.541,\n  arcs: [{\n    ref: 4,\n    mode: \"i\",\n    x2: -0.495,\n    y2: -3.303,\n    sweep: true,\n    large: false\n  }, {\n    ref: 3,\n    mode: \"o\",\n    x2: -0.954,\n    y2: -3.015,\n    large: false\n  }, {\n    ref: 2,\n    mode: \"o\",\n    x2: -1.746,\n    y2: -3.196,\n    large: false\n  }, {\n    ref: 0,\n    mode: \"i\",\n    x2: -1.653,\n    y2: -3.541\n  }],\n  text: {\n    x: -1.199,\n    y: -3.272\n  }\n}, {\n  sets: [1, 2],\n  x1: 3.291,\n  y1: 1.559,\n  arcs: [{\n    ref: 2,\n    mode: \"i\",\n    x2: 3.419,\n    y2: 1.893,\n    sweep: true,\n    large: false\n  }, {\n    ref: 1,\n    mode: \"i\",\n    x2: 2.342,\n    y2: 2.381,\n    sweep: true,\n    large: false\n  }, {\n    ref: 0,\n    mode: \"o\",\n    x2: 2.544,\n    y2: 1.878,\n    large: false\n  }, {\n    ref: 4,\n    mode: \"o\",\n    x2: 3.291,\n    y2: 1.559\n  }],\n  text: {\n    x: 2.894,\n    y: 1.942\n  }\n}, {\n  sets: [1, 3],\n  x1: -1.54,\n  y1: 2.963,\n  arcs: [{\n    ref: 1,\n    mode: \"i\",\n    x2: -3.579,\n    y2: 0.673,\n    sweep: true,\n    large: false\n  }, {\n    ref: 4,\n    mode: \"o\",\n    x2: -2.7,\n    y2: 1.147,\n    large: false\n  }, {\n    ref: 2,\n    mode: \"o\",\n    x2: -1.54,\n    y2: 2.963,\n    large: false\n  }],\n  text: {\n    x: -3.174,\n    y: 1.557\n  }\n}, {\n  sets: [1, 4],\n  x1: 2.988,\n  y1: -1.492,\n  arcs: [{\n    ref: 4,\n    mode: \"i\",\n    x2: 3.291,\n    y2: 1.559,\n    sweep: true,\n    large: false\n  }, {\n    ref: 2,\n    mode: \"o\",\n    x2: 2.858,\n    y2: 0.659,\n    large: false\n  }, {\n    ref: 0,\n    mode: \"o\",\n    x2: 2.988,\n    y2: -1.492,\n    large: false\n  }],\n  text: {\n    x: 3.483,\n    y: 0.606\n  }\n}, {\n  sets: [2, 3],\n  x1: -0.466,\n  y1: 3.612,\n  arcs: [{\n    ref: 3,\n    mode: \"i\",\n    x2: -0.744,\n    y2: 3.837,\n    sweep: true,\n    large: false\n  }, {\n    ref: 2,\n    mode: \"i\",\n    x2: -1.54,\n    y2: 2.963,\n    sweep: true,\n    large: false\n  }, {\n    ref: 1,\n    mode: \"o\",\n    x2: -1,\n    y2: 3,\n    large: false\n  }, {\n    ref: 0,\n    mode: \"o\",\n    x2: -0.466,\n    y2: 3.612\n  }],\n  text: {\n    x: -0.953,\n    y: 3.352\n  }\n}, {\n  sets: [2, 4],\n  x1: -3.294,\n  y1: -0.549,\n  arcs: [{\n    ref: 2,\n    mode: \"i\",\n    x2: -1.746,\n    y2: -3.196,\n    sweep: true\n  }, {\n    ref: 0,\n    mode: \"o\",\n    x2: -1.925,\n    y2: -2.213\n  }, {\n    ref: 3,\n    mode: \"o\",\n    x2: -3.294,\n    y2: -0.549\n  }],\n  text: {\n    x: -2.462,\n    y: -2.538\n  }\n}, {\n  sets: [3, 4],\n  x1: -3.579,\n  y1: 0.673,\n  arcs: [{\n    ref: 4,\n    mode: \"i\",\n    x2: -3.879,\n    y2: 0.478,\n    sweep: true,\n    large: false\n  }, {\n    ref: 3,\n    mode: \"i\",\n    x2: -3.294,\n    y2: -0.549,\n    sweep: true,\n    large: false\n  }, {\n    ref: 2,\n    mode: \"o\",\n    x2: -3.162,\n    y2: -0.024,\n    large: false\n  }, {\n    ref: 1,\n    mode: \"o\",\n    x2: -3.579,\n    y2: 0.673\n  }],\n  text: {\n    x: -3.483,\n    y: 0.13\n  }\n}, {\n  sets: [0, 1, 2],\n  x1: 2.544,\n  y1: 1.878,\n  arcs: [{\n    ref: 0,\n    mode: \"i\",\n    x2: 2.342,\n    y2: 2.381,\n    sweep: true,\n    large: false\n  }, {\n    ref: 1,\n    mode: \"i\",\n    x2: 0.257,\n    y2: 2.922,\n    sweep: true,\n    large: false\n  }, {\n    ref: 3,\n    mode: \"o\",\n    x2: 0.983,\n    y2: 2.049,\n    large: false\n  }, {\n    ref: 4,\n    mode: \"o\",\n    x2: 2.544,\n    y2: 1.878\n  }],\n  text: {\n    x: 1.457,\n    y: 2.331\n  }\n}, {\n  sets: [0, 1, 3],\n  x1: 1.51,\n  y1: -2.515,\n  arcs: [{\n    ref: 1,\n    mode: \"i\",\n    x2: 2.5,\n    y2: -2.648,\n    sweep: true,\n    large: false\n  }, {\n    ref: 3,\n    mode: \"i\",\n    x2: 2.572,\n    y2: -1.839,\n    sweep: true,\n    large: false\n  }, {\n    ref: 4,\n    mode: \"o\",\n    x2: 1.51,\n    y2: -2.515,\n    large: false\n  }],\n  text: {\n    x: 2.194,\n    y: -2.334\n  }\n}, {\n  sets: [0, 1, 4],\n  x1: 2.572,\n  y1: -1.839,\n  arcs: [{\n    ref: 4,\n    mode: \"i\",\n    x2: 2.988,\n    y2: -1.492,\n    sweep: true,\n    large: false\n  }, {\n    ref: 0,\n    mode: \"i\",\n    x2: 2.858,\n    y2: 0.659,\n    sweep: true,\n    large: false\n  }, {\n    ref: 2,\n    mode: \"o\",\n    x2: 2.253,\n    y2: -0.302,\n    large: false\n  }, {\n    ref: 3,\n    mode: \"o\",\n    x2: 2.572,\n    y2: -1.839\n  }],\n  text: {\n    x: 2.667,\n    y: -0.665\n  }\n}, {\n  sets: [0, 2, 3],\n  x1: 0.257,\n  y1: 2.922,\n  arcs: [{\n    ref: 3,\n    mode: \"i\",\n    x2: -0.466,\n    y2: 3.612,\n    sweep: true,\n    large: false\n  }, {\n    ref: 0,\n    mode: \"i\",\n    x2: -1,\n    y2: 3,\n    sweep: true,\n    large: false\n  }, {\n    ref: 1,\n    mode: \"o\",\n    x2: 0.257,\n    y2: 2.922,\n    large: false\n  }],\n  text: {\n    x: -0.403,\n    y: 3.178\n  }\n}, {\n  sets: [0, 2, 4],\n  x1: -1.746,\n  y1: -3.196,\n  arcs: [{\n    ref: 2,\n    mode: \"i\",\n    x2: -0.954,\n    y2: -3.015,\n    sweep: true,\n    large: false\n  }, {\n    ref: 3,\n    mode: \"o\",\n    x2: -1.925,\n    y2: -2.213,\n    sweep: false,\n    large: false\n  }, {\n    ref: 0,\n    mode: \"i\",\n    x2: -1.746,\n    y2: -3.196,\n    sweep: true,\n    large: false\n  }],\n  text: {\n    x: -1.542,\n    y: -2.808\n  }\n}, {\n  sets: [0, 3, 4],\n  x1: -0.495,\n  y1: -3.303,\n  arcs: [{\n    ref: 4,\n    mode: \"i\",\n    x2: 1.51,\n    y2: -2.515,\n    sweep: true,\n    large: false\n  }, {\n    ref: 1,\n    mode: \"o\",\n    x2: 0.409,\n    y2: -2.236,\n    large: false\n  }, {\n    ref: 2,\n    mode: \"o\",\n    x2: -0.954,\n    y2: -3.015,\n    large: false\n  }, {\n    ref: 3,\n    mode: \"i\",\n    x2: -0.495,\n    y2: -3.303\n  }],\n  text: {\n    x: 0.192,\n    y: -2.742\n  }\n}, {\n  sets: [1, 2, 3],\n  x1: -1.54,\n  y1: 2.963,\n  arcs: [{\n    ref: 2,\n    mode: \"i\",\n    x2: -2.7,\n    y2: 1.147,\n    sweep: true,\n    large: false\n  }, {\n    ref: 4,\n    mode: \"o\",\n    x2: -1.645,\n    y2: 1.568,\n    large: false\n  }, {\n    ref: 0,\n    mode: \"o\",\n    x2: -1,\n    y2: 3,\n    large: false\n  }, {\n    ref: 1,\n    mode: \"i\",\n    x2: -1.54,\n    y2: 2.963\n  }],\n  text: {\n    x: -1.767,\n    y: 2.106\n  }\n}, {\n  sets: [1, 2, 4],\n  x1: 2.858,\n  y1: 0.659,\n  arcs: [{\n    ref: 2,\n    mode: \"i\",\n    x2: 3.291,\n    y2: 1.559,\n    sweep: true,\n    large: false\n  }, {\n    ref: 4,\n    mode: \"i\",\n    x2: 2.544,\n    y2: 1.878,\n    sweep: true,\n    large: false\n  }, {\n    ref: 0,\n    mode: \"o\",\n    x2: 2.858,\n    y2: 0.659,\n    large: false\n  }],\n  text: {\n    x: 2.898,\n    y: 1.365\n  }\n}, {\n  sets: [1, 3, 4],\n  x1: -2.7,\n  y1: 1.147,\n  arcs: [{\n    ref: 4,\n    mode: \"i\",\n    x2: -3.579,\n    y2: 0.673,\n    sweep: true,\n    large: false\n  }, {\n    ref: 1,\n    mode: \"i\",\n    x2: -3.162,\n    y2: -0.024,\n    sweep: true,\n    large: false\n  }, {\n    ref: 2,\n    mode: \"o\",\n    x2: -2.7,\n    y2: 1.147,\n    large: false\n  }],\n  text: {\n    x: -3.147,\n    y: 0.599\n  }\n}, {\n  sets: [2, 3, 4],\n  x1: -3.294,\n  y1: -0.549,\n  arcs: [{\n    ref: 3,\n    mode: \"i\",\n    x2: -1.925,\n    y2: -2.213,\n    sweep: true,\n    large: false\n  }, {\n    ref: 0,\n    mode: \"o\",\n    x2: -2,\n    y2: -1.08,\n    large: false\n  }, {\n    ref: 1,\n    mode: \"o\",\n    x2: -3.162,\n    y2: -0.024,\n    large: false\n  }, {\n    ref: 2,\n    mode: \"i\",\n    x2: -3.294,\n    y2: -0.549\n  }],\n  text: {\n    x: -2.548,\n    y: -1.029\n  }\n}, {\n  sets: [0, 1, 2, 3],\n  x1: 0.983,\n  y1: 2.049,\n  arcs: [{\n    ref: 3,\n    mode: \"i\",\n    x2: 0.257,\n    y2: 2.922,\n    sweep: true,\n    large: false\n  }, {\n    ref: 1,\n    mode: \"i\",\n    x2: -1,\n    y2: 3,\n    sweep: true,\n    large: false\n  }, {\n    ref: 0,\n    mode: \"i\",\n    x2: -1.645,\n    y2: 1.568,\n    sweep: true,\n    large: false\n  }, {\n    ref: 4,\n    mode: \"o\",\n    x2: 0.983,\n    y2: 2.049\n  }],\n  text: {\n    x: -0.407,\n    y: 2.31\n  }\n}, {\n  sets: [0, 1, 2, 4],\n  x1: 2.253,\n  y1: -0.302,\n  arcs: [{\n    ref: 2,\n    mode: \"i\",\n    x2: 2.858,\n    y2: 0.659,\n    sweep: true,\n    large: false\n  }, {\n    ref: 0,\n    mode: \"i\",\n    x2: 2.544,\n    y2: 1.878,\n    sweep: true,\n    large: false\n  }, {\n    ref: 4,\n    mode: \"i\",\n    x2: 0.983,\n    y2: 2.049,\n    sweep: true,\n    large: false\n  }, {\n    ref: 3,\n    mode: \"o\",\n    x2: 2.253,\n    y2: -0.302\n  }],\n  text: {\n    x: 2.071,\n    y: 1.101\n  }\n}, {\n  sets: [0, 1, 3, 4],\n  x1: 1.51,\n  y1: -2.515,\n  arcs: [{\n    ref: 4,\n    mode: \"i\",\n    x2: 2.572,\n    y2: -1.839,\n    sweep: true,\n    large: false\n  }, {\n    ref: 3,\n    mode: \"i\",\n    x2: 2.253,\n    y2: -0.302,\n    sweep: true,\n    large: false\n  }, {\n    ref: 2,\n    mode: \"o\",\n    x2: 0.409,\n    y2: -2.236,\n    sweep: false,\n    large: false\n  }, {\n    ref: 1,\n    mode: \"i\",\n    x2: 1.51,\n    y2: -2.515,\n    sweep: true\n  }],\n  text: {\n    x: 1.687,\n    y: -1.63\n  }\n}, {\n  sets: [0, 2, 3, 4],\n  x1: -2,\n  y1: -1.08,\n  arcs: [{\n    ref: 0,\n    mode: \"i\",\n    x2: -1.925,\n    y2: -2.213,\n    sweep: true,\n    large: false\n  }, {\n    ref: 3,\n    mode: \"i\",\n    x2: -0.954,\n    y2: -3.015,\n    sweep: true,\n    large: false\n  }, {\n    ref: 2,\n    mode: \"i\",\n    x2: 0.409,\n    y2: -2.236,\n    sweep: true,\n    large: false\n  }, {\n    ref: 1,\n    mode: \"o\",\n    x2: -2,\n    y2: -1.08\n  }],\n  text: {\n    x: -1.028,\n    y: -2.108\n  }\n}, {\n  sets: [1, 2, 3, 4],\n  x1: -1.645,\n  y1: 1.568,\n  arcs: [{\n    ref: 4,\n    mode: \"i\",\n    x2: -2.7,\n    y2: 1.147,\n    sweep: true,\n    large: false\n  }, {\n    ref: 2,\n    mode: \"i\",\n    x2: -3.162,\n    y2: -0.024,\n    sweep: true,\n    large: false\n  }, {\n    ref: 1,\n    mode: \"i\",\n    x2: -2,\n    y2: -1.08,\n    sweep: true,\n    large: false\n  }, {\n    ref: 0,\n    mode: \"o\",\n    x2: -1.645,\n    y2: 1.568\n  }],\n  text: {\n    x: -2.323,\n    y: 0.327\n  }\n}, {\n  sets: [0, 1, 2, 3, 4],\n  x1: 0.409,\n  y1: -2.236,\n  arcs: [{\n    ref: 2,\n    mode: \"i\",\n    x2: 2.253,\n    y2: -0.302,\n    sweep: true,\n    large: false\n  }, {\n    ref: 3,\n    mode: \"i\",\n    x2: 0.983,\n    y2: 2.049,\n    sweep: true,\n    large: false\n  }, {\n    ref: 4,\n    mode: \"i\",\n    x2: -1.645,\n    y2: 1.568,\n    sweep: true,\n    large: false\n  }, {\n    ref: 0,\n    mode: \"i\",\n    x2: -2,\n    y2: -1.08,\n    sweep: true\n  }, {\n    ref: 1,\n    mode: \"i\",\n    x2: 0.409,\n    y2: -2.236,\n    sweep: true\n  }],\n  text: {\n    x: 0,\n    y: 0\n  }\n}];\nconst bb = {\n  x: -5.5,\n  y: -6,\n  width: 11.6,\n  height: 11.8\n};\nconst venn5 = {\n  sets,\n  intersections,\n  bb\n};\nconst shapes = [venn0, venn1, venn2, venn3, venn4, venn5];\nconst upto = limit => Array.from({\n  length: limit\n}, (_, i) => i);\nfunction isEllipse(d) {\n  return typeof d.rx === \"number\";\n}\nfunction combinations(array) {\n  return new Array(1 << array.length).fill().map((_e1, i) => array.filter((_e2, j) => i & 1 << j));\n}\nfunction lookup(combo, data) {\n  const key = combo.join(\"|\");\n  const found = data.find(d => d.key === key);\n  return {\n    key,\n    sets: combo,\n    size: (found == null ? void 0 : found.size) || 0\n  };\n}\nfunction buildData(data) {\n  const uniqueSets = data.filter(d => d.sets.length === 1).sort((a, b) => b.size - a.size);\n  const uniqueSetKeys = uniqueSets.map(u => u.key);\n  const sets2 = combinations(uniqueSetKeys);\n  const filteredSets = sets2.slice(1, sets2.length);\n  const result = filteredSets.map(d => [...d].sort((a, b) => uniqueSetKeys.indexOf(a) - uniqueSetKeys.indexOf(b)));\n  result.sort((a, b) => a.length - b.length || upto(a.length).reduce((diff, i) => diff || uniqueSetKeys.indexOf(a[i]) - uniqueSetKeys.indexOf(b[i]), 0));\n  const keyedData = data.map(d => {\n    const sets22 = [...d.sets].sort((a, b) => uniqueSetKeys.indexOf(a) - uniqueSetKeys.indexOf(b));\n    const key = sets22.join(\"|\");\n    return {\n      size: d.size,\n      sets: sets22,\n      key\n    };\n  });\n  return {\n    uniqueCount: uniqueSets.length,\n    data: result.map(r => lookup(r, keyedData))\n  };\n}\nfunction generateArcSlicePath(s, refs) {\n  return `M ${s.x1},${s.y1} ${s.arcs.map(arc2 => {\n    const ref = refs[arc2.ref];\n    const rx = isEllipse(ref) ? ref.rx : ref.r;\n    const ry = isEllipse(ref) ? ref.ry : ref.r;\n    const rot = isEllipse(ref) ? ref.rotation : 0;\n    return `A ${rx} ${ry} ${rot} ${arc2.large ? 1 : 0} ${arc2.sweep ? 1 : 0} ${arc2.x2} ${arc2.y2}`;\n  }).join(\" \")}`;\n}\nfunction buildLayout({\n  data,\n  uniqueCount\n}, box) {\n  const shape = shapes[Math.min(shapes.length - 1, uniqueCount)];\n  const f = Math.min(box.width / shape.bb.width, box.height / shape.bb.height);\n  const x = f * -shape.bb.x + (box.width - f * shape.bb.width) / 2 + 0;\n  const y = f * -shape.bb.y + (box.height - f * shape.bb.height) / 2 + 0;\n  const mx = v => x + f * v;\n  const my = v => y + f * v;\n  const shapeSets = shape.sets.map((c, i) => ({\n    ...c,\n    ...{\n      data: data[i],\n      cx: mx(c.cx),\n      cy: my(c.cy),\n      text: {\n        x: mx(c.text.x),\n        y: my(c.text.y)\n      },\n      ...(c.icon ? {\n        icon: {\n          x: mx(c.icon.x),\n          y: my(c.icon.y)\n        }\n      } : {})\n    },\n    ...(isEllipse(c) ? {\n      rx: c.rx * f,\n      ry: c.ry * f\n    } : {\n      r: c.r * f\n    })\n  }));\n  const intersections2 = shape.intersections.map((c, i) => ({\n    text: {\n      x: mx(c.text.x),\n      y: my(c.text.y)\n    },\n    x1: mx(c.x1),\n    y1: my(c.y1),\n    data: data[i],\n    set: shapeSets[i],\n    arcs: c.arcs.map(a => ({\n      ...a,\n      x2: mx(a.x2),\n      y2: my(a.y2)\n    }))\n  }));\n  return intersections2.map(i => ({\n    ...i,\n    path: generateArcSlicePath(i, shapeSets)\n  }));\n}\nfunction starEulerLayout(data, bb2) {\n  return buildLayout(buildData(data), bb2);\n}\nconst VennDiagram = ({\n  id,\n  type,\n  width,\n  height,\n  margins,\n  className,\n  containerClassName,\n  data,\n  disabled,\n  series\n}) => {\n  const renderChart = useCallback(containerProps => {\n    const normalized = data.map(d => ({\n      key: d.key.join(\"|\"),\n      sets: d.key,\n      size: d.data\n    }));\n    let layoutData;\n    if (type === \"starEuler\") {\n      layoutData = starEulerLayout(normalized, {\n        height: containerProps.height,\n        width: containerProps.width\n      });\n    } else {\n      layoutData = layout(normalized, {\n        height: containerProps.height,\n        width: containerProps.width,\n        distinct: type !== \"euler\"\n      });\n    }\n    return /* @__PURE__ */jsx(CloneElement, {\n      element: series,\n      data: layoutData,\n      disabled,\n      id: containerProps.id\n    });\n  }, [data, disabled, series, type]);\n  return /* @__PURE__ */jsx(ChartContainer, {\n    id,\n    width,\n    height,\n    margins,\n    containerClassName,\n    xAxisVisible: false,\n    yAxisVisible: false,\n    center: false,\n    className,\n    children: renderChart\n  });\n};\nVennDiagram.defaultProps = {\n  type: \"venn\",\n  series: /* @__PURE__ */jsx(VennSeries, {})\n};\nconst Bubble = ({\n  id,\n  data,\n  fill,\n  mask,\n  gradient: gradient2,\n  glow,\n  onClick,\n  onMouseEnter,\n  onMouseLeave,\n  animated,\n  tooltip: tooltip2 = /* @__PURE__ */jsx(ChartTooltip, {})\n}) => {\n  const [internalActive, setInternalActive] = useState(false);\n  const bubbleRef = useRef(null);\n  const transition = animated ? DEFAULT_TRANSITION : {\n    type: false,\n    delay: 0\n  };\n  const {\n    pointerOut,\n    pointerOver\n  } = useHoverIntent({\n    onPointerOver: event => {\n      setInternalActive(true);\n      onMouseEnter == null ? void 0 : onMouseEnter(event);\n    },\n    onPointerOut: event => {\n      setInternalActive(false);\n      onMouseLeave == null ? void 0 : onMouseLeave(event);\n    }\n  });\n  const arcFill = gradient2 && !mask ? `url(#gradient-${id})` : mask ? `url(#mask-pattern-${id})` : fill;\n  const tooltipData = useMemo(() => ({\n    y: data.data.data,\n    x: data.data.key\n  }), [data]);\n  const ariaLabelData = useMemo(() => getAriaLabel(tooltipData), [tooltipData]);\n  return /* @__PURE__ */jsxs(Fragment, {\n    children: [/* @__PURE__ */jsx(motion.circle, {\n      id: `${id}-bubble`,\n      ref: bubbleRef,\n      fill: arcFill,\n      style: generateGlowStyles({\n        glow\n      }),\n      initial: {\n        r: data.r,\n        cx: data.x,\n        cy: data.y\n      },\n      animate: {\n        r: data.r,\n        cx: data.x,\n        cy: data.y\n      },\n      transition,\n      onClick: event => onClick && onClick(event, data),\n      onPointerOver: pointerOver,\n      onPointerOut: pointerOut,\n      tabIndex: 0,\n      \"aria-label\": ariaLabelData,\n      role: \"graphics-document\"\n    }), mask && /* @__PURE__ */jsxs(Fragment, {\n      children: [/* @__PURE__ */jsx(Mask, {\n        id: `mask-${id}`,\n        fill: `url(#gradient-${id})`\n      }), /* @__PURE__ */jsx(CloneElement, {\n        element: mask,\n        id: `mask-pattern-${id}`,\n        fill\n      })]\n    }), gradient2 && /* @__PURE__ */jsx(CloneElement, {\n      element: gradient2,\n      id: `gradient-${id}`,\n      color: fill\n    }), tooltip2 && !tooltip2.props.disabled && /* @__PURE__ */jsx(CloneElement, {\n      element: tooltip2,\n      visible: !!internalActive,\n      reference: bubbleRef,\n      value: tooltipData\n    })]\n  });\n};\nconst BubbleLabel = ({\n  id,\n  data,\n  format,\n  wrap,\n  fill,\n  fontSize,\n  fontFamily,\n  animated\n}) => {\n  const transition = animated ? DEFAULT_TRANSITION : {\n    type: false,\n    delay: 0\n  };\n  let isElement = false;\n  let label2;\n  if (format) {\n    label2 = format(data);\n    isElement = isValidElement(label2);\n  }\n  if (!isElement) {\n    const text = wrap ? wrapText({\n      key: data.data.key,\n      fontFamily,\n      fontSize,\n      width: data.r\n    }) : data.data.key;\n    return /* @__PURE__ */jsx(motion.text, {\n      initial: {\n        x: data.x,\n        y: data.y\n      },\n      animate: {\n        x: data.x,\n        y: data.y\n      },\n      transition,\n      id: `${id}-text`,\n      style: {\n        pointerEvents: \"none\",\n        fontFamily,\n        fontSize\n      },\n      fill,\n      textAnchor: \"middle\",\n      children: text\n    });\n  }\n  return /* @__PURE__ */jsx(\"g\", {\n    style: {\n      transform: `translate(${data.x}px, ${data.y}px)`\n    },\n    children: label2\n  });\n};\nBubbleLabel.defaultProps = {\n  wrap: true,\n  fontSize: 14,\n  fontFamily: \"sans-serif\"\n};\nconst BubbleSeries = ({\n  id,\n  data,\n  colorScheme,\n  animated,\n  bubble,\n  format,\n  label: label2\n}) => {\n  const transition = animated ? DEFAULT_TRANSITION : {\n    type: false,\n    delay: 0\n  };\n  const renderBubble = (item2, index) => {\n    const fill = getColor({\n      data,\n      colorScheme,\n      point: item2.data,\n      index\n    });\n    const textFill = fill ? invert(chroma(fill).darken(0.5).hex(), true) : \"white\";\n    return /* @__PURE__ */jsxs(motion.g, {\n      initial: {\n        scale: 0.5,\n        opacity: 0\n      },\n      animate: {\n        scale: 1,\n        opacity: 1\n      },\n      transition,\n      children: [/* @__PURE__ */jsx(CloneElement, {\n        element: format ? format(item2) : bubble,\n        id: identifier(`${id}-${item2.data.key}-bubble`),\n        animated,\n        data: item2,\n        fill\n      }), /* @__PURE__ */jsx(CloneElement, {\n        element: label2,\n        id: identifier(`${id}-${item2.data.key}-label`),\n        animated,\n        data: item2,\n        fill: textFill\n      })]\n    }, item2.data.key);\n  };\n  return /* @__PURE__ */jsx(Fragment, {\n    children: data.map(renderBubble)\n  });\n};\nBubbleSeries.defaultProps = {\n  colorScheme: \"cybertron\",\n  animated: true,\n  bubble: /* @__PURE__ */jsx(Bubble, {}),\n  label: /* @__PURE__ */jsx(BubbleLabel, {})\n};\nconst BubbleChart = ({\n  data,\n  id,\n  width,\n  height,\n  className,\n  containerClassName,\n  margins,\n  series\n}) => {\n  const getData = useCallback((cw, ch) => {\n    const bubble = pack().size([cw, ch]).padding(3);\n    const root = hierarchy({\n      children: data\n    }).sum(d => d.data).sort((a, b) => b.data - a.data);\n    return bubble(root).leaves();\n  }, [data]);\n  const renderChart = useCallback(({\n    chartWidth,\n    chartHeight,\n    ...rest\n  }) => {\n    const circles = getData(chartWidth, chartHeight);\n    return /* @__PURE__ */jsx(CloneElement, {\n      element: series,\n      id: `${rest.id}-series`,\n      data: circles\n    });\n  }, [series, getData]);\n  return /* @__PURE__ */jsx(ChartContainer, {\n    id,\n    width,\n    height,\n    containerClassName,\n    margins,\n    xAxisVisible: false,\n    yAxisVisible: false,\n    className,\n    children: renderChart\n  });\n};\nBubbleChart.defaultProps = {\n  data: [],\n  margins: 10,\n  series: /* @__PURE__ */jsx(BubbleSeries, {})\n};\nconst TreeMapLabel = ({\n  id,\n  data,\n  fill,\n  wrap,\n  placement,\n  fontSize,\n  fontFamily\n}) => {\n  const key = data.data.key;\n  const width = data.x1 - data.x0;\n  const text = wrapText({\n    key,\n    fontFamily,\n    fontSize,\n    paddingX: 10,\n    wrap,\n    paddingY: 10,\n    width,\n    height: data.y1 - data.y0\n  });\n  const size = calculateDimensions(typeof text === \"string\" ? text : key, fontFamily, fontSize);\n  const offsetX = placement === \"start\" ? 10 : placement === \"middle\" ? (width - size.width) / 2 : width - size.width - 10;\n  return /* @__PURE__ */jsx(\"g\", {\n    style: {\n      transform: `translate(${offsetX}px, 15px)`\n    },\n    children: /* @__PURE__ */jsx(\"text\", {\n      id: `${id}-text`,\n      style: {\n        pointerEvents: \"none\",\n        fontFamily,\n        fontSize\n      },\n      fill,\n      children: text\n    })\n  });\n};\nTreeMapLabel.defaultProps = {\n  fill: \"#FFF\",\n  wrap: true,\n  fontSize: 14,\n  fontFamily: \"sans-serif\",\n  placement: \"start\"\n};\nconst TreeMapRect = ({\n  data,\n  fill,\n  animated,\n  cursor,\n  tooltip: tooltip2,\n  onMouseEnter,\n  onMouseLeave,\n  onClick\n}) => {\n  const [internalActive, setInternalActive] = useState(false);\n  const rectRef = useRef(null);\n  const transition = animated ? DEFAULT_TRANSITION : {\n    type: false,\n    delay: 0\n  };\n  const currentFill = internalActive ? chroma(fill).darken(0.8).hex() : fill;\n  const {\n    pointerOut,\n    pointerOver\n  } = useHoverIntent({\n    onPointerOver: event => {\n      setInternalActive(true);\n      onMouseEnter == null ? void 0 : onMouseEnter(event, data);\n    },\n    onPointerOut: event => {\n      setInternalActive(false);\n      onMouseLeave == null ? void 0 : onMouseLeave(event, data);\n    }\n  });\n  const tooltipLabel2 = useMemo(() => {\n    const getKey = node2 => {\n      if (!node2.parent) {\n        return [];\n      }\n      return [...getKey(node2.parent), node2.data.key];\n    };\n    return getKey(data).join(\"  \");\n  }, [data]);\n  const tooltipData = useMemo(() => ({\n    y: data.value,\n    x: tooltipLabel2\n  }), [data, tooltipLabel2]);\n  const ariaLabelData = useMemo(() => getAriaLabel(tooltipData), [tooltipData]);\n  return /* @__PURE__ */jsxs(Fragment, {\n    children: [/* @__PURE__ */jsx(motion.rect, {\n      ref: rectRef,\n      initial: {\n        fill: currentFill,\n        width: data.x1 - data.x0,\n        height: data.y1 - data.y0\n      },\n      animate: {\n        fill: currentFill,\n        width: data.x1 - data.x0,\n        height: data.y1 - data.y0\n      },\n      style: {\n        cursor\n      },\n      transition,\n      onClick: event => {\n        onClick == null ? void 0 : onClick(event, data);\n      },\n      onPointerOver: pointerOver,\n      onPointerOut: pointerOut,\n      tabIndex: 0,\n      \"aria-label\": ariaLabelData,\n      role: \"graphics-document\"\n    }), tooltip2 && !tooltip2.props.disabled && /* @__PURE__ */jsx(CloneElement, {\n      element: tooltip2,\n      visible: !!internalActive,\n      reference: rectRef,\n      value: tooltipData\n    })]\n  });\n};\nTreeMapRect.defaultProps = {\n  cursor: \"pointer\",\n  tooltip: /* @__PURE__ */jsx(ChartTooltip, {})\n};\nconst TreeMapSeries = ({\n  id,\n  data,\n  colorScheme,\n  animated,\n  rect,\n  label: label2\n}) => {\n  const transition = animated ? DEFAULT_TRANSITION : {\n    type: false,\n    delay: 0\n  };\n  const renderItem = (item2, index) => {\n    const fill = getColor({\n      data,\n      colorScheme,\n      point: item2.data,\n      index\n    });\n    const textFill = fill ? invert(chroma(fill).darken(0.5).hex(), true) : \"white\";\n    return /* @__PURE__ */jsxs(motion.g, {\n      initial: {\n        scale: 0.5,\n        opacity: 0,\n        x: item2.x0,\n        y: item2.y0\n      },\n      animate: {\n        scale: 1,\n        opacity: 1,\n        x: item2.x0,\n        y: item2.y0\n      },\n      transition,\n      children: [/* @__PURE__ */jsx(CloneElement, {\n        element: rect,\n        id: `${id}-${item2.data.key}-rect`,\n        animated,\n        data: item2,\n        fill\n      }), /* @__PURE__ */jsx(CloneElement, {\n        element: label2,\n        id: `${id}-${item2.data.key}-label`,\n        data: item2,\n        fill: textFill\n      })]\n    }, item2.data.key);\n  };\n  return /* @__PURE__ */jsx(Fragment, {\n    children: data.map((d, index) => renderItem(d, index))\n  });\n};\nTreeMapSeries.defaultProps = {\n  colorScheme: \"cybertron\",\n  animated: true,\n  rect: /* @__PURE__ */jsx(TreeMapRect, {}),\n  label: /* @__PURE__ */jsx(TreeMapLabel, {})\n};\nconst TreeMap = ({\n  data,\n  id,\n  containerClassName,\n  paddingInner,\n  paddingTop,\n  paddingOuter,\n  width,\n  height,\n  className,\n  margins,\n  series\n}) => {\n  const getData = useCallback((cw, ch) => {\n    const root = hierarchy({\n      data\n    }, d => d.data).sum(d => d.data).sort((a, b) => b.data - a.data);\n    const t = treemap().size([cw, ch]).tile(treemapSquarify).round(true).paddingInner(paddingInner).paddingOuter(paddingOuter).paddingTop(paddingTop);\n    const tree = t(root);\n    const nodes = [];\n    const getAllNodes = node2 => {\n      if (node2 == null ? void 0 : node2.parent) {\n        nodes.push(node2);\n      }\n      for (let child of (node2 == null ? void 0 : node2.children) || []) {\n        getAllNodes(child);\n      }\n    };\n    getAllNodes(tree);\n    return nodes;\n  }, [data, paddingInner, paddingOuter, paddingTop]);\n  const renderChart = useCallback(({\n    chartWidth,\n    chartHeight,\n    ...rest\n  }) => {\n    const datas = getData(chartWidth, chartHeight);\n    return /* @__PURE__ */jsx(CloneElement, {\n      element: series,\n      ...rest,\n      id: `${id || rest.id}-series`,\n      data: datas\n    });\n  }, [series, getData, id]);\n  return /* @__PURE__ */jsx(ChartContainer, {\n    id,\n    width,\n    height,\n    containerClassName,\n    margins,\n    xAxisVisible: false,\n    yAxisVisible: false,\n    className,\n    children: renderChart\n  });\n};\nTreeMap.defaultProps = {\n  margins: 0,\n  paddingInner: 5,\n  paddingOuter: 5,\n  paddingTop: 30,\n  series: /* @__PURE__ */jsx(TreeMapSeries, {}),\n  data: []\n};\nconst item = \"_item_18e6r_1\";\nconst labelStart = \"_labelStart_18e6r_8\";\nconst valueEnd = \"_valueEnd_18e6r_9\";\nconst labelBottom = \"_labelBottom_18e6r_15\";\nconst labelNone = \"_labelNone_18e6r_24\";\nconst label = \"_label_18e6r_8\";\nconst labelEnd = \"_labelEnd_18e6r_35\";\nconst valueStart = \"_valueStart_18e6r_36\";\nconst labelTop = \"_labelTop_18e6r_42\";\nconst valueBottom = \"_valueBottom_18e6r_57\";\nconst valueNone = \"_valueNone_18e6r_65\";\nconst valueLabel = \"_valueLabel_18e6r_71\";\nconst clickable = \"_clickable_18e6r_77\";\nconst outerBar = \"_outerBar_18e6r_97\";\nconst bar = \"_bar_18e6r_105\";\nconst css$1 = {\n  item,\n  labelStart,\n  valueEnd,\n  labelBottom,\n  labelNone,\n  label,\n  labelEnd,\n  valueStart,\n  labelTop,\n  valueBottom,\n  valueNone,\n  valueLabel,\n  clickable,\n  outerBar,\n  bar\n};\nconst BarListSeries = ({\n  data,\n  colorScheme,\n  itemClassName,\n  labelClassName,\n  outerBarClassName,\n  valueClassName,\n  labelFormat,\n  barClassName,\n  labelPosition,\n  valuePosition,\n  valueFormat,\n  onItemClick,\n  onItemMouseEnter,\n  onItemMouseLeave\n}) => {\n  const renderBar = useCallback((item2, index) => {\n    const fill = getColor({\n      data,\n      colorScheme,\n      point: item2.data,\n      index\n    });\n    return /* @__PURE__ */jsx(\"div\", {\n      className: classNames(css$1.outerBar, outerBarClassName),\n      children: /* @__PURE__ */jsx(motion.div, {\n        transition: DEFAULT_TRANSITION,\n        className: classNames(css$1.bar, barClassName),\n        initial: {\n          width: \"0%\"\n        },\n        animate: {\n          width: `${item2.data}%`\n        },\n        style: {\n          background: fill\n        },\n        tabIndex: 0,\n        \"aria-label\": getAriaLabel(item2),\n        role: \"graphics-document\"\n      })\n    });\n  }, [barClassName, outerBarClassName, colorScheme, data]);\n  return /* @__PURE__ */jsx(Fragment$1, {\n    children: data.map((d, i) => {\n      const label2 = labelFormat ? labelFormat(d.key, i) : d.key;\n      const valueLabel2 = valueFormat ? valueFormat(d.metadata.value, i) : formatValue(d.metadata.value);\n      return /* @__PURE__ */jsxs(\"div\", {\n        role: \"listitem\",\n        className: classNames(css$1.item, itemClassName, {\n          [css$1.clickable]: onItemClick,\n          [css$1.valueBottom]: valuePosition === \"bottom\",\n          [css$1.valueStart]: valuePosition === \"start\",\n          [css$1.valueEnd]: valuePosition === \"end\",\n          [css$1.valueNone]: valuePosition === \"none\",\n          [css$1.labelBottom]: labelPosition === \"bottom\",\n          [css$1.labelTop]: labelPosition === \"top\",\n          [css$1.labelStart]: labelPosition === \"start\",\n          [css$1.labelEnd]: labelPosition === \"end\",\n          [css$1.labelNone]: labelPosition === \"none\"\n        }),\n        onMouseEnter: () => onItemMouseEnter == null ? void 0 : onItemMouseEnter(d),\n        onMouseLeave: () => onItemMouseLeave == null ? void 0 : onItemMouseLeave(d),\n        onClick: () => onItemClick == null ? void 0 : onItemClick(d),\n        children: [/* @__PURE__ */jsx(\"label\", {\n          title: label2,\n          className: classNames(css$1.label, labelClassName),\n          children: label2\n        }), renderBar(d, i), /* @__PURE__ */jsx(\"label\", {\n          title: valueLabel2,\n          className: classNames(css$1.valueLabel, valueClassName),\n          children: /* @__PURE__ */jsx(\"small\", {\n            children: valueLabel2\n          })\n        })]\n      }, d.key);\n    })\n  });\n};\nBarListSeries.defaultProps = {\n  colorScheme: \"cybertron\",\n  labelPosition: \"top\",\n  valuePosition: \"none\"\n};\nconst BarList = ({\n  data,\n  id,\n  className,\n  sortDirection,\n  style,\n  series,\n  type\n}) => {\n  const curId = useId(id);\n  const mashedData = useMemo(() => {\n    const maxVal = type === \"count\" ? max(data, d => d.data) : 100;\n    const domainVal = maxVal == 0 ? [0] : [0, maxVal];\n    const groupScale = scaleLinear().domain(domainVal).rangeRound([0, 100]);\n    const mashed = data.map(d => ({\n      ...d,\n      data: groupScale(d.data),\n      metadata: {\n        value: d.data,\n        percent: data.length * d.data / 100\n      }\n    }));\n    if (sortDirection === \"asc\") {\n      mashed.sort((a, b) => a.data - b.data);\n    } else if (sortDirection === \"desc\") {\n      mashed.sort((a, b) => b.data - a.data);\n    }\n    return mashed;\n  }, [data, sortDirection]);\n  return /* @__PURE__ */jsx(motion.section, {\n    role: \"list\",\n    variants: {\n      initial: {\n        transition: {\n          staggerChildren: 0.05,\n          staggerDirection: -1\n        }\n      },\n      animate: {\n        transition: {\n          staggerChildren: 0.07,\n          delayChildren: 0.2\n        }\n      }\n    },\n    id: curId,\n    className,\n    style,\n    children: /* @__PURE__ */jsx(CloneElement, {\n      element: series,\n      data: mashedData\n    })\n  });\n};\nBarList.defaultProps = {\n  data: [],\n  sortDirection: \"desc\",\n  series: /* @__PURE__ */jsx(BarListSeries, {}),\n  type: \"count\"\n};\nconst MeterColumn = ({\n  index,\n  scale: scale2,\n  value: value2,\n  count,\n  height,\n  className,\n  animated,\n  activeFill,\n  inActiveFill\n}) => {\n  const isActive = scale2(index) <= scale2(value2);\n  const fill = isActive ? activeFill : inActiveFill;\n  const transition = animated ? {\n    ...DEFAULT_TRANSITION,\n    delay: index / count * 0.5\n  } : {\n    type: false,\n    delay: 0\n  };\n  return /* @__PURE__ */jsx(motion.div, {\n    initial: {\n      background: inActiveFill,\n      height\n    },\n    animate: {\n      background: fill,\n      height\n    },\n    tranisition: transition,\n    className\n  }, index);\n};\nMeterColumn.defaultProps = {\n  activeFill: schemes.cybertron[0],\n  inActiveFill: \"#414242\",\n  height: 32,\n  animated: true\n};\nconst container = \"_container_13giw_1\";\nconst css = {\n  container\n};\nconst Meter = ({\n  min: min2,\n  max: max2,\n  className,\n  column,\n  gap,\n  style,\n  value: value2,\n  columns\n}) => {\n  const scale2 = scaleLinear().domain([min2, max2]).range([0, 100]);\n  const cols = scale2.ticks(columns);\n  return /* @__PURE__ */jsx(\"div\", {\n    className: classNames(css.container, className),\n    style: {\n      gap: `${gap}px`,\n      ...style\n    },\n    children: cols.map(index => /* @__PURE__ */jsx(CloneElement, {\n      element: column,\n      count: cols.length,\n      index,\n      scale: scale2,\n      value: value2\n    }, index))\n  });\n};\nMeter.defaultProps = {\n  min: 0,\n  max: 100,\n  columns: 10,\n  gap: 15,\n  style: {},\n  column: /* @__PURE__ */jsx(MeterColumn, {})\n};\nconst RadarChartSeries = props => /* @__PURE__ */jsx(RadialAreaSeries, {\n  ...props\n});\nRadarChartSeries.defaultProps = {\n  area: null,\n  type: \"grouped\",\n  symbols: /* @__PURE__ */jsx(RadialPointSeries, {\n    show: true\n  })\n};\nconst RadarChart = props => /* @__PURE__ */jsx(RadialAreaChart, {\n  ...props\n});\nRadarChart.defaultProps = {\n  series: /* @__PURE__ */jsx(RadarChartSeries, {}),\n  axis: /* @__PURE__ */jsx(RadialAxis, {\n    type: \"category\",\n    arcs: /* @__PURE__ */jsx(RadialAxisArcSeries, {\n      count: 5,\n      arc: null,\n      line: /* @__PURE__ */jsx(RadialAxisArcLine, {})\n    })\n  })\n};\nconst FunnelArc = ({\n  data,\n  id,\n  xScale,\n  opacity,\n  index,\n  variant,\n  yScale,\n  interpolation,\n  colorScheme,\n  gradient: gradient2,\n  glow,\n  tooltip: tooltip2\n}) => {\n  const internalData = [...data, data[data.length - 1]];\n  const areaGenerator = area().curve(interpolate(interpolation)).x((_d, i) => xScale(i)).y0(yScale(0)).y1(({\n    data: data2\n  }) => yScale(data2));\n  const areaMirrorGenerator = area().curve(interpolate(interpolation)).x((_d, i) => xScale(i)).y0(yScale(0)).y1(({\n    data: data2\n  }) => yScale(-data2));\n  const fillColor = getColor({\n    data,\n    domain: [0, 1, 2, 3],\n    colorScheme,\n    key: index\n  });\n  const fillTop = gradient2 ? `url(#gradient-${id}-top)` : fillColor;\n  const fillBottom = gradient2 ? `url(#gradient-${id}-bottom)` : fillColor;\n  const [height] = yScale.range();\n  const [_, width] = xScale.range();\n  const ariaLabelData = useMemo(() => getAriaLabel(data), [data]);\n  return /* @__PURE__ */jsx(CloneElement, {\n    element: tooltip2,\n    xScale,\n    yScale,\n    data,\n    height,\n    width,\n    tooltip: /* @__PURE__ */jsx(ChartTooltip, {\n      followCursor: true,\n      content: (data2, color) => {\n        const value2 = {\n          x: data2.key,\n          y: data2.data,\n          value: data2.data\n        };\n        return /* @__PURE__ */jsx(TooltipTemplate, {\n          value: value2,\n          color\n        });\n      }\n    }),\n    children: /* @__PURE__ */jsxs(\"g\", {\n      pointerEvents: tooltip2 ? \"none\" : \"auto\",\n      style: generateGlowStyles({\n        glow\n      }),\n      \"aria-label\": ariaLabelData,\n      role: \"graphics-document\",\n      children: [/* @__PURE__ */jsx(motion.path, {\n        d: areaGenerator(internalData),\n        fill: fillTop,\n        stroke: \"none\",\n        initial: {\n          opacity: 0\n        },\n        animate: {\n          opacity\n        }\n      }), /* @__PURE__ */jsx(motion.path, {\n        d: areaMirrorGenerator(internalData),\n        fill: fillBottom,\n        stroke: \"none\",\n        initial: {\n          opacity: 0\n        },\n        animate: {\n          opacity\n        }\n      }), gradient2 && /* @__PURE__ */jsxs(Fragment$1, {\n        children: [/* @__PURE__ */jsx(CloneElement, {\n          element: gradient2,\n          id: `gradient-${id}-top`,\n          color: fillColor\n        }), /* @__PURE__ */jsx(CloneElement, {\n          element: gradient2,\n          id: `gradient-${id}-bottom`,\n          color: fillColor\n        })]\n      })]\n    })\n  });\n};\nFunnelArc.defaultProps = {\n  gradient: /* @__PURE__ */jsx(Gradient, {\n    direction: \"horizontal\",\n    stops: [/* @__PURE__ */jsx(GradientStop, {\n      offset: \"0%\",\n      stopOpacity: 1\n    }, \"stop\"), /* @__PURE__ */jsx(GradientStop, {\n      offset: \"80%\",\n      stopOpacity: 0.5\n    }, \"start\")]\n  }),\n  interpolation: \"smooth\",\n  colorScheme: schemes.cybertron[0],\n  animated: true,\n  variant: \"default\",\n  opacity: 1,\n  tooltip: null\n};\nconst FunnelAxisLabel = ({\n  data,\n  index,\n  xScale,\n  yScale,\n  fontFamily,\n  padding,\n  fontSize,\n  fill,\n  className,\n  position,\n  showValue,\n  labelVisibility\n}) => {\n  const x = xScale(index) + padding;\n  const [height] = yScale.range();\n  const y = height / 2 + padding;\n  const label2 = data.key;\n  const nextOffset = xScale(index + 1);\n  const width = (nextOffset ? nextOffset - xScale(index) : 0) - padding;\n  const size = calculateDimensions(label2, fontFamily, fontSize);\n  const text = wrapText({\n    key: label2,\n    size,\n    paddingY: padding,\n    paddingX: padding,\n    width,\n    height,\n    fontFamily,\n    fontSize,\n    visibility: labelVisibility\n  });\n  const getTransformString = useCallback(() => {\n    let transform2;\n    switch (position) {\n      case \"top\":\n        transform2 = `translate(${x}, ${fontSize * 3})`;\n        break;\n      case \"middle\":\n        transform2 = `translate(${x}, ${y})`;\n        break;\n      case \"bottom\":\n        {\n          const textWrapHeight = Array.isArray(text) ? text.slice(1).reduce((acc, curr) => acc + curr.props.dy, 0) : 0;\n          transform2 = `translate(${x}, ${height - padding - textWrapHeight})`;\n        }\n        break;\n    }\n    return transform2;\n  }, [position, x, fontSize, y, text, height, padding]);\n  if (labelVisibility !== \"always\" && size.width > width) {\n    return null;\n  }\n  return /* @__PURE__ */jsxs(motion.g, {\n    transform: getTransformString(),\n    initial: {\n      opacity: 0\n    },\n    animate: {\n      opacity: 1\n    },\n    children: [showValue && /* @__PURE__ */jsx(\"text\", {\n      pointerEvents: \"none\",\n      fill,\n      y: -(fontSize + padding),\n      className,\n      dominantBaseline: \"middle\",\n      fontFamily,\n      fontSize: fontSize * 2,\n      children: formatValue(data.data)\n    }), /* @__PURE__ */jsx(\"text\", {\n      pointerEvents: \"none\",\n      fill,\n      className,\n      dominantBaseline: \"middle\",\n      fontFamily,\n      fontSize,\n      children: text\n    })]\n  });\n};\nFunnelAxisLabel.defaultProps = {\n  fontSize: 13,\n  padding: 10,\n  fontFamily: \"sans-serif\",\n  fill: \"#fff\",\n  position: \"middle\",\n  showValue: true,\n  labelVisibility: \"auto\"\n};\nconst FunnelAxisLine = ({\n  strokeColor,\n  strokeWidth,\n  yScale,\n  xScale,\n  index\n}) => {\n  const [height] = yScale.range();\n  return /* @__PURE__ */jsx(\"line\", {\n    x1: xScale(index),\n    y1: 0,\n    x2: xScale(index),\n    y2: height,\n    stroke: strokeColor,\n    strokeWidth,\n    pointerEvents: \"none\"\n  });\n};\nFunnelAxisLine.defaultProps = {\n  strokeColor: \"#333\",\n  strokeWidth: 2\n};\nconst FunnelAxis = ({\n  data,\n  xScale,\n  yScale,\n  line: line2,\n  label: label2\n}) => {\n  const lines = range(0, data.length);\n  return /* @__PURE__ */jsx(Fragment$1, {\n    children: lines.map(index => /* @__PURE__ */jsxs(Fragment, {\n      children: [line2 && index !== 0 && /* @__PURE__ */jsx(CloneElement, {\n        element: line2,\n        index,\n        xScale,\n        yScale\n      }), label2 && /* @__PURE__ */jsx(CloneElement, {\n        element: label2,\n        index,\n        data: data[index],\n        xScale,\n        yScale\n      })]\n    }, index))\n  });\n};\nFunnelAxis.defaultProps = {\n  label: /* @__PURE__ */jsx(FunnelAxisLabel, {}),\n  line: /* @__PURE__ */jsx(FunnelAxisLine, {})\n};\nconst FunnelSeries = ({\n  data,\n  id,\n  arc: arc2,\n  axis,\n  height,\n  width,\n  onSegmentClick\n}) => {\n  const getScales = useCallback((height2, width2) => {\n    const yScale = scaleLinear().domain([-max(data, ({\n      data: data2\n    }) => data2), max(data, ({\n      data: data2\n    }) => data2)]).nice().range([height2, 0]);\n    const xScale = scaleLinear().domain([0, data.length]).range([0, width2]);\n    const transformedData = data.map((d, i) => ({\n      ...d,\n      key: d.key,\n      x: xScale(i),\n      i\n    }));\n    return {\n      data: transformedData,\n      yScale,\n      xScale\n    };\n  }, [data]);\n  const {\n    datas,\n    halfOffset\n  } = useMemo(() => {\n    if (arc2.props.variant === \"layered\") {\n      const offset = height / 4;\n      const halfOffset2 = offset / 2;\n      return {\n        halfOffset: halfOffset2,\n        datas: [{\n          data,\n          ...getScales(height, width)\n        }, {\n          data,\n          ...getScales(height - offset, width)\n        }, {\n          data,\n          ...getScales(height - offset * 2, width)\n        }]\n      };\n    } else {\n      return {\n        halfOffset: 0,\n        datas: [{\n          data,\n          ...getScales(height, width)\n        }]\n      };\n    }\n  }, [data, arc2, height, width, getScales]);\n  const handleSegmentClick = useCallback(e => {\n    if (onSegmentClick) {\n      const {\n        xScale,\n        data: data2\n      } = datas[0];\n      const {\n        clientX,\n        clientY,\n        target\n      } = e;\n      const position = getPositionForTarget({\n        target,\n        clientX,\n        clientY\n      });\n      const value2 = getClosestContinousScalePoint({\n        pos: position.x,\n        scale: xScale,\n        data: data2,\n        attr: \"i\"\n      });\n      onSegmentClick({\n        value: {\n          key: value2.key,\n          data: value2.data\n        },\n        nativeEvent: e\n      });\n    }\n  }, [datas, onSegmentClick]);\n  return /* @__PURE__ */jsxs(Fragment$1, {\n    children: [datas.map((d, i) => /* @__PURE__ */jsx(\"g\", {\n      style: {\n        transform: `translate(0, ${i * halfOffset}px)`\n      },\n      onClick: handleSegmentClick,\n      children: /* @__PURE__ */jsx(CloneElement, {\n        element: arc2,\n        ...d,\n        id: `${id}-arc-${i}`,\n        index: i\n      })\n    }, i)), /* @__PURE__ */jsx(CloneElement, {\n      element: axis,\n      data,\n      xScale: datas[0].xScale,\n      yScale: datas[0].yScale\n    })]\n  });\n};\nFunnelSeries.defaultProps = {\n  arc: /* @__PURE__ */jsx(FunnelArc, {}),\n  axis: /* @__PURE__ */jsx(FunnelAxis, {})\n};\nconst FunnelChart = ({\n  data,\n  width,\n  margins,\n  height,\n  className,\n  containerClassName,\n  series,\n  ...rest\n}) => {\n  const id = useId(rest.id);\n  const renderChart = useCallback(({\n    id: id2,\n    chartWidth,\n    chartHeight,\n    chartSized\n  }) => {\n    if (!chartSized) {\n      return null;\n    }\n    return /* @__PURE__ */jsx(CloneElement, {\n      element: series,\n      id: `funnel-series-${id2}`,\n      data,\n      height: chartHeight,\n      width: chartWidth\n    });\n  }, [data, series]);\n  return /* @__PURE__ */jsx(ChartContainer, {\n    id,\n    width,\n    height,\n    margins,\n    containerClassName,\n    className,\n    children: renderChart\n  });\n};\nFunnelChart.defaultProps = {\n  margins: 0,\n  series: /* @__PURE__ */jsx(FunnelSeries, {})\n};\nexport { Area, AreaChart, AreaSeries, AreaSparklineChart, Bar, BarChart, BarLabel, BarList, BarListSeries, BarSeries, BarSparklineChart, Brush, BrushHandle, BrushSlice, Bubble, BubbleChart, BubbleLabel, BubbleSeries, COUNT_DEFAULTS, CalendarHeatmap, ChartBrush, ChartConsumer, ChartContainer, ChartContext, ChartProvider, ChartTooltip, ChartZoomPan, Count, DEFAULT_TRANSITION, DiscreteLegend, DiscreteLegendEntry, DiscreteLegendSymbol, FunnelArc, FunnelAxis, FunnelAxisLabel, FunnelAxisLine, FunnelChart, FunnelSeries, Gradient, GradientStop, GridStripe, Gridline, GridlineSeries, GuideBar, Heatmap, HeatmapCell, HeatmapSeries, HistogramBarChart, HistogramBarSeries, Line, LineChart, LineSeries, LinearAxis, LinearAxisLine, LinearAxisTickLabel, LinearAxisTickLine, LinearAxisTickSeries, LinearGauge, LinearGaugeBar, LinearGaugeOuterBar, LinearGaugeSeries, LinearValueMarker, LinearXAxis, LinearXAxisTickLabel, LinearXAxisTickLine, LinearXAxisTickSeries, LinearYAxis, LinearYAxisTickLabel, LinearYAxisTickLine, LinearYAxisTickSeries, Map$1 as Map, MapMarker, MarimekkoBarSeries, MarimekkoChart, MarkLine, Mask, Meter, MeterColumn, MotionPath, Move, Pan, PieArc, PieArcLabel, PieArcSeries, PieChart, PointSeries, RadarChart, RadarChartSeries, RadialArea, RadialAreaChart, RadialAreaSeries, RadialAxis, RadialAxisArc, RadialAxisArcLine, RadialAxisArcSeries, RadialAxisTick, RadialAxisTickLabel, RadialAxisTickLine, RadialAxisTickSeries, RadialBar, RadialBarChart, RadialBarSeries, RadialGauge, RadialGaugeArc, RadialGaugeLabel, RadialGaugeOuterArc, RadialGaugeSeries, RadialGaugeStackedArc, RadialGaugeValueLabel, RadialGradient, RadialGuideBar, RadialLine, RadialPointSeries, RadialScatterPlot, RadialScatterPoint, RadialScatterSeries, RadialValueMarker, RangeLines, Sankey, SankeyLabel, SankeyLink, SankeyNode, ScatterPlot, ScatterPoint, ScatterSeries, SequentialLegend, SonarChart, SparklineChart, StackedAreaChart, StackedAreaSeries, StackedBarChart, StackedBarSeries, StackedNormalizedAreaChart, StackedNormalizedAreaSeries, StackedNormalizedBarChart, StackedNormalizedBarSeries, StackedRadialGaugeDescriptionLabel, StackedRadialGaugeSeries, StackedRadialGaugeValueLabel, Stripes, TooltipArea, TooltipTemplate, TreeMap, TreeMapLabel, TreeMapRect, TreeMapSeries, VennArc, VennDiagram, VennLabel, VennOuterLabel, VennSeries, Zoom, ZoomPan, addWeeksToDate, bigIntegerToLocaleString, buildBarStackData, buildBins, buildDataScales, buildMarimekkoData, buildNestedChartData, buildShallowChartData, buildStackData, buildWaterfall, calculateDimensions, calculateShowStroke, constrainMatrix, constructFunctionProps, createColorSchemeValueScales, extent, formatValue, functionProps, getAriaLabel, getClosestBandScalePoint, getClosestContinousScalePoint, getColor, getColorSchemeStyles, getDegrees, getDimension, getDurationTicks, getGroupScale, getInnerScale, getLimitMatrix, getMarimekkoGroupScale, getMarimekkoScale, getMaxBigIntegerForNested, getMaxBigIntegerForShallow, getMaxTicks, getParentSVG, getPointFromMatrix, getPositionForTarget, getRadialYScale, getTicks, getXDomain, getXScale, getYDomain, getYScale, humanFormatBigInteger, interpolate, isAxisVisible, isZoomLevelGoingOutOfBounds, normalizeValue, normalizeValueForFormatting, reduceTicks, schemes, toggleTextSelection, tooltipTheme, uniqueBy, useChart, useCount, weekDays, wrapText };","map":{"version":3,"names":["useDimensions","bigInt","chroma","isEqual","useMotionValue","useSpring","motion","animate","interpolate","interpolate$1","identifier","geoNaturalEarth1","geoMercator","geoPath","sankey","sankeyJustify","sankeyCenter","sankeyLeft","sankeyRight","sankeyLinkHorizontal","layout","invert","pack","hierarchy","treemap","treemapSquarify","LinearAxisLine","strokeColor","strokeWidth","strokeGradient","scale","scale2","orientation","className","id","useId","range0","range1","range","jsxs","Fragment","children","jsx","x1","x2","y1","y2","stroke","CloneElement","element","defaultProps","LinearAxis","props","position","tickSeries","axisLine","height","width","visibility","onDimensionsChange","containerRef","createRef","dimensions","setDimensions","useState","updateDimensions","useCallback","shouldOffset","height2","width2","dims","current","getBoundingClientRect","Math","floor","useEffect","getPosition","translateY2","translateX2","translateX","translateY","transform","ref","line","label","axis","scaled","roundDomains","LinearAxisTickLabel","text","fullText","angle","half","line2","textAnchor","fill","fontSize","fontFamily","rotation","padding","formatTooltip","align","getAlign","getTickLineSpacing","size","position2","getOffset","adjustedPadding","fromAxis","alongAxis","spacing","offset1","align2","offset2","horz","getTextPosition","transform2","newtextAnchor","alignmentBaseline","x","y","textPosition","titleHover","LinearAxisTickLine","path2","useMemo","isVertical","tickSize","start2","end2","getNavigatorLanguage","window","navigator","languages","length","userLanguage","language","browserLanguage","locale","options","month","day","hour12","formatMatcher","formatValue","value2","Date","toLocaleDateString","toLocaleString","getAriaLabel","datapoint","isArray","Array","map","row","join","key","data","ONE_DAY","DURATION_TICK_STEPS","reduceTicks","ticks","maxTicks","reduced","modulus","i","push","getMaxTicks","dimension","tickWidth","max","getDurationTicks","domain","domainWidth","tickStep","s","numDayTicks","dayStep","ceil","getTicks","tickValues","type","interval","result","cache","calculateDimensions","document","parseInt","toString","dimensions2","createElement","style","left","whiteSpace","fontWeight","lineHeight","wordBreak","textContent","body","appendChild","offsetHeight","offsetWidth","removeChild","LinearAxisTickSeries","label2","getAdjustedScale","bandwidth","offset","round","d","scaledTick","getDimension2","labelFormatFn","format","tickFormat","apply","v","ticks2","adjustedScale","midpoint","tick","ellipsize","labelProps","maxTicksLength","angle2","baseWidth","maxBaseWidth","cos","PI","LinearXAxisTickLabel","LinearXAxisTickLine","LinearXAxisTickSeries","LinearXAxis","LinearYAxisTickLabel","LinearYAxisTickLine","LinearYAxisTickSeries","LinearYAxis","isAxisVisible","RadialAxisTickLine","innerRadius","outerRadius","pointerEvents","rad2deg","RadialAxisTickLabel","point","point2","autoRotate","lineSize","index","rest","textAnchor2","transform22","shouldRotate","rotate","translate2","dy","startAngle","endAngle","RadialAxisTick","RadialAxisTickSeries","count","tickElement","RadialAxisArc","strokeDasharray","_a","_b","_c","_d","r","strokeDash","isFullCircle","abs","arc","REGEX","matches","match","split","Fragment$1","cx","cy","getPointsForLevels","arcs","levels","polyangle","level","hyp","points","vertex","theta","sin","RadialAxisArcSeries","arc2","scaleLinear","RadialAxisArcLine","lineGenerator","line$1","d2","humanFormatScale","humanFormat","Scale","k","M","B","humanFormatMillionScale","T","ONE_MILLION","ONE_BILLION","humanFormatBigInteger","bigInteger","greater","divide","toJSNumber","bigIntegerToLocaleString","formattedString","c","reverse","parseMargins","margins","top","right","bottom","calculateMarginOffsets","newHeight","newWidth","getDimension","xOffset","yOffset","parsedMargins","marginDims","chartWidth","chartHeight","xMargin","yMargin","extent","attr","accessor","val","fn","vv","minVal","min","maxVal","getYDomain","isDiverging","startY","endY","startY1","endY1","posStart","maxNum","getXDomain","startX0","endX1","curveMonotoneX","curveStep","curveLinear","scaleBandInvert","paddingOuter","eachBand","step","band","getClosestContinousScalePoint","pos","roundDown","bisect","bisector","minIndex","before","maxIndex2","after","beforeVal","afterVal","getClosestBandScalePoint","roundClosest","prop","mariemkoInvert","idx","indexOf","getParentSVG","event","node2","target","ownerSVGElement","getPositionForTarget","clientX","clientY","rect","clientLeft","clientTop","getPointFromMatrix","matrix","parent","applyToPoint","inverse","getLimitMatrix","applyToPoints","constrainMatrix","min2","max2","lessThanScaleFactorMin","scaleFactor","scaleFactorMin","moreThanScaleFactorMax","scaleFactorMax","isZoomLevelGoingOutOfBounds","a","b","toggleTextSelection","allowSelection","forEach","calculateShowStroke","showLine","prev","cur","next","getDegrees","radians","functionProps","classNames","constructFunctionProps","uniqueBy","accessors","ittr","arr","depth","acc","Error","includes","wrapText","paddingY","wrap","paddingX","words","rows","maxWidth","maxHeight","curText","currWidth","nextText","nextWidth","word","dominantBaseline","baselineShift","RadialAxis","xScale","Move","started","deltaX","deltaY","prevXPosition","prevYPosition","rqf","useRef","cancelAnimationFrame","disposeHandlers","removeEventListener","onMouseMove","onMouseUp","onTouchMove","onTouchEnd","setCursor","disableText","shouldDisable","set","cursor","checkThreshold","threshold","getTouchCoords","touches","onMouseDown","preventRightClick","disabled","shouldCancel","nativeEvent","which","preventDefault","stopPropagation","addEventListener","movementX","movementY","localDeltaX","localDeltaY","onMoveStart","requestAnimationFrame","onMove","onMoveEnd","onMoveCancel","onTouchStart","Children","child","cloneElement","e","handle","dragging","dot","css$s","BrushHandle","onHandleDrag","isDragging","setIsDragging","slice","unsliced","css$r","BrushSlice","start","end","onBrushChange","sliceWidth","endSliceWidth","hasNoSlice","hasNoSlice2","startUpdated","endUpdated","direction","opacity","Brush","startProp","endProp","isSlicing","setIsSlicing","initial","setInitial","range2","setRange","ensurePositionInBounds","newStart","newEnd","getPositionsForPanEvent","eventObj","getStartEnd","positions","start22","end22","onSliceChange","state","bind","ChartBrush","getBrushOffset","onBrushChangeHandler","domain2","context","useContext","ChartContext","container$3","svg","css$q","container","ChartContainer","center","centerX","centerY","containerClassName","xAxisVisible","yAxisVisible","curId","xAxisSized","setXAxisSized","yAxisSized","setYAxisSized","setXOffset","setYOffset","observe","chartSized","onUpdateAxes","childProps","updateAxes","styleHeight","styleWidth","ChartProvider","value","tabIndex","normalizeValue","maxBigInt","isInstance","divideBy","normalizeValueForFormatting","getMaxBigIntegerForNested","series","maxBigInteger","one","group","maxBigIntegerForGroup","getMaxBigIntegerForShallow","buildNestedChartData","sort","nestedPoint","findIndex","getTime","metadata","x0","y0","aMax","median","bMax","addToChartType","add","valueOf","buildShallowChartData","binSize","isTuple","k1","k0","v0","v1","xProp","yProp","buildBins","thresholds","layout2","histogram","bins","bin","transformDataToStack$1","category","formattedValues","transformStackToData$1","stackData","categoryKey","buildBarStackData","keys","stackFn","stack","stackOffsetExpand","stackOffsetDiverging","buildMarimekkoData","sums","totalSum","sum","reduce","transformDataToStack","transformStackToData","buildStackData","normalized","buildWaterfall","cumulative","Pan","Component","constructor","arguments","childRef","globalPanning","classList","contains","onPanStart","pan","onPanEnd","onPanCancel","source","contrained","componentDidMount","passive","componentWillUnmount","onPanMove","constrain","newMatrix","smoothMatrix","translate","shouldConstrain","f","render","getMidpoint","pointA","pointB","getDistanceBetweenPoints","sqrt","pow","getTouchPoints","touch","distance","Zoom","onMouseWheel","disableMouseWheel","requireZoomModifier","onZoomEnd","hasModifier","metaKey","ctrlKey","getStep","clearTimeout","timeout","setTimeout","firstTouch","lastDistance","distanceFactor","outside","delta","minZoom","maxZoom","onZoom","container$2","horizontal$2","vertical$2","css$p","horizontal","vertical","DiscreteLegend","entries","entry2","symbol","css$o","entry","vertical$1","label$3","horizontal$1","css$n","DiscreteLegendEntry","symbol2","title","color","onMouseEnter","onMouseLeave","onClick","gradient","css$m","container$1","SequentialLegend","gradientClassName","colorScheme","colors","extent$1","gradientDir","background","gridLine","css$l","Gridline","coords","GridlineSeries","stripe","yScale","yAxis","xAxis","shouldRenderY","shouldRenderX","yAxisGrid","xAxisGrid","renderGroup","grid","renderSeries","yAxisGrid2","xAxisGrid2","gridStripe","css$k","GridStripe","stripeFill","dim","markLine","css$j","MarkLine","pointX","vectorEffect","GradientStop","stopOpacity","stopColor","Gradient","stops","stop","spreadMethod","RadialGradient","radius","gradientUnits","label$2","subValue","subValueColor","subValueName","css$i","TooltipTemplate","renderValues","backgroundColor","renderMultiple","value22","excessCount","pagedValues","isMultiple","base","disablePointer","css$h","tooltipTheme","ChartTooltip","content","Tooltip","theme","TooltipArea","forwardRef","inverse2","tooltip","tooltip2","isRadial","isContinous","onValueEnter","isHorizontal","placement","placementProp","onValueLeave","visible","setVisible","setPlacement","setValue","offsetX","setOffsetX","offsetY","setOffsetY","prevX","setPrevX","prevY","setPrevY","fullCircleref","rotationFactor","getXCoord","outerRadiusNew","rad","atan2","transformData","seriesPoint","data2","shallowPoint","transformed","newPlacement","keyScale","valueScale","coord","newValue","pointY","marginX","marginY","isNaN","target2","offsetX2","offsetY2","outerRadius2","useImperativeHandle","triggerMouseMove","tooltipReference","renderRadial","innerRadiusNew","fullCircle","renderLinear","modifiers","reference","ZoomPan","pannable","zoomable","zoomStep","onZoomPan","zoomRef","panRef","isZooming","setIsZooming","isPanning","setIsPanning","setMatrix","identity","fromDefinition","tx","ty","sx","sy","onPanStartHandler","onPanMoveHandler","onPanEndHandler","onZoomHandler","onZoomEndHandler","selection","matrixObj","fromObject","userSelect","getXScale","isMultiSeries","scaleTime","rangeRound","scaleBand","nice","getYScale","getMarimekkoScale","getMarimekkoGroupScale","barCount","widthMinusPadding","xMultiplier","getXRange","arg","found","getGroupScale","paddingInner","getInnerScale","groupScale","getRadialYScale","Object","assign","ChartZoomPan","axisType","onZoomPanHandler","can","newScale","copy","clamp","isZoomed","zoomOffset","zoomOffset2","endOffset","DEFAULT_TRANSITION","velocity","damping","restDelta","restSpeed","MotionPath","custom","transition","exit","spring","interpolator","get","enter","prevSpring","on","enterD","enterRest","exitD","exitRest","path","schemes","cybertron","correctLightness","brewer","isColorSchemeStyleArray","rangeHelper","attribute","getColor","active","scaleOrdinal","maxIdx","maxIndex","getValueScale","emptyColor","selections","valueDomain","scaleQuantile","getColorSchemeStyles","valueScales","from","getColorSchemeForProperty","colorSchemeProperty","schemeItem","createColorSchemeValueScales","Map","colorSchemeProperties","Set","flatMap","COUNT_DEFAULTS","duration","delay","decimalPlaces","useCount","to","prefix","suffix","nodeRef","controls","onUpdate","formatted","Number","toFixed","Count","localize","LinearValueMarker","thickness","coordinates","RadialValueMarker","inactive$1","hidden$1","css$g","inactive","hidden","generateGlowStyles","glow","colorSchemeColor","blur","alpha","css","filter","ScatterPoint","animated","rectRef","tooltipVisible","setTooltipVisible","extras","renderedSymbol","transitionProps","enterProps","exitProps","yStartDomain","ariaLabelData","isVisible","role","g","circle","PADDING$1","HALF_PADDING$1","ScatterSeries","activeIds","valueMarkers","renderPoint","pointData","pointId","renderValueMarkers","marker2","clipPath","scatterPlot","css$f","ScatterPlot","gridlines","brush","zoomPan","secondaryAxis","zoomControlled","hasOwnProperty","preventAnimation","setPreventAnimation","zoomDomain","setZoomDomain","setIsZoomed","aggregatedData","getScales","renderChart","id2","disableBrush","css$e","PointSeries","activeValues","show","getIsVisible","point22","isActive","Area","gradient2","mask","total","interpolation","item2","getAreaPath","area","curve","areaPath","maxY","coords2","renderArea","maskPath","Mask","Line","hasArea","showZeroStroke","pathLength","setPathLength","ghostPathRef","getTotalLength","getLinePath","defined","linePath","strokeDashoffset","newCoords","strokeFill","PADDING","HALF_PADDING","AreaSeries","markLine2","symbols","area2","setActiveValues","setActivePoint","isMulti","getPointColor","renderSymbols","activeSymbols","isAnimated","renderMarkLine","activePoint","renderSingleSeries","renderMultiSeries","StackedNormalizedAreaSeries","StackedAreaSeries","areaChart","css$d","AreaChart","zoom","timeoutRef","seriesType","zoom2","StackedAreaChart","StackedNormalizedAreaChart","Bar","activeBrightness","barIndex","groupIndex","minHeight","rangeLines","rx","ry","isCategorical","guide","xScale1","internalActive","setInternalActive","calculateLinearScalePadding","scale22","totalSize","sizeMinusPadding","multiplier","getExit","newX","newY","getKeyCoords","sizeOverride","isCategorical2","padding2","calc","c0","c1","getValueCoords","minSize","getCoords","newYScale","newXScale","xCoords","yCoords","onMouseEnterInternal","onMouseLeaveInternal","onMouseClick","getFill","color2","tooltipData","xAttr","getTransition","index2","renderBar","currentColorShade2","initialExit","attrX","attrY","animate2","renderGuideBar","console","error","attrStart","endPoint","startPoint","currentColorShade","brighten","hex","rangeLineColor","rangeLineColorShade","barLabel","BarSeries","bar","bar2","getTransform","xPos","yPos","getBarColor","barElements","renderBarGroup","barData","groupData","groupPadding","followCursor","RangeLines","rangeLineHeight","isTop","minX","delay2","StackedBarSeries","StackedNormalizedBarSeries","MarimekkoBarSeries","BarLabel","HistogramBarSeries","GuideBar","other","barChart","stackedNormalized","stacked","marimekko","css$c","BarChart","keyAxis","getMarimekkoGroupScales","getMultiGroupScales","getKeyScale","getValueScale2","getScalesAndData","isMarimekko","isGrouped","isStacked","distroType","containerProps","MarimekkoChart","StackedBarChart","StackedNormalizedBarChart","HistogramBarChart","LineSeries","LineChart","Map$1","markers","projection","getProjection","fitSize","renderMarker","projection2","warn","renderCountry","geoProjection","features","marker","css$b","modifiers$1","MapMarker","setActive","useInterpolate$1","prevData","newData","useHoverIntent","sensitivity","onPointerOver","onPointerOut","mouseOver","timer","px","py","comparePosition","cleanup","pointerOver","pointerOut","PieArc","arcRef","internalFill","findBreakPoint","startX","endX","breakPoint","breakPointCondition","sign","minScale","maxScale","getTextAnchor","PieArcLabel","centroid","lineStroke","fontFill","posX","posY","minRadius","innerPoint","shapeRendering","factor","midAngle","labelVisible","shouldDisplayLabel","displayAllLabels","arcData","calculateOuterRadius","explode","calculateCentroid","newOuter","calculateRadius","arcWidth","doughnut","minDimension","labelWidth","outerArcRadius","calculateInnerArc","cornerRadius","padAngle","padRadius","calculateLabelPositions","minDistance","outerArc","aPosX","aPosY","j","bPosX","bPosY","overlap","PieArcSeries","innerArc","renderItem","safeKey","PieChart","newId","internalData","pieLayout","pie","DEFAULT_COLOR","LABEL_PADDING_PERCENT","JUSTIFICATION","justify","Sankey","links","justification","nodeWidth","nodePadding","labelPosition","nodeSort","nodes","activeNodes","setActiveNodes","activeLinks","setActiveLinks","getNodeColor","onNodeActive","activeNodes2","activeLinks2","sourceLinks","sourceLink","sourceLinkTarget","targetLinks","targetLink","targetLinkSource","onLinkActive","link2","onInactive","nodeMap","nodeMap2","renderNode","computedNode","some","node22","labelPadding","renderLink","computedLink","chartId","getNodesAndLinks","sankeyChart","nodeAlign","nodeId","nodesCopy","linksCopy","sankeyNodes","sankeyLinks","nodePosition","label$1","css$a","LABEL_PADDING","LABEL_TRUNCATE_LENGTH","SankeyLabel","node","ellipsis","paddedWidth","showRightSide","truncatedTitle","avaialableWidth","link","tooltip$1","tooltipLabel$1","tooltipValue$1","css$9","tooltipLabel","tooltipValue","SankeyLink","linkSource","linkTarget","hovered","setHovered","linkRef","getLink","renderTooltipContent","strokeOpacity","css$8","SankeyNode","nodeHeight","fillOpacity","SparklineChart","AreaSparklineChart","Stripes","BarSparklineChart","SonarChart","RadialArea","isClosedCurve","getPath","curveCardinalClosed","curveCardinal","curveLinearClosed","radialFn","radialArea","dd","_","yStart","RadialLine","preData","radialLine","RadialScatterPlot","outer","inner","xDomain","yDomain","css$7","RadialScatterPoint","getTranslate","parseFloat","sizeVal","exitTransform","RadialScatterSeries","internalActiveIds","setInternalActiveIds","dataId","pointVisible","RadialPointSeries","RadialAreaSeries","getColorForPoint","RadialAreaChart","getXScale2","scalePoint","innerRadius2","pi","tau","epsilon","tauEpsilon","append","strings","n","appendRound","digits","Path","_x0","_y0","_x1","_y1","_append","moveTo","closePath","lineTo","quadraticCurveTo","bezierCurveTo","arcTo","x21","y21","x01","y01","l01_2","x20","y20","l21_2","l20_2","l21","l01","l","tan","acos","t01","t21","a0","a1","ccw","dx","cw","da","w","h","prototype","MotionBar","currentYRef","timeoutId","unsubscribe","onChange","RadialGuideBar","variants","RadialBar","curved","innerBarCount","previousEnter","getArc","arcFn","xScaleDomain","xScaleRange","xScaleBandwidth","rotateMid","innerAngleDistance","arcLength","outerAngleDistance","halfAngleDistanceDelta","innerDiff","innerStart","innerEnd","outerDiff","halfAngleDiffDistanceDelta","pathFn","fill2","yEnd","guidePath","RadialBarSeries","RadialBarChart","RadialGaugeArc","arcGenerator","arcElement","valueLabel$2","css$6","valueLabel","RadialGaugeLabel","valueLabel$1","css$5","RadialGaugeValueLabel","RadialGaugeOuterArc","RadialGaugeSeries","valueLabel2","minGaugeWidth","columns","columns2","xScale2","yScale2","renderGauge","dataEndAngle","labelOffset","RadialGaugeStackedArc","restProps","stackedArcs","prevEndAngle","renderArc","startArcAngle","endArcAngle","stackedValueLabel","css$4","StackedRadialGaugeValueLabel","isChartNestedData","StackedRadialGaugeSeries","stackedInnerArc","descriptionLabel","fillFactor","arcPadding","rAxis","renderOuterArc","renderInnerArc","renderStackedArc","renderStackedGauges","call","stackedDescriptionLabel","css$3","StackedRadialGaugeDescriptionLabel","RadialGauge","minValue","maxValue","cell","css$2","HeatmapCell","cellIndex","cellCount","isTransparent","appliedStroke","HeatmapSeries","cellElement","renderCell","cell2","rowIndex","cellCount2","Heatmap","getScalesData","nestedData","scalesData","getFirstOfMonth","date","getFullYear","getMonth","addWeeksToDate","weeks","setDate","getDate","getStartOfDay","setHours","getNewDayFromDay","num","weekDays","base2","UTC","name","weekday","buildDataScales","rawData","view","startDate","endDomain","xDomainRange","dates","firstDayOfStart","getDay","curDate","week","dayValue","find","xAxisLabelFormat","CalendarHeatmap","domainData","xTickValues","yAxisLabelFormat","LinearGaugeBar","LinearGaugeOuterBar","LinearGaugeSeries","outerBar","outerBar2","LinearGauge","transformedData","minValue2","maxValue2","useInterpolate","stiffness","VennArc","inactiveStyle","activeStyle","initialStyle","currentStyle","arcFill","sets","VennLabel","labelType","showAll","_e","large","circles","VennOuterLabel","isElement","isValidElement","showIcon","icon","verticalAlign","VennSeries","actives","setActives","onActivate","textFill","darken","isSelected","isHovered","getStrokeColor","arcStroke","outerLabel","topArcs","xlinkHref","bb","venn5","intersections","shapes","venn0","venn1","venn2","venn3","venn4","upto","limit","isEllipse","combinations","array","_e1","_e2","lookup","combo","buildData","uniqueSets","uniqueSetKeys","u","sets2","filteredSets","diff","keyedData","sets22","uniqueCount","generateArcSlicePath","refs","rot","sweep","buildLayout","box","shape","mx","my","shapeSets","intersections2","starEulerLayout","bb2","VennDiagram","layoutData","distinct","Bubble","bubbleRef","BubbleLabel","BubbleSeries","bubble","renderBubble","BubbleChart","getData","ch","root","leaves","TreeMapLabel","TreeMapRect","currentFill","tooltipLabel2","getKey","TreeMapSeries","TreeMap","paddingTop","t","tile","tree","getAllNodes","datas","labelNone","labelEnd","valueStart","labelTop","valueBottom","valueNone","clickable","BarListSeries","itemClassName","labelClassName","outerBarClassName","valueClassName","labelFormat","barClassName","valuePosition","valueFormat","onItemClick","onItemMouseEnter","onItemMouseLeave","css$1","div","item","valueEnd","labelBottom","labelStart","BarList","sortDirection","mashedData","domainVal","mashed","percent","section","staggerChildren","staggerDirection","delayChildren","MeterColumn","activeFill","inActiveFill","Meter","column","gap","cols","RadarChartSeries","RadarChart","FunnelArc","variant","areaGenerator","areaMirrorGenerator","fillColor","fillTop","fillBottom","FunnelAxisLabel","showValue","labelVisibility","nextOffset","getTransformString","textWrapHeight","curr","FunnelAxisLine","FunnelAxis","lines","FunnelSeries","onSegmentClick","halfOffset","halfOffset2","handleSegmentClick","FunnelChart"],"sources":["/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/common/Axis/LinearAxis/LinearAxisLine.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/common/Axis/LinearAxis/LinearAxis.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/common/Axis/LinearAxis/LinearAxisTickLabel.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/common/Axis/LinearAxis/LinearAxisTickLine.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/common/utils/formatting.ts","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/common/utils/ticks.ts","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/common/utils/size.ts","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/common/Axis/LinearAxis/LinearAxisTickSeries.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/common/Axis/LinearAxis/LinearXAxis.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/common/Axis/LinearAxis/LinearYAxis.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/common/Axis/LinearAxis/helpers.ts","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/common/Axis/RadialAxis/RadialAxisTickSeries/RadialAxisTickLine.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/common/Axis/RadialAxis/RadialAxisTickSeries/RadialAxisTickLabel.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/common/Axis/RadialAxis/RadialAxisTickSeries/RadialAxisTick.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/common/Axis/RadialAxis/RadialAxisTickSeries/RadialAxisTickSeries.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/common/Axis/RadialAxis/RadialAxisArcSeries/RadialAxisArc.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/common/Axis/RadialAxis/RadialAxisArcSeries/utils.ts","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/common/Axis/RadialAxis/RadialAxisArcSeries/RadialAxisArcSeries.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/common/Axis/RadialAxis/RadialAxisArcSeries/RadialAxisArcLine.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/common/utils/bigint.ts","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/common/utils/dimensions.ts","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/common/utils/domains.ts","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/common/utils/interpolation.ts","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/common/utils/position.ts","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/common/utils/selection.ts","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/common/utils/stroke.ts","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/common/utils/math.ts","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/common/utils/functions.ts","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/common/utils/array.ts","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/common/utils/wrapText.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/common/Axis/RadialAxis/RadialAxis.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/common/Gestures/Move.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/common/Brush/BrushHandle.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/common/Brush/BrushSlice.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/common/Brush/Brush.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/common/Brush/ChartBrush.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/common/containers/ChartContext.ts","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/common/containers/ChartContainer.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/common/data/bigInteger.ts","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/common/data/builder.ts","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/common/data/histogram.ts","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/common/data/barStack.ts","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/common/data/marimekko.ts","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/common/data/areaStack.ts","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/common/data/waterfall.ts","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/common/Gestures/Pan.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/common/Gestures/pinchUtils.ts","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/common/Gestures/Zoom.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/common/legends/DiscreteLegend/DiscreteLegend.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/common/legends/DiscreteLegend/DiscreteLegendSymbol.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/common/legends/DiscreteLegend/DiscreteLegendEntry.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/common/legends/SequentialLegend/SequentialLegend.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/common/Gridline/Gridline.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/common/Gridline/GridlineSeries.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/common/Gridline/GridStripe.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/common/MarkLine/MarkLine.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/common/Gradient/GradientStop.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/common/Gradient/Gradient.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/common/Gradient/RadialGradient.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/common/Mask/Mask.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/common/Mask/Stripes.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/common/Tooltip/TooltipTemplate.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/common/Tooltip/TooltipTheme.ts","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/common/Tooltip/ChartTooltip.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/common/Tooltip/TooltipArea.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/common/ZoomPan/ZoomPan.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/common/scales/basic.ts","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/common/scales/marimekko.ts","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/common/scales/multiSeries.ts","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/common/scales/radial.ts","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/common/ZoomPan/ChartZoomPan.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/common/Motion/config.ts","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/common/Motion/MotionPath.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/common/color/schemes.ts","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/common/color/helper.ts","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/common/Count/useCount.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/common/Count/Count.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/common/ValueMarker/LinearValueMarker.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/common/ValueMarker/RadialValueMarker.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/common/Glow/utils.ts","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/ScatterPlot/ScatterSeries/ScatterPoint.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/ScatterPlot/ScatterSeries/ScatterSeries.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/ScatterPlot/ScatterPlot.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/AreaChart/AreaSeries/PointSeries.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/AreaChart/AreaSeries/Area.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/AreaChart/AreaSeries/Line.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/AreaChart/AreaSeries/AreaSeries.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/AreaChart/AreaSeries/StackedNormalizedAreaSeries.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/AreaChart/AreaSeries/StackedAreaSeries.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/AreaChart/AreaChart.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/AreaChart/StackedAreaChart.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/AreaChart/StackedNormalizedAreaChart.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/BarChart/BarSeries/Bar.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/BarChart/BarSeries/BarSeries.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/BarChart/BarSeries/RangeLines.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/BarChart/BarSeries/StackedBarSeries.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/BarChart/BarSeries/StackedNormalizedBarSeries.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/BarChart/BarSeries/MarimekkoBarSeries.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/BarChart/BarSeries/BarLabel.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/BarChart/BarSeries/HistogramBarSeries.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/BarChart/BarSeries/GuideBar.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/BarChart/BarChart.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/BarChart/MarimekkoChart.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/BarChart/StackedBarChart.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/BarChart/StackedNormalizedBarChart.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/BarChart/HistogramBarChart.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/LineChart/LineSeries.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/LineChart/LineChart.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/Map/Map.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/Map/MapMarker.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/PieChart/PieArcSeries/useInterpolate.ts","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/common/utils/useHoverIntent.ts","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/PieChart/PieArcSeries/PieArc.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/PieChart/PieArcSeries/findBreakPoint.ts","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/PieChart/PieArcSeries/PieArcLabel.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/PieChart/PieArcSeries/radiusUtils.ts","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/PieChart/PieArcSeries/PieArcSeries.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/PieChart/PieChart.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/Sankey/utils.ts","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/Sankey/Sankey.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/Sankey/SankeyLabel/SankeyLabel.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/Sankey/SankeyLink/SankeyLink.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/Sankey/SankeyNode/SankeyNode.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/Sparkline/SparklineChart.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/Sparkline/AreaSparklineChart.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/Sparkline/BarSparklineChart.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/Sparkline/SonarChart.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/RadialAreaChart/RadialAreaSeries/RadialArea.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/RadialAreaChart/RadialAreaSeries/RadialLine.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/RadialScatterPlot/RadialScatterPlot.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/RadialScatterPlot/RadialScatterSeries/RadialScatterPoint.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/RadialScatterPlot/RadialScatterSeries/RadialScatterSeries.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/RadialAreaChart/RadialAreaSeries/RadialPointSeries.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/RadialAreaChart/RadialAreaSeries/RadialAreaSeries.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/RadialAreaChart/RadialAreaChart.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/node_modules/d3-path/src/path.js","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/RadialBarChart/RadialBarSeries/MotionBar.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/RadialBarChart/RadialBarSeries/RadialGuideBar.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/RadialBarChart/RadialBarSeries/RadialBar.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/RadialBarChart/RadialBarSeries/RadialBarSeries.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/RadialBarChart/RadialBarChart.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/RadialGauge/RadialGaugeSeries/RadialGaugeArc.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/RadialGauge/RadialGaugeSeries/RadialGaugeLabel/RadialGaugeLabel.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/RadialGauge/RadialGaugeSeries/RadialGaugeValueLabel/RadialGaugeValueLabel.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/RadialGauge/RadialGaugeSeries/RadialGaugeOuterArc.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/RadialGauge/RadialGaugeSeries/RadialGaugeSeries.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/RadialGauge/RadialGaugeSeries/RadialGaugeStackedArc.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/RadialGauge/RadialGaugeSeries/StackedRadialGaugeValueLabel/StackedRadialGaugeValueLabel.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/RadialGauge/RadialGaugeSeries/StackedRadialGaugeSeries.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/RadialGauge/RadialGaugeSeries/StackedRadialGaugeDescriptionLabel/StackedRadialGaugeDescriptionLabel.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/RadialGauge/RadialGauge.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/Heatmap/HeatmapSeries/HeatmapCell.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/Heatmap/HeatmapSeries/HeatmapSeries.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/Heatmap/Heatmap.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/Heatmap/calendarUtils.ts","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/Heatmap/CalendarHeatmap.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/LinearGauge/LinearGaugeBar.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/LinearGauge/LinearGaugeOuterBar.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/LinearGauge/LinearGaugeSeries.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/LinearGauge/LinearGauge.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/VennDiagram/useInterpolate.ts","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/VennDiagram/VennArc.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/VennDiagram/VennLabel.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/VennDiagram/VennOuterLabel.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/VennDiagram/VennSeries.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/VennDiagram/starEuler/starEuler.ts","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/VennDiagram/VennDiagram.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/BubbleChart/Bubble.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/BubbleChart/BubbleLabel.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/BubbleChart/BubbleSeries.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/BubbleChart/BubbleChart.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/TreeMap/TreeMapLabel.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/TreeMap/TreeMapRect.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/TreeMap/TreeMapSeries.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/TreeMap/TreeMap.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/BarList/BarListSeries.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/BarList/BarList.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/Meter/MeterColumn.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/Meter/Meter.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/RadarChart/RadarChartSeries.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/RadarChart/RadarChart.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/FunnelChart/FunnelSeries/FunnelArc.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/FunnelChart/FunnelSeries/FunnelAxis/FunnelAxisLabel.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/FunnelChart/FunnelSeries/FunnelAxis/FunnelAxisLine.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/FunnelChart/FunnelSeries/FunnelAxis/FunnelAxis.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/FunnelChart/FunnelSeries/FunnelSeries.tsx","/Users/jenn/Desktop/info340/project-jsorror/node_modules/reaviz/src/FunnelChart/FunnelChart.tsx"],"sourcesContent":["import React, { Fragment, FC, ReactElement } from 'react';\nimport { GradientProps, Gradient } from '../../Gradient';\nimport { CloneElement, useId } from 'reablocks';\n\nexport interface LinearAxisLineProps {\n  height: number;\n  width: number;\n  strokeColor?: string;\n  strokeWidth: number;\n  strokeGradient: ReactElement<GradientProps, typeof Gradient> | null;\n  scale: any;\n  orientation: 'horizontal' | 'vertical';\n  className?: string;\n}\n\nexport const LinearAxisLine: FC<Partial<LinearAxisLineProps>> = ({\n  strokeColor,\n  strokeWidth,\n  strokeGradient,\n  scale,\n  orientation,\n  className\n}) => {\n  const id = useId();\n  const [range0, range1] = scale.range();\n\n  return (\n    <Fragment>\n      <line\n        className={className}\n        x1={orientation === 'vertical' ? 0 : range0}\n        // Workaround for a Chrome/Firefox bug where it won't render gradients for straight lines\n        x2={orientation === 'vertical' ? 0.00001 : range1}\n        y1={orientation === 'vertical' ? range0 : 0}\n        y2={orientation === 'vertical' ? range1 : 0.00001}\n        strokeWidth={strokeWidth}\n        stroke={strokeGradient ? `url(#axis-gradient-${id})` : strokeColor}\n      />\n      {strokeGradient && (\n        <CloneElement<GradientProps>\n          element={strokeGradient}\n          id={`axis-gradient-${id}`}\n        />\n      )}\n    </Fragment>\n  );\n};\n\nLinearAxisLine.defaultProps = {\n  strokeColor: '#8F979F',\n  strokeWidth: 1\n};\n","import { CloneElement } from 'reablocks';\nimport React, {\n  FC,\n  ReactElement,\n  createRef,\n  useCallback,\n  useEffect,\n  useState\n} from 'react';\nimport { ChartDataTypes } from '../../data';\nimport { LinearAxisLine, LinearAxisLineProps } from './LinearAxisLine';\nimport {\n  LinearAxisTickSeries,\n  LinearAxisTickSeriesProps\n} from './LinearAxisTickSeries';\n\nexport interface LinearAxisDimensionChanged {\n  height?: number;\n  width?: number;\n}\n\nexport interface LinearAxisProps {\n  height?: number;\n  width?: number;\n  domain?: ChartDataTypes[];\n  scaled?: boolean;\n  roundDomains?: boolean;\n  type?: 'value' | 'time' | 'category' | 'duration';\n  position?: 'start' | 'end' | 'center';\n  tickSeries?: ReactElement<\n    LinearAxisTickSeriesProps,\n    typeof LinearAxisTickSeries\n  >;\n  axisLine?: ReactElement<LinearAxisLineProps, typeof LinearAxisLine> | null;\n  scale?: any;\n  visibility?: 'visible' | 'hidden';\n  orientation?: 'horizontal' | 'vertical';\n  onDimensionsChange?: (event: LinearAxisDimensionChanged) => void;\n}\n\ninterface LinearAxisState {\n  height?: number;\n  width?: number;\n}\n\nexport const LinearAxis: FC<Partial<LinearAxisProps>> = (props) => {\n  const {\n    position,\n    tickSeries,\n    axisLine,\n    height,\n    width,\n    scale,\n    orientation,\n    visibility = 'visible',\n    onDimensionsChange\n  } = props;\n\n  const containerRef = createRef<SVGGElement>();\n  const [dimensions, setDimensions] = useState<LinearAxisState>({\n    height: height,\n    width: width\n  });\n\n  const updateDimensions = useCallback(() => {\n    const shouldOffset = position !== 'center';\n\n    let height;\n    let width;\n    if (shouldOffset) {\n      const dims = containerRef.current!.getBoundingClientRect();\n      width = Math.floor(dims.width);\n      height = Math.floor(dims.height);\n    }\n\n    if (orientation === 'vertical') {\n      if (dimensions.width !== width) {\n        setDimensions({ ...dimensions, width: width });\n        onDimensionsChange({ width });\n      }\n    } else {\n      if (dimensions.height !== height) {\n        setDimensions({ ...dimensions, height: height });\n        onDimensionsChange({ height });\n      }\n    }\n  }, [containerRef, dimensions, onDimensionsChange, orientation, position]);\n\n  useEffect(() => {\n    updateDimensions();\n  }, [updateDimensions, height, width, scale]);\n\n  function getPosition() {\n    let translateY = 0;\n    let translateX = 0;\n\n    if (position === 'end' && orientation === 'horizontal') {\n      translateY = height;\n    } else if (position === 'center' && orientation === 'horizontal') {\n      translateY = height / 2;\n    } else if (position === 'end' && orientation === 'vertical') {\n      translateX = width;\n    } else if (position === 'center' && orientation === 'vertical') {\n      translateX = width / 2;\n    }\n\n    return { translateX, translateY };\n  }\n\n  const { translateX, translateY } = getPosition();\n\n  return (\n    <g\n      transform={`translate(${translateX}, ${translateY})`}\n      ref={containerRef}\n      visibility={visibility}\n    >\n      {axisLine && (\n        <CloneElement<LinearAxisLineProps>\n          element={axisLine}\n          height={height}\n          width={width}\n          scale={scale}\n          orientation={orientation}\n        />\n      )}\n      {(tickSeries.props.line || tickSeries.props.label) && (\n        <CloneElement<LinearAxisTickSeriesProps>\n          element={tickSeries}\n          height={height}\n          width={width}\n          scale={scale}\n          orientation={orientation}\n          axis={props}\n        />\n      )}\n    </g>\n  );\n};\n\nLinearAxis.defaultProps = {\n  scaled: false,\n  roundDomains: false,\n  axisLine: <LinearAxisLine />,\n  onDimensionsChange: () => undefined\n};\n","import React, { FC, ReactElement } from 'react';\nimport {\n  LinearAxisTickLine,\n  LinearAxisTickLineProps\n} from './LinearAxisTickLine';\n\nexport interface LinearAxisTickLabelProps {\n  text: string;\n  fullText: string;\n  angle: number;\n  orientation: 'horizontal' | 'vertical';\n  half: 'start' | 'end' | 'center';\n  line: ReactElement<LinearAxisTickLineProps, typeof LinearAxisTickLine>;\n  format?: (v) => any;\n  /**\n   * Format tooltip title on hover label.\n   */\n  formatTooltip?: (value: any) => any | string;\n  fill: string;\n  fontSize: number;\n  fontFamily: string;\n  rotation: boolean | number;\n  padding: number | { fromAxis: number; alongAxis: number };\n  textAnchor?: 'start' | 'end' | 'middle';\n  position: 'start' | 'end' | 'center';\n  align: 'start' | 'end' | 'center' | 'inside' | 'outside';\n  className?: string;\n}\n\nexport const LinearAxisTickLabel: FC<Partial<LinearAxisTickLabelProps>> = ({\n  text,\n  fullText,\n  angle,\n  orientation,\n  half,\n  line,\n  textAnchor,\n  position,\n  className,\n  fill,\n  fontSize,\n  fontFamily,\n  rotation,\n  padding,\n  formatTooltip,\n  align\n}) => {\n  function getAlign() {\n    if ((align === 'inside' || align === 'outside') && half === 'center') {\n      return 'center';\n    }\n\n    if (align === 'inside') {\n      return half === 'start' ? 'end' : 'start';\n    }\n\n    if (align === 'outside') {\n      return half === 'start' ? 'start' : 'end';\n    }\n\n    return align;\n  }\n\n  // bug in this function - spacing is NA\n  function getTickLineSpacing() {\n    if (!line) {\n      return [0, 0];\n    }\n\n    const size = line.props.size ?? 3;\n    const position = line.props.position ?? 'center';\n\n    if (position === 'start') {\n      return [size * -1, 0];\n    } else if (position === 'end') {\n      return [0, size];\n    } else {\n      return [size * -0.5, size * 0.5];\n    }\n  }\n\n  function getOffset() {\n    const adjustedPadding =\n      typeof padding === 'number'\n        ? { fromAxis: padding, alongAxis: padding }\n        : padding;\n\n    const spacing = getTickLineSpacing();\n    const offset1 =\n      position === 'start'\n        ? spacing[0] - adjustedPadding.fromAxis\n        : position === 'end'\n          ? spacing[1] + adjustedPadding.fromAxis\n          : 0;\n\n    const align = getAlign();\n    let offset2 = 0;\n    offset2 +=\n      align === 'center'\n        ? 0\n        : align === 'start'\n          ? -adjustedPadding.alongAxis\n          : adjustedPadding.alongAxis;\n\n    const horz = orientation === 'horizontal';\n\n    return {\n      [horz ? 'x' : 'y']: offset2,\n      [horz ? 'y' : 'x']: offset1\n    };\n  }\n\n  function getTextPosition() {\n    let transform = '';\n    let newtextAnchor = '';\n    let alignmentBaseline = 'middle' as 'middle' | 'baseline' | 'hanging';\n\n    if (angle !== 0) {\n      transform = `rotate(${angle})`;\n      newtextAnchor = 'end';\n    } else {\n      const align = getAlign();\n      if (orientation === 'horizontal') {\n        newtextAnchor =\n          align === 'center' ? 'middle' : align === 'start' ? 'end' : 'start';\n        if (position === 'start') {\n          alignmentBaseline = 'baseline';\n        } else if (position === 'end') {\n          alignmentBaseline = 'hanging';\n        }\n      } else {\n        alignmentBaseline =\n          align === 'center'\n            ? 'middle'\n            : align === 'start'\n              ? 'baseline'\n              : 'hanging';\n        if (position === 'start') {\n          newtextAnchor = 'end';\n        } else if (position === 'end') {\n          newtextAnchor = 'start';\n        } else {\n          newtextAnchor = 'middle';\n        }\n      }\n    }\n\n    return {\n      transform,\n      textAnchor: textAnchor || newtextAnchor,\n      alignmentBaseline\n    };\n  }\n\n  const { x, y } = getOffset();\n  const textPosition = getTextPosition();\n  const titleHover =\n    typeof formatTooltip === 'function' ? formatTooltip(fullText) : fullText;\n\n  return (\n    <g\n      transform={`translate(${x}, ${y})`}\n      fontSize={fontSize}\n      fontFamily={fontFamily}\n    >\n      <title>{titleHover}</title>\n      <text {...textPosition} fill={fill} className={className}>\n        {text}\n      </text>\n    </g>\n  );\n};\n\nLinearAxisTickLabel.defaultProps = {\n  fill: '#8F979F',\n  fontSize: 11,\n  fontFamily: 'sans-serif',\n  rotation: true,\n  padding: 5,\n  align: 'center'\n};\n","import React, { FC, useMemo } from 'react';\n\nexport interface LinearAxisTickLineProps {\n  height: number;\n  width: number;\n  orientation: 'horizontal' | 'vertical';\n  size: number;\n  strokeColor?: string;\n  strokeWidth: number;\n  position: 'start' | 'end' | 'center';\n  className?: string;\n}\n\nexport const LinearAxisTickLine: FC<Partial<LinearAxisTickLineProps>> = ({\n  size,\n  position,\n  orientation,\n  strokeColor,\n  strokeWidth,\n  className\n}) => {\n  const path = useMemo(() => {\n    const isVertical = orientation === 'vertical';\n    const tickSize = size || 0;\n    const start =\n      position === 'start'\n        ? tickSize * -1\n        : position === 'center'\n          ? tickSize * -0.5\n          : 0;\n    const end = start + tickSize;\n\n    return {\n      x1: isVertical ? end : 0,\n      x2: isVertical ? start : 0,\n      y1: isVertical ? 0 : start,\n      y2: isVertical ? 0 : end\n    };\n  }, [orientation, position, size]);\n\n  return (\n    <line\n      className={className}\n      strokeWidth={strokeWidth}\n      stroke={strokeColor}\n      {...path}\n    />\n  );\n};\n\nLinearAxisTickLine.defaultProps = {\n  strokeColor: '#8F979F',\n  strokeWidth: 1,\n  size: 5\n};\n","import { ChartInternalDataTypes } from '../data';\n\n// https://stackoverflow.com/questions/673905/best-way-to-determine-users-locale-within-browser\nconst getNavigatorLanguage = () => {\n  if (typeof window === 'undefined') {\n    return 'en';\n  }\n\n  if (navigator.languages && navigator.languages.length) {\n    return navigator.languages[0];\n  }\n\n  if (\n    (navigator as any).userLanguage ||\n    navigator.language ||\n    (navigator as any).browserLanguage\n  ) {\n    return 'en';\n  }\n};\n\nconst locale = getNavigatorLanguage();\n\nconst options = {\n  year: 'numeric',\n  month: 'numeric',\n  day: 'numeric',\n  hour12: true,\n  formatMatcher: 'best fit'\n};\n\n/**\n * Format a value based on type.\n */\nexport function formatValue(value: ChartInternalDataTypes): string {\n  if (value !== undefined) {\n    if (value instanceof Date) {\n      return (value as Date).toLocaleDateString(locale, options as any);\n    } else if (typeof value === 'number') {\n      return value.toLocaleString();\n    }\n\n    return value as string;\n  }\n\n  return 'No value';\n}\n\n/**\n * Generate aria label text for the given data point(s)\n * @param datapoint \n * @returns Aria Label\n */\nexport function getAriaLabel(datapoint) {\n  const isArray = Array.isArray(datapoint);\n  if (isArray) {\n    return datapoint?.map(row => (getAriaLabel(row))).join(', ');\n  } else {\n    const key = datapoint?.key || datapoint?.x;\n    // 'data' or 'y' will not be an array as the label is unique for each element\n    const value = datapoint?.data || datapoint?.y;\n    return `${key}: ${formatValue(value)}`;\n  }\n}","import { TimeInterval } from 'd3-time';\n\nconst ONE_DAY = 60 * 60 * 24;\nconst DURATION_TICK_STEPS = [\n  0.001, // 1 ms\n  0.005, // 5 ms\n  0.01, // 10 ms\n  0.05, // 50 ms\n  0.1, // 100 ms\n  0.5, // 500 ms\n  1, // 1 s\n  5, // 5 s\n  10, // 10 s\n  15, // 15 s\n  60, // 1 m\n  60 * 15, // 15 m\n  60 * 30, // 30 m\n  60 * 60, // 1 h\n  60 * 60 * 2, // 2 h\n  60 * 60 * 4, // 4 h\n  60 * 60 * 6, // 6 h\n  60 * 60 * 8, // 8 h\n  60 * 60 * 12, // 12 h\n  ONE_DAY // 24 h\n];\n\n/**\n * Reduce the ticks to the max number of ticks.\n */\nexport function reduceTicks<T>(ticks: T[], maxTicks: number) {\n  if (ticks.length > maxTicks) {\n    const reduced: T[] = [];\n    const modulus = Math.floor(ticks.length / maxTicks);\n\n    for (let i = 0; i < ticks.length; i++) {\n      if (i % modulus === 0) {\n        reduced.push(ticks[i]);\n      }\n    }\n    ticks = reduced;\n  }\n\n  return ticks;\n}\n\n/**\n * Determine the max ticks for the available width.\n */\nexport function getMaxTicks(size: number, dimension: number) {\n  const tickWidth = Math.max(size, 0);\n  return Math.floor(dimension / tickWidth);\n}\n\n/**\n * Formats the ticks in a duration format.\n */\nexport function getDurationTicks(domain, maxTicks) {\n  const domainWidth = domain[1] - domain[0];\n  let tickStep: number | null = null;\n  for (const s of DURATION_TICK_STEPS) {\n    if (domainWidth / s < maxTicks) {\n      tickStep = s;\n      break;\n    }\n  }\n\n  if (tickStep === null) {\n    const numDayTicks = domainWidth / ONE_DAY;\n    const dayStep = Math.ceil(numDayTicks / maxTicks);\n    tickStep = ONE_DAY * dayStep;\n  }\n\n  const ticks = [domain[0]];\n  while (ticks[ticks.length - 1] + tickStep <= domain[1]) {\n    ticks.push(ticks[ticks.length - 1] + tickStep);\n  }\n\n  return ticks;\n}\n\n/**\n * Get the tick values from the scale.\n */\nexport function getTicks(\n  scale: any,\n  tickValues: any[],\n  type: 'value' | 'category' | 'time' | 'duration',\n  maxTicks = 100,\n  interval?: number | TimeInterval\n) {\n  let result;\n\n  if (tickValues) {\n    result = tickValues;\n  } else {\n    if (scale.ticks) {\n      if (type === 'duration') {\n        result = getDurationTicks(scale.domain(), maxTicks);\n      } else if (interval) {\n        result = scale.ticks(interval);\n      } else {\n        if (type === 'time') {\n          // If its time, we need to handle the time count\n          // manually because d3 does this odd rounding\n          result = scale.ticks();\n          result = reduceTicks(result, maxTicks);\n        } else {\n          result = scale.ticks(maxTicks);\n        }\n      }\n    } else {\n      tickValues = scale.domain();\n      result = reduceTicks(tickValues, maxTicks);\n    }\n  }\n\n  return result;\n}\n","export interface TextDimensions {\n  height: number;\n  width: number;\n}\n\nconst cache: { [key: string]: TextDimensions } = {};\n\nexport const calculateDimensions = (\n  text: string,\n  fontFamily: string,\n  fontSize: string | number\n): TextDimensions => {\n  const key = `${text}_${fontFamily}_${fontSize}`;\n\n  // Check if we have a cache hit\n  if (cache[key]) {\n    return cache[key];\n  }\n\n  // If we are in a Node.js environment\n  if (typeof window === 'undefined' || typeof document === 'undefined') {\n    const height = parseInt(typeof fontSize === 'string' ? fontSize : fontSize.toString(), 10);\n    const dimensions = {\n      height,\n      // 8 is an approximation of the width of a character\n      width: text.length * 8\n    };\n\n    cache[key] = dimensions;\n\n    return dimensions;\n  }\n\n  // Create a temporary div element\n  const element = document.createElement('div');\n\n  // Set up the style so the size can be measured\n  element.style.fontFamily = fontFamily;\n  element.style.fontSize = typeof fontSize === 'string' ? fontSize : `${fontSize}px`;\n  element.style.position = 'absolute';\n  element.style.left = '-9999px';\n  element.style.whiteSpace = 'nowrap';\n  element.style.height = 'auto';\n  element.style.fontWeight = 'normal';\n  element.style.lineHeight = 'normal';\n  element.style.width = 'auto';\n  element.style.wordBreak = 'normal';\n\n  // Add the text to the div\n  element.textContent = text;\n\n  // Add the div to the body\n  document.body.appendChild(element);\n\n  // Measure the div\n  const dimensions = {\n    height: element.offsetHeight,\n    width: element.offsetWidth\n  };\n\n  // Remove the div from the body\n  document.body.removeChild(element);\n\n  // Store the result in the cache for future calls\n  cache[key] = dimensions;\n\n  return dimensions;\n};\n","import React, { FC, Fragment, ReactElement, useCallback, useMemo } from 'react';\nimport {\n  LinearAxisTickLabel,\n  LinearAxisTickLabelProps\n} from './LinearAxisTickLabel';\nimport {\n  LinearAxisTickLine,\n  LinearAxisTickLineProps\n} from './LinearAxisTickLine';\nimport { formatValue } from '../../utils/formatting';\nimport { getTicks, getMaxTicks } from '../../utils/ticks';\nimport { TimeInterval } from 'd3-time';\nimport { CloneElement } from 'reablocks';\nimport { LinearAxisProps } from './LinearAxis';\nimport ellipsize from 'ellipsize';\nimport { max } from 'd3-array';\nimport { calculateDimensions } from '../../utils/size';\n\nexport interface LinearAxisTickSeriesProps {\n  height: number;\n  width: number;\n  scale: any;\n  interval?: number | TimeInterval;\n  tickSize: number;\n  tickValues: any[];\n  orientation: 'horizontal' | 'vertical';\n  label: ReactElement<\n    LinearAxisTickLabelProps,\n    typeof LinearAxisTickLabel\n  > | null;\n  line: ReactElement<LinearAxisTickLineProps, typeof LinearAxisTickLine> | null;\n  axis: LinearAxisProps;\n}\n\ninterface ProcessedTick {\n  text: string;\n  fullText: string;\n  x: number;\n  y: number;\n  height: number;\n  width: number;\n  half: 'start' | 'end' | 'center';\n}\n\nexport const LinearAxisTickSeries: FC<Partial<LinearAxisTickSeriesProps>> = ({\n  scale,\n  orientation,\n  height,\n  width,\n  label,\n  tickSize,\n  tickValues,\n  interval,\n  line,\n  axis\n}) => {\n  /**\n   * Gets the adjusted scale given offsets.\n   */\n  const getAdjustedScale = useCallback(() => {\n    if (scale.bandwidth) {\n      let offset = scale.bandwidth() / 2;\n      if (scale.round()) {\n        offset = Math.round(offset);\n      }\n\n      return (d) => +scale(d) + offset;\n    } else {\n      return (d) => +scale(d);\n    }\n  }, [scale]);\n\n  /**\n   * Gets the x/y position for a given tick.\n   */\n  const getPosition = useCallback(\n    (scaledTick: number) => {\n      if (orientation === 'horizontal') {\n        return { x: scaledTick, y: 0 };\n      } else {\n        return { x: 0, y: scaledTick };\n      }\n    },\n    [orientation]\n  );\n\n  /**\n   * Gets the dimension (height/width) this axis is calculating on.\n   */\n  const getDimension = useCallback(() => {\n    return orientation === 'vertical' ? height : width;\n  }, [height, orientation, width]);\n\n  /**\n   * Gets the formatted label of the tick.\n   */\n  const labelFormatFn = useMemo((): any => {\n    if (label && label.props.format) {\n      return label.props.format;\n    } else if (scale.tickFormat) {\n      return scale.tickFormat.apply(scale, [5]);\n    } else {\n      return (v) => formatValue(v);\n    }\n  }, [label, scale]);\n\n  /**\n   * Gets the ticks given the dimensions and scales and returns\n   * the text and position.\n   */\n  const ticks = useMemo((): ProcessedTick[] => {\n    const dimension = getDimension();\n    const maxTicks = getMaxTicks(tickSize, dimension);\n    const ticks = getTicks(scale, tickValues, axis.type, maxTicks, interval);\n    const adjustedScale = getAdjustedScale();\n    const format = labelFormatFn;\n    const midpoint = dimension / 2;\n\n    return ticks.map((tick) => {\n      const fullText = format(tick);\n      const scaledTick = adjustedScale(tick);\n      const position = getPosition(scaledTick);\n      const text = ellipsize(fullText, 18);\n      const size = label\n        ? calculateDimensions(\n          text,\n          label.props.fontFamily,\n          label.props.fontSize.toString()\n        )\n        : {};\n\n      return {\n        ...position,\n        ...size,\n        text,\n        fullText,\n        half:\n          scaledTick === midpoint\n            ? 'center'\n            : scaledTick < midpoint\n              ? 'start'\n              : 'end'\n      };\n    });\n  }, [\n    axis.type,\n    getAdjustedScale,\n    getDimension,\n    getPosition,\n    interval,\n    label,\n    labelFormatFn,\n    scale,\n    tickSize,\n    tickValues\n  ]);\n\n  /**\n   * Calculates the rotation angle that the ticks need to be shifted to.\n   * This equation will measure the length of the text in a external canvas\n   * object and determine what the longest label is and rotate until they fit.\n   */\n  const angle = useMemo((): number => {\n    if (!label) {\n      return 0;\n    }\n\n    const labelProps = label.props;\n    const dimension = getDimension();\n    const maxTicksLength = max(ticks, (tick) => tick.width);\n    let angle = 0;\n\n    if (labelProps.rotation) {\n      if (labelProps.rotation === true) {\n        let baseWidth = maxTicksLength;\n        const maxBaseWidth = Math.floor(dimension / ticks.length);\n\n        while (baseWidth > maxBaseWidth && angle > -90) {\n          angle -= 30;\n          baseWidth = Math.cos(angle * (Math.PI / 180)) * maxTicksLength;\n        }\n      } else {\n        angle = labelProps.rotation;\n      }\n    }\n\n    return angle;\n  }, [getDimension, label, ticks]);\n\n  return (\n    <Fragment>\n      {ticks.map((tick, i) => (\n        <g key={i} transform={`translate(${tick.x}, ${tick.y})`}>\n          {line && (\n            <CloneElement<LinearAxisTickLineProps>\n              element={line}\n              height={height}\n              width={width}\n              orientation={orientation}\n            />\n          )}\n          {label && (\n            <CloneElement<LinearAxisTickLabelProps>\n              element={label}\n              text={tick.text}\n              fullText={tick.fullText}\n              half={tick.half}\n              angle={angle}\n              orientation={orientation}\n              line={line!}\n            />\n          )}\n        </g>\n      ))}\n    </Fragment>\n  );\n};\n\nLinearAxisTickSeries.defaultProps = {\n  line: (\n    <LinearAxisTickLine\n      height={10}\n      width={10}\n      orientation=\"horizontal\"\n      position=\"center\"\n    />\n  ),\n  label: (\n    <LinearAxisTickLabel\n      line={\n        <LinearAxisTickLine\n          orientation=\"horizontal\"\n          position=\"center\"\n          height={5}\n          width={5}\n        />\n      }\n      text=\"\"\n      fullText=\"\"\n      angle={0}\n      orientation=\"horizontal\"\n      half=\"start\"\n      position=\"center\"\n    />\n  ),\n  tickSize: 30\n};\n","import React, { FC } from 'react';\nimport {\n  LinearAxisTickLabelProps,\n  LinearAxisTickLabel\n} from './LinearAxisTickLabel';\nimport {\n  LinearAxisTickLineProps,\n  LinearAxisTickLine\n} from './LinearAxisTickLine';\nimport {\n  LinearAxisTickSeriesProps,\n  LinearAxisTickSeries\n} from './LinearAxisTickSeries';\nimport { LinearAxisProps, LinearAxis } from './LinearAxis';\n\nexport const LinearXAxisTickLabel: FC<Partial<LinearAxisTickLabelProps>> = (\n  props\n) => <LinearAxisTickLabel {...props} />;\nLinearXAxisTickLabel.defaultProps = {\n  ...LinearAxisTickLabel.defaultProps,\n  rotation: true,\n  position: 'end',\n  align: 'center'\n};\n\nexport const LinearXAxisTickLine: FC<Partial<LinearAxisTickLineProps>> = (\n  props\n) => <LinearAxisTickLine {...props} />;\nLinearXAxisTickLine.defaultProps = {\n  ...LinearAxisTickLine.defaultProps,\n  position: 'end'\n};\n\nexport const LinearXAxisTickSeries: FC<Partial<LinearAxisTickSeriesProps>> = (\n  props\n) => <LinearAxisTickSeries {...props} />;\nLinearXAxisTickSeries.defaultProps = {\n  ...LinearAxisTickSeries.defaultProps,\n  tickSize: 75,\n  line: <LinearXAxisTickLine />,\n  label: <LinearXAxisTickLabel />\n};\n\nexport const LinearXAxis: FC<Partial<LinearAxisProps>> = (props) => (\n  <LinearAxis {...props} />\n);\nLinearXAxis.defaultProps = {\n  ...LinearAxis.defaultProps,\n  position: 'end',\n  roundDomains: false,\n  scaled: false,\n  type: 'value',\n  orientation: 'horizontal',\n  tickSeries: <LinearXAxisTickSeries />\n};\n","import React, { FC } from 'react';\nimport {\n  LinearAxisTickLabelProps,\n  LinearAxisTickLabel\n} from './LinearAxisTickLabel';\nimport {\n  LinearAxisTickLineProps,\n  LinearAxisTickLine\n} from './LinearAxisTickLine';\nimport {\n  LinearAxisTickSeriesProps,\n  LinearAxisTickSeries\n} from './LinearAxisTickSeries';\nimport { LinearAxisProps, LinearAxis } from './LinearAxis';\n\nexport const LinearYAxisTickLabel: FC<Partial<LinearAxisTickLabelProps>> = (\n  props\n) => <LinearAxisTickLabel {...props} />;\nLinearYAxisTickLabel.defaultProps = {\n  ...LinearAxisTickLabel.defaultProps,\n  rotation: false,\n  position: 'start',\n  align: 'center'\n};\n\nexport const LinearYAxisTickLine: FC<Partial<LinearAxisTickLineProps>> = (\n  props\n) => <LinearAxisTickLine {...props} />;\nLinearYAxisTickLine.defaultProps = {\n  ...LinearAxisTickLine.defaultProps,\n  position: 'start'\n};\n\nexport const LinearYAxisTickSeries: FC<Partial<LinearAxisTickSeriesProps>> = (\n  props\n) => <LinearAxisTickSeries {...props} />;\nLinearYAxisTickSeries.defaultProps = {\n  ...LinearAxisTickSeries.defaultProps,\n  tickSize: 30,\n  line: <LinearYAxisTickLine />,\n  label: <LinearYAxisTickLabel />\n};\n\nexport const LinearYAxis: FC<Partial<LinearAxisProps>> = (props) => (\n  <LinearAxis {...props} />\n);\nLinearYAxis.defaultProps = {\n  ...LinearAxis.defaultProps,\n  orientation: 'vertical',\n  scaled: false,\n  roundDomains: false,\n  type: 'value',\n  position: 'start',\n  tickSeries: <LinearYAxisTickSeries />\n};\n","import { LinearAxisProps } from './LinearAxis';\n\n/**\n * Returns whether the axis has a visual element or not.\n */\nexport const isAxisVisible = (axis: LinearAxisProps) =>\n  !!axis.tickSeries.props.label || !!axis.tickSeries.props.line;\n","import React, { FC } from 'react';\n\nexport interface RadialAxisTickLineProps {\n  /**\n   * Size of the tick line.\n   */\n  size?: number;\n\n  /**\n   * Stroke color of the tick line.\n   */\n  stroke: string;\n\n  /**\n   * Inner radius of the arc.\n   */\n  innerRadius: number;\n\n  /**\n   * Outer radius of the arc.\n   */\n  outerRadius: number;\n\n  /**\n   * Position of the tick line.\n   */\n  position: 'inside' | 'outside';\n}\n\nexport const RadialAxisTickLine: FC<Partial<RadialAxisTickLineProps>> = ({\n  stroke,\n  size,\n  position,\n  innerRadius,\n  outerRadius\n}) => {\n  const x1 = position === 'outside' ? size : -(outerRadius - innerRadius);\n\n  return (\n    <line x1={x1} x2={0} stroke={stroke} style={{ pointerEvents: 'none' }} />\n  );\n};\n\nRadialAxisTickLine.defaultProps = {\n  stroke: 'rgba(113, 128, 141, .5)',\n  size: 10,\n  position: 'inside'\n};\n","import React, { FC, SVGTextElementAttributes, useMemo } from 'react';\nimport { formatValue } from '../../../utils/formatting';\n\nconst rad2deg = (angle: number) => (angle * 180) / Math.PI;\n\nexport interface RadialAxisTickLabelProps\n  extends Omit<SVGTextElementAttributes<SVGTextElement>, 'format'> {\n  /**\n   * Data to render.\n   */\n  data: any;\n\n  /**\n   * Size of the line.\n   */\n  lineSize: number;\n\n  /**\n   * Color of the text.\n   */\n  fill: string;\n\n  /**\n   * Font size of the text.\n   */\n  fontSize: number;\n\n  /**\n   * Rotation of the text.\n   */\n  rotation: number;\n\n  /**\n   * Font family of the text.\n   */\n  fontFamily: string;\n\n  /**\n   * Index of the tick.\n   */\n  index: number;\n\n  /**\n   * Padding of the tick.\n   */\n  padding: number;\n\n  /**\n   * Point of the tick.\n   */\n  point: any;\n\n  /**\n   * Auto rotate the text.\n   */\n  autoRotate: boolean;\n\n  /**\n   * Format of the label.\n   */\n  format?: (value: any, index: number) => any | string;\n\n  /**\n   * Format tooltip title on hover label.\n   */\n  formatTooltip?: (value: any, index: number) => any | string;\n}\n\nexport const RadialAxisTickLabel: FC<Partial<RadialAxisTickLabelProps>> = ({\n  point,\n  autoRotate,\n  rotation,\n  padding,\n  data,\n  fill,\n  fontFamily,\n  fontSize,\n  format,\n  lineSize,\n  index,\n  formatTooltip,\n  ...rest\n}) => {\n  const { transform, textAnchor } = useMemo(() => {\n    let textAnchor;\n    let transform;\n\n    if (autoRotate) {\n      // TODO: This centers the text, determine better way later\n      if (\n        (rotation >= 85 && rotation <= 95) ||\n        (rotation <= -85 && rotation >= -95) ||\n        (rotation >= 265 && rotation <= 275) ||\n        (rotation <= -265 && rotation >= -275)\n      ) {\n        textAnchor = 'middle';\n      } else if (\n        (rotation < -85 && rotation > -265) ||\n        (rotation > 95 && rotation < 265)\n      ) {\n        textAnchor = 'end';\n      } else {\n        textAnchor = 'start';\n      }\n\n      transform = `rotate(${90 - rad2deg(point)}, ${padding}, 0)`;\n    } else {\n      const shouldRotate = rotation && (rotation > 100 || rotation < -100);\n      const rotate = shouldRotate ? 180 : 0;\n      const translate = shouldRotate ? -30 : 0;\n      textAnchor = shouldRotate ? 'end' : 'start';\n      transform = `rotate(${rotate}) translate(${translate})`;\n    }\n\n    return {\n      transform,\n      textAnchor\n    };\n  }, [autoRotate, padding, point, rotation]);\n\n  const text = format ? format(data, index) : formatValue(data);\n  const titleHover =\n    typeof formatTooltip === 'function' ? formatTooltip(data, index) : text;\n\n  return (\n    <g transform={transform}>\n      <title>{titleHover}</title>\n      <text\n        dy=\"0.35em\"\n        x={lineSize + 5}\n        textAnchor={textAnchor}\n        fill={fill}\n        fontFamily={fontFamily}\n        fontSize={fontSize}\n        {...rest}\n      >\n        {text}\n      </text>\n    </g>\n  );\n};\n\nRadialAxisTickLabel.defaultProps = {\n  fill: '#71808d',\n  fontSize: 11,\n  padding: 15,\n  fontFamily: 'sans-serif',\n  autoRotate: true,\n  startAngle: 0,\n  endAngle: 2 * Math.PI\n};\n","import React, { FC, ReactElement } from 'react';\nimport {\n  RadialAxisTickLineProps,\n  RadialAxisTickLine\n} from './RadialAxisTickLine';\nimport {\n  RadialAxisTickLabelProps,\n  RadialAxisTickLabel\n} from './RadialAxisTickLabel';\nimport { CloneElement } from 'reablocks';\n\nexport interface RadialAxisTickProps {\n  /**\n   * Scale to use for the tick.\n   */\n  scale: any;\n\n  /**\n   * Outer radius of the arc.\n   */\n  outerRadius: number;\n\n  /**\n   * Inner radius of the arc.\n   */\n  innerRadius: number;\n\n  /**\n   * Padding between the tick and the label.\n   */\n  padding: number;\n\n  /**\n   * Data to render.\n   */\n  data: any;\n\n  /**\n   * Index of the tick.\n   */\n  index: number;\n\n  /**\n   * Line element to render.\n   */\n  line: ReactElement<RadialAxisTickLineProps, typeof RadialAxisTickLine> | null;\n\n  /**\n   * Label element to render.\n   */\n  label: ReactElement<\n    RadialAxisTickLabelProps,\n    typeof RadialAxisTickLabel\n  > | null;\n\n  /**\n   * Start angle for the first value.\n   */\n  startAngle?: number;\n\n  /**\n   * End angle for the last value.\n   */\n  endAngle?: number;\n}\n\nexport const RadialAxisTick: FC<Partial<RadialAxisTickProps>> = ({\n  line,\n  label,\n  scale,\n  outerRadius,\n  data,\n  index,\n  padding,\n  innerRadius,\n  startAngle,\n  endAngle\n}) => {\n  const point = scale(data);\n\n  const rotation = (point * 180) / Math.PI - 90;\n  const transform = `rotate(${rotation}) translate(${outerRadius + padding},0)`;\n  const lineSize = line ? line.props.size : 0;\n\n  return (\n    <g transform={transform}>\n      {line && (\n        <CloneElement<RadialAxisTickLineProps>\n          element={line}\n          innerRadius={innerRadius}\n          outerRadius={outerRadius}\n        />\n      )}\n      {label && (\n        <CloneElement<RadialAxisTickLabelProps>\n          element={label}\n          index={index}\n          point={point}\n          rotation={rotation}\n          lineSize={lineSize}\n          data={data}\n          startAngle={startAngle}\n          endAngle={endAngle}\n        />\n      )}\n    </g>\n  );\n};\n\nRadialAxisTick.defaultProps = {\n  outerRadius: 0,\n  padding: 0,\n  line: <RadialAxisTickLine />,\n  label: <RadialAxisTickLabel />,\n  startAngle: 0,\n  endAngle: 2 * Math.PI\n};\n","import React, { FC, Fragment, ReactElement } from 'react';\nimport { RadialAxisTick, RadialAxisTickProps } from './RadialAxisTick';\nimport { CloneElement } from 'reablocks';\nimport { getTicks } from '../../../utils/ticks';\nimport { TimeInterval } from 'd3-time';\n\nexport interface TickCallback {\n  index?: number;\n}\n\nexport interface RadialAxisTickSeriesProps {\n  /**\n   * Scale to use for the tick.\n   */\n  scale: any;\n\n  /**\n   * Number of ticks to render.\n   */\n  count?: number;\n\n  /**\n   * Interval between ticks.\n   */\n  interval?: number | TimeInterval;\n\n  /**\n   * Tick values to render.\n   */\n  tickValues: any[];\n\n  /**\n   * Outer radius of the arc.\n   */\n  outerRadius: number;\n\n  /**\n   * Type of the axis.\n   */\n  type: 'value' | 'category' | 'time' | 'duration';\n\n  /**\n   * Inner radius of the arc.\n   */\n  innerRadius: number;\n\n  /**\n   * Tick element to render.\n   */\n  tick:\n    | ((\n        tick: TickCallback\n      ) => ReactElement<RadialAxisTickProps, typeof RadialAxisTick>)\n    | ReactElement<RadialAxisTickProps, typeof RadialAxisTick>;\n\n  /**\n   * Start angle for the first value.\n   */\n  startAngle?: number;\n\n  /**\n   * End angle for the last value.\n   */\n  endAngle?: number;\n}\n\nexport const RadialAxisTickSeries: FC<Partial<RadialAxisTickSeriesProps>> = ({\n  scale,\n  count,\n  outerRadius,\n  tick,\n  tickValues,\n  innerRadius,\n  interval,\n  type,\n  startAngle,\n  endAngle\n}) => {\n  const ticks = getTicks(scale, tickValues, type, count, interval || count);\n\n  return (\n    <Fragment>\n      {ticks.map((data, i) => {\n        const tickElement =\n          typeof tick === 'function' ? tick({ index: i }) : tick;\n        return (\n          <CloneElement<RadialAxisTickProps>\n            element={tickElement}\n            key={i}\n            index={i}\n            scale={scale}\n            data={data}\n            innerRadius={innerRadius}\n            outerRadius={outerRadius}\n            startAngle={startAngle}\n            endAngle={endAngle}\n          />\n        );\n      })}\n    </Fragment>\n  );\n};\n\nRadialAxisTickSeries.defaultProps = {\n  count: 12,\n  type: 'time',\n  tick: <RadialAxisTick />,\n  startAngle: 0,\n  endAngle: 2 * Math.PI\n};\n","import { arc } from 'd3-shape';\nimport React, { FC } from 'react';\n\nexport interface RadialAxisArcProps {\n  /**\n   * Index of the arc.\n   */\n  index: number;\n\n  /**\n   * Scale to use for the arc.\n   */\n  scale: any;\n\n  /**\n   * Stroke color of the arc.\n   */\n  stroke: ((index: number) => string) | string;\n\n  /**\n   * Stroke dash array of the arc.\n   */\n  strokeDasharray: ((index: number) => string) | string;\n\n  /**\n   * Start angle for the first value.\n   */\n  startAngle?: number;\n\n  /**\n   * End angle for the last value.\n   */\n  endAngle?: number;\n}\n\nexport const RadialAxisArc: FC<Partial<RadialAxisArcProps>> = ({\n  index,\n  stroke,\n  strokeDasharray,\n  scale,\n  startAngle,\n  endAngle\n}) => {\n  const r = scale(index);\n  const strokeColor = typeof stroke === 'string' ? stroke : stroke(index);\n  const strokeDash =\n    typeof strokeDasharray === 'string'\n      ? strokeDasharray\n      : strokeDasharray(index);\n\n  const isFullCircle = Math.abs(endAngle - startAngle) >= 2 * Math.PI;\n\n  const x = arc()({\n    innerRadius: r,\n    outerRadius: r,\n    startAngle: startAngle,\n    endAngle: endAngle\n  });\n\n  // Path calculation for intermediate angles\n  const REGEX = /(-?\\d+\\.?\\d*,-?\\d+\\.?\\d*A-?\\d+\\.?\\d*,-?\\d+\\.?\\d*)/gm;\n  const matches = x.match(REGEX);\n  const start = matches?.[0]?.split('A', 2)?.[0];\n  const end = matches?.[1]?.split('A', 2)?.[0];\n  const d = x + ` M ${start} L 0,0 M ${end} L 0,0`;\n\n  return (\n    <>\n      {isFullCircle ? \n        <circle\n          fill=\"none\"\n          strokeDasharray={strokeDash}\n          stroke={strokeColor}\n          style={{ pointerEvents: 'none' }}\n          cx=\"0\"\n          cy=\"0\"\n          r={r}\n        />\n        :\n        <path d={d} fill=\"none\"\n          strokeDasharray={strokeDash}\n          stroke={strokeColor}\n          style={{ pointerEvents: 'none' }}\n        />\n      }\n    </>\n  );\n};\n\nRadialAxisArc.defaultProps = {\n  stroke: '#71808d',\n  strokeDasharray: '1,4',\n  startAngle: 0,\n  endAngle: 2 * Math.PI\n};\n","/**\n * Given a set of arcs, return an array of points for each arc.\n */\nexport const getPointsForLevels = ({ count, outerRadius, ticks, arcs }) => {\n  const levels: Array<Array<{ x: number; y: number }>> = [];\n  const polyangle = (Math.PI * 2) / ticks;\n\n  for (const level of arcs) {\n    const hyp = (level / count) * outerRadius;\n\n    const points: Array<{ x: number; y: number }> = [];\n    for (let vertex = 0; vertex < ticks; vertex++) {\n      const theta = vertex * polyangle;\n      points.push({\n        x: hyp * Math.sin(Math.PI - theta),\n        y: hyp * Math.cos(Math.PI - theta)\n      });\n    }\n\n    levels.push([...points, points[0]]);\n  }\n\n  return levels;\n};\n","import React, { FC, ReactElement } from 'react';\nimport { RadialAxisArc, RadialAxisArcProps } from './RadialAxisArc';\nimport { CloneElement } from 'reablocks';\nimport { scaleLinear } from 'd3-scale';\nimport { getPointsForLevels } from './utils';\nimport { RadialAxisArcLine, RadialAxisArcLineProps } from './RadialAxisArcLine';\n\nexport interface RadialAxisArcSeriesProps {\n  /**\n   * Arc element to render.\n   */\n  arc: ReactElement<RadialAxisArcProps, typeof RadialAxisArc>;\n\n  /**\n   * Line element to render.\n   */\n  line: ReactElement<RadialAxisArcLineProps, typeof RadialAxisArcLine>;\n\n  /**\n   * Number of arcs to render.\n   */\n  count: number;\n\n  /**\n   * Inner radius of the arc.\n   */\n  innerRadius: number;\n\n  /**\n   * Outer radius of the arc.\n   */\n  outerRadius: number;\n\n  /**\n   * Calculated tick values by the Radial Axis.\n   */\n  tickValues?: any[];\n\n  /**\n   * Start angle for the first value.\n   */\n  startAngle?: number;\n\n  /**\n   * End angle for the last value.\n   */\n  endAngle?: number;\n}\n\nexport const RadialAxisArcSeries: FC<Partial<RadialAxisArcSeriesProps>> = ({\n  count,\n  innerRadius,\n  outerRadius,\n  line,\n  arc,\n  tickValues,\n  startAngle,\n  endAngle\n}) => {\n  const scale = scaleLinear()\n    .domain([0, count])\n    .range([innerRadius, outerRadius]);\n\n  const arcs = scale.ticks(count);\n\n  const points = getPointsForLevels({\n    count,\n    outerRadius,\n    ticks: tickValues.length,\n    arcs\n  });\n\n  return (\n    <>\n      {line && (\n        <>\n          {points.map((d, i) => (\n            <CloneElement<RadialAxisArcLineProps>\n              element={line}\n              key={i}\n              data={d}\n              index={i}\n            />\n          ))}\n        </>\n      )}\n      {arc && (\n        <>\n          {arcs.map((d) => (\n            <CloneElement<RadialAxisArcProps>\n              element={arc}\n              key={d}\n              index={d}\n              scale={scale}\n              startAngle={startAngle}\n              endAngle={endAngle}\n            />\n          ))}\n        </>\n      )}\n    </>\n  );\n};\n\nRadialAxisArcSeries.defaultProps = {\n  type: 'arc',\n  count: 12,\n  arc: <RadialAxisArc />,\n  startAngle: 0,\n  endAngle: 2 * Math.PI\n};\n","import { line } from 'd3-shape';\nimport React, { FC } from 'react';\n\nexport interface RadialAxisArcLineProps {\n  /**\n   * Stroke color of the arc.\n   */\n  stroke: ((index: number) => string) | string;\n\n  /**\n   * Data to render the line.\n   */\n  data: Array<{ x: number; y: number }>;\n\n  /**\n   * Index of the arc.\n   */\n  index: number;\n}\n\nexport const RadialAxisArcLine: FC<Partial<RadialAxisArcLineProps>> = ({\n  data,\n  stroke,\n  index\n}) => {\n  const lineGenerator = line<{ x: number; y: number }>()\n    .x((d: any) => d.x)\n    .y((d: any) => d.y);\n\n  const d = lineGenerator(data);\n  const strokeColor = typeof stroke === 'string' ? stroke : stroke(index);\n\n  return (\n    <path\n      d={d}\n      stroke={strokeColor}\n      fill=\"none\"\n      style={{ pointerEvents: 'none' }}\n    />\n  );\n};\n\nRadialAxisArcLine.defaultProps = {\n  stroke: '#71808d'\n};\n","import humanFormat from 'human-format';\n\nconst humanFormatScale = new humanFormat.Scale({\n  k: 1000,\n  M: 1000000,\n  B: 1000000000\n});\n\nconst humanFormatMillionScale = new humanFormat.Scale({\n  M: 1,\n  B: 1000,\n  T: 1000000\n});\n\nconst ONE_MILLION = 1000000;\nconst ONE_BILLION = 1000000000;\n\nexport const humanFormatBigInteger = (bigInteger) => {\n  if (bigInteger.greater(ONE_BILLION)) {\n    return humanFormat(bigInteger.divide(ONE_MILLION).toJSNumber(), {\n      scale: humanFormatMillionScale\n    });\n  }\n  return humanFormat(bigInteger.toJSNumber(), { scale: humanFormatScale });\n};\n\nexport const bigIntegerToLocaleString = (bigInteger) => {\n  let i = 0;\n  let formattedString = '';\n  for (const c of bigInteger.toString().split('').reverse()) {\n    if (i > 0 && i % 3 === 0) {\n      formattedString = ',' + formattedString;\n    }\n    formattedString = c + formattedString;\n    i++;\n  }\n  return formattedString;\n};\n","export interface Dimensions {\n  xOffset: number;\n  yOffset: number;\n  height: number;\n  width: number;\n  chartWidth: number;\n  chartHeight: number;\n  xMargin: number;\n  yMargin: number;\n}\n\nexport interface DimensionParameter {\n  xOffset: number;\n  yOffset: number;\n  yAxis: any;\n  xAxis: any;\n  height: number;\n  width: number;\n  margins: Margins;\n}\n\nexport type Margins =\n  | [number, number]\n  | [number, number, number, number]\n  | number;\n\n/**\n * Given a margins object, returns the top/left/right/bottom positions.\n */\nfunction parseMargins(margins?: Margins) {\n  let top = 0;\n  let right = 0;\n  let bottom = 0;\n  let left = 0;\n\n  if (Array.isArray(margins)) {\n    if (margins.length === 2) {\n      top = margins[0];\n      bottom = margins[0];\n      left = margins[1];\n      right = margins[1];\n    } else if (margins.length === 4) {\n      top = margins[0];\n      right = margins[1];\n      bottom = margins[2];\n      left = margins[3];\n    }\n  } else if (margins !== undefined) {\n    top = margins;\n    right = margins;\n    bottom = margins;\n    left = margins;\n  }\n\n  return {\n    top,\n    right,\n    bottom,\n    left\n  };\n}\n\n/**\n * Calculates the margins for the chart.\n */\nfunction calculateMarginOffsets(\n  height: number,\n  width: number,\n  margins: { left: number; right: number; bottom: number; top: number }\n) {\n  const { left, right, bottom, top } = margins;\n  const newHeight = height - top - bottom;\n  const newWidth = width - left - right;\n\n  return {\n    height: newHeight,\n    width: newWidth\n  };\n}\n\n/**\n * Calculates the dimensions for the chart.\n */\nexport function getDimension({\n  xOffset,\n  yOffset,\n  height,\n  width,\n  margins\n}: DimensionParameter | any): Dimensions {\n  const parsedMargins = parseMargins(margins);\n  const marginDims = calculateMarginOffsets(height, width, parsedMargins);\n  const chartWidth = marginDims.width - xOffset;\n  const chartHeight = marginDims.height - yOffset;\n\n  return {\n    xOffset,\n    yOffset,\n    height,\n    width,\n    chartWidth,\n    chartHeight,\n    xMargin: xOffset + parsedMargins.left,\n    yMargin: parsedMargins.top\n  };\n}\n","import { min, max } from 'd3-array';\n\n/**\n * Gets the min/max values handling nested arrays.\n */\nexport function extent(data: any[], attr: string): number[] {\n  const accessor = (val, fn) => {\n    if (Array.isArray(val.data)) {\n      return fn(val.data, (vv) => vv[attr]);\n    }\n    return val[attr];\n  };\n\n  const minVal = min(data, (d) => accessor(d, min));\n  const maxVal = max(data, (d) => accessor(d, max));\n\n  return [minVal, maxVal];\n}\n\n/**\n * Get the domain for the Y Axis.\n */\nexport function getYDomain({\n  data,\n  scaled = false,\n  isDiverging = false\n}): number[] {\n  const [startY, endY] = extent(data, 'y');\n  const [startY1, endY1] = extent(data, 'y1');\n\n  // If dealing w/ negative numbers, we should\n  // normalize the top and bottom values\n  if (startY < 0 || isDiverging) {\n    const posStart = -startY;\n    const maxNum = Math.max(posStart, endY);\n\n    return [-maxNum, maxNum];\n  }\n\n  // Scaled start scale at non-zero\n  if (scaled) {\n    return [startY1, endY1];\n  }\n\n  // Start at 0 based\n  return [0, endY1];\n}\n\n/**\n * Get the domain for the X Axis.\n */\nexport function getXDomain({\n  data,\n  scaled = false,\n  isDiverging = false\n}): number[] {\n  const startX0 = extent(data, 'x0')[0];\n  const endX1 = extent(data, 'x1')[1];\n\n  // Histograms use dates for start/end\n  if (typeof startX0 === 'number' && typeof endX1 === 'number') {\n    // If dealing w/ negative numbers, we should\n    // normalize the top and bottom values\n    if (startX0 < 0 || isDiverging) {\n      const posStart = -startX0;\n      const maxNum = Math.max(posStart, endX1);\n\n      return [-maxNum, maxNum];\n    }\n\n    // If not scaled, return 0/max domains\n    if (!scaled) {\n      return [0, endX1];\n    }\n  }\n\n  // Scaled start scale at non-zero\n  return [startX0, endX1];\n}\n","import { curveLinear, curveMonotoneX, curveStep } from 'd3-shape';\n\nexport type InterpolationTypes = 'linear' | 'smooth' | 'step';\nexport type RadialInterpolationTypes = 'linear' | 'smooth';\n\n/**\n * Helper function for interpolation.\n */\nexport function interpolate(\n  type: InterpolationTypes | RadialInterpolationTypes\n) {\n  if (type === 'smooth') {\n    return curveMonotoneX;\n  } else if (type === 'step') {\n    return curveStep;\n  } else {\n    return curveLinear;\n  }\n}\n","import { bisector } from 'd3-array';\nimport { applyToPoint, applyToPoints, inverse } from 'transformation-matrix';\n\ntype PointObjectNotation = { x: number; y: number };\n\n/**\n * Add ability to calculate scale band position.\n * Reference: https://stackoverflow.com/questions/38633082/d3-getting-invert-value-of-band-scales\n */\nconst scaleBandInvert = (scale, round = false) => {\n  const domain = scale.domain();\n  const paddingOuter = scale(domain[0]);\n  const eachBand = scale.step();\n  const [, end] = scale.range();\n\n  return (offset) => {\n    // Keep the band from going outside the domain length\n    let band = Math.min(\n      (offset - paddingOuter) / eachBand,\n      domain.length - 0.01\n    );\n\n    // Catch negative band values from horizontal charts exceeding domain length\n    if (band < 0 && Math.abs(band) > domain.length - 1) {\n      band = Math.floor(Math.abs(band)) * -1;\n    }\n\n    // Round to the closest index OR take the floor value\n    let index = round\n      ? Math.round(band) % domain.length\n      : Math.floor(band) % domain.length;\n\n    // Handle horizontal charts...\n    if (end === 0) {\n      index = index * -1;\n    }\n\n    return domain[Math.max(0, Math.min(index, domain.length - 1))];\n  };\n};\n\n/**\n * Get the data point closest to a given position on a continuous scale.\n *\n * @param {Object} params - The parameters for the function.\n * @param {number} params.pos - The position to find the closest point to.\n * @param {Object} params.scale - The scale object.\n * @param {Array} params.data - The data array.\n * @param {string} [params.attr='x'] - The attribute to use for comparison.\n * @param {boolean} [params.roundDown=false] - Whether to round down to the nearest point.\n *\n * @returns {Object} The closest point to the specified position.\n */\nexport const getClosestContinousScalePoint = ({\n  pos,\n  scale,\n  data,\n  attr = 'x',\n  roundDown = false\n}: {\n  pos: number;\n  scale: any;\n  data: any[];\n  attr?: string;\n  roundDown?: boolean;\n}) => {\n  const domain = scale.invert(pos);\n\n  // Select the index\n  const bisect = bisector((d: any) => {\n    // add 1 to an index so it's the upper limit of a domain\n    return attr === 'i' ? d[attr] + 1 : d[attr];\n  }).right;\n  const index = bisect(data, domain);\n\n  // Determine min index\n  const minIndex = Math.max(0, index - 1);\n  const before = data[minIndex];\n\n  if (roundDown) {\n    return before;\n  }\n\n  // Determine max index\n  const maxIndex = Math.min(data.length - 1, index);\n  const after = data[maxIndex];\n\n  // Determine which is closest to the point\n  let beforeVal = before[attr];\n  let afterVal = after[attr];\n  beforeVal = domain - beforeVal;\n  afterVal = afterVal - domain;\n\n  return beforeVal < afterVal ? before : after;\n};\n\n/**\n * Get the data point closest to a given position on a band scale. This rounds down by default.\n *\n * @param {Object} params - The parameters for the function.\n * @param {number} params.pos - The position to find the closest point to.\n * @param {Object} params.scale - The scale object.\n * @param {Array} params.data - The data array.\n * @param {boolean} [params.roundClosest=false] - Whether to round to the closest point instead of down.\n *\n * @returns {Object} The closest point to the specified position.\n */\nexport const getClosestBandScalePoint = ({\n  pos,\n  scale,\n  data,\n  roundClosest = false\n}: {\n  pos: number;\n  scale: any;\n  data: any[];\n  roundClosest?: boolean;\n}) => {\n  const domain = scale.domain();\n  let prop;\n\n  // Of course the Marimekko is a pain...\n  if (scale.mariemkoInvert) {\n    prop = scale.mariemkoInvert(pos);\n  } else {\n    prop = scaleBandInvert(scale, roundClosest)(pos);\n  }\n\n  const idx = domain.indexOf(prop);\n  return data[idx];\n};\n\n/**\n * Given an event, get the parent svg element;\n */\nexport const getParentSVG = (event) => {\n  // set node to targets owner svg\n  let node = event.target.ownerSVGElement;\n\n  // find the outermost svg\n  if (node) {\n    while (node.ownerSVGElement) {\n      node = node.ownerSVGElement;\n    }\n  }\n\n  return node;\n};\n\n/**\n * Given an event, get the relative X/Y position for a target.\n */\nexport const getPositionForTarget = ({ target, clientX, clientY }) => {\n  const rect = target.getBoundingClientRect();\n  return {\n    x: clientX - (rect?.left || 0) - target.clientLeft,\n    y: clientY - (rect?.top || 0) - target.clientTop\n  };\n};\n\n/**\n * Gets the point from q given matrix.\n */\nexport const getPointFromMatrix = (event, matrix): PointObjectNotation => {\n  const parent = getParentSVG(event);\n\n  if (!parent) {\n    return null;\n  }\n\n  // Determines client coordinates relative to the editor component\n  const { top, left } = parent.getBoundingClientRect();\n  const x = event.clientX - left;\n  const y = event.clientY - top;\n\n  // Transforms the coordinate to world coordinate (in the SVG/DIV world)\n  return applyToPoint(inverse(matrix), { x, y });\n};\n\n/**\n * Get the start/end matrix.\n */\nexport const getLimitMatrix = (\n  height: number,\n  width: number,\n  matrix\n): PointObjectNotation[] =>\n  applyToPoints(matrix, [\n    { x: 0, y: 0 },\n    { x: width, y: height }\n  ]);\n\n/**\n * Constrain the matrix.\n */\nexport const constrainMatrix = (height: number, width: number, matrix) => {\n  const [min, max] = getLimitMatrix(height, width, matrix) as {\n    x: number;\n    y: number;\n  }[];\n\n  if (max.x < width || max.y < height) {\n    return true;\n  }\n\n  if (min.x > 0 || min.y > 0) {\n    return true;\n  }\n\n  return false;\n};\n\n/**\n * Determine if scale factor is less than allowed.\n */\nconst lessThanScaleFactorMin = (value, scaleFactor: number) =>\n  value.scaleFactorMin && value.d * scaleFactor <= value.scaleFactorMin;\n\n/**\n * Determine if scale factor is larger than allowed.\n */\nconst moreThanScaleFactorMax = (value, scaleFactor: number) =>\n  value.scaleFactorMax && value.d * scaleFactor >= value.scaleFactorMax;\n\n/**\n * Determine if both min and max scale fctors are going out of bounds.\n */\nexport const isZoomLevelGoingOutOfBounds = (value, scaleFactor: number) => {\n  const a = lessThanScaleFactorMin(value, scaleFactor) && scaleFactor < 1;\n  const b = moreThanScaleFactorMax(value, scaleFactor) && scaleFactor > 1;\n  return a || b;\n};\n","/**\n * Toggle the text selection of the body.\n */\nexport function toggleTextSelection(allowSelection: boolean) {\n  const style = allowSelection ? '' : 'none';\n  [\n    '-webkit-touch-callout',\n    '-webkit-user-select',\n    '-khtml-user-select',\n    '-moz-user-select',\n    '-ms-user-select',\n    'user-select'\n  ].forEach((prop) => (document.body.style[prop] = style));\n}\n","import { ChartInternalShallowDataShape } from '../data';\n\n/**\n * Calculates whether the stroke should be shown.\n */\nexport function calculateShowStroke(\n  current: ChartInternalShallowDataShape,\n  data: ChartInternalShallowDataShape[]\n) {\n  const i = data.indexOf(current);\n  let showLine = false;\n\n  const prev = data[i - 1];\n  if (i > 0 && prev.y) {\n    showLine = true;\n  }\n\n  const cur = data[i];\n  if (cur.y) {\n    showLine = true;\n  }\n\n  const next = data[i + 1];\n  if (i < data.length - 1 && next.y) {\n    showLine = true;\n  }\n\n  return showLine;\n}\n","/**\n * Get the angle from a radian.\n */\nexport const getDegrees = (radians: number) => (radians / Math.PI) * 180 - 90;\n","import classNames from 'classnames';\n\nexport interface PropFunctionTypes {\n  /**\n   * Classnames to apply to the element.\n   */\n  className?: any;\n\n  /**\n   * CSS styles to apply to the element.\n   */\n  style?: any;\n}\n\nexport const functionProps = (prop: string, val: any, data: any) => {\n  if (typeof val === 'function') {\n    return val(data);\n  } else if (prop === 'className') {\n    return classNames(val);\n  } else if (val !== undefined || val !== null) {\n    return val;\n  }\n\n  return {};\n};\n\nexport const constructFunctionProps = (\n  props: PropFunctionTypes,\n  data: any\n) => ({\n  className: functionProps('className', props.className, data),\n  style: functionProps('style', props.style, data)\n});\n","type AccessorCallback = (data: any) => any;\n\n/**\n * Given a dataset and a list of accessors, returns a unique collection.\n */\nexport function uniqueBy<T = any>(data: T[], ...accessors: AccessorCallback[]) {\n  const result: any[] = [];\n\n  const ittr = (arr: T[], depth: number) => {\n    for (const a of arr) {\n      const acc = accessors[depth];\n      if (acc === undefined) {\n        throw new Error(`Accessor not found for depth: ${depth}`);\n      }\n\n      const val = acc(a);\n      if (Array.isArray(val)) {\n        ittr(val, depth + 1);\n      } else if (!result.includes(val)) {\n        result.push(val);\n      }\n    }\n  };\n\n  ittr(data, 0);\n\n  return result;\n}\n","import React, { ReactElement } from 'react';\nimport { calculateDimensions } from './size';\n\nexport interface WrapTextInputs {\n  key: string;\n  x?: any;\n  paddingY?: number;\n  paddingX?: number;\n  width: number;\n  height?: number;\n  fontFamily: string;\n  fontSize: number;\n  wrap?: boolean;\n  size?: {\n    width: number;\n    height: number;\n  };\n  visibility?: 'auto' | 'always';\n}\n\nexport function wrapText({\n  key,\n  x = 0,\n  size,\n  paddingY,\n  wrap = true,\n  paddingX,\n  width,\n  height,\n  fontFamily,\n  fontSize,\n  visibility = 'auto'\n}: WrapTextInputs): ReactElement | ReactElement[] | null {\n  size = size || calculateDimensions(key, fontFamily, fontSize);\n  const words = key.toString().split(/\\s+/);\n\n  if (words.length > 1 && size.width > width) {\n    let rows = [];\n    let maxWidth = 0;\n    let maxHeight = 0;\n    let curText = '';\n    let currWidth = 0;\n    let nextText = '';\n    let nextWidth = 0;\n\n    for (const word of words) {\n      nextText = curText === '' ? word : `${curText} ${word}`;\n      nextWidth = calculateDimensions(nextText, fontFamily, fontSize).width;\n\n      if (nextWidth <= width - (paddingX ? 2 * paddingX : 0)) {\n        curText = nextText;\n        currWidth = nextWidth;\n      } else {\n        rows.push(curText);\n        maxWidth = Math.max(maxWidth, currWidth);\n        curText = word;\n        currWidth = calculateDimensions(curText, fontFamily, fontSize).width;\n      }\n    }\n    rows.push(curText);\n    maxHeight = rows.length * size.height;\n\n    if (visibility !== 'always') {\n      if (height && maxHeight >= height - (paddingY ? 2 * paddingY : 0)) {\n        return null;\n      }\n\n      if (width && maxWidth >= width - (paddingX ? 2 * paddingX : 0)) {\n        return null;\n      }\n    }\n\n    if (!wrap && rows.length > 1) {\n      return rows[0];\n    }\n\n    return rows.map((r, i) => (\n      <tspan\n        key={i}\n        dominantBaseline=\"alphabetic\"\n        style={{ baselineShift: '0%' }}\n        dy={\n          i > 0\n            ? size.height\n            : height\n              ? size.height / 2 - 5\n              : -maxHeight / 2 + size.height\n        }\n        x={x}\n      >\n        {r}\n      </tspan>\n    ));\n  }\n\n  if (visibility !== 'always') {\n    if (height && size.height + paddingY >= height) {\n      return null;\n    }\n\n    if (width && size.width + paddingX >= width) {\n      return null;\n    }\n  }\n\n  // NOTE: 5px seems to magic number for making it center\n  return (\n    <tspan\n      dominantBaseline=\"alphabetic\"\n      style={{ baselineShift: '0%' }}\n      dy={size.height / 2 - 5}\n      x={x}\n    >\n      {key}\n    </tspan>\n  );\n}\n","import React, { FC, Fragment, ReactElement } from 'react';\nimport {\n  RadialAxisTickSeries,\n  RadialAxisTickSeriesProps\n} from './RadialAxisTickSeries';\nimport {\n  RadialAxisArcSeries,\n  RadialAxisArcSeriesProps\n} from './RadialAxisArcSeries';\nimport { CloneElement } from 'reablocks';\nimport { getTicks } from '../../utils';\n\nexport interface RadialAxisProps {\n  /**\n   * Height of the axis.\n   */\n  height: number;\n\n  /**\n   * Width of the axis.\n   */\n  width: number;\n\n  /**\n   * Scale to use for the axis.\n   */\n  xScale: any;\n\n  /**\n   * Inner radius of the axis.\n   */\n  innerRadius: number;\n\n  /**\n   * Type of the axis.\n   */\n  type: 'value' | 'time' | 'category';\n\n  /**\n   * Arc element to render.\n   */\n  arcs: ReactElement<\n    RadialAxisArcSeriesProps,\n    typeof RadialAxisArcSeries\n  > | null;\n\n  /**\n   * Tick element to render.\n   */\n  ticks: ReactElement<\n    RadialAxisTickSeriesProps,\n    typeof RadialAxisTickSeries\n  > | null;\n\n  /**\n   * Start angle for the first value.\n   */\n  startAngle?: number;\n\n  /**\n   * End angle for the last value.\n   */\n  endAngle?: number;\n}\n\nexport const RadialAxis: FC<Partial<RadialAxisProps>> = ({\n  arcs,\n  ticks,\n  xScale,\n  height,\n  width,\n  innerRadius,\n  type,\n  startAngle,\n  endAngle\n}) => {\n  const outerRadius = Math.min(height, width) / 2;\n\n  // TODO: This is a hack to get the ticks in the parent\n  // component. This is because the ticks are needed\n  // for the arcs's lines.\n  const tickValues = getTicks(\n    xScale,\n    ticks.props.tickValues,\n    type,\n    ticks.props.count,\n    ticks.props.interval || ticks.props.count\n  );\n\n  return (\n    <Fragment>\n      {arcs && (\n        <CloneElement<RadialAxisArcSeriesProps>\n          element={arcs}\n          outerRadius={outerRadius}\n          innerRadius={innerRadius}\n          tickValues={tickValues}\n          startAngle={startAngle}\n          endAngle={endAngle}\n        />\n      )}\n      {ticks && (\n        <CloneElement<RadialAxisTickSeriesProps>\n          element={ticks}\n          scale={xScale}\n          type={type}\n          innerRadius={innerRadius}\n          outerRadius={outerRadius}\n          startAngle={startAngle}\n          endAngle={endAngle}\n        />\n      )}\n    </Fragment>\n  );\n};\n\nRadialAxis.defaultProps = {\n  innerRadius: 10,\n  type: 'value',\n  arcs: <RadialAxisArcSeries />,\n  ticks: <RadialAxisTickSeries />,\n  startAngle: 0,\n  endAngle: 2 * Math.PI\n};\n","import React, {\n  Children,\n  cloneElement,\n  PropsWithChildren,\n  FC,\n  useEffect,\n  useRef\n} from 'react';\nimport { toggleTextSelection } from '../utils/selection';\n\ninterface MoveProps extends PropsWithChildren {\n  cursor?: string;\n  disabled?: boolean;\n  preventRightClick: boolean;\n  disableText: boolean;\n  threshold: number;\n  onMoveStart: (event) => void;\n  onMove: (event) => void;\n  onMoveCancel: (event) => void;\n  onMoveEnd: (event) => void;\n}\n\nexport const Move: FC<Partial<MoveProps>> = (props) => {\n  let started = false;\n  let deltaX = 0;\n  let deltaY = 0;\n  let prevXPosition = 0;\n  let prevYPosition = 0;\n  const rqf = useRef<number>();\n\n  useEffect(() => {\n    return () => {\n      cancelAnimationFrame(rqf.current);\n      disposeHandlers();\n    };\n  }, []);\n\n  const disposeHandlers = () => {\n    window.removeEventListener('mousemove', onMouseMove);\n    window.removeEventListener('mouseup', onMouseUp);\n    window.removeEventListener('touchmove', onTouchMove);\n    window.removeEventListener('touchend', onTouchEnd);\n\n    setCursor(false);\n    disableText(true);\n  };\n\n  const disableText = (shouldDisable: boolean) => {\n    if (props.disableText) {\n      toggleTextSelection(shouldDisable);\n    }\n  };\n\n  const setCursor = (set: boolean) => {\n    let { cursor } = props;\n\n    if (cursor) {\n      if (!set) {\n        cursor = 'inherit';\n      }\n\n      document.body.style['cursor'] = cursor;\n    }\n  };\n\n  const checkThreshold = () => {\n    const { threshold } = props;\n\n    return (\n      !started && (Math.abs(deltaX) > threshold || Math.abs(deltaY) > threshold)\n    );\n  };\n\n  const getTouchCoords = (event) => {\n    const { clientX, clientY } = event.touches[0];\n    return {\n      clientX,\n      clientY\n    };\n  };\n\n  const onMouseDown = (event: React.MouseEvent) => {\n    const { preventRightClick, disabled } = props;\n\n    const shouldCancel = event.nativeEvent.which === 3 && preventRightClick;\n    if (shouldCancel || disabled) {\n      return;\n    }\n\n    event.preventDefault();\n    event.stopPropagation();\n\n    started = false;\n\n    // Always bind event so we cancel movement even if no action was taken\n    window.addEventListener('mousemove', onMouseMove);\n    window.addEventListener('mouseup', onMouseUp);\n  };\n\n  const onMouseMove = (event) => {\n    event.preventDefault();\n    event.stopPropagation();\n\n    const { movementX, movementY } = event;\n    let localDeltaX = deltaX + movementX;\n    let localDeltaY = deltaY + movementY;\n\n    if (checkThreshold()) {\n      disableText(true);\n      setCursor(true);\n\n      localDeltaX = 0;\n      localDeltaY = 0;\n      started = true;\n\n      props.onMoveStart({\n        nativeEvent: event,\n        type: 'mouse'\n      });\n    } else {\n      rqf.current = requestAnimationFrame(() => {\n        props.onMove({\n          nativeEvent: event,\n          type: 'mouse',\n          x: localDeltaX,\n          y: localDeltaY\n        });\n      });\n    }\n\n    deltaX = localDeltaX;\n    deltaY = localDeltaY;\n  };\n\n  const onMouseUp = (event) => {\n    event.preventDefault();\n    event.stopPropagation();\n\n    disposeHandlers();\n\n    if (started) {\n      props.onMoveEnd({\n        nativeEvent: event,\n        type: 'mouse'\n      });\n    } else {\n      props.onMoveCancel({\n        nativeEvent: event,\n        type: 'mouse'\n      });\n    }\n  };\n\n  const onTouchStart = (event: React.TouchEvent) => {\n    const { disabled } = props;\n\n    if (disabled || event.touches.length !== 1) {\n      return;\n    }\n\n    event.preventDefault();\n    event.stopPropagation();\n\n    started = false;\n    prevXPosition = event.touches[0].clientX;\n    prevYPosition = event.touches[0].clientY;\n\n    // Always bind event so we cancel movement even if no action was taken\n    window.addEventListener('touchmove', onTouchMove);\n    window.addEventListener('touchend', onTouchEnd);\n  };\n\n  const onTouchMove = (event: TouchEvent) => {\n    event.preventDefault();\n    event.stopPropagation();\n\n    // Calculate delta from previous position and current\n    const { clientX, clientY } = getTouchCoords(event);\n    let localDeltaX = clientX - prevXPosition;\n    let localDeltaY = clientY - prevYPosition;\n\n    // Track the delta\n    localDeltaX = localDeltaX + localDeltaX;\n    localDeltaY = localDeltaY + localDeltaY;\n\n    if (checkThreshold()) {\n      disableText(true);\n      setCursor(true);\n\n      localDeltaX = 0;\n      localDeltaY = 0;\n      started = true;\n\n      props.onMoveStart({\n        // TODO: Come back and clean this up...\n        nativeEvent: {\n          ...event,\n          clientX,\n          clientY\n        },\n        type: 'touch'\n      });\n    } else {\n      rqf.current = requestAnimationFrame(() => {\n        props.onMove({\n          // TODO: Come back and clean this up...\n          nativeEvent: {\n            ...event,\n            clientX,\n            clientY\n          },\n          type: 'touch',\n          x: localDeltaX,\n          y: localDeltaY\n        });\n      });\n    }\n\n    prevXPosition = clientX;\n    prevYPosition = clientY;\n  };\n\n  const onTouchEnd = (event: TouchEvent) => {\n    event.preventDefault();\n    event.stopPropagation();\n    disposeHandlers();\n\n    if (started) {\n      props.onMoveEnd({\n        nativeEvent: event,\n        type: 'touch'\n      });\n    } else {\n      props.onMoveCancel({\n        nativeEvent: event,\n        type: 'touch'\n      });\n    }\n  };\n\n  return Children.map(props.children, (child: any) =>\n    cloneElement(child, {\n      ...child.props,\n      onMouseDown: (e) => {\n        onMouseDown(e);\n        if (child.props.onMouseDown) {\n          child.props.onMouseDown(e);\n        }\n      },\n      onTouchStart: (e) => {\n        onTouchStart(e);\n        if (child.props.onTouchStart) {\n          child.props.onTouchStart(e);\n        }\n      }\n    })\n  );\n};\n\nMove.defaultProps = {\n  preventRightClick: true,\n  disableText: true,\n  threshold: 0,\n  onMoveStart: () => undefined,\n  onMove: () => undefined,\n  onMoveEnd: () => undefined,\n  onMoveCancel: () => undefined\n};\n","import React, { FC, useState } from 'react';\nimport classNames from 'classnames';\nimport { range } from 'd3-array';\nimport { Move } from '../Gestures/Move';\nimport css from './BrushHandle.module.css';\n\nexport interface BrushHandleProps {\n  height: number;\n  onHandleDrag: (deltaX: number) => void;\n}\n\nexport const BrushHandle: FC<BrushHandleProps> = (props) => {\n  const { height, onHandleDrag } = props;\n  const [isDragging, setIsDragging] = useState(false);\n\n  return (\n    <Move\n      cursor=\"ew-resize\"\n      onMoveStart={() => setIsDragging(true)}\n      onMove={({x}) =>  onHandleDrag(x)}\n      onMoveEnd={() =>  setIsDragging(false)}\n    >\n      <g>\n        <line className={css.line} y1=\"0\" y2={height} x1=\"5\" x2=\"5\" />\n        <rect\n          className={classNames(css.handle, { [css.dragging]: isDragging })}\n          height={height - 10}\n          style={{ cursor: 'ew-resize' }}\n          width={8}\n          y=\"5\"\n          y1={height - 5}\n        />\n        <g\n          transform={`translate(-1, ${height / 2 - 10})`}\n          style={{ pointerEvents: 'none' }}\n        >\n          {range(5).map((i) => (\n            <circle cy={i * 5} cx=\"5\" r=\".5\" key={i} className={css.dot} />\n          ))}\n        </g>\n      </g>\n    </Move>\n  );\n};\n\nBrushHandle.defaultProps = {};\n\n","import React, { Fragment, useState, FC, useCallback } from 'react';\nimport { BrushHandle } from './BrushHandle';\nimport { Move } from '../Gestures/Move';\nimport css from './BrushSlice.module.css';\n\nexport interface BrushChangeEvent {\n  start?: number;\n  end?: number;\n}\n\ninterface BrushSliceProps {\n  height: number;\n  width: number;\n  start: number;\n  end: number;\n  onBrushChange: (event: BrushChangeEvent) => void;\n}\n\nexport const BrushSlice: FC<BrushSliceProps> = (props) => {\n  const { height, start, end, width, onBrushChange, } = props;\n  const [isDragging, setIsDragging] = useState(false);\n  const sliceWidth = Math.max(end - start, 0);\n  const endSliceWidth = Math.max(width - end, 0);\n  const hasNoSlice = start === 0 && end === width;\n\n  const onMoveStart = useCallback(() =>  {\n    const hasNoSlice = start === 0 && end === width;\n\n    if (!hasNoSlice) {\n      setIsDragging(true);\n    }\n  }, [end, start, width]);\n\n  const onMove = useCallback(({ x }) => {\n    const startUpdated = start + x;\n    const endUpdated = end + x;\n\n    if (startUpdated >= 0 && endUpdated <= width) {\n      onBrushChange({\n        start: startUpdated,\n        end: endUpdated\n      });\n    }\n  }, [start, end, width, onBrushChange]);\n\n  const onHandleDrag = useCallback((direction: 'start' | 'end', deltaX: number) => {\n    const startUpdated = direction === 'start' ? start + deltaX : start;\n    const endUpdated = direction !== 'start' ? end + deltaX : end;\n\n    onBrushChange({\n      start: startUpdated,\n      end: endUpdated\n    });\n  }, [end, onBrushChange, start]);\n\n  return (\n    <Fragment>\n      <rect className={css.unsliced} height={height} width={start} />\n      <rect\n        transform={`translate(${end}, 0)`}\n        className={css.unsliced}\n        height={height}\n        width={endSliceWidth}\n      />\n      <g transform={`translate(${start}, 0)`}>\n        <Move\n          cursor=\"grabbing\"\n          onMoveStart={onMoveStart}\n          onMove={onMove}\n          onMoveEnd={() => setIsDragging(false)}\n        >\n          <rect\n            className={css.slice}\n            height={height}\n            width={sliceWidth}\n            style={{\n              cursor: isDragging ? 'grabbing' : 'grab',\n              opacity: hasNoSlice ? 0 : 0.1,\n              pointerEvents: !hasNoSlice ? 'initial' : 'none'\n            }}\n          />\n        </Move>\n        <g transform={'translate(-4, 0)'}>\n          <BrushHandle\n            height={height}\n            onHandleDrag={(deltaX) => onHandleDrag('start', deltaX)}\n          />\n        </g>\n        <g transform={`translate(${sliceWidth - 5}, 0)`}>\n          <BrushHandle\n            height={height}\n            onHandleDrag={(deltaX) => onHandleDrag('end', deltaX)}\n          />\n        </g>\n      </g>\n    </Fragment>\n  );\n};\n\nBrushSlice.defaultProps = {};\n","import React, { useState, useEffect, useRef, FC, PropsWithChildren, useCallback } from 'react';\nimport bind from 'memoize-bind';\nimport { getPositionForTarget } from '../utils/position';\nimport { BrushSlice, BrushChangeEvent } from './BrushSlice';\nimport { ChartDataTypes } from '../data';\nimport { Move } from '../Gestures/Move';\n\nexport interface BrushConfiguration {\n  disabled?: boolean;\n  fill?: string;\n  domain?: [ChartDataTypes, ChartDataTypes];\n  onBrushChange?: (e) => void;\n}\n\ninterface BrushProps extends PropsWithChildren {\n  height: number;\n  width: number;\n  disabled?: boolean;\n  start?: number;\n  end?: number;\n  onBrushChange?: (e: BrushChangeEvent) => void;\n}\n\ninterface BrushState {\n  start?: number;\n  end?: number;\n}\n\nexport const Brush: FC<Partial<BrushProps>> = (props) => {\n  const { children, disabled, height, width, start: startProp, end: endProp, onBrushChange } = props;\n  const [isSlicing, setIsSlicing] = useState(false);\n  const [initial, setInitial] = useState<number>();\n  const [range, setRange] = useState<BrushState>({\n    start: props.start || 0,\n    end: props.end || props.width,\n  });\n  const { start, end } = range;\n\n  const ref = useRef<any>();\n\n  const ensurePositionInBounds = useCallback((\n    newStart?: number,\n    newEnd?: number,\n  ) => {\n    let startUpdated = newStart;\n    let endUpdated = newEnd;\n\n    if (startUpdated === undefined || startUpdated <= 0) {\n      startUpdated = 0;\n    }\n\n    if (end === undefined) {\n      endUpdated = width;\n    }\n\n    if (startUpdated > endUpdated) {\n      startUpdated = start;\n    }\n\n    if (endUpdated < startUpdated) {\n      endUpdated = end;\n    }\n\n    if (endUpdated >= width) {\n      endUpdated = width;\n    }\n\n    return { start: startUpdated, end: endUpdated };\n  }, [end, start, width]);\n\n  const getPositionsForPanEvent = useCallback((event: any) => {\n    const eventObj = {\n      target: ref.current,\n      clientX: event.clientX,\n      clientY: event.clientY,\n    };\n\n    return getPositionForTarget(eventObj);\n  }, []);\n\n  const getStartEnd = useCallback((event: any) => {\n    const { x } = getPositionsForPanEvent(event);\n\n    if (x < initial) {\n      return ensurePositionInBounds(x, initial);\n    } else {\n      return ensurePositionInBounds(initial, x);\n    }\n  }, [ensurePositionInBounds, getPositionsForPanEvent, initial]);\n\n  const onMoveStart = useCallback((event: any) => {\n    if (!disabled) {\n      const positions = getPositionsForPanEvent(event.nativeEvent);\n\n      setIsSlicing(true);\n      setInitial(positions.x);\n    }\n  }, [disabled, getPositionsForPanEvent]);\n\n  const onMove = useCallback((event: any) => {\n    if (!disabled) {\n      const { start, end } = getStartEnd(event.nativeEvent);\n\n      if (onBrushChange) {\n        onBrushChange({\n          start,\n          end,\n        });\n      }\n\n      setRange({start, end});\n    }\n  }, [disabled, getStartEnd, onBrushChange]);\n\n  const onMoveEnd = useCallback(() => {\n    setIsSlicing(false);\n  }, []);\n\n  const onMoveCancel = useCallback(() => {\n    const val = {\n      start: 0,\n      end: width,\n    };\n\n    setRange(val);\n\n    if (onBrushChange) {\n      onBrushChange(val);\n    }\n  }, [onBrushChange, width]);\n\n  const onSliceChange = useCallback((event: BrushChangeEvent) => {\n    const val = ensurePositionInBounds(event.start, event.end);\n\n    setRange((state) => ({...state, ...val}));\n\n    if (onBrushChange) {\n      onBrushChange(val);\n    }\n  }, [ensurePositionInBounds, onBrushChange]);\n\n  useEffect(() => {\n    if (end === width) {\n      setRange((prev) => ({\n        ...prev,\n        end: width,\n      }));\n    }\n  }, [end, width]);\n\n  useEffect(() => {\n    // Don't update if we are doing the slicing\n    if (!isSlicing) {\n      const startUpdated = startProp !== start;\n      const endUpdated = endProp !== end;\n\n      if (startUpdated || endUpdated) {\n        setRange(ensurePositionInBounds(start, end));\n      }\n    }\n  }, [end, endProp, ensurePositionInBounds, isSlicing, start, startProp]);\n\n  return (\n    <Move\n      cursor=\"crosshair\"\n      onMoveStart={bind(onMoveStart, this)}\n      onMove={bind(onMove, this)}\n      onMoveEnd={bind(onMoveEnd, this)}\n      onMoveCancel={bind(onMoveCancel, this)}\n    >\n      <g\n        style={{\n          pointerEvents: isSlicing ? 'none' : 'auto',\n          cursor: disabled ? '' : 'crosshair',\n        }}\n      >\n        {children}\n        {!disabled && (\n          <>\n            <rect\n              ref={ref}\n              height={height}\n              width={width}\n              opacity={0}\n            />\n            {start !== undefined && end !== undefined && (\n              <BrushSlice\n                start={start}\n                end={end}\n                height={height}\n                width={width}\n                onBrushChange={bind(onSliceChange, this)}\n              />\n            )}\n          </>\n        )}\n      </g>\n    </Move>\n  );\n};","import React, { FC, PropsWithChildren, useCallback } from 'react';\nimport { BrushConfiguration, Brush } from './Brush';\nimport { BrushChangeEvent } from './BrushSlice';\n\nexport interface ChartBrushProps extends BrushConfiguration, PropsWithChildren {\n  scale: any;\n  height: number;\n  width: number;\n  children: any;\n}\n\nexport const ChartBrush: FC<Partial<ChartBrushProps>> = (props) => {\n  const { disabled, domain, scale, onBrushChange, width, children } = props;\n\n  const getBrushOffset = useCallback(() => {\n    let start;\n    let end;\n\n    if (!disabled && domain) {\n      start = scale(domain[0]);\n      end = scale(domain[1]);\n    }\n\n    return { start, end };\n  }, [disabled, domain, scale]);\n\n  const onBrushChangeHandler = useCallback((event: BrushChangeEvent) => {\n    if (onBrushChange) {\n      let domain;\n\n      if (\n        event.start !== undefined &&\n        event.end !== undefined &&\n        (event.start !== 0 || event.end !== width)\n      ) {\n        if (scale.invert) {\n          const start = scale.invert(event.start);\n          const end = scale.invert(event.end);\n          domain = [start, end];\n        } else {\n          // invert scaleBend\n          const band = scale.step();\n          const start = Math.ceil((event.start - band / 2) / band);\n          const end = Math.ceil((event.end - band / 2) / band);\n\n          domain = [scale.domain()[start], scale.domain()[end]];\n        }\n      }\n\n      onBrushChange({\n        domain\n      });\n    }\n  }, [onBrushChange, scale, width]);\n\n  return (\n    <Brush\n      {...props}\n      {...getBrushOffset()}\n      onBrushChange={onBrushChangeHandler}\n    >\n      {children}\n    </Brush>\n  );\n};\n\n\nChartBrush.defaultProps = {};\n","import { createContext, useContext } from 'react';\nimport { Dimensions } from '../utils';\nimport { LinearAxisDimensionChanged } from '../Axis';\n\nexport interface ChartContextProps extends Dimensions {\n  id: string;\n  chartSized?: boolean;\n  yAxisSized?: boolean;\n  xAxisSized?: boolean;\n  updateAxes: (\n    orientation: 'horizontal' | 'vertical',\n    event: LinearAxisDimensionChanged\n  ) => void;\n}\n\nexport const ChartContext = createContext<Partial<ChartContextProps>>({});\n\nexport const { Provider: ChartProvider, Consumer: ChartConsumer } =\n  ChartContext;\n\nexport const useChart = () => {\n  const context = useContext(ChartContext);\n\n  if (context === undefined) {\n    throw new Error('`useChart` hook must be used within a `ChartProvider`');\n  }\n\n  return context;\n};\n","import React, { FC, useCallback, useState, useMemo } from 'react';\nimport { Margins, getDimension } from '../utils/dimensions';\nimport useDimensions from 'react-cool-dimensions';\nimport { useId } from 'reablocks';\nimport { LinearAxisDimensionChanged } from '../Axis';\nimport classNames from 'classnames';\nimport { ChartContextProps, ChartProvider } from './ChartContext';\nimport css from './ChartContainer.module.css';\n\nexport interface ChartProps {\n  /**\n   * Id of the chart.\n   */\n  id?: string;\n\n  /**\n   * Width of the chart. If not provided will autosize.\n   */\n  width?: number;\n\n  /**\n   * Height of the chart. If not provided will autosize.\n   */\n  height?: number;\n\n  /**\n   * Margins for the chart.\n   */\n  margins?: Margins;\n\n  /**\n   * Classnames for the chart.\n   */\n  className?: string;\n\n  /**\n   * Classnames for the chart.\n   */\n  containerClassName?: string;\n\n  /**\n   * Additional css styles.\n   */\n  style?: React.StyleHTMLAttributes<SVGSVGElement>;\n\n  /**\n   * Center the chart. Used mainly internally.\n   */\n  center?: boolean;\n\n  /**\n   * Center chart on X Axis only. Used mainly internally.\n   */\n  centerX?: boolean;\n\n  /**\n   * Center chart on Y Axis only. Used mainly internally.\n   */\n  centerY?: boolean;\n}\n\nexport interface ChartContainerProps extends ChartProps {\n  /**\n   * Internal property to identify if the xAxis is visible.\n   */\n  xAxisVisible?: boolean;\n\n  /**\n   * Internal property to identify if the xAxis is visible.\n   */\n  yAxisVisible?: boolean;\n\n  /**\n   * Children elements to recieve the calculated props.\n   */\n  children: (props: ChartContainerChildProps) => any;\n}\n\nexport type ChartContainerChildProps = ChartContextProps;\n\nexport const ChartContainer: FC<ChartContainerProps> = ({\n  className,\n  children,\n  center,\n  centerX,\n  centerY,\n  style,\n  margins,\n  containerClassName,\n  xAxisVisible,\n  yAxisVisible,\n  id,\n  ...rest\n}) => {\n  const curId = useId(id);\n  const [xAxisSized, setXAxisSized] = useState<boolean>(false);\n  const [yAxisSized, setYAxisSized] = useState<boolean>(false);\n  const [xOffset, setXOffset] = useState<number>(0);\n  const [yOffset, setYOffset] = useState<number>(0);\n  const { observe, width, height } = useDimensions<HTMLDivElement>();\n\n  const chartSized = useMemo(() => {\n    if (!height || !width) {\n      return false;\n    }\n\n    // TODO: @amcdnl refactor this to account for 0-2 axises on x/y\n    if (xAxisVisible && !xAxisSized) {\n      return false;\n    }\n\n    if (yAxisVisible && !yAxisSized) {\n      return false;\n    }\n\n    return true;\n  }, [height, width, xAxisSized, xAxisVisible, yAxisVisible, yAxisSized]);\n\n  const onUpdateAxes = useCallback(\n    (\n      orientation: 'horizontal' | 'vertical',\n      event: LinearAxisDimensionChanged\n    ) => {\n      if (orientation === 'horizontal') {\n        setXAxisSized(true);\n      } else {\n        setYAxisSized(true);\n      }\n\n      if (event.height) {\n        setYOffset(event.height);\n      }\n\n      if (event.width) {\n        setXOffset(event.width);\n      }\n    },\n    []\n  );\n\n  const childProps: ChartContainerChildProps = useMemo(\n    () => ({\n      chartSized,\n      id: curId,\n      updateAxes: onUpdateAxes,\n      yAxisSized,\n      xAxisSized,\n      ...getDimension({\n        margins,\n        height,\n        width,\n        yOffset,\n        xOffset\n      })\n    }),\n    [\n      chartSized,\n      curId,\n      onUpdateAxes,\n      yAxisSized,\n      xAxisSized,\n      margins,\n      height,\n      width,\n      yOffset,\n      xOffset\n    ]\n  );\n\n  const translateX = center || centerX ? width / 2 : childProps.xMargin;\n  const translateY = center || centerY ? height / 2 : childProps.yMargin;\n\n  const styleHeight =\n    rest.height !== undefined && rest.height !== null ? rest.height : '100%';\n  const styleWidth =\n    rest.width !== undefined && rest.width !== null ? rest.width : '100%';\n\n  return (\n    <div\n      ref={observe}\n      style={{ height: styleHeight, width: styleWidth }}\n      className={classNames(containerClassName, css.container)}\n      {...rest}\n    >\n      <ChartProvider value={childProps}>\n        {height > 0 && width > 0 && (\n          <svg\n            width={width}\n            height={height}\n            className={classNames(css.svg, className)}\n            style={style}\n            tabIndex={0}\n          >\n            <g transform={`translate(${translateX}, ${translateY})`}>\n              {children(childProps)}\n            </g>\n          </svg>\n        )}\n      </ChartProvider>\n    </div>\n  );\n};\n","import bigInt from 'big-integer';\nimport { bigIntegerToLocaleString } from '../../common/utils/bigint';\nimport {\n  ChartDataTypes,\n  ChartInternalDataTypes,\n  ChartNestedDataShape,\n  ChartShallowDataShape\n} from './types';\n\nexport function normalizeValue(\n  value: ChartDataTypes,\n  maxBigInt: bigInt.BigInteger\n): ChartInternalDataTypes {\n  if (bigInt.isInstance(value)) {\n    if (maxBigInt.greater(1000000)) {\n      const divideBy = maxBigInt.divide(1000000);\n      return (value as bigInt.BigInteger).divide(divideBy).toJSNumber();\n    } else {\n      return (value as bigInt.BigInteger).toJSNumber();\n    }\n  } else {\n    return value as ChartInternalDataTypes;\n  }\n}\n\nexport function normalizeValueForFormatting(\n  value: ChartDataTypes\n): ChartInternalDataTypes {\n  if (bigInt.isInstance(value)) {\n    return bigIntegerToLocaleString(value as bigInt.BigInteger);\n  }\n  return value as ChartInternalDataTypes;\n}\n\nexport function getMaxBigIntegerForNested(series: ChartNestedDataShape[]) {\n  let maxBigInteger = bigInt.one;\n  for (const group of series) {\n    const maxBigIntegerForGroup = getMaxBigIntegerForShallow(group.data);\n    if (maxBigIntegerForGroup.greater(maxBigInteger)) {\n      maxBigInteger = maxBigIntegerForGroup;\n    }\n  }\n  return maxBigInteger;\n}\n\nexport function getMaxBigIntegerForShallow(series: ChartShallowDataShape[]) {\n  let maxBigInteger = bigInt.one;\n  for (const point of series) {\n    if (bigInt.isInstance(point.data)) {\n      const bigInteger = point.data as bigInt.BigInteger;\n      if (bigInteger.greater(maxBigInteger)) {\n        maxBigInteger = bigInteger;\n      }\n    }\n  }\n  return maxBigInteger;\n}\n","import { median } from 'd3-array';\nimport {\n  ChartInternalNestedDataShape,\n  ChartShallowDataShape,\n  ChartNestedDataShape,\n  ChartInternalShallowDataShape,\n  ChartDataTypes\n} from './types';\nimport {\n  getMaxBigIntegerForNested,\n  getMaxBigIntegerForShallow,\n  normalizeValue,\n  normalizeValueForFormatting\n} from './bigInteger';\nimport bigInt from 'big-integer';\n\nexport type Direction = 'vertical' | 'horizontal';\n\n/**\n * Accepts a `ChartDataShape` and transforms it to a chart readable data shape.\n *\n * Example:\n *\n *   [{\n *    key: 'Threat Intel',\n *    data: [{ key:'2011', data: 25 }]\n *   }]\n *\n * will be transformed to:\n *\n *  [{\n *    key: 'Threat Intel',\n *    data: [\n *      key: 'Threat Intel',\n *      x: '2011',\n *      y: 25\n *    ]\n *  }]\n */\nexport function buildNestedChartData(\n  series: ChartNestedDataShape[],\n  sort = false,\n  direction: Direction = 'vertical'\n): ChartInternalNestedDataShape[] {\n  let result: ChartInternalNestedDataShape[] = [];\n  const maxBigInteger = getMaxBigIntegerForNested(series);\n  const isVertical = direction === 'vertical';\n\n  for (const point of series) {\n    for (const nestedPoint of point.data) {\n      const key = normalizeValueForFormatting(point.key);\n      let idx = result.findIndex((r) => {\n        const left = r.key;\n        if (left instanceof Date && key instanceof Date) {\n          return left.getTime() === key.getTime();\n        }\n        return left === key;\n      });\n\n      if (idx === -1) {\n        result.push({\n          key,\n          metadata: point.metadata,\n          data: []\n        });\n\n        idx = result.length - 1;\n      }\n\n      const x = normalizeValue(\n        isVertical ? nestedPoint.key : nestedPoint.data,\n        maxBigInteger\n      );\n\n      const y = normalizeValue(\n        isVertical ? nestedPoint.data : nestedPoint.key,\n        maxBigInteger\n      );\n\n      result[idx].data.push({\n        key,\n        value: normalizeValueForFormatting(nestedPoint.data),\n        metadata: nestedPoint.metadata,\n        id: point.id,\n        x,\n        x0: isVertical ? x : 0,\n        x1: x,\n        y,\n        y0: isVertical ? 0 : y,\n        y1: y\n      });\n    }\n  }\n\n  // Sort the series data based on the median value\n  if (sort) {\n    result = result.sort((a, b) => {\n      const aMax = median(a.data, (d: any) => d.y)!;\n      const bMax = median(b.data, (d: any) => d.y)!;\n      return aMax < bMax ? 1 : -1;\n    });\n  }\n\n  return result;\n}\n\nfunction addToChartType(\n  a: ChartDataTypes,\n  b: number | bigInt.BigInteger\n): ChartDataTypes {\n  if (bigInt.isInstance(a) && bigInt.isInstance(b)) {\n    return (a as bigInt.BigInteger).add(b as bigInt.BigInteger);\n  } else if (a instanceof Date && typeof b === 'number') {\n    return new Date(a.valueOf() + b);\n  } else if (typeof a === 'number' && typeof b === 'number') {\n    return a + b;\n  } else {\n    throw new Error('Invalid types to addToChartTypes');\n  }\n}\n\n/**\n * Accepts a shallow shape and normalizes it to a chart readable format.\n */\nexport function buildShallowChartData(\n  series: ChartShallowDataShape[],\n  direction: Direction = 'vertical',\n  binSize: number | undefined = undefined\n): ChartInternalShallowDataShape[] {\n  const result: ChartInternalShallowDataShape[] = [];\n  const maxBigInteger = getMaxBigIntegerForShallow(series);\n  const isVertical = direction === 'vertical';\n\n  for (const point of series) {\n    const isTuple = Array.isArray(point.data);\n    let k1 = point.key;\n    if (binSize) {\n      k1 = addToChartType(point.key, binSize);\n    }\n\n    const props = {\n      k0: normalizeValue(point.key, maxBigInteger),\n      k1: normalizeValue(k1, maxBigInteger),\n      v0: normalizeValue(isTuple ? point.data[0] : 0, maxBigInteger),\n      v1: normalizeValue(isTuple ? point.data[1] : point.data, maxBigInteger)\n    };\n\n    const xProp = isVertical ? 'k' : 'v';\n    const yProp = isVertical ? 'v' : 'k';\n\n    result.push({\n      key: normalizeValueForFormatting(props.k0),\n      value: normalizeValueForFormatting(props.v1),\n      metadata: point.metadata,\n      id: point.id,\n      x: props[`${xProp}1`],\n      x0: props[`${xProp}0`],\n      x1: props[`${xProp}1`],\n      y: props[`${yProp}1`],\n      y0: props[`${yProp}0`],\n      y1: props[`${yProp}1`]\n    });\n  }\n\n  return result;\n}\n","import { histogram } from 'd3-array';\nimport { ChartInternalShallowDataShape, ChartInternalDataTypes } from './types';\n\n/**\n * Build a histogram given data set.\n */\nexport function buildBins(\n  xScale,\n  thresholds,\n  data: any[]\n): ChartInternalShallowDataShape[] {\n  const layout = histogram()\n    .value((d: any) => d.x)\n    .domain(xScale.domain())\n    .thresholds(xScale.ticks(thresholds));\n\n  const bins = layout(data as any);\n\n  return bins.map((bin) => ({\n    x0: bin.x0 as ChartInternalDataTypes,\n    x1: bin.x1 as ChartInternalDataTypes,\n    y: bin.length,\n    y0: 0,\n    y1: bin.length\n  }));\n}\n","import { stack, stackOffsetExpand, stackOffsetDiverging } from 'd3-shape';\nimport { ChartNestedDataShape, ChartInternalNestedDataShape } from './types';\nimport {\n  getMaxBigIntegerForNested,\n  normalizeValue,\n  normalizeValueForFormatting\n} from './bigInteger';\nimport { uniqueBy } from '../../common/utils/array';\n\nexport type StackTypes = 'default' | 'expand' | 'diverging';\n\n/**\n * Given a dataset like:\n *\n *   [{\n *    key: 'Threat Intel',\n *    data: [{ key:'2011', data: 25 }]\n *   }]\n *\n * it will transform it to:\n *\n *  [\n *    { x: 'Theat Intel', '2011': 25 }\n *  ]\n */\nfunction transformDataToStack(data: ChartNestedDataShape[]) {\n  const result: any[] = [];\n  const maxBigInteger = getMaxBigIntegerForNested(data);\n\n  for (const category of data) {\n    for (const value of category.data) {\n      let idx = result.findIndex((r) => {\n        if (r.x instanceof Date && category.key instanceof Date) {\n          return r.x.getTime() === category.key.getTime();\n        }\n        return r.x === category.key;\n      });\n\n      if (idx === -1) {\n        result.push({\n          metadata: category.metadata,\n          x: category.key,\n          formattedValues: {}\n        });\n\n        idx = result.length - 1;\n      }\n\n      result[idx].metadata = value.metadata;\n\n      result[idx][value.key as string] = normalizeValue(\n        value.data,\n        maxBigInteger\n      );\n\n      result[idx].formattedValues[value.key as string] =\n        normalizeValueForFormatting(value.data);\n    }\n  }\n\n  return result;\n}\n\n/**\n * Translates the stack data to a chart standard dataset.\n */\nfunction transformStackToData(\n  stackData,\n  direction = 'vertical'\n): ChartInternalNestedDataShape[] {\n  const result: ChartInternalNestedDataShape[] = [];\n  const isVertical = direction === 'vertical';\n\n  // Transform the data from the d3 stack format to our internal format\n  for (const category of stackData) {\n    for (const point of category) {\n      const key = point.data.x;\n\n      let idx = result.findIndex((r) => {\n        if (r.key instanceof Date && key instanceof Date) {\n          return r.key.getTime() === key.getTime();\n        }\n        return r.key === key;\n      });\n\n      if (idx === -1) {\n        result.push({\n          key,\n          data: []\n        });\n\n        idx = result.length - 1;\n      }\n\n      const categoryKey = category.key;\n      const y = point.data[categoryKey];\n      const [y0, y1] = point;\n\n      result[idx].data.push({\n        metadata: point.data.metadata,\n        key,\n        x: isVertical ? categoryKey : y1,\n        x0: isVertical ? categoryKey : y0,\n        x1: isVertical ? categoryKey : y1,\n        y: isVertical ? y : categoryKey,\n        y0: isVertical ? y0 : categoryKey,\n        y1: isVertical ? y1 : categoryKey,\n        value: point.data.formattedValues[categoryKey]\n      });\n    }\n  }\n\n  return result;\n}\n\n/**\n * Builds a stack dataset from the standard data format.\n */\nexport function buildBarStackData(\n  data: ChartNestedDataShape[] = [],\n  offset: StackTypes = 'default',\n  direction = 'vertical'\n) {\n  const keys = uniqueBy<ChartNestedDataShape>(\n    data,\n    (d) => d.data,\n    (d) => d.key\n  );\n  const stackData = transformDataToStack(data);\n\n  let stackFn = stack();\n  if (offset === 'expand') {\n    stackFn = stackFn.offset(stackOffsetExpand);\n  } else if (offset === 'diverging') {\n    stackFn = stackFn.offset(stackOffsetDiverging);\n  }\n\n  const result = stackFn.keys(keys)(stackData);\n\n  return transformStackToData(result, direction);\n}\n","import { ChartNestedDataShape, ChartInternalNestedDataShape } from './types';\nimport { buildBarStackData } from './barStack';\n\n/**\n * Builds a stack dataset from the standard data format.\n */\nexport function buildMarimekkoData(\n  data: ChartNestedDataShape[] = []\n): ChartInternalNestedDataShape[] {\n  const result = buildBarStackData(data, 'expand');\n  const sums = {};\n\n  // Calculate the sum for each series and the total sum\n  let totalSum = 0;\n  for (const series of result) {\n    const sum = series.data.reduce((acc, cur) => acc + (cur.y as number), 0);\n\n    sums[series.key as string] = sum;\n    totalSum += sum;\n  }\n\n  // Calculate the x0/x1 for each series\n  let prev = 0;\n  for (const series of result) {\n    const x0 = prev;\n    const x1 = prev + sums[series.key as string] / totalSum;\n    prev = x1;\n\n    for (const point of series.data) {\n      point.x0 = x0;\n      point.x1 = x1;\n    }\n  }\n\n  return result;\n}\n","import { stack, stackOffsetExpand } from 'd3-shape';\nimport {\n  ChartNestedDataShape,\n  ChartInternalDataShape,\n  ChartInternalNestedDataShape,\n  ChartInternalShallowDataShape\n} from './types';\nimport {\n  getMaxBigIntegerForNested,\n  normalizeValue,\n  normalizeValueForFormatting\n} from './bigInteger';\nimport { uniqueBy } from '../../common/utils/array';\n\n/**\n * Given a dataset like:\n *\n *   [{\n *    key: 'Threat Intel',\n *    data: [{ key:'2011', data: 25 }]\n *   }]\n *\n * it will transform it to:\n *\n *  [\n *    { x: '2011', 'Theat Intel': 25 }\n *  ]\n */\nfunction transformDataToStack(data) {\n  const result: any[] = [];\n  const maxBigInteger = getMaxBigIntegerForNested(data);\n\n  for (const category of data) {\n    for (const value of category.data) {\n      let idx = result.findIndex((r) => {\n        if (r.x instanceof Date && value.key instanceof Date) {\n          return r.x.getTime() === value.key.getTime();\n        }\n        return r.x === value.key;\n      });\n\n      if (idx === -1) {\n        result.push({\n          x: value.key,\n          formattedValues: {}\n        });\n\n        idx = result.length - 1;\n      }\n\n      result[idx][category.key as string] = normalizeValue(\n        value.data,\n        maxBigInteger\n      );\n      result[idx].formattedValues[\n        category.key as string\n      ] = normalizeValueForFormatting(value.data);\n    }\n  }\n\n  return result;\n}\n\n/**\n * Translates the stack data to a chart standard dataset.\n */\nfunction transformStackToData(stackData): ChartInternalNestedDataShape[] {\n  const result: ChartInternalNestedDataShape[] = [];\n\n  for (const category of stackData) {\n    const series: ChartInternalShallowDataShape[] = [];\n\n    for (const point of category) {\n      const [y0, y1] = point;\n      const x = point.data.x;\n      series.push({\n        key: category.key,\n        x,\n        x0: x,\n        x1: x,\n        y: y1 - y0,\n        y0,\n        y1,\n        value: point.data.formattedValues[category.key]\n      });\n    }\n\n    result.push({\n      key: category.key,\n      data: series\n    });\n  }\n\n  return result;\n}\n\n/**\n * Builds a stack dataset from the standard data format.\n */\nexport function buildStackData(\n  data: ChartNestedDataShape[],\n  normalized = false\n): ChartInternalDataShape[] {\n  const keys = uniqueBy<ChartNestedDataShape>(data, (d) => d.key);\n  const stackData = transformDataToStack(data);\n  const stackFn = !normalized ? stack() : stack().offset(stackOffsetExpand);\n\n  const result = stackFn.keys(keys)(stackData);\n\n  return transformStackToData(result);\n}\n","import { ChartShallowDataShape } from './types';\nimport { Direction, buildShallowChartData } from './builder';\n\nexport const buildWaterfall = (\n  series: ChartShallowDataShape[],\n  direction: Direction = 'vertical',\n  binSize: number | undefined = undefined\n) => {\n  const data = buildShallowChartData(series, direction, binSize);\n  const isVertical = direction === 'vertical';\n  const v = isVertical ? 'y' : 'x';\n\n  let cumulative = 0;\n  for (const point of data) {\n    point[`${v}0`] = cumulative;\n    cumulative += point[v] as number;\n    point[`${v}1`] = cumulative;\n    point[v] = cumulative;\n  }\n\n  return data;\n};\n","import React, { Component, PropsWithChildren, createRef } from 'react';\nimport { toggleTextSelection } from '../utils/selection';\nimport { smoothMatrix, transform, translate } from 'transformation-matrix';\nimport { constrainMatrix } from '../utils/position';\n\ninterface PanProps extends PropsWithChildren {\n  disabled: boolean;\n  threshold: number;\n  cursor?: string;\n  x: number;\n  y: number;\n  scale: number;\n  matrix: any;\n  width: number;\n  height: number;\n  constrain: boolean;\n  globalPanning: boolean;\n  onPanStart: (event: PanStartEvent) => void;\n  onPanMove: (event: PanMoveEvent) => void;\n  onPanEnd: (event: PanEndEvent) => void;\n  onPanCancel: (event: PanCancelEvent) => void;\n}\n\nexport interface PanStartEvent {\n  source: 'mouse' | 'touch';\n  nativeEvent: MouseEvent | TouchEvent;\n}\n\nexport interface PanMoveEvent {\n  source: 'mouse' | 'touch';\n  x: number;\n  y: number;\n  nativeEvent: MouseEvent | TouchEvent;\n}\n\nexport interface PanEndEvent {\n  source: 'mouse' | 'touch';\n  nativeEvent: MouseEvent | TouchEvent;\n}\n\nexport interface PanCancelEvent {\n  source: 'mouse' | 'touch';\n  nativeEvent: MouseEvent | TouchEvent;\n}\n\nexport class Pan extends Component<PanProps> {\n  static defaultProps: Partial<PanProps> = {\n    x: 0,\n    y: 0,\n    disabled: false,\n    scale: 1,\n    threshold: 10,\n    globalPanning: true,\n    onPanStart: () => undefined,\n    onPanMove: () => undefined,\n    onPanEnd: () => undefined,\n    onPanCancel: () => undefined\n  };\n\n  prevXPosition: number = 0;\n  prevYPosition: number = 0;\n  started: boolean = false;\n  deltaX: number = 0;\n  deltaY: number = 0;\n  childRef = createRef<SVGGElement>();\n\n  componentDidMount() {\n    if (this.childRef.current) {\n      this.childRef.current.addEventListener('mousedown', this.onMouseDown, {\n        passive: false\n      });\n      this.childRef.current.addEventListener('touchstart', this.onTouchStart, {\n        passive: false\n      });\n    }\n  }\n\n  componentWillUnmount() {\n    this.disposeHandlers();\n\n    if (this.childRef.current) {\n      this.childRef.current.removeEventListener('mousedown', this.onMouseDown);\n      this.childRef.current.removeEventListener(\n        'touchstart',\n        this.onTouchStart\n      );\n    }\n  }\n\n  disposeHandlers() {\n    window.removeEventListener('mousemove', this.onMouseMove);\n    window.removeEventListener('mouseup', this.onMouseUp);\n    window.removeEventListener('touchmove', this.onTouchMove);\n    window.removeEventListener('touchend', this.onTouchEnd);\n\n    // Reset cursor on body back to original\n    document.body.style['cursor'] = 'inherit';\n    toggleTextSelection(true);\n  }\n\n  checkThreshold() {\n    const { threshold } = this.props;\n    return (\n      !this.started &&\n      (Math.abs(this.deltaX) > threshold || Math.abs(this.deltaY) > threshold)\n    );\n  }\n\n  onPanStart(nativeEvent, source: 'mouse' | 'touch') {\n    this.props.onPanStart({\n      nativeEvent,\n      source\n    });\n  }\n\n  onPanMove(x: number, y: number, source: 'mouse' | 'touch', nativeEvent) {\n    this.props.onPanMove({\n      source,\n      nativeEvent,\n      x,\n      y\n    });\n  }\n\n  onPanEnd(nativeEvent, source: 'mouse' | 'touch') {\n    const { onPanEnd } = this.props;\n\n    onPanEnd({\n      nativeEvent,\n      source\n    });\n  }\n\n  pan(x: number, y: number, nativeEvent, source: 'mouse' | 'touch') {\n    const { scale, constrain, width, height, matrix } = this.props;\n\n    const newMatrix = smoothMatrix(\n      transform(matrix, translate(x / scale, y / scale)),\n      100\n    );\n\n    const shouldConstrain =\n      constrain && constrainMatrix(height, width, newMatrix);\n    if (!shouldConstrain) {\n      this.onPanMove(newMatrix.e, newMatrix.f, source, nativeEvent);\n    }\n\n    return shouldConstrain;\n  }\n\n  onMouseDown = (event: MouseEvent) => {\n    // Stop at disabled\n    if (this.props.disabled) {\n      return;\n    }\n\n    // Ignore right click\n    if (event.which === 3) {\n      return;\n    }\n\n    // If global panning is turned off, it will only pan on the container\n    if (\n      !this.props.globalPanning &&\n      event.target &&\n      !(event.target as HTMLElement).classList.contains('pan-container')\n    ) {\n      return;\n    }\n\n    event.preventDefault();\n    event.stopPropagation();\n\n    toggleTextSelection(false);\n    this.started = false;\n\n    // Always bind event so we cancel movement even if no action was taken\n    window.addEventListener('mousemove', this.onMouseMove);\n    window.addEventListener('mouseup', this.onMouseUp);\n  };\n\n  onMouseMove = (event: MouseEvent) => {\n    event.preventDefault();\n    event.stopPropagation();\n\n    this.deltaX = this.deltaX + event.movementX;\n    this.deltaY = this.deltaY + event.movementY;\n\n    if (this.checkThreshold()) {\n      if (this.props.cursor) {\n        document.body.style['cursor'] = this.props.cursor;\n      }\n\n      this.deltaX = 0;\n      this.deltaY = 0;\n      this.started = true;\n\n      this.onPanStart(event, 'mouse');\n    } else {\n      this.pan(event.movementX, event.movementY, event, 'mouse');\n    }\n  };\n\n  onMouseUp = (event: MouseEvent) => {\n    event.preventDefault();\n    event.stopPropagation();\n\n    this.disposeHandlers();\n    toggleTextSelection(true);\n\n    if (this.started) {\n      this.onPanEnd(event, 'mouse');\n    } else {\n      this.props.onPanCancel({\n        nativeEvent: event,\n        source: 'mouse'\n      });\n    }\n  };\n\n  onTouchStart = (event: TouchEvent) => {\n    // Stop at disabled\n    if (this.props.disabled) {\n      return;\n    }\n\n    // Reqquire more than one touch\n    if (event.touches.length !== 1) {\n      return;\n    }\n\n    event.preventDefault();\n    event.stopPropagation();\n\n    toggleTextSelection(false);\n    this.started = false;\n\n    this.prevXPosition = event.touches[0].clientX;\n    this.prevYPosition = event.touches[0].clientY;\n\n    // Always bind event so we cancel movement even if no action was taken\n    window.addEventListener('touchmove', this.onTouchMove);\n    window.addEventListener('touchend', this.onTouchEnd);\n  };\n\n  onTouchMove = (event: TouchEvent) => {\n    event.preventDefault();\n    event.stopPropagation();\n\n    // Calculate delta from previous position and current\n    const x = event.touches[0].clientX;\n    const y = event.touches[0].clientY;\n\n    const deltaX = x - this.prevXPosition;\n    const deltaY = y - this.prevYPosition;\n\n    this.deltaX = this.deltaX + deltaX;\n    this.deltaY = this.deltaY + deltaY;\n\n    if (this.checkThreshold()) {\n      this.deltaX = 0;\n      this.deltaY = 0;\n      this.started = true;\n\n      this.onPanStart(event, 'touch');\n    } else {\n      const contrained = this.pan(deltaX, deltaY, event, 'touch');\n\n      if (!contrained) {\n        this.prevXPosition = x;\n        this.prevYPosition = y;\n      }\n    }\n  };\n\n  onTouchEnd = (event: TouchEvent) => {\n    event.preventDefault();\n    event.stopPropagation();\n\n    this.disposeHandlers();\n    toggleTextSelection(true);\n\n    if (this.started) {\n      this.onPanEnd(event, 'touch');\n    } else {\n      this.props.onPanCancel({\n        nativeEvent: event,\n        source: 'touch'\n      });\n    }\n  };\n\n  render() {\n    return <g ref={this.childRef}>{this.props.children}</g>;\n  }\n}\n","/**\n * Gets the position between a given set of points.\n */\nexport const getMidpoint = (pointA, pointB) => ({\n  x: (pointA.x + pointB.x) / 2,\n  y: (pointA.y + pointB.y) / 2\n});\n\n/**\n * Gets the distance between a given set of points.\n */\nexport const getDistanceBetweenPoints = (pointA, pointB) =>\n  Math.sqrt(\n    Math.pow(pointB.y - pointA.y, 2) + Math.pow(pointB.x - pointA.x, 2)\n  );\n\n/**\n * Get touch points.\n */\nexport function getTouchPoints(event, node) {\n  const { left, top } = node.getBoundingClientRect();\n\n  const [pointA, pointB] = [...event.touches].map((touch) => ({\n    x: touch.clientX - Math.round(left),\n    y: touch.clientY - Math.round(top)\n  }));\n\n  const distance = getDistanceBetweenPoints(pointA, pointB);\n  const midpoint = getMidpoint(pointA, pointB);\n\n  return {\n    pointA,\n    pointB,\n    distance,\n    midpoint\n  };\n}\n","import React, { Component, PropsWithChildren, createRef } from 'react';\nimport { toggleTextSelection } from '../utils/selection';\nimport {\n  getPointFromMatrix,\n  isZoomLevelGoingOutOfBounds\n} from '../utils/position';\nimport { getTouchPoints } from './pinchUtils';\nimport {\n  scale,\n  smoothMatrix,\n  transform,\n  translate,\n  applyToPoint,\n  inverse\n} from 'transformation-matrix';\n\ninterface ZoomGestureProps extends PropsWithChildren {\n  disabled?: boolean;\n  maxZoom: number;\n  minZoom: number;\n  scaleFactor: number;\n  scale: number;\n  matrix: any;\n  x: number;\n  y: number;\n  style?: any;\n  disableMouseWheel?: boolean;\n  requireZoomModifier?: boolean;\n  onZoom: (event: ZoomEvent) => void;\n  onZoomEnd: () => void;\n}\n\nexport interface ZoomEvent {\n  scale: number;\n  x: number;\n  y: number;\n  nativeEvent: any;\n}\n\nexport class Zoom extends Component<ZoomGestureProps> {\n  static defaultProps: Partial<ZoomGestureProps> = {\n    x: 0,\n    y: 0,\n    scale: 1,\n    scaleFactor: 0.1,\n    minZoom: 1,\n    maxZoom: 10\n  };\n\n  firstTouch: any;\n  lastDistance: any;\n  timeout: any;\n  childRef = createRef<SVGGElement>();\n  rqf: any;\n\n  componentDidMount() {\n    const { disabled, disableMouseWheel } = this.props;\n\n    const ref = this.childRef.current;\n    if (!disabled && ref) {\n      if (!disableMouseWheel) {\n        ref.addEventListener('mousewheel', this.onMouseWheel, {\n          passive: false\n        });\n      }\n\n      ref.addEventListener('touchstart', this.onTouchStart, { passive: false });\n    }\n  }\n\n  componentWillUnmount() {\n    window.removeEventListener('touchmove', this.onTouchMove);\n    window.removeEventListener('touchend', this.onTouchEnd);\n    cancelAnimationFrame(this.rqf);\n    clearTimeout(this.timeout);\n\n    const ref = this.childRef.current;\n    if (ref) {\n      ref.removeEventListener('mousewheel', this.onMouseWheel);\n      ref.removeEventListener('touchstart', this.onTouchStart);\n    }\n\n    toggleTextSelection(true);\n  }\n\n  getStep(delta: number) {\n    const { scaleFactor } = this.props;\n    return -delta > 0 ? scaleFactor + 1 : 1 - scaleFactor;\n  }\n\n  scale(x: number, y: number, step: number, nativeEvent) {\n    const { minZoom, maxZoom, onZoom, matrix } = this.props;\n\n    const outside = isZoomLevelGoingOutOfBounds(\n      {\n        d: matrix.a,\n        scaleFactorMin: minZoom,\n        scaleFactorMax: maxZoom\n      },\n      step\n    );\n\n    if (!outside) {\n      const newMatrix = smoothMatrix(\n        transform(\n          matrix,\n          translate(x, y),\n          scale(step, step),\n          translate(-x, -y)\n        ),\n        100\n      );\n\n      this.rqf = requestAnimationFrame(() => {\n        onZoom({\n          scale: newMatrix.a,\n          x: newMatrix.e,\n          y: newMatrix.f,\n          nativeEvent\n        });\n      });\n    }\n\n    return outside;\n  }\n\n  onMouseWheel = (event) => {\n    const {\n      disableMouseWheel,\n      requireZoomModifier,\n      matrix,\n      onZoomEnd\n    } = this.props;\n\n    if (disableMouseWheel) {\n      return false;\n    }\n\n    const hasModifier = event.metaKey || event.ctrlKey;\n    if (requireZoomModifier && !hasModifier) {\n      return false;\n    }\n\n    event.preventDefault();\n    event.stopPropagation();\n\n    const point = getPointFromMatrix(event, matrix);\n    if (point) {\n      const { x, y } = point as { x: number; y: number };\n      const step = this.getStep(event.deltaY);\n\n      this.scale(x, y, step, event);\n\n      // Do small timeout to 'guess' when its done zooming\n      clearTimeout(this.timeout);\n      this.timeout = setTimeout(() => onZoomEnd(), 500);\n    }\n  };\n\n  onTouchStart = (event: TouchEvent) => {\n    if (event.touches.length === 2) {\n      event.preventDefault();\n      event.stopPropagation();\n      toggleTextSelection(false);\n\n      this.firstTouch = getTouchPoints(event, this.childRef.current);\n      this.lastDistance = this.firstTouch.distance;\n\n      window.addEventListener('touchmove', this.onTouchMove);\n      window.addEventListener('touchend', this.onTouchEnd);\n    }\n  };\n\n  onTouchMove = (event: TouchEvent) => {\n    if (event.touches.length === 2) {\n      event.preventDefault();\n      event.stopPropagation();\n\n      const { distance } = getTouchPoints(event, this.childRef.current);\n      const distanceFactor = distance / this.lastDistance;\n\n      const point = applyToPoint(inverse(this.props.matrix), {\n        x: this.firstTouch.midpoint.x,\n        y: this.firstTouch.midpoint.y\n      }) as { x: number; y: number };\n\n      if (point.x && point.y) {\n        const outside = this.scale(point.x, point.y, distanceFactor, event);\n\n        if (!outside) {\n          this.lastDistance = distance;\n        }\n      }\n    }\n  };\n\n  onTouchEnd = (event: TouchEvent) => {\n    event.preventDefault();\n    event.stopPropagation();\n\n    window.removeEventListener('touchmove', this.onTouchMove);\n    window.removeEventListener('touchend', this.onTouchEnd);\n\n    toggleTextSelection(true);\n    this.props.onZoomEnd();\n  };\n\n  render() {\n    const { style, children } = this.props;\n    return (\n      <g ref={this.childRef} style={style}>\n        {children}\n      </g>\n    );\n  }\n}\n","import React, { FC, ReactElement } from 'react';\nimport classNames from 'classnames';\nimport { CloneElement } from 'reablocks';\nimport {\n  DiscreteLegendEntryProps,\n  DiscreteLegendEntry\n} from './DiscreteLegendEntry';\nimport css from './DiscreteLegend.module.css';\n\nexport interface DiscreteLegendProps {\n  /**\n   * CSS Class name.\n   */\n  className?: string;\n\n  /**\n   * CSS Styles.\n   */\n  style?: React.CSSProperties;\n\n  /**\n   * Orientation of the legend.\n   */\n  orientation?: 'horizontal' | 'vertical';\n\n  /**\n   * Entry components to show in the legend.\n   */\n  entries: ReactElement<DiscreteLegendEntryProps, typeof DiscreteLegendEntry>[];\n}\n\nexport const DiscreteLegend: FC<Partial<DiscreteLegendProps>> = ({\n  entries,\n  orientation,\n  style,\n  className\n}) => (\n  <div\n    className={classNames(css.container, className, {\n      [css.horizontal]: orientation === 'horizontal',\n      [css.vertical]: orientation === 'vertical'\n    })}\n    style={style}\n  >\n    {entries.map((entry, index) => (\n      <CloneElement<DiscreteLegendEntryProps>\n        element={entry}\n        key={`dle-${index}`}\n        orientation={orientation}\n      />\n    ))}\n  </div>\n);\n\nDiscreteLegend.defaultProps = {\n  orientation: 'vertical'\n};\n","import React, { FC } from 'react';\nimport classNames from 'classnames';\nimport css from './DiscreteLegendSymbol.module.css';\n\nexport interface DiscreteLegendSymbolProps {\n  /**\n   * Color for the symbol set by the `DiscreteLegendEntry`.\n   */\n  color: string;\n\n  /**\n   * CSS Class names.\n   */\n  className?: string;\n}\n\nexport const DiscreteLegendSymbol: FC<Partial<DiscreteLegendSymbolProps>> = ({\n  className,\n  color\n}) => (\n  <div\n    className={classNames(css.symbol, className)}\n    style={{ background: color }}\n  />\n);\n","import React, { ReactNode, ReactElement, FC } from 'react';\nimport classNames from 'classnames';\nimport {\n  DiscreteLegendSymbol,\n  DiscreteLegendSymbolProps\n} from './DiscreteLegendSymbol';\nimport { CloneElement } from 'reablocks';\nimport css from './DiscreteLegendEntry.module.css';\n\nexport interface DiscreteLegendEntryProps {\n  /**\n   * Label for the entry.\n   */\n  label: string;\n\n  /**\n   * Color for the entry.\n   */\n  color: string;\n\n  /**\n   * Symbol for the entry.\n   */\n  symbol:\n    | ReactElement<DiscreteLegendSymbolProps, typeof DiscreteLegendSymbol>\n    | ReactNode;\n\n  /**\n   * CSS Styles.\n   */\n  style?: React.CSSProperties;\n\n  /**\n   * CSS Class names.\n   */\n  className?: string;\n\n  /**\n   * HTML Title Attribute.\n   */\n  title?: string;\n\n  /**\n   * Orientation of the entry set internally by `DiscreteLegend`.\n   */\n  orientation: 'horizontal' | 'vertical';\n\n  /**\n   * Mouse enter event.\n   */\n  onMouseEnter: (event: React.MouseEvent<HTMLDivElement>) => void;\n\n  /**\n   * Mouse leave event.\n   */\n  onMouseLeave: (event: React.MouseEvent<HTMLDivElement>) => void;\n\n  /**\n   * On click event.\n   */\n  onClick: (event: React.MouseEvent<HTMLDivElement>) => void;\n}\n\nexport const DiscreteLegendEntry: FC<Partial<DiscreteLegendEntryProps>> = ({\n  label,\n  symbol,\n  title,\n  className,\n  color,\n  style,\n  orientation,\n  onMouseEnter,\n  onMouseLeave,\n  onClick\n}) => (\n  <div\n    title={title}\n    className={classNames(css.entry, className, {\n      [css.vertical]: orientation === 'vertical',\n      [css.horizontal]: orientation === 'horizontal'\n    })}\n    onClick={onClick}\n    onMouseEnter={onMouseEnter}\n    onMouseLeave={onMouseLeave}\n    style={style}\n  >\n    <CloneElement<DiscreteLegendSymbolProps> element={symbol} color={color} />\n    <span className={css.label}>{label}</span>\n  </div>\n);\n\nDiscreteLegendEntry.defaultProps = {\n  symbol: <DiscreteLegendSymbol />,\n  orientation: 'horizontal'\n};\n","import React, { FC, useMemo } from 'react';\nimport classNames from 'classnames';\nimport { ChartDataShape } from '../../../common/data';\nimport chroma from 'chroma-js';\nimport { uniqueBy } from '../../../common/utils/array';\nimport { extent } from 'd3-array';\nimport { formatValue } from '../../utils/formatting';\n\nimport css from './SequentialLegend.module.css';\n\nexport interface SequentialLegendProps {\n  /**\n   * CSS Class name.\n   */\n  className?: any;\n\n  /**\n   * CSS Class name for the gradient element.\n   */\n  gradientClassName?: string;\n\n  /**\n   * CSS Styles.\n   */\n  style?: any;\n\n  /**\n   * Orientation of the legend.\n   */\n  orientation?: 'horizontal' | 'vertical';\n\n  /**\n   * Data to use to render the scale.\n   */\n  data: ChartDataShape[];\n\n  /**\n   * Color scheme for the scale.\n   */\n  colorScheme?: string[];\n}\n\nexport const SequentialLegend: FC<SequentialLegendProps> = ({\n  className,\n  gradientClassName,\n  style,\n  data,\n  colorScheme = ['rgba(28, 107, 86, 0.5)', '#2da283'],\n  orientation = 'orientation'\n}) => {\n  // Generate the color gradient\n  const color = chroma\n    .scale(colorScheme)\n    .colors(10)\n    .reverse()\n    .map((c, i) => `${c} ${i * 10}%`)\n    .join(',');\n\n  // Get the extent from the data passed\n  const [end, start] = useMemo(\n    () =>\n      extent(\n        uniqueBy(\n          data,\n          (d) => d.data,\n          (d) => d.data\n        )\n      ),\n    [data]\n  );\n\n  // Get direction\n  const gradientDir = orientation === 'vertical' ? '' : 'to left,';\n\n  return (\n    <div\n      style={style}\n      className={classNames(css.container, className, {\n        [css.vertical]: orientation === 'vertical',\n        [css.horizontal]: orientation === 'horizontal'\n      })}\n    >\n      <div className={css.start}>{formatValue(start)}</div>\n      <div\n        className={classNames(css.gradient, gradientClassName)}\n        style={{\n          background: `linear-gradient(${gradientDir}${color})`\n        }}\n      />\n      <div className={css.end}>{formatValue(end)}</div>\n    </div>\n  );\n};\n\nSequentialLegend.defaultProps = {\n  colorScheme: ['rgba(28, 107, 86, 0.5)', '#2da283'],\n  orientation: 'vertical'\n};\n","import classNames from 'classnames';\nimport React, { FC, useMemo } from 'react';\nimport css from './Gridline.module.css';\n\nexport interface GridlineProps {\n  /**\n   * Height of the line set by the `GridlineSeries`.\n   */\n  height: number;\n\n  /**\n   * Width of the line set by the `GridlineSeries`.\n   */\n  width: number;\n\n  /**\n   * CSS Classname to apply.\n   */\n  className?: string;\n\n  /**\n   * Direction set by the `GridlineSeries`.\n   */\n  direction: 'all' | 'x' | 'y';\n\n  /**\n   * D3 Scale set by `GridlineSeries`.\n   */\n  scale: any;\n\n  /**\n   * SVG Stroke Width Property.\n   */\n  strokeWidth: number;\n\n  /**\n   * SVG Stroke Color Property.\n   */\n  strokeColor: string;\n\n  /**\n   * Data point for the position set by the `GridlineSeries`.\n   */\n  data: number;\n\n  /**\n   * Index set by the `GridlineSeries`.\n   */\n  index: number;\n\n  /**\n   * SVG Stroke Dash Array Property.\n   */\n  strokeDasharray: string;\n}\n\nexport const Gridline: FC<Partial<GridlineProps>> = ({\n  strokeWidth,\n  direction,\n  className,\n  strokeColor,\n  data,\n  height,\n  width,\n  scale,\n  strokeDasharray\n}) => {\n  const coords = useMemo(() => {\n    const pos = scale(data);\n\n    if (direction === 'x') {\n      return {\n        x1: pos,\n        x2: pos,\n        y1: 0,\n        y2: height\n      };\n    } else {\n      return {\n        y1: pos,\n        y2: pos,\n        x1: 0,\n        x2: width\n      };\n    }\n  }, [direction, data, height, width, scale]);\n\n  return (\n    <line\n      {...coords}\n      className={classNames(css.gridLine, className)}\n      strokeDasharray={strokeDasharray}\n      strokeWidth={strokeWidth}\n      stroke={strokeColor}\n      fill=\"none\"\n    />\n  );\n};\n\nGridline.defaultProps = {\n  strokeWidth: 1,\n  strokeDasharray: '2 5',\n  direction: 'all',\n  strokeColor: 'rgba(153, 153, 153, 0.5)'\n};\n","import React, { Fragment, ReactElement, FC, useMemo, useCallback } from 'react';\nimport { Gridline, GridlineProps } from './Gridline';\nimport { getTicks, getMaxTicks } from '../utils/ticks';\nimport { CloneElement } from 'reablocks';\nimport { LinearAxisProps } from '../Axis';\nimport { GridStripeProps, GridStripe } from './GridStripe';\n\ntype GridLineElement = ReactElement<GridlineProps, typeof Gridline>;\ntype GridStripeElement = ReactElement<GridStripeProps, typeof GridStripe>;\ntype GridElement = GridLineElement | GridStripeElement;\n\nexport interface GridlineSeriesProps {\n  /**\n   * D3 scale for Y Axis.\n   */\n  yScale: any;\n\n  /**\n   * D3 scale for X Axis.\n   */\n  xScale: any;\n\n  /**\n   * The linear axis component for the Y Axis of the chart.\n   */\n  yAxis: LinearAxisProps;\n\n  /**\n   * The linear axis component for the X Axis of the chart.\n   */\n  xAxis: LinearAxisProps;\n\n  /**\n   * Height of the chart.\n   */\n  height: number;\n\n  /**\n   * Width of the chart.\n   */\n  width: number;\n\n  /**\n   * Gridline that is rendered.\n   */\n  line: GridLineElement | null;\n\n  /**\n   * GridStripe that is rendered.\n   */\n  stripe: GridStripeElement | null;\n}\n\nexport const GridlineSeries: FC<Partial<GridlineSeriesProps>> = ({\n  line,\n  stripe,\n  yScale,\n  xScale,\n  yAxis,\n  xAxis,\n  height,\n  width\n}) => {\n  const shouldRenderY = (direction: 'all' | 'x' | 'y') =>\n    direction === 'all' || direction === 'y';\n  const shouldRenderX = (direction: 'all' | 'x' | 'y') =>\n    direction === 'all' || direction === 'x';\n\n  const { yAxisGrid, xAxisGrid } = useMemo(() => {\n    return {\n      yAxisGrid: getTicks(\n        yScale,\n        yAxis.tickSeries.props.tickValues,\n        yAxis.type,\n        getMaxTicks(yAxis.tickSeries.props.tickSize, height),\n        yAxis.tickSeries.props.interval\n      ),\n      xAxisGrid: getTicks(\n        xScale,\n        xAxis.tickSeries.props.tickValues,\n        xAxis.type,\n        getMaxTicks(xAxis.tickSeries.props.tickSize, width),\n        xAxis.tickSeries.props.interval\n      )\n    };\n  }, [height, width, xAxis, yAxis, yScale, xScale]);\n\n  const renderGroup = useCallback(\n    (\n      element: GridElement,\n      grid,\n      scale,\n      direction: 'x' | 'y',\n      type: 'line' | 'stripe'\n    ) => {\n      return grid.map((point, index) => (\n        <Fragment key={`${type}-${direction}-${index}`}>\n          <CloneElement<GridlineProps | GridStripeProps>\n            element={element}\n            index={index}\n            scale={scale}\n            data={point}\n            height={height}\n            width={width}\n            direction={direction}\n          />\n        </Fragment>\n      ));\n    },\n    [height, width]\n  );\n\n  const renderSeries = useCallback(\n    (yAxisGrid, xAxisGrid, element: GridElement, type: 'line' | 'stripe') => {\n      return (\n        <Fragment>\n          {shouldRenderY(element.props.direction) &&\n            renderGroup(element, yAxisGrid, yScale, 'y', type)}\n          {shouldRenderX(element.props.direction) &&\n            renderGroup(element, xAxisGrid, xScale, 'x', type)}\n        </Fragment>\n      );\n    },\n    [renderGroup, xScale, yScale]\n  );\n\n  return (\n    <g style={{ pointerEvents: 'none' }}>\n      {line && renderSeries(yAxisGrid, xAxisGrid, line, 'line')}\n      {stripe && renderSeries(yAxisGrid, xAxisGrid, stripe, 'stripe')}\n    </g>\n  );\n};\n\nGridlineSeries.defaultProps = {\n  line: <Gridline direction=\"all\" />,\n  stripe: null\n};\n","import classNames from 'classnames';\nimport React, { FC, useMemo } from 'react';\nimport css from './GridStripe.module.css';\n\nexport interface GridStripeProps {\n  /**\n   * Position set by the `GridlineSeries`.\n   */\n  position: 'horizontal' | 'vertical';\n\n  /**\n   * CSS Classname to apply.\n   */\n  className?: string;\n\n  /**\n   * Stripe fill color.\n   */\n  fill: string;\n\n  /**\n   * Height of the line set by the `GridlineSeries`.\n   */\n  height: number;\n\n  /**\n   * Width of the line set by the `GridlineSeries`.\n   */\n  width: number;\n\n  /**\n   * Direction set by the `GridlineSeries`.\n   */\n  direction: 'all' | 'x' | 'y';\n\n  /**\n   * D3 Scale set by `GridlineSeries`.\n   */\n  scale: any;\n\n  /**\n   * Data point for the position set by the `GridlineSeries`.\n   */\n  data: number;\n\n  /**\n   * Index set by the `GridlineSeries`.\n   */\n  index: number;\n}\n\nexport const GridStripe: FC<Partial<GridStripeProps>> = ({\n  fill,\n  className,\n  position,\n  data,\n  height,\n  width,\n  scale,\n  index\n}) => {\n  const coords = useMemo(() => {\n    const pos = scale(data);\n    const stripeFill = index % 2 ? 'none' : fill;\n    const dim = scale.bandwidth();\n\n    if (position === 'vertical') {\n      return {\n        y: 0,\n        x: pos,\n        height: height,\n        width: dim,\n        fill: stripeFill\n      };\n    } else {\n      return {\n        y: pos,\n        x: 0,\n        height: dim,\n        width,\n        fill: stripeFill\n      };\n    }\n  }, [scale, data, index, height, width, fill, position]);\n\n  return <rect className={classNames(css.gridStripe, className)} {...coords} />;\n};\n\nGridStripe.defaultProps = {\n  fill: '#393c3e'\n};\n","import React, { FC } from 'react';\nimport css from './MarkLine.module.css';\n\nexport interface MarkLineProps {\n  height: number;\n  pointX?: number;\n  strokeColor: string;\n  strokeWidth: number;\n}\n\nexport const MarkLine: FC<Partial<MarkLineProps>> = ({\n  pointX,\n  height,\n  strokeWidth = 1,\n  strokeColor = '#eee'\n}) => (\n  <line\n    stroke={strokeColor}\n    strokeWidth={strokeWidth}\n    y1=\"0\"\n    vectorEffect=\"non-scaling-stroke\"\n    y2={height}\n    x1={pointX}\n    x2={pointX}\n    className={css.markLine}\n  />\n);\n","import React, { FC } from 'react';\n\nexport interface GradientStopProps {\n  offset: number | string;\n  stopOpacity: number | string;\n  color?: string;\n}\n\nexport const GradientStop: FC<Partial<GradientStopProps>> = ({\n  color,\n  offset,\n  stopOpacity = 1\n}) => <stop offset={offset} stopOpacity={stopOpacity} stopColor={color} />;\n","import React, { FC, ReactElement } from 'react';\nimport { GradientStop, GradientStopProps } from './GradientStop';\nimport { CloneElement } from 'reablocks';\n\nexport interface GradientProps {\n  id: string;\n  stops: ReactElement<GradientStopProps, typeof GradientStop>[];\n  color?: string;\n  direction: 'vertical' | 'horizontal' | 'radial';\n}\n\nexport const Gradient: FC<Partial<GradientProps>> = ({\n  id,\n  color,\n  direction,\n  stops\n}) => {\n  if (direction === 'radial') {\n    return (\n      <radialGradient id={id}>\n        {stops.map((stop, index) => (\n          <CloneElement<GradientStopProps>\n            element={stop}\n            key={`gradient-${index}`}\n            color={stop.props.color || color}\n          />\n        ))}\n      </radialGradient>\n    );\n  }\n\n  const pos =\n    direction === 'vertical'\n      ? {\n        x1: '10%',\n        x2: '10%',\n        y1: '100%',\n        y2: '0%'\n      }\n      : {\n        y1: '0%',\n        y2: '0%',\n        x1: '0%',\n        x2: '100%'\n      };\n\n  return (\n    <linearGradient spreadMethod=\"pad\" id={id} {...pos}>\n      {stops.map((stop, index) => (\n        <CloneElement<GradientStopProps>\n          element={stop}\n          key={`gradient-${index}`}\n          color={stop.props.color || color}\n        />\n      ))}\n    </linearGradient>\n  );\n};\n\nGradient.defaultProps = {\n  direction: 'vertical',\n  stops: [\n    <GradientStop offset=\"0%\" stopOpacity={0.3} key=\"start\" />,\n    <GradientStop offset=\"80%\" stopOpacity={1} key=\"stop\" />\n  ]\n};\n","import React, { FC, ReactElement } from 'react';\nimport { GradientStop, GradientStopProps } from './GradientStop';\nimport { CloneElement } from 'reablocks';\n\nexport interface RadialGradientProps {\n  id: string;\n  stops: ReactElement<GradientStopProps, typeof GradientStop>[];\n  color?: string;\n  radius: number | string;\n}\n\nexport const RadialGradient: FC<Partial<RadialGradientProps>> = ({\n  id,\n  color,\n  radius = '30%',\n  stops = [\n    <GradientStop offset=\"0%\" stopOpacity={0.2} key=\"start\" />,\n    <GradientStop offset=\"80%\" stopOpacity={0.7} key=\"stop\" />\n  ]\n}) => (\n  <radialGradient\n    id={id}\n    cx={0}\n    cy={0}\n    r={radius}\n    gradientUnits=\"userSpaceOnUse\"\n  >\n    {stops.map((stop, index) => (\n      <CloneElement<GradientStopProps>\n        element={stop}\n        key={`gradient-${index}`}\n        color={color}\n      />\n    ))}\n  </radialGradient>\n);\n","import React, { FC } from 'react';\n\nexport interface MaskProps {\n  id?: string;\n  fill?: string;\n}\n\nexport const Mask: FC<MaskProps> = ({ id, fill }) => (\n  <mask id={id}>\n    <rect x=\"0\" y=\"0\" width=\"100%\" height=\"100%\" fill={fill} />\n  </mask>\n);\n","import React, { FC } from 'react';\nimport { MaskProps } from './Mask';\n\nexport interface StripesProps extends MaskProps {\n  id?: string;\n  fill?: string;\n}\n\nexport const Stripes: FC<StripesProps> = ({ id, fill }) => (\n  <pattern\n    id={id}\n    width=\"4\"\n    height=\"4\"\n    patternUnits=\"userSpaceOnUse\"\n    patternTransform=\"rotate(45)\"\n  >\n    <rect className=\"area-stripe\" width=\"1\" height=\"4\" fill={fill} />\n  </pattern>\n);\n","import React, { Fragment, FC } from 'react';\nimport { formatValue } from '../utils/formatting';\nimport { ChartInternalDataTypes } from '../data';\nimport css from './TooltipTemplate.module.css';\n\ninterface SingleTooltipValue {\n  key?: ChartInternalDataTypes;\n  value?: ChartInternalDataTypes;\n  x: ChartInternalDataTypes;\n  y: ChartInternalDataTypes;\n}\n\ninterface MultipleTooltipValues {\n  x: ChartInternalDataTypes;\n  data: SingleTooltipValue[];\n}\n\ninterface TooltipTemplateProps {\n  /**\n   * Tooltip data value.\n   */\n  value?: SingleTooltipValue | MultipleTooltipValues;\n\n  /**\n   * Color scheme to apply.\n   */\n  color?: any;\n\n  /**\n   * Additional CSS classes to apply.\n   */\n  className?: any;\n}\n\nexport const TooltipTemplate: FC<TooltipTemplateProps> = ({\n  value,\n  color,\n  className\n}) => {\n  if (!value) {\n    return null;\n  }\n\n  const renderValues = (data: SingleTooltipValue, index: number) => {\n    const fill = color(data, index);\n\n    return (\n      <span className={css.subValue}>\n        <span className={css.subValueColor} style={{ backgroundColor: fill }} />\n        <span className={css.subValueName}>\n          {formatValue(data.key || data.x)}:\n        </span>\n        <span>{formatValue(data.value || data.y)}</span>\n      </span>\n    );\n  };\n\n  const renderMultiple = (value: MultipleTooltipValues) => {\n    const excessCount = value.data.length - 15;\n    const pagedValues = value.data.slice(0, 15);\n\n    return (\n      <Fragment>\n        {pagedValues.map((point, i) => (\n          <Fragment key={i}>{renderValues(point, i)}</Fragment>\n        ))}\n        {excessCount > 0 && <div>...{excessCount} more...</div>}\n      </Fragment>\n    );\n  };\n\n  const isMultiple = Array.isArray((value as any).data);\n\n  return (\n    <div className={className} role=\"tooltip\">\n      <div className={css.label}>{formatValue(value!.x)}</div>\n      <div className={css.value}>\n        {isMultiple && renderMultiple(value as MultipleTooltipValues)}\n        {!isMultiple && (\n          <Fragment>\n            {formatValue(\n              (value as SingleTooltipValue).value ||\n                (value as SingleTooltipValue).y\n            )}\n          </Fragment>\n        )}\n      </div>\n    </div>\n  );\n};\n","import { TooltipTheme } from 'reablocks';\n\nimport css from './Tooltip.module.css';\n\nexport const tooltipTheme: TooltipTheme = {\n  base: css.base,\n  disablePointer: css.disablePointer\n};\n","import React, { cloneElement, FC } from 'react';\nimport { Tooltip, TooltipProps } from 'reablocks';\nimport { TooltipTemplate } from './TooltipTemplate';\nimport { tooltipTheme } from './TooltipTheme';\n\nexport interface ChartTooltipProps extends TooltipProps {\n  /**\n   * Content for the tooltip.\n   */\n  content: any;\n\n  /**\n   * Tooltip data value.\n   */\n  value?: any;\n\n  /**\n   * Color scheme to apply.\n   */\n  color?: any;\n\n  /**\n   * Complete dataset.\n   */\n  data: any;\n\n  /**\n   * Whether the tooltip should move with the cursor or not.\n   */\n  followCursor?: boolean;\n}\n\nexport const ChartTooltip: FC<Partial<ChartTooltipProps>> = ({\n  content,\n  value,\n  data,\n  color,\n  ...rest\n}) => (\n  <Tooltip\n    theme={tooltipTheme}\n    {...rest}\n    content={() => {\n      if (!value && !data) {\n        return null;\n      }\n\n      return typeof content === 'function'\n        ? content(data || value, color)\n        : cloneElement(content, {\n          ...content.props,\n          value,\n          color\n        });\n    }}\n  />\n);\n\nChartTooltip.defaultProps = {\n  content: <TooltipTemplate />\n};\n","import React, {\n  Fragment,\n  ReactElement,\n  useState,\n  useRef,\n  useCallback,\n  useMemo,\n  forwardRef,\n  useImperativeHandle\n} from 'react';\nimport { TooltipAreaEvent } from './TooltipAreaEvent';\nimport {\n  ChartDataTypes,\n  ChartInternalDataShape,\n  ChartInternalShallowDataShape,\n  ChartInternalNestedDataShape\n} from '../data';\nimport {\n  getPositionForTarget,\n  getClosestContinousScalePoint,\n  getClosestBandScalePoint\n} from '../utils/position';\nimport { CloneElement, Placement } from 'reablocks';\nimport { ChartTooltip, ChartTooltipProps } from './ChartTooltip';\nimport { arc } from 'd3-shape';\nimport isEqual from 'react-fast-compare';\nimport { scaleLinear } from 'd3-scale';\n\nexport interface TooltipAreaProps {\n  /**\n   * Popperjs placement.\n   */\n  placement: Placement;\n\n  /**\n   * Chart height. Set internally.\n   */\n  height: number;\n\n  /**\n   * Chart width. Set internally.\n   */\n  width: number;\n\n  /**\n   * Chart D3 XScale. Set internally.\n   */\n  xScale: any;\n\n  /**\n   * Chart D3 YScale. Set internally.\n   */\n  yScale: any;\n\n  /**\n   * Whether the tooltip is disabled or not.\n   */\n  disabled: boolean;\n\n  /**\n   * Color setter.\n   */\n  color: any;\n\n  /**\n   * Chart internal data type.\n   */\n  data: ChartInternalDataShape[];\n\n  /**\n   * Child elements to be contained by.\n   */\n  children?: any;\n\n  /**\n   * Whether the area is radial or not.\n   */\n  isRadial?: boolean;\n\n  /**\n   * Whether the area is continous or not (e.g. line and area charts are continous, bar charts are not).\n   */\n  isContinous?: boolean;\n\n  /**\n   * Inner-radius to set the positioning by. Set internally.\n   */\n  innerRadius?: number;\n\n  /**\n   * Outer-radius to set the positioning by. Set internally.\n   */\n  outerRadius?: number;\n\n  /**\n   * Tooltip element.\n   */\n  tooltip: ReactElement<ChartTooltipProps, typeof ChartTooltip>;\n\n  /**\n   * Whether to inverse the data or not.\n   */\n  inverse: boolean;\n\n  /**\n   * When pointer entered mouse area.\n   */\n  onValueEnter: (event: TooltipAreaEvent) => void;\n\n  /**\n   * When pointer left mouse area.\n   */\n  onValueLeave: () => void;\n\n  /**\n   * Whether the layout is horizontal or not.\n   */\n  isHorizontal: boolean;\n\n  /**\n   * Start angle for the first value.\n   */\n  startAngle?: number;\n\n  /**\n   * End angle for the last value.\n   */\n  endAngle?: number;\n}\n\ninterface TooltipDataShape {\n  x?: ChartDataTypes;\n  y?: ChartDataTypes;\n  data?: ChartDataTypes | Array<ChartDataTypes | ChartInternalShallowDataShape>;\n  i?: number;\n}\n\n// eslint-disable-next-line react/display-name\nexport const TooltipArea = forwardRef<any, Partial<TooltipAreaProps>>(\n  (\n    {\n      children,\n      inverse,\n      tooltip,\n      disabled,\n      color,\n      isRadial,\n      isContinous,\n      width,\n      height,\n      xScale,\n      yScale,\n      onValueEnter,\n      data,\n      isHorizontal,\n      innerRadius,\n      outerRadius,\n      placement: placementProp,\n      onValueLeave,\n      startAngle,\n      endAngle\n    },\n    childRef\n  ) => {\n    const [visible, setVisible] = useState<boolean>();\n    const [placement, setPlacement] = useState<Placement>();\n    const [value, setValue] = useState<any>();\n    const [offsetX, setOffsetX] = useState<any>();\n    const [offsetY, setOffsetY] = useState<any>();\n    const [prevX, setPrevX] = useState<number>();\n    const [prevY, setPrevY] = useState<number>();\n    const ref = useRef<SVGRectElement | SVGPathElement | any>();\n    const fullCircleref = useRef<SVGRectElement | SVGPathElement | any>(null);\n    const isFullCircle = Math.abs(endAngle - startAngle) >= 2 * Math.PI;\n\n    const range = Math.abs(endAngle - startAngle);\n\n    const rotationFactor = 0.5;\n\n    const getXCoord = useCallback(\n      (x: number, y: number) => {\n        // If the shape is radial, we need to convert the X coords to a radial format.\n        if (isRadial) {\n          const outerRadiusNew = outerRadius || Math.min(width, height) / 2;\n          let rad =\n            Math.atan2(y - outerRadiusNew, x - outerRadiusNew) +\n            rotationFactor * Math.PI;\n\n          // Align it with the expected start angle\n          rad = (rad - startAngle) % (2 * Math.PI);\n\n          // TODO: Figure out what the 'correct' way to do this is...\n          if (rad < 0) {\n            rad += Math.PI * 2;\n          }\n\n          // convert to given range\n          const scale = scaleLinear()\n            .domain([0, range])\n            .range([startAngle, endAngle]);\n          rad = scale(rad);\n\n          return rad;\n        }\n\n        return x;\n      },\n      [endAngle, height, isRadial, outerRadius, range, startAngle, width]\n    );\n\n    const transformData = useCallback(\n      (series: ChartInternalDataShape[]) => {\n        const result: TooltipDataShape[] = [];\n\n        if (inverse) {\n          for (const point of series) {\n            const seriesPoint = point as ChartInternalNestedDataShape;\n            if (Array.isArray(seriesPoint.data)) {\n              for (const nestedPoint of seriesPoint.data) {\n                const right = nestedPoint.x;\n                let idx = result.findIndex((r) => {\n                  const left = r.x;\n                  if (left instanceof Date && right instanceof Date) {\n                    return left.getTime() === right.getTime();\n                  }\n                  return left === right;\n                });\n\n                if (idx === -1) {\n                  result.push({\n                    x: nestedPoint.x,\n                    data: []\n                  });\n\n                  idx = result.length - 1;\n                }\n\n                const data = result[idx].data;\n\n                if (Array.isArray(data)) {\n                  data.push(nestedPoint);\n                }\n              }\n            } else {\n              result.push(point);\n            }\n          }\n        } else {\n          for (const point of series) {\n            const nestedPoint = point as ChartInternalNestedDataShape;\n            if (Array.isArray(nestedPoint.data)) {\n              result.push({\n                ...nestedPoint,\n                x: nestedPoint.key,\n                data: nestedPoint.data.map((d) => ({\n                  ...d,\n                  key: !isHorizontal ? d.x : d.y,\n                  value: !isHorizontal ? d.y : d.x\n                }))\n              });\n            } else {\n              const shallowPoint = point as ChartInternalShallowDataShape;\n              result.push({\n                ...shallowPoint,\n                // Histograms special logic...\n                x: shallowPoint.key === undefined ? shallowPoint.x0 : point.key,\n                y:\n                  shallowPoint.value === undefined\n                    ? shallowPoint.y\n                    : shallowPoint.value\n              });\n            }\n          }\n        }\n\n        return result;\n      },\n      [inverse, isHorizontal]\n    );\n\n    const onMouseMove = useCallback(\n      (event: React.MouseEvent) => {\n        const transformed = transformData(data);\n\n        // Get our default placement\n        let newPlacement = placementProp;\n        if (!placementProp) {\n          if (isHorizontal) {\n            newPlacement = 'right';\n          } else {\n            newPlacement = 'top';\n          }\n        }\n\n        // Get the path container element\n        // Note that we are using the dummy 'full' circle for alignment\n        let target = fullCircleref.current || ref.current;\n\n        const { y, x } = getPositionForTarget({\n          target: target,\n          // Manually pass the x/y from the event\n          clientX: event.clientX,\n          clientY: event.clientY\n        });\n\n        // Need to flip scales/coords if we are a horz layout\n        let keyScale;\n        let valueScale;\n        let coord;\n        let attr = 'x';\n        if (isHorizontal) {\n          keyScale = yScale;\n          valueScale = xScale;\n          coord = y;\n        } else {\n          coord = getXCoord(x, y);\n          keyScale = xScale;\n          valueScale = yScale;\n        }\n\n        // If an index value exists in the data, use that to grab closest point\n        if (typeof transformed[0].i === 'number') {\n          attr = 'i';\n        }\n\n        // Get the closest point to the mouse\n        // Consider invertable scales to be continous\n        // Round non-continous charts with a continous scale down\n        // Round band scales to the closest point for radial charts\n        const newValue = keyScale.invert\n          ? getClosestContinousScalePoint({\n            pos: coord,\n            scale: keyScale,\n            data: transformed,\n            attr,\n            roundDown: !isContinous\n          })\n          : getClosestBandScalePoint({\n            pos: coord,\n            scale: keyScale,\n            data: transformed,\n            attr,\n            roundClosest: isRadial\n          });\n\n        if (!isEqual(newValue, value) && newValue) {\n          const pointX = keyScale(newValue.x);\n          let pointY = valueScale(newValue.y);\n          let marginX = 0;\n          let marginY = 0;\n\n          if (isNaN(pointY)) {\n            pointY = height / 2;\n            marginX = 10;\n            if (!placement) {\n              newPlacement = 'right';\n            }\n          } else {\n            marginY = -10;\n          }\n\n          // If the points didn't change, don't trigger an update\n          if (pointX === prevX && pointY === prevY) {\n            return;\n          }\n\n          setPrevX(pointX);\n          setPrevY(pointY);\n\n          const target = event.target as SVGRectElement;\n          const { top, left } = target.getBoundingClientRect();\n\n          let offsetX = 0;\n          let offsetY = 0;\n\n          if (isRadial) {\n            // If its radial, we need to convert the coords to radial format\n            const outerRadius = Math.min(width, height) / 2;\n            offsetX =\n              pointY * Math.cos(pointX - rotationFactor * Math.PI) +\n              outerRadius;\n            offsetY =\n              pointY * Math.sin(pointX - rotationFactor * Math.PI) +\n              outerRadius;\n          } else {\n            offsetX = pointX;\n            offsetY = pointY;\n          }\n\n          offsetX += left + marginX;\n          offsetY += top + marginY;\n\n          setPlacement(newPlacement);\n          setVisible(true);\n          setValue(newValue);\n          setOffsetX(offsetX);\n          setOffsetY(offsetY);\n\n          onValueEnter({\n            visible: true,\n            value: newValue,\n            pointY,\n            pointX,\n            offsetX,\n            offsetY,\n            nativeEvent: event\n          });\n        }\n      },\n      [\n        data,\n        getXCoord,\n        height,\n        isContinous,\n        isHorizontal,\n        isRadial,\n        onValueEnter,\n        placement,\n        placementProp,\n        prevX,\n        prevY,\n        transformData,\n        value,\n        width,\n        xScale,\n        yScale\n      ]\n    );\n\n    const onMouseLeave = useCallback(() => {\n      setPrevX(undefined);\n      setPrevY(undefined);\n\n      setValue(undefined);\n      setVisible(false);\n\n      onValueLeave();\n    }, [onValueLeave]);\n\n    useImperativeHandle(childRef, () => ({\n      triggerMouseMove(e: React.MouseEvent) {\n        onMouseMove(e);\n      }\n    }));\n\n    const tooltipReference = useMemo(\n      () => ({\n        width: 4,\n        height: 4,\n        top: offsetY,\n        left: offsetX\n      }),\n      [offsetX, offsetY]\n    );\n\n    const renderRadial = useCallback(() => {\n      const innerRadiusNew = innerRadius || 0;\n      const outerRadiusNew = outerRadius || Math.min(width, height) / 2;\n\n      const d = arc()({\n        innerRadius: innerRadiusNew,\n        outerRadius: outerRadiusNew,\n        startAngle: isFullCircle ? 0 : startAngle,\n        endAngle: isFullCircle ? 2 * Math.PI : endAngle\n      });\n\n      // This is a dummuy full circle in the background as we need the\n      // full circle to get the coordinates right from getBoundingClientRect().\n      // If we don't use a full circle, then the bounding rectangle could be of any dimension and\n      // the logic in getPositionForTarget() wouldn't work\n      const fullCircle = arc()({\n        innerRadius: innerRadiusNew,\n        outerRadius: outerRadiusNew,\n        startAngle: 0,\n        endAngle: 2 * Math.PI\n      });\n\n      return (\n        <>\n          <path d={fullCircle!} opacity=\"0\" cursor=\"auto\" ref={fullCircleref} />\n          <path\n            d={d!}\n            opacity=\"0\"\n            cursor=\"auto\"\n            ref={ref}\n            onMouseMove={onMouseMove}\n          />\n        </>\n      );\n    }, [\n      endAngle,\n      height,\n      innerRadius,\n      isFullCircle,\n      onMouseMove,\n      outerRadius,\n      startAngle,\n      width\n    ]);\n\n    const renderLinear = useCallback(() => {\n      return (\n        <rect\n          height={height}\n          ref={ref}\n          width={width}\n          opacity={0}\n          cursor=\"auto\"\n          onMouseMove={onMouseMove}\n        />\n      );\n    }, [height, onMouseMove, width]);\n\n    return (\n      <Fragment>\n        {disabled && children}\n        {!disabled && (\n          <g onMouseLeave={onMouseLeave} ref={childRef}>\n            {isRadial && renderRadial()}\n            {!isRadial && renderLinear()}\n            <CloneElement<ChartTooltipProps>\n              element={tooltip}\n              visible={visible}\n              placement={placement}\n              modifiers={{\n                offset: {\n                  offset: '0, 15px'\n                }\n              }}\n              reference={tooltipReference}\n              color={color}\n              value={value}\n            />\n            {children}\n          </g>\n        )}\n      </Fragment>\n    );\n  }\n);\n\nTooltipArea.defaultProps = {\n  isRadial: false,\n  isContinous: true,\n  tooltip: <ChartTooltip />,\n  inverse: true,\n  onValueEnter: () => undefined,\n  onValueLeave: () => undefined,\n  startAngle: 0,\n  endAngle: 2 * Math.PI\n};\n","import React, { PropsWithChildren, FC, useRef, useState, useEffect, useCallback } from 'react';\nimport bind from 'memoize-bind';\nimport {\n  Pan,\n  PanMoveEvent,\n  PanStartEvent,\n  PanEndEvent,\n  PanCancelEvent\n} from '../Gestures/Pan';\nimport { Zoom, ZoomEvent } from '../Gestures/Zoom';\nimport {\n  identity,\n  fromObject,\n  fromDefinition,\n  transform\n} from 'transformation-matrix';\nimport isEqual from 'react-fast-compare';\n\nexport interface ZoomPanEvent {\n  scale: number;\n  x: number;\n  y: number;\n  type: 'zoom' | 'pan';\n  nativeEvent: any;\n}\n\nexport interface ZoomPanProps extends PropsWithChildren {\n  height: number;\n  width: number;\n  scale: number;\n  x: number;\n  y: number;\n  pannable: boolean;\n  zoomable: boolean;\n  disabled?: boolean;\n  maxZoom: number;\n  minZoom: number;\n  zoomStep: number;\n  constrain: boolean;\n  globalPanning: boolean;\n  disableMouseWheel?: boolean;\n  requireZoomModifier?: boolean;\n  onZoomPan: (event: ZoomPanEvent) => void;\n  onZoom: (event: ZoomEvent) => void;\n  onZoomEnd: () => void;\n  onPanStart: (event: PanStartEvent) => void;\n  onPanMove: (event: PanMoveEvent) => void;\n  onPanEnd: (event: PanEndEvent) => void;\n  onPanCancel: (event: PanCancelEvent) => void;\n}\n\nexport const ZoomPan: FC<Partial<ZoomPanProps>> = ({\n  height,\n  width,\n  children,\n  disabled,\n  pannable,\n  maxZoom,\n  minZoom,\n  zoomable,\n  scale,\n  x,\n  y,\n  disableMouseWheel,\n  constrain,\n  zoomStep,\n  onPanCancel,\n  requireZoomModifier,\n  globalPanning,\n  onPanStart,\n  onZoomPan,\n  onPanMove,\n  onPanEnd,\n  onZoom,\n  onZoomEnd\n}) =>  {\n  const zoomRef = useRef<Zoom>();\n  const panRef = useRef<Pan>();\n  const [isZooming, setIsZooming] = useState<boolean>();\n  const [isPanning, setIsPanning] = useState<boolean>();\n  const [matrix, setMatrix] = useState<any>(identity());\n\n  useEffect(() => {\n    const newMatrix = transform(\n      fromDefinition([\n        { type: 'translate', tx: x, ty: y },\n        { type: 'scale', sx: scale, sy: scale },\n      ])\n    );\n\n    if (!isEqual(newMatrix, matrix)) {\n      setMatrix(newMatrix);\n    }\n  }, [x, y, scale, matrix]);\n\n\n  const onPanStartHandler = useCallback((event: PanStartEvent) => {\n    setIsPanning(true);\n    onPanStart(event);\n  }, [onPanStart]);\n\n  const onPanMoveHandler =  useCallback((event: PanMoveEvent) => {\n    onZoomPan({\n      scale: scale,\n      x: event.x,\n      y: event.y,\n      type: 'pan',\n      nativeEvent: event.nativeEvent\n    });\n\n    onPanMove(event);\n  }, [onPanMove, onZoomPan, scale]);\n\n  const onPanEndHandler =  useCallback((event: PanEndEvent) => {\n    setIsPanning(false);\n    onPanEnd(event);\n  }, [onPanEnd]);\n\n  const onZoomHandler =  useCallback((event: ZoomEvent) => {\n    onZoomPan({\n      x: event.x,\n      y: event.y,\n      scale: event.scale,\n      nativeEvent: event.nativeEvent,\n      type: 'zoom'\n    });\n    onZoom(event);\n  }, [onZoom, onZoomPan]);\n\n  const onZoomEndHandler =  useCallback(() => {\n    setIsZooming(false);\n    onZoomEnd();\n  }, [onZoomEnd]);\n\n  const cursor = pannable ? 'move' : 'auto';\n  const selection = isZooming || isPanning ? 'none' : 'auto';\n  const matrixObj = fromObject(matrix);\n\n  return (\n    <Pan\n      x={x}\n      y={y}\n      scale={scale}\n      matrix={matrixObj}\n      constrain={constrain}\n      height={height}\n      width={width}\n      disabled={!pannable || disabled}\n      ref={panRef}\n      globalPanning={globalPanning}\n      onPanStart={bind(onPanStartHandler)}\n      onPanMove={bind(onPanMoveHandler)}\n      onPanEnd={bind(onPanEndHandler)}\n      onPanCancel={onPanCancel}\n    >\n      <Zoom\n        ref={zoomRef}\n        disabled={!zoomable || disabled}\n        scaleFactor={zoomStep}\n        disableMouseWheel={disableMouseWheel}\n        maxZoom={maxZoom}\n        minZoom={minZoom}\n        scale={scale}\n        x={x}\n        y={y}\n        style={{ cursor }}\n        requireZoomModifier={requireZoomModifier}\n        matrix={matrix}\n        onZoom={bind(onZoomHandler)}\n        onZoomEnd={bind(onZoomEndHandler)}\n      >\n        {!disabled && (\n          <rect\n            height={height}\n            width={width}\n            opacity={0}\n            className=\"pan-container\"\n          />\n        )}\n        <g\n          style={{\n            pointerEvents: selection,\n            userSelect: selection\n          }}\n        >\n          {children}\n        </g>\n      </Zoom>\n    </Pan>\n  );\n};\n\nZoomPan.defaultProps = {\n  maxZoom: 10,\n  minZoom: 0,\n  zoomStep: 0.1,\n  pannable: true,\n  zoomable: true,\n  constrain: true,\n  height: 0,\n  width: 0,\n  x: 0,\n  y: 0,\n  scale: 1,\n  globalPanning: true,\n  onPanStart: () => undefined,\n  onPanMove: () => undefined,\n  onPanEnd: () => undefined,\n  onPanCancel: () => undefined,\n  onZoom: () => undefined,\n  onZoomEnd: () => undefined\n};\n","import { scaleLinear, scaleTime, scaleBand } from 'd3-scale';\nimport { getXDomain, getYDomain } from '../utils/domains';\nimport {\n  ChartInternalShallowDataShape,\n  ChartInternalNestedDataShape\n} from '../data';\nimport { uniqueBy } from '../utils/array';\n\ninterface ScaleConfig {\n  type: 'category' | 'value' | 'time' | 'duration';\n  roundDomains?: boolean;\n  data: any[];\n  domain?: any[];\n  padding?: number;\n  scaled?: boolean;\n  width?: number;\n  height?: number;\n  isMultiSeries?: boolean;\n  isDiverging?: boolean;\n}\n\n/**\n * Gets the X Scale function.\n */\nexport function getXScale({\n  type,\n  roundDomains,\n  data,\n  width,\n  domain,\n  padding,\n  scaled,\n  isMultiSeries = false,\n  isDiverging = false\n}: ScaleConfig) {\n  let scale;\n\n  if (type === 'time' || type === 'duration' || type === 'value') {\n    if (type === 'time') {\n      scale = scaleTime().rangeRound([0, width!]);\n    } else {\n      scale = scaleLinear().rangeRound([0, width!]);\n    }\n\n    scale = scale.domain(domain || getXDomain({ data, scaled, isDiverging }));\n  } else {\n    if (!domain) {\n      if (isMultiSeries) {\n        domain = uniqueBy<ChartInternalShallowDataShape>(data, (d) => d.key);\n      } else {\n        domain = uniqueBy<ChartInternalShallowDataShape>(data, (d) => d.x);\n      }\n    }\n\n    scale = scaleBand()\n      .rangeRound([0, width!])\n      .padding(padding || 0)\n      .domain(domain as ReadonlyArray<any>);\n  }\n\n  return roundDomains ? scale.nice() : scale;\n}\n\n/**\n * Gets the Y Scale function.\n */\nexport function getYScale({\n  type,\n  height,\n  data,\n  domain,\n  roundDomains = false,\n  scaled = false,\n  padding = 0,\n  isMultiSeries = false,\n  isDiverging = false\n}: ScaleConfig) {\n  let scale;\n\n  if (type === 'time' || type === 'value' || type === 'duration') {\n    scale = scaleLinear()\n      .range([height!, 0])\n      .domain(domain || getYDomain({ data, scaled, isDiverging }));\n  } else {\n    if (!domain) {\n      if (isMultiSeries) {\n        domain = uniqueBy<ChartInternalNestedDataShape>(\n          data as [],\n          (d) => d.key\n        );\n      } else {\n        domain = uniqueBy<ChartInternalShallowDataShape>(data, (d) => d.y);\n      }\n    }\n\n    scale = scaleBand()\n      .rangeRound([height!, 0])\n      .padding(padding)\n      .domain(domain as ReadonlyArray<any>);\n  }\n\n  return roundDomains ? scale.nice() : scale;\n}\n","import { scaleLinear } from 'd3-scale';\nimport { ChartInternalNestedDataShape } from '../data';\nimport { uniqueBy } from '../utils/array';\n\ninterface MariemkoScaleData {\n  data: ChartInternalNestedDataShape[];\n  width: number;\n  valueScale: any;\n  padding: number;\n}\n\n/**\n * Get a linear scale for the mariemko chart.\n */\nexport const getMarimekkoScale = (width: number, roundDomains: boolean) => {\n  const scale = scaleLinear().rangeRound([0, width]);\n  return roundDomains ? scale.nice() : scale;\n};\n\n/**\n * Builds a fake scale function to get a group scale for a marimekko value scale.\n */\nexport const getMarimekkoGroupScale = ({\n  data,\n  width,\n  valueScale,\n  padding\n}: MariemkoScaleData) => {\n  const domain = uniqueBy<ChartInternalNestedDataShape>(data, (d) => d.key);\n  const barCount = data.length;\n  const widthMinusPadding = width - padding * (barCount - 1);\n  const xMultiplier = widthMinusPadding / width;\n\n  // Given a data series, find the x0/x1 for it.\n  const getXRange = (series) => {\n    const [val] = series.data;\n    const x0 = valueScale(val.x0);\n    const x1 = valueScale(val.x1);\n    return { x0, x1 };\n  };\n\n  const scale: any = (arg) => {\n    let result = 0;\n    const index = data.findIndex((d) => d.key === arg);\n    const series = data[index];\n\n    if (series && series.data && series.data.length) {\n      const { x1, x0 } = getXRange(series);\n      result = (x1 - x0) / 2 + x0;\n\n      if (padding) {\n        result = result * xMultiplier + index * padding;\n      }\n    }\n\n    return result;\n  };\n\n  scale.range = () => [0, width];\n  scale.domain = () => domain;\n\n  // Special invert function for marimekko\n  scale.mariemkoInvert = (offset: number) => {\n    let found;\n\n    for (let i = 0; i < domain.length; i++) {\n      const attr = domain[i];\n      const series = data[i];\n      const { x1, x0 } = getXRange(series);\n\n      if (offset >= x0 - padding / 2 && offset <= x1 - padding / 2) {\n        found = attr;\n        break;\n      }\n    }\n\n    return found;\n  };\n\n  return scale;\n};\n","import { scaleBand } from 'd3-scale';\nimport { uniqueBy } from '../utils/array';\n\n/**\n * Get the group scale aka x0.\n */\nexport function getGroupScale({\n  dimension,\n  padding,\n  data,\n  direction = 'vertical'\n}) {\n  const domain = uniqueBy(data, (d) => d.key);\n  const spacing = domain.length / (dimension / padding + 1);\n  const range = direction === 'vertical' ? [0, dimension] : [dimension, 0];\n\n  return scaleBand()\n    .rangeRound(range as any)\n    .paddingInner(spacing)\n    .paddingOuter(spacing / 2)\n    .domain(domain as string[]);\n}\n\n/**\n * Get the inner scale aka x1.\n */\nexport function getInnerScale({ groupScale, padding, data, prop = 'x' }) {\n  const dimension = groupScale.bandwidth();\n  const domain = uniqueBy(\n    data,\n    (d) => d.data,\n    (d) => d[prop]\n  );\n  const spacing = domain.length / (dimension / padding + 1);\n\n  return scaleBand()\n    .rangeRound([0, dimension])\n    .paddingInner(spacing)\n    .domain(domain as string[]);\n}\n","import { scaleLinear } from 'd3-scale';\n\n/**\n * Get the Y Scale for a given set of radiuses.\n * Reference: https://github.com/d3/d3-scale/issues/90\n */\nexport const getRadialYScale = (\n  innerRadius: number,\n  outerRadius: number,\n  domain: any[]\n) => {\n  if (domain[0] === 0 && domain[1] === 0) {\n    // If all values are 0, set the domain to [0, 1], so the zero values are\n    // all at the bottom of the chart, not the middle.\n    domain = [0, 1];\n  }\n  const y = scaleLinear()\n    .range([innerRadius * innerRadius, outerRadius * outerRadius])\n    .domain(domain);\n\n  const yScale = Object.assign((d) => Math.sqrt(y(d)), y);\n\n  return yScale;\n};\n","import React, { FC, PropsWithChildren, useCallback, useMemo } from 'react';\nimport { ZoomPan, ZoomPanEvent } from './ZoomPan';\nimport { ChartInternalDataShape, ChartDataTypes } from '../data';\nimport { getXScale } from '../scales';\n\nexport interface ZoomPanChangeEvent {\n  domain: [ChartDataTypes, ChartDataTypes];\n  isZoomed: boolean;\n}\n\nexport interface ChartZoomPanProps extends PropsWithChildren {\n  data: ChartInternalDataShape[];\n  domain?: [ChartDataTypes, ChartDataTypes];\n  axisType: 'value' | 'time' | 'category' | 'duration';\n  roundDomains: boolean;\n  height: number;\n  width: number;\n  scale: number;\n  offset: number;\n  pannable: boolean;\n  zoomable: boolean;\n  disabled?: boolean;\n  maxZoom: number;\n  zoomStep: number;\n  disableMouseWheel?: boolean;\n  requireZoomModifier?: boolean;\n  onZoomPan?: (event: ZoomPanChangeEvent) => void;\n}\n\nexport const ChartZoomPan: FC<Partial<ChartZoomPanProps>> = ({\n  data,\n  height,\n  children,\n  disabled,\n  domain,\n  width,\n  axisType,\n  roundDomains,\n  onZoomPan,\n  ...rest\n}) => {\n  const onZoomPanHandler = useCallback((event: ZoomPanEvent) => {\n    const can =\n      event.type === 'zoom' || (event.type === 'pan' && event.scale > 1);\n\n    if (can) {\n      const scale: any = getXScale({\n        width: width,\n        type: axisType,\n        roundDomains,\n        data\n      });\n\n      const newScale = scale.copy().domain(\n        scale\n          .range()\n          .map((x) => (x - event.x) / event.scale)\n          .map(scale.clamp(true).invert, event.x)\n      );\n\n      onZoomPan!({\n        domain: newScale.domain(),\n        isZoomed: event.scale !== 1\n      });\n    }\n  }, [axisType, data, onZoomPan, roundDomains, width]);\n\n  const zoomOffset = useMemo(() => {\n    let zoomOffset = {\n      scale: undefined,\n      x: undefined\n    } as any;\n\n    if (!disabled && domain) {\n      const xScale: any = getXScale({\n        width,\n        type: axisType,\n        roundDomains,\n        data\n      });\n\n      let offset = xScale(domain[0]);\n      const endOffset = xScale(domain[1]);\n      const scale = width / (endOffset - offset);\n\n      // Apply the new scale to the offset so its scaled correctly\n      offset = offset * scale;\n\n      zoomOffset = {\n        scale: scale,\n        x: -offset\n      };\n    }\n\n    return zoomOffset;\n  }, [axisType, data, disabled, domain, roundDomains, width]);\n\n  return (\n    <ZoomPan\n      {...rest}\n      scale={zoomOffset.scale}\n      x={zoomOffset.x}\n      height={height}\n      width={width}\n      pannable={zoomOffset.scale > 1}\n      onZoomPan={onZoomPanHandler}\n    >\n      {children}\n    </ZoomPan>\n  );\n};\n\nChartZoomPan.defaultProps = {\n  onZoomPan: () => undefined,\n};\n","export const DEFAULT_TRANSITION = {\n  type: 'spring',\n  velocity: 5,\n  damping: 20,\n  // https://github.com/framer/motion/issues/1513#issuecomment-1121133717\n  restDelta: 0.01,\n  restSpeed: 0.01\n};\n","import React, { useEffect } from 'react';\nimport { motion, useMotionValue, useSpring } from 'framer-motion';\nimport { interpolate } from 'd3-interpolate';\nimport { DEFAULT_TRANSITION } from './config';\n\nexport const MotionPath = ({ custom, transition, ...rest }) => {\n  const d = useMotionValue(custom.exit.d);\n  const spring = useSpring(0, DEFAULT_TRANSITION);\n\n  useEffect(() => {\n    const interpolator = interpolate(d.get(), custom.enter.d);\n    const prevSpring = spring.get();\n    spring.set(prevSpring + 1);\n\n    return spring.on('change', (v) => d.set(interpolator(v - prevSpring)));\n  }, [custom.enter.d, custom.exit.d, d, spring]);\n\n  const { d: enterD, ...enterRest } = custom.enter;\n  const { d: exitD, ...exitRest } = custom.exit;\n\n  return (\n    <motion.path\n      {...rest}\n      initial={exitRest}\n      exit={exitRest}\n      animate={enterRest}\n      transition={transition}\n      d={transition.type !== false ? d : enterD}\n    />\n  );\n};\n","import chroma from 'chroma-js';\n\n/**\n * Color Schemes\n * Credits: https://gka.github.io/chroma.js/#chroma-brewer\n */\nexport const schemes = {\n  cybertron: chroma.scale(['#2d60e8', '#26efb5']).correctLightness().colors(8),\n  ...chroma.brewer\n};\n","import { scaleOrdinal, scaleQuantile } from 'd3-scale';\nimport { maxIndex, extent } from 'd3-array';\nimport { schemes } from './schemes';\nimport { uniqueBy } from '../utils';\n\nexport type ColorSchemeType =\n  | ((data, index: number, active?: any[]) => string)\n  | string[]\n  | string;\n\nexport type ColorSchemeStyleArray = Partial<CSSStyleDeclaration>[];\n\ntype ColorHelperProps = {\n  colorScheme: ColorSchemeType;\n  point: any;\n  data: any[];\n  index: number;\n  active: any[];\n  scale?: any;\n  domain?: any[];\n  key?: any;\n  attribute?: string;\n  isMultiSeries?: boolean;\n};\n\ntype ColorSchemeValueScale = (point: any) => string;\n\nfunction isColorSchemeStyleArray(\n  colorScheme: any\n): colorScheme is ColorSchemeStyleArray {\n  return Array.isArray(colorScheme) && typeof colorScheme[0] === 'object';\n}\n\n/**\n * Given a point, get the key attributes for it.\n */\nconst rangeHelper = (point: any, attribute: string) =>\n  point.map((r, i) => {\n    if (r) {\n      if (r[attribute] !== undefined) {\n        return r[attribute];\n      } else if (r.data && r.data[attribute] !== undefined) {\n        return r.data[attribute];\n      }\n    }\n\n    return i;\n  });\n\n/**\n * Get a color given a range.\n */\nexport const getColor = (props: Partial<ColorHelperProps>) => {\n  let {\n    point,\n    colorScheme,\n    attribute,\n    index,\n    data,\n    active,\n    isMultiSeries,\n    domain,\n    key,\n    scale\n  } = {\n    attribute: 'key',\n    isMultiSeries: false,\n    scale: scaleOrdinal,\n    ...props\n  };\n\n  if (typeof colorScheme === 'string' && schemes[colorScheme]) {\n    colorScheme = schemes[colorScheme];\n  }\n\n  if (Array.isArray(colorScheme)) {\n    if (!domain) {\n      if (isMultiSeries && Array.isArray(data)) {\n        const maxIdx = maxIndex(data, (d) => d.data.length);\n        const maxVal = data[maxIdx];\n        data = maxVal.data;\n      }\n\n      domain = rangeHelper(data, attribute);\n    }\n\n    key = key !== undefined ? key : point[attribute];\n\n    return scale(colorScheme).domain(domain)(key);\n  } else if (typeof colorScheme === 'function') {\n    return colorScheme(point, index!, active);\n  } else {\n    return colorScheme;\n  }\n};\n\n/**\n * This function creates a value scale that maps data points to colors or CSS styles.\n *\n * @param {Array} data - The data used to create the scale.\n * @param {ColorSchemeType} colorScheme - The color scheme used to generate the scale.\n * @param {string} emptyColor - The color used for data points with no value.\n * @param {any} selections - Selected values in active state\n *\n * @returns {ColorSchemeValueScale} A function that takes a data point and returns a color or CSS style based on the data point's value.\n */\nconst getValueScale = (\n  data,\n  colorScheme: ColorSchemeType,\n  emptyColor: string,\n  selections: any\n): ColorSchemeValueScale => {\n  const valueDomain = extent(\n    uniqueBy(\n      data,\n      (d) => d.data,\n      (d) => d.value\n    )\n  );\n\n  return (point) => {\n    // For 0 values, lets show a placeholder fill\n    if (point?.value === undefined || point?.value === null) {\n      return emptyColor;\n    }\n\n    // Note: this can return css style values, not just colors\n    return getColor({\n      scale: scaleQuantile,\n      domain: valueDomain,\n      key: point.value,\n      colorScheme,\n      point,\n      active: selections\n    });\n  };\n};\n\n/**\n * This function generates a style object for a given data point based on a map of value scales.\n *\n * @param {any} point - The data point for which to generate the style object.\n * @param {Map<string, ColorSchemeValueScale>} valueScales - A map where each key is a property name and each value is a function that takes a data point and returns a CSS style.\n *\n * @returns {Partial<CSSStyleDeclaration>} A style object where each key is a property name and each value is a color or CSS style based on the value of the data point for that property.\n */\nexport const getColorSchemeStyles = (\n  point,\n  valueScales: Map<string, ColorSchemeValueScale>\n): Partial<CSSStyleDeclaration> =>\n  Array.from(valueScales).reduce((acc, [key, valueScale]) => {\n    return { ...acc, [key]: valueScale(point) };\n  }, {});\n\n/**\n * This function retrieves a color scheme for a specific property from a given color scheme.\n *\n * @param {ColorSchemeStyleArray} colorScheme - The color scheme used to generate the scale.\n * @param {string} colorSchemeProperty - The property for which to retrieve the new color scheme.\n *\n * @returns {ColorSchemeType} A color scheme for the specified property.\n */\nconst getColorSchemeForProperty = (\n  colorScheme: ColorSchemeStyleArray,\n  colorSchemeProperty: string\n): ColorSchemeType =>\n  colorScheme.map(\n    (schemeItem: Partial<CSSStyleDeclaration>) =>\n      schemeItem?.[colorSchemeProperty]\n  );\n\n/**\n * This function creates a map of value scales for different properties based on a provided color scheme.\n * Each value scale is a function that takes a data point and returns a css style value based on that point.\n *\n * @param {Array} data - The data used to create the scales.\n * @param {ColorSchemeType | ColorSchemeStyleArray} colorScheme - The color scheme used to generate the scales. This can be an array of colors or an array of objects where each object contains a set of css styles.\n * @param {string} emptyColor - The color used for data points with no value.\n * @param {any} selections - Selected values in active state\n *\n * @returns {Map<string, ColorSchemeValueScale>} A map where each key is a property name and each value is a function that takes a data point and returns a value for the property.\n *\n * If the color scheme is an array of strings, they will be treated as fill values.\n */\nexport const createColorSchemeValueScales = (\n  data,\n  colorScheme: ColorSchemeType | ColorSchemeStyleArray,\n  emptyColor: string,\n  selections: any\n): Map<string, ColorSchemeValueScale> => {\n  const valueScales = new Map<string, ColorSchemeValueScale>();\n\n  if (isColorSchemeStyleArray(colorScheme)) {\n    const colorSchemeProperties = [\n      ...new Set(colorScheme.flatMap(Object.keys))\n    ];\n\n    colorSchemeProperties.forEach((key) => {\n      const valueScale = getValueScale(\n        data,\n        getColorSchemeForProperty(colorScheme, key),\n        emptyColor,\n        selections\n      );\n      valueScales.set(key, valueScale);\n    });\n  } else {\n    valueScales.set('fill', getValueScale(data, colorScheme, emptyColor, selections));\n  }\n\n  return valueScales;\n};\n","import { animate } from 'framer-motion';\nimport { useEffect, useRef } from 'react';\n\nexport interface CountInputs {\n  /**\n   * Number to animate to\n   */\n  to: number;\n\n  /**\n   * Number to animate from. Defaults 0.\n   */\n  from?: number;\n\n  /**\n   * Duration of the animation in seconds. Defaults 1.\n   */\n  duration?: number;\n\n  /**\n   * Delay of the animation. Defaults 0.\n   */\n  delay?: number;\n\n  /**\n   * Localize the number. Defaults true.\n   */\n  format?: boolean;\n\n  /**\n   * Number of decimal places. Defaults 0.\n   */\n  decimalPlaces?: number;\n\n  /**\n   * Prefix the number with a string or number.\n   */\n  prefix?: string | number;\n\n  /**\n   * Suffix the number with a string or number.\n   */\n  suffix?: string | number;\n}\n\nexport const COUNT_DEFAULTS = {\n  from: 0,\n  duration: 1,\n  delay: 0,\n  format: true,\n  decimalPlaces: 0\n};\n\nexport const useCount = ({\n  from,\n  to,\n  duration,\n  delay,\n  prefix,\n  suffix,\n  decimalPlaces,\n  format\n}: CountInputs) => {\n  const nodeRef = useRef<any | null>(null);\n\n  from = from || COUNT_DEFAULTS.from;\n  duration = duration || COUNT_DEFAULTS.duration;\n  delay = delay || COUNT_DEFAULTS.delay;\n  format = format || COUNT_DEFAULTS.format;\n  decimalPlaces = decimalPlaces || COUNT_DEFAULTS.decimalPlaces;\n\n  useEffect(() => {\n    const node = nodeRef.current;\n\n    const controls = animate(from, to, {\n      duration,\n      delay,\n      onUpdate(value) {\n        let formatted: number | string = value;\n        if (decimalPlaces) {\n          formatted = Number(value.toFixed(decimalPlaces));\n        } else {\n          formatted = Number(value.toFixed(0));\n        }\n\n        if (format) {\n          formatted = formatted.toLocaleString();\n        }\n\n        if (node) {\n          if (prefix) {\n            formatted = `${prefix}${formatted}`;\n          }\n          if (suffix) {\n            formatted = `${formatted}${suffix}`;\n          }\n\n          node.textContent = formatted as string;\n        }\n      }\n    });\n\n    return () => controls.stop();\n  }, [from, to, duration, delay, decimalPlaces, format, prefix, suffix]);\n\n  return nodeRef;\n};\n","import React, { FC } from 'react';\nimport { CountInputs, useCount } from './useCount';\n\nexport interface CountProps extends CountInputs {\n  className?: string;\n}\n\nexport const Count: FC<CountProps> = ({ className, ...rest }) => {\n  const ref = useCount(rest);\n  return <span ref={ref} className={className} />;\n};\n\nCount.defaultProps = {\n  from: 0,\n  duration: 1,\n  delay: 0,\n  localize: true,\n  decimalPlaces: 0\n};\n","import React, { FC } from 'react';\n\nexport interface LinearValueMarkerProps {\n  color: string;\n  value: any;\n  className?: string;\n  thickness?: number;\n  size?: number;\n  direction?: 'horizontal' | 'vertical';\n}\nexport const LinearValueMarker: FC<LinearValueMarkerProps> = ({\n  color,\n  value,\n  className,\n  thickness = 1,\n  size,\n  direction = 'horizontal'\n}) => {\n  const coordinates =\n    direction === 'horizontal'\n      ? { x1: 0, y1: value, x2: size, y2: value }\n      : { x1: value, y1: 0, x2: value, y2: size };\n\n  return (\n    <line\n      className={className}\n      stroke={color}\n      strokeWidth={thickness}\n      {...coordinates}\n    />\n  );\n};\n","import React, { FC } from 'react';\n\nexport interface RadialValueMarkerProps {\n  color: string;\n  value: number;\n  className?: string;\n  thickness?: number;\n}\nexport const RadialValueMarker: FC<RadialValueMarkerProps> = ({\n  color,\n  value,\n  className,\n  thickness = 1\n}) => (\n  <circle\n    className={className}\n    cx={0}\n    cy={0}\n    r={value}\n    fill=\"none\"\n    stroke={color}\n    strokeWidth={thickness}\n  />\n);\n","import { Glow } from './Glow';\nimport chroma from 'chroma-js';\n\nexport interface generateGlowStylesInput {\n  glow?: Glow;\n  colorSchemeColor?: string;\n}\n\nexport const generateGlowStyles = ({\n  glow,\n  colorSchemeColor\n}: generateGlowStylesInput) => {\n  if (!glow) return {};\n\n  let {\n    x = 0,\n    y = 0,\n    blur = 5,\n    color = colorSchemeColor || 'rgb(255, 255, 255, 0.25)',\n    opacity = 1\n  } = glow;\n\n  color = chroma(color).alpha(opacity).css();\n\n  return blur\n    ? { filter: `drop-shadow(${x}px ${y}px ${blur}px ${color})` }\n    : {};\n};\n","import React, {\n  Fragment,\n  ReactNode,\n  ReactElement,\n  useState,\n  FC,\n  useRef,\n  useMemo\n} from 'react';\nimport { ChartInternalShallowDataShape } from '../../common/data';\nimport { ChartTooltip, ChartTooltipProps } from '../../common/Tooltip';\nimport classNames from 'classnames';\nimport { CloneElement } from 'reablocks';\nimport {\n  constructFunctionProps,\n  PropFunctionTypes\n} from '../../common/utils/functions';\nimport { motion } from 'framer-motion';\nimport { DEFAULT_TRANSITION } from '../../common/Motion';\nimport { schemes, getColor, ColorSchemeType } from '../../common/color';\nimport { identifier } from 'safe-identifier';\nimport css from './ScatterPoint.module.css';\nimport { Glow } from '../../common/Glow';\nimport { generateGlowStyles } from '../../common/Glow/utils';\nimport { getAriaLabel } from '../../common';\n\nexport type ScatterPointProps = {\n  /**\n   * Whether the element is active or not. Set internally by `ScatterSeries`.\n   */\n  active?: boolean;\n\n  /**\n   * Size of the circle element.\n   */\n  size?: ((data: ChartInternalShallowDataShape) => number) | number;\n\n  /**\n   * Color of the circle.\n   */\n  color?: ColorSchemeType;\n\n  /**\n   * Cursor for the element.\n   */\n  cursor?: string;\n\n  /**\n   * D3 scale for X Axis. Set internally by `ScatterPlot`.\n   */\n  xScale: any;\n\n  /**\n   * D3 scale for Y Axis. Set internally by `ScatterPlot`.\n   */\n  yScale: any;\n\n  /**\n   * Height of the chart. Set internally by `ScatterPlot`.\n   */\n  height: number;\n\n  /**\n   * Whether to animate the enter/update/exit. Set internally by `ScatterSeries`.\n   */\n  animated?: boolean;\n\n  /**\n   * Index of the element in the series. Set internally by `ScatterSeries`.\n   */\n  index: number;\n\n  /**\n   * Tooltip element.\n   */\n  tooltip: ReactElement<ChartTooltipProps, typeof ChartTooltip> | null;\n\n  /**\n   * Parsed data shape. Set internally by `ScatterPlot`.\n   */\n  data: ChartInternalShallowDataShape;\n\n  /**\n   * Id set internally by `ScatterPlot`.\n   */\n  id: string;\n\n  /**\n   * Glow styling for the point.\n   */\n  glow?: Glow;\n\n  /**\n   * Symbol element to render.\n   */\n  symbol?: (data: ChartInternalShallowDataShape) => ReactNode;\n\n  /**\n   * Whether the elment is visiblbe or not.\n   */\n  visible?: (data: ChartInternalShallowDataShape, index: number) => boolean;\n\n  /**\n   * Event for when a symbol is clicked.\n   */\n  onClick?: (data: ChartInternalShallowDataShape) => void;\n\n  /**\n   * Event for when the symbol has mouse enter.\n   */\n  onMouseEnter?: (data: ChartInternalShallowDataShape) => void;\n\n  /**\n   * Event for when the symbol has mouse leave.\n   */\n  onMouseLeave?: (data: ChartInternalShallowDataShape) => void;\n} & PropFunctionTypes;\n\nexport const ScatterPoint: FC<Partial<ScatterPointProps>> = ({\n  symbol,\n  index,\n  id,\n  data,\n  xScale,\n  yScale,\n  active,\n  tooltip,\n  cursor,\n  size,\n  glow,\n  color,\n  animated,\n  onClick,\n  onMouseEnter,\n  onMouseLeave,\n  visible,\n  ...rest\n}) => {\n  const rectRef = useRef<any | null>(null);\n  const [tooltipVisible, setTooltipVisible] = useState<boolean>(false);\n  const extras = useMemo(\n    () => constructFunctionProps(rest, data),\n    [rest, data]\n  );\n  const r = useMemo(\n    () => (typeof size === 'function' ? size(data!) : size),\n    [size, data]\n  );\n  const renderedSymbol = useMemo(\n    () => (symbol ? symbol(data!) : null),\n    [data, symbol]\n  );\n\n  const transitionProps = useMemo(\n    () =>\n      animated\n        ? {\n          ...DEFAULT_TRANSITION,\n          delay: index! * 0.005\n        }\n        : {\n          type: false,\n          delay: 0\n        },\n    [index, animated]\n  );\n\n  const enterProps = useMemo(() => {\n    let cy = yScale(data!.y1);\n    if (yScale.bandwidth) {\n      const width = yScale.bandwidth();\n      cy = cy + width / 2;\n    }\n\n    return {\n      x: xScale(data!.x),\n      y: cy\n    };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [data, yScale]);\n\n  const exitProps = useMemo(() => {\n    const [yStartDomain] = yScale.domain();\n    return {\n      y: yScale(yStartDomain),\n      x: xScale(data!.x)\n    };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [data, yScale]);\n\n  const fill = useMemo(\n    () =>\n      getColor({\n        colorScheme: color,\n        index,\n        point: data\n      }),\n    [data, color, index]\n  );\n\n  const key = `symbol-${id}-${identifier(`${data!.id}`)}`;\n  const ariaLabelData = useMemo(() => getAriaLabel(data), [data]);\n\n  const isVisible = visible ? visible?.(data, index) : active;\n\n  return (\n    <Fragment>\n      <g\n        ref={rectRef}\n        className={classNames({\n          [css.inactive]: !active,\n          [css.hidden]: !isVisible\n        })}\n        onMouseEnter={() => {\n          setTooltipVisible(true);\n          onMouseEnter(data!);\n        }}\n        onMouseLeave={() => {\n          setTooltipVisible(false);\n          onMouseLeave(data!);\n        }}\n        onClick={() => onClick(data!)}\n        tabIndex={0}\n        aria-label={ariaLabelData}\n        role=\"graphics-document\"\n      >\n        {symbol ? (\n          <motion.g\n            key={key}\n            {...extras}\n            initial={{\n              translateX: exitProps.x,\n              translateY: exitProps.y,\n              opacity: 0\n            }}\n            animate={{\n              translateX: enterProps.x,\n              translateY: enterProps.y,\n              opacity: 1\n            }}\n            exit={{\n              translateX: exitProps.x,\n              translateY: exitProps.y,\n              opacity: 0\n            }}\n            transition={transitionProps}\n          >\n            {renderedSymbol}\n          </motion.g>\n        ) : (\n          <motion.circle\n            key={key}\n            className={extras.className}\n            style={{\n              ...extras.style,\n              ...generateGlowStyles({ glow }),\n              cursor\n            }}\n            fill={fill}\n            initial={{\n              cx: exitProps.x,\n              cy: exitProps.y,\n              r,\n              opacity: 0\n            }}\n            animate={{\n              cx: enterProps.x,\n              cy: enterProps.y,\n              opacity: 1,\n              r\n            }}\n            exit={{\n              cx: exitProps.x,\n              cy: exitProps.y,\n              r,\n              opacity: 0\n            }}\n            transition={transitionProps}\n          />\n        )}\n      </g>\n      {tooltip && !tooltip.props.disabled && (\n        <CloneElement<ChartTooltipProps>\n          element={tooltip}\n          visible={tooltipVisible}\n          reference={rectRef}\n          value={data}\n        />\n      )}\n    </Fragment>\n  );\n};\n\nScatterPoint.defaultProps = {\n  active: true,\n  tooltip: <ChartTooltip />,\n  cursor: 'pointer',\n  size: 4,\n  color: schemes.cybertron[0],\n  animated: true,\n  onClick: () => undefined,\n  onMouseEnter: () => undefined,\n  onMouseLeave: () => undefined\n};\n","import React, { useCallback, Fragment, ReactElement, FC } from 'react';\nimport { ChartInternalShallowDataShape } from '../../common/data';\nimport { CloneElement } from 'reablocks';\nimport { ScatterPoint, ScatterPointProps } from './ScatterPoint';\nimport { identifier } from 'safe-identifier';\nimport { LinearValueMarker, LinearValueMarkerProps } from '../../common';\n\nexport interface ScatterSeriesProps {\n  /**\n   * Point that is rendered.\n   */\n  point: ReactElement<ScatterPointProps, typeof ScatterPoint>;\n\n  /**\n   * D3 scale for X Axis. Set internally by `ScatterPlot`.\n   */\n  xScale: any;\n\n  /**\n   * D3 scale for Y Axis. Set internally by `ScatterPlot`.\n   */\n  yScale: any;\n\n  /**\n   * Parsed data shape. Set internally by `ScatterPlot`.\n   */\n  data: ChartInternalShallowDataShape[];\n\n  /**\n   * Id set internally by `ScatterPlot`.\n   */\n  id: string;\n\n  /**\n   * Height of the chart. Set internally by `ScatterPlot`.\n   */\n  height: number;\n\n  /**\n   * Width of the chart. Set internally by `ScatterPlot`.\n   */\n  width: number;\n\n  /**\n   * Whether the chart has been zoomed or not. Set internally by `ScatterPlot`.\n   */\n  isZoomed: boolean;\n\n  /**\n   * Whether to animate the enter/update/exit.\n   */\n  animated: boolean;\n\n  /**\n   * Active element ids to highlight.\n   */\n  activeIds?: string[];\n\n  /**\n   * Value markers line for the chart.\n   */\n  valueMarkers:\n    | ReactElement<LinearValueMarkerProps, typeof LinearValueMarker>[]\n    | null;\n}\n\n// For bubble charts, often symbols exceed the area\n// and we want to add a little bit of padding to prevent clipping\nconst PADDING = 25;\nconst HALF_PADDING = PADDING / 2;\n\nexport const ScatterSeries: FC<Partial<ScatterSeriesProps>> = ({\n  data,\n  height,\n  width,\n  id,\n  isZoomed,\n  activeIds,\n  point,\n  valueMarkers,\n  xScale,\n  yScale,\n  ...rest\n}) => {\n  const renderPoint = useCallback(\n    (pointData: ChartInternalShallowDataShape, index: number) => {\n      let pointId;\n      if (pointData.id) {\n        pointId = pointData.id;\n      }\n\n      const key = identifier(`${pointId || index}`);\n      const active =\n        !(activeIds && activeIds.length) || activeIds.includes(pointId);\n\n      return (\n        <CloneElement<ScatterPointProps>\n          element={point}\n          key={key}\n          xScale={xScale}\n          yScale={yScale}\n          {...rest}\n          id={id}\n          data={pointData}\n          index={index}\n          active={active}\n        />\n      );\n    },\n    [activeIds, point, yScale, rest, id]\n  );\n\n  const renderValueMarkers = useCallback(\n    () => (\n      <>\n        {valueMarkers?.length &&\n          valueMarkers.map((marker) => {\n            const isVertical = marker?.props?.direction === 'vertical';\n            const size = isVertical ? height : width;\n            const value = isVertical\n              ? xScale(marker.props.value)\n              : yScale(marker.props.value);\n            return (\n              <CloneElement<LinearValueMarkerProps>\n                key={marker.key}\n                element={marker}\n                size={size}\n                value={value}\n              />\n            );\n          })}\n      </>\n    ),\n    [valueMarkers, width, yScale]\n  );\n\n  return (\n    <Fragment>\n      <defs>\n        <clipPath id={`${id}-path`}>\n          <rect\n            width={isZoomed ? width : width! + PADDING}\n            height={height! + PADDING}\n            x={isZoomed ? 0 : -HALF_PADDING}\n            y={-HALF_PADDING}\n          />\n        </clipPath>\n      </defs>\n      {renderValueMarkers()}\n      <g clipPath={`url(#${id}-path)`}>{data!.map(renderPoint)}</g>\n    </Fragment>\n  );\n};\n\nScatterSeries.defaultProps = {\n  point: <ScatterPoint />\n};\n","import React, {\n  FC,\n  Fragment,\n  ReactElement,\n  useState,\n  useRef,\n  useCallback,\n  useMemo\n} from 'react';\nimport classNames from 'classnames';\nimport {\n  ChartShallowDataShape,\n  buildShallowChartData,\n  ChartDataTypes\n} from '../common/data';\nimport {\n  isAxisVisible,\n  LinearAxisProps,\n  LinearXAxis,\n  LinearYAxis,\n  LinearAxis\n} from '../common/Axis';\nimport { getYScale, getXScale } from '../common/scales';\nimport { ScatterSeries, ScatterSeriesProps } from './ScatterSeries';\nimport { GridlineSeries, GridlineSeriesProps } from '../common/Gridline';\nimport {\n  ZoomPanChangeEvent,\n  ChartZoomPanProps,\n  ChartZoomPan\n} from '../common/ZoomPan';\nimport { ChartBrushProps, ChartBrush } from '../common/Brush';\nimport {\n  ChartProps,\n  ChartContainer,\n  ChartContainerChildProps\n} from '../common/containers/ChartContainer';\nimport { CloneElement } from 'reablocks';\nimport css from './ScatterPlot.module.css';\n\nexport interface ScatterPlotProps extends ChartProps {\n  /**\n   * Data the chart will receive to render.\n   */\n  data: ChartShallowDataShape[];\n\n  /**\n   * The series component that renders the scatter components.\n   */\n  series: ReactElement<ScatterSeriesProps, typeof ScatterSeries>;\n\n  /**\n   * The linear axis component for the Y Axis of the chart.\n   */\n  yAxis: ReactElement<LinearAxisProps, typeof LinearAxis>;\n\n  /**\n   * The linear axis component for the X Axis of the chart.\n   */\n  xAxis: ReactElement<LinearAxisProps, typeof LinearAxis>;\n\n  /**\n   * The chart's background gridlines component.\n   */\n  gridlines: ReactElement<GridlineSeriesProps, typeof GridlineSeries> | null;\n\n  /**\n   * The chart's brush component.\n   */\n  brush: ReactElement<ChartBrushProps, typeof ChartBrush> | null;\n\n  /**\n   * The chart's zoom pan component.\n   */\n  zoomPan: ReactElement<ChartZoomPanProps, typeof ChartZoomPan> | null;\n\n  /**\n   * Any secondary axis components. Useful for multi-axis charts.\n   */\n  secondaryAxis?: ReactElement<LinearAxisProps, typeof LinearAxis>[];\n}\n\nexport const ScatterPlot: FC<Partial<ScatterPlotProps>> = ({\n  id,\n  width,\n  height,\n  margins,\n  className,\n  series,\n  xAxis,\n  yAxis,\n  data,\n  gridlines,\n  containerClassName,\n  brush,\n  zoomPan,\n  secondaryAxis\n}) => {\n  const zoomControlled = useMemo(\n    () =>\n      // eslint-disable-next-line\n      !zoomPan?.props?.domain?.hasOwnProperty('domain'),\n    [zoomPan]\n  );\n\n  const timeout = useRef<any | null>(null);\n  const [preventAnimation, setPreventAnimation] = useState<boolean>(false);\n  const [zoomDomain, setZoomDomain] = useState<\n    [ChartDataTypes, ChartDataTypes] | null\n  >(null);\n  const [isZoomed, setIsZoomed] = useState<boolean>(false);\n  const aggregatedData = useMemo(() => buildShallowChartData(data), [data]);\n\n  const getScales = useCallback(\n    (chartHeight: number, chartWidth: number) => {\n      const yScale = getYScale({\n        roundDomains: yAxis.props.roundDomains,\n        type: yAxis.props.type,\n        height: chartHeight,\n        data: aggregatedData,\n        domain: yAxis.props.domain\n      });\n\n      const xScale = getXScale({\n        width: chartWidth,\n        type: xAxis.props.type,\n        roundDomains: xAxis.props.roundDomains,\n        data: aggregatedData,\n        domain: zoomDomain || xAxis.props.domain\n      });\n\n      return {\n        yScale,\n        xScale\n      };\n    },\n    [yAxis, xAxis, aggregatedData, zoomDomain]\n  );\n\n  const onZoomPan = useCallback(\n    (event: ZoomPanChangeEvent) => {\n      if (zoomControlled) {\n        setPreventAnimation(true);\n        setZoomDomain(event.domain);\n        setIsZoomed(event.isZoomed);\n\n        clearTimeout(timeout.current);\n        timeout.current = setTimeout(() => setPreventAnimation(true), 500);\n      }\n    },\n    [zoomControlled]\n  );\n\n  const renderChart = useCallback(\n    ({\n      chartHeight,\n      chartWidth,\n      id,\n      updateAxes,\n      chartSized\n    }: ChartContainerChildProps) => {\n      const { yScale, xScale } = getScales(chartHeight, chartWidth);\n      const animated =\n        preventAnimation === true ? false : series.props.animated;\n      const disableBrush = aggregatedData.length <= 1;\n\n      return (\n        <Fragment>\n          {chartSized && gridlines && (\n            <CloneElement<GridlineSeriesProps>\n              element={gridlines}\n              height={chartHeight}\n              width={chartWidth}\n              yScale={yScale}\n              xScale={xScale}\n              yAxis={yAxis.props}\n              xAxis={xAxis.props}\n            />\n          )}\n          <CloneElement<LinearAxisProps>\n            element={xAxis}\n            height={chartHeight}\n            width={chartWidth}\n            scale={xScale}\n            visibility={chartSized ? 'visible' : 'hidden'}\n            onDimensionsChange={(e) => updateAxes('horizontal', e)}\n          />\n          <CloneElement<LinearAxisProps>\n            element={yAxis}\n            height={chartHeight}\n            width={chartWidth}\n            scale={yScale}\n            visibility={chartSized ? 'visible' : 'hidden'}\n            onDimensionsChange={(e) => updateAxes('vertical', e)}\n          />\n          {secondaryAxis &&\n            secondaryAxis.map((axis, i) => (\n              <CloneElement<LinearAxisProps>\n                key={i}\n                element={axis}\n                height={chartHeight}\n                width={chartWidth}\n                visibility={chartSized ? 'visible' : 'hidden'}\n                onDimensionsChange={(e) => updateAxes('horizontal', e)}\n              />\n            ))}\n          {chartSized && (\n            <CloneElement<ChartBrushProps>\n              disabled={disableBrush}\n              element={brush}\n              height={chartHeight}\n              width={chartWidth}\n              scale={xScale}\n            >\n              <CloneElement<ChartZoomPanProps>\n                element={zoomPan}\n                onZoomPan={onZoomPan}\n                height={chartHeight}\n                width={chartWidth}\n                axisType={xAxis.props.type}\n                roundDomains={xAxis.props.roundDomains}\n                data={aggregatedData}\n                domain={zoomDomain}\n              >\n                <CloneElement<ScatterSeriesProps>\n                  element={series}\n                  id={`area-series-${id}`}\n                  data={aggregatedData}\n                  height={chartHeight}\n                  width={chartWidth}\n                  yScale={yScale}\n                  xScale={xScale}\n                  isZoomed={isZoomed}\n                  animated={animated}\n                />\n              </CloneElement>\n            </CloneElement>\n          )}\n        </Fragment>\n      );\n    },\n    [\n      getScales,\n      preventAnimation,\n      series,\n      gridlines,\n      yAxis,\n      xAxis,\n      secondaryAxis,\n      brush,\n      zoomPan,\n      onZoomPan,\n      aggregatedData,\n      zoomDomain,\n      isZoomed\n    ]\n  );\n\n  return (\n    <ChartContainer\n      id={id}\n      width={width}\n      height={height}\n      containerClassName={containerClassName}\n      margins={margins}\n      xAxisVisible={isAxisVisible(xAxis.props)}\n      yAxisVisible={isAxisVisible(yAxis.props)}\n      className={classNames(css.scatterPlot, className)}\n    >\n      {renderChart}\n    </ChartContainer>\n  );\n};\n\nScatterPlot.defaultProps = {\n  data: [],\n  xAxis: <LinearXAxis type=\"time\" />,\n  yAxis: <LinearYAxis type=\"value\" />,\n  series: <ScatterSeries />,\n  gridlines: <GridlineSeries />,\n  brush: null,\n  zoomPan: null\n};\n","import React, { FC, ReactElement, useCallback } from 'react';\nimport { ChartInternalShallowDataShape } from '../../common/data';\nimport { CloneElement } from 'reablocks';\nimport {\n  ScatterPoint,\n  ScatterSeries,\n  ScatterPointProps\n} from '../../ScatterPlot';\nimport css from './PointSeries.module.css';\nimport isEqual from 'react-fast-compare';\n\nexport interface PointSeriesProps {\n  /**\n   * Determines if the points should be animated or not.\n   */\n  animated: boolean;\n\n  /**\n   * The color of the points.\n   */\n  color: any;\n\n  /**\n   * The active values for the points.\n   */\n  activeValues?: any;\n\n  /**\n   * The data for the points.\n   */\n  data: ChartInternalShallowDataShape[];\n\n  /**\n   * The y-scale for the points.\n   */\n  yScale: any;\n\n  /**\n   * The x-scale for the points.\n   */\n  xScale: any;\n\n  /**\n   * The unique identifier for the points.\n   */\n  id: string;\n\n  /**\n   * The height of the points.\n   */\n  height: number;\n\n  /**\n   * The width of the points.\n   */\n  width: number;\n\n  /**\n   * Determines when the points should be shown. Can be a boolean or one of the following strings: 'hover', 'first', 'last'.\n   */\n  show: boolean | 'hover' | 'first' | 'last';\n\n  /**\n   * The point element.\n   */\n  point: ReactElement<ScatterPointProps, typeof ScatterPoint>;\n\n  /**\n   * The index of the points.\n   */\n  index: number;\n}\n\nexport const PointSeries: FC<Partial<PointSeriesProps>> = ({\n  data,\n  xScale,\n  yScale,\n  animated,\n  point,\n  color,\n  height,\n  width,\n  id,\n  activeValues,\n  show\n}) => {\n  const getIsVisible = useCallback(\n    (point: ChartInternalShallowDataShape, index: number) => {\n      const isActive =\n        activeValues && point && isEqual(activeValues.x, point.x);\n\n      if (show === 'hover') {\n        return isActive;\n      } else if (show === 'first') {\n        if (activeValues) {\n          return isActive;\n        } else {\n          return index === 0;\n        }\n      } else if (show === 'last') {\n        if (activeValues) {\n          return isActive;\n        } else {\n          return index === data.length - 1;\n        }\n      }\n\n      return show;\n    },\n    [activeValues, data.length, show]\n  );\n\n  return (\n    <ScatterSeries\n      height={height}\n      width={width}\n      id={id}\n      animated={animated}\n      data={data}\n      xScale={xScale}\n      yScale={yScale}\n      point={\n        <CloneElement<ScatterPointProps>\n          element={point}\n          color={color}\n          className={css.point}\n          size={4}\n          tooltip={null}\n          visible={getIsVisible}\n        />\n      }\n    />\n  );\n};\n\nPointSeries.defaultProps = {\n  show: 'hover',\n  point: <ScatterPoint />\n};\n","import React, { Fragment, useMemo, ReactElement, FC, useCallback } from 'react';\nimport { area } from 'd3-shape';\nimport { Gradient, GradientProps } from '../../common/Gradient';\nimport { Mask, MaskProps } from '../../common/Mask';\nimport {\n  interpolate,\n  InterpolationTypes\n} from '../../common/utils/interpolation';\nimport {\n  ChartInternalDataShape,\n  ChartInternalShallowDataShape\n} from '../../common/data';\nimport { CloneElement } from 'reablocks';\nimport {\n  constructFunctionProps,\n  PropFunctionTypes\n} from '../../common/utils/functions';\nimport { MotionPath, DEFAULT_TRANSITION } from '../../common/Motion';\nimport { generateGlowStyles } from '../../common/Glow/utils';\nimport { Glow } from '../../common';\n\nexport interface AreaProps extends PropFunctionTypes {\n  /**\n   * Id set internally by `AreaSeries`.\n   */\n  id: string;\n\n  /**\n   * Parsed data shape. Set internally by `AreaChart`.\n   */\n  data: ChartInternalDataShape[];\n\n  /**\n   * Interpolation for the area. Set internally by `AreaSeries`.\n   */\n  interpolation: InterpolationTypes;\n\n  /**\n   * Color for the area. Set internally by `AreaSeries`.\n   */\n  color: any;\n\n  /**\n   * D3 scale for X Axis. Set internally by `AreaChart`.\n   */\n  xScale: any;\n\n  /**\n   * D3 scale for Y Axis. Set internally by `AreaChart`.\n   */\n  yScale: any;\n\n  /**\n   * Index of the area in the series. Set internally by `AreaSeries`.\n   */\n  index: number;\n\n  /**\n   * Total number of areas in the series. Set internally by `AreaSeries`.\n   */\n  total: number;\n\n  /**\n   * Whether to animate the enter/update/exit. Set internally by `AreaSeries`.\n   */\n  animated: boolean;\n\n  /**\n   * Mask to apply to the area.\n   */\n  mask: ReactElement<MaskProps, typeof Mask> | null;\n\n  /**\n   * Gradient to apply to the area.\n   */\n  gradient: ReactElement<GradientProps, typeof Gradient> | null;\n\n  /**\n   * Glow to apply to the area.\n   */\n  glow?: Glow;\n}\n\nexport const Area: FC<Partial<AreaProps>> = ({\n  id,\n  gradient,\n  glow,\n  mask,\n  data,\n  color,\n  index,\n  total,\n  xScale,\n  yScale,\n  animated,\n  interpolation,\n  ...rest\n}) => {\n  const stroke = color(data, index);\n\n  const coords = useMemo(() => {\n    return data.map((item: any) => ({\n      x: xScale(item.x),\n      x1: xScale(item.x) - xScale(item.x1),\n      y: yScale(item.y),\n      y0: yScale(item.y0),\n      y1: yScale(item.y1)\n    })) as ChartInternalShallowDataShape[];\n  }, [data, xScale, yScale]);\n\n  const getAreaPath = useCallback(\n    (d: ChartInternalShallowDataShape[]) => {\n      // If the input data is a single value and this is the only\n      // area in a series, fill the available space with an area:\n      if (d.length === 1 && total === 1) {\n        const [point] = d;\n        // Assume the single data point's `x` value\n        // is the middle of the graph:\n        const midpoint = point.x as number;\n        d = [{ ...point }, { ...point }];\n        const [start, end] = d;\n        start.x = 0;\n        end.x = midpoint * 2;\n      }\n\n      const fn = area()\n        .x((d: any) => d.x)\n        .y0((d: any) => d.y0)\n        .y1((d: any) => d.y1)\n        .curve(interpolate(interpolation));\n\n      return fn(d as any);\n    },\n    [interpolation, total]\n  );\n\n  const enter = useMemo(() => {\n    const areaPath = getAreaPath(coords);\n\n    return {\n      d: areaPath === null ? undefined : areaPath\n    };\n  }, [coords, getAreaPath]);\n\n  const exit = useMemo(() => {\n    const maxY = Math.max(...yScale.range());\n    const coords = data.map((item: any) => ({\n      x: xScale(item.x),\n      x1: 0,\n      y: 0,\n      y1: maxY,\n      y0: maxY\n    })) as ChartInternalShallowDataShape[];\n\n    const areaPath = getAreaPath(coords);\n\n    return {\n      d: areaPath === null ? undefined : areaPath\n    };\n  }, [data, getAreaPath, xScale, yScale]);\n\n  const fill = useMemo(() => {\n    if (mask) {\n      return `url(#mask-pattern-${id})`;\n    } else {\n      if (gradient) {\n        return `url(#gradient-${id})`;\n      }\n\n      return '';\n    }\n  }, [gradient, id, mask]);\n\n  const transition = useMemo(() => {\n    if (animated) {\n      return {\n        ...DEFAULT_TRANSITION,\n        delay: index * 0.05\n      };\n    } else {\n      return {\n        type: false,\n        delay: 0\n      };\n    }\n  }, [animated, index]);\n\n  const renderArea = useCallback(() => {\n    const maskPath = mask ? `url(#mask-${id})` : '';\n    const extras = constructFunctionProps(rest, data);\n\n    return (\n      <MotionPath\n        {...extras}\n        pointerEvents=\"none\"\n        mask={maskPath}\n        fill={fill}\n        transition={transition}\n        custom={{\n          enter,\n          exit\n        }}\n        style={{\n          ...extras.style,\n          ...generateGlowStyles({ glow, colorSchemeColor: stroke })\n        }}\n      />\n    );\n  }, [data, enter, exit, fill, glow, id, mask, rest, stroke, transition]);\n\n  return (\n    <Fragment>\n      {renderArea()}\n      {mask && (\n        <Fragment>\n          <Mask id={`mask-${id}`} fill={`url(#gradient-${id})`} />\n          <CloneElement<MaskProps>\n            element={mask}\n            id={`mask-pattern-${id}`}\n            fill={stroke}\n          />\n        </Fragment>\n      )}\n      {gradient && (\n        <CloneElement<GradientProps>\n          element={gradient}\n          id={`gradient-${id}`}\n          color={stroke}\n        />\n      )}\n    </Fragment>\n  );\n};\n\nArea.defaultProps = {\n  gradient: <Gradient />,\n  interpolation: 'linear'\n};\n","import React, {\n  FC,\n  Fragment,\n  ReactElement,\n  useCallback,\n  useEffect,\n  useMemo,\n  useRef,\n  useState\n} from 'react';\nimport { line } from 'd3-shape';\nimport {\n  interpolate,\n  InterpolationTypes\n} from '../../common/utils/interpolation';\nimport {\n  ChartInternalDataShape,\n  ChartInternalShallowDataShape\n} from '../../common/data';\nimport { calculateShowStroke } from '../../common/utils/stroke';\nimport {\n  constructFunctionProps,\n  PropFunctionTypes\n} from '../../common/utils/functions';\nimport { MotionPath, DEFAULT_TRANSITION } from '../../common/Motion';\nimport { Glow, Gradient, GradientProps } from '../../common';\nimport { generateGlowStyles } from '../../common/Glow/utils';\nimport { CloneElement } from 'reablocks';\n\nexport interface LineProps extends PropFunctionTypes {\n  /**\n   * Id set internally by `AreaChart`.\n   */\n  id: string;\n\n  /**\n   * Parsed data shape. Set internally by `AreaChart`.\n   */\n  data: ChartInternalDataShape[];\n\n  /**\n   * Width of the chart. Set internally by `AreaChart`.\n   */\n  width: number;\n\n  /**\n   * Interpolation for the area. Set internally by `AreaSeries`.\n   */\n  interpolation: InterpolationTypes;\n\n  /**\n   * Color for the area. Set internally by `AreaSeries`.\n   */\n  color: any;\n\n  /**\n   * D3 scale for X Axis. Set internally by `AreaChart`.\n   */\n  xScale: any;\n\n  /**\n   * D3 scale for Y Axis. Set internally by `AreaChart`.\n   */\n  yScale: any;\n\n  /**\n   * Index of the area in the series. Set internally by `AreaSeries`.\n   */\n  index: number;\n\n  /**\n   * Whether to animate the enter/update/exit. Set internally by `AreaSeries`.\n   */\n  animated: boolean;\n\n  /**\n   * Stroke width of the line.\n   */\n  strokeWidth: number;\n\n  /**\n   * Show the stroke if there is no value.\n   */\n  showZeroStroke: boolean;\n\n  /**\n   * Internal property to identify if there is a area or not.\n   */\n  hasArea: boolean;\n\n  /**\n   * Gradient to apply to the line.\n   */\n  gradient: ReactElement<GradientProps, typeof Gradient> | null;\n\n  /**\n   * Glow to apply to the line.\n   */\n  glow?: Glow;\n}\n\nexport const Line: FC<Partial<LineProps>> = ({\n  id,\n  width,\n  data,\n  color,\n  index,\n  strokeWidth,\n  hasArea,\n  animated,\n  yScale,\n  xScale,\n  showZeroStroke,\n  interpolation,\n  gradient,\n  glow,\n  ...rest\n}) => {\n  const [pathLength, setPathLength] = useState<number | null>(null);\n  const ghostPathRef = useRef<SVGPathElement | null>(null);\n\n  useEffect(() => {\n    if (ghostPathRef.current) {\n      setPathLength(ghostPathRef.current.getTotalLength());\n    }\n  }, [data, xScale, yScale, width]);\n\n  const getLinePath = useCallback(\n    (point: ChartInternalShallowDataShape[]) => {\n      const fn = line()\n        .x((d: any) => d.x)\n        .y((d: any) => d.y1)\n        .defined((d: any) => showZeroStroke || calculateShowStroke(d, point))\n        .curve(interpolate(interpolation));\n\n      return fn(point as any);\n    },\n    [interpolation, showZeroStroke]\n  );\n\n  const transition = useMemo(() => {\n    if (animated) {\n      return {\n        ...DEFAULT_TRANSITION,\n        delay: hasArea ? 0 : index * 0.05\n      };\n    } else {\n      return {\n        type: false,\n        delay: 0\n      };\n    }\n  }, [animated, hasArea, index]);\n\n  const coords = useMemo(() => {\n    return data.map((item: any) => ({\n      x: xScale(item.x),\n      x1: xScale(item.x) - xScale(item.x1),\n      y: yScale(item.y),\n      y0: yScale(item.y0),\n      y1: yScale(item.y1)\n    })) as ChartInternalShallowDataShape[];\n  }, [data, xScale, yScale]);\n\n  const enter = useMemo(() => {\n    const linePath = getLinePath(coords);\n\n    let strokeDasharray = '';\n    if (!hasArea && pathLength !== null) {\n      strokeDasharray = `${pathLength} ${pathLength}`;\n    }\n\n    return {\n      d: linePath === null ? undefined : linePath,\n      strokeDashoffset: 0,\n      strokeDasharray: strokeDasharray\n    };\n  }, [coords, getLinePath, hasArea, pathLength]);\n\n  const exit = useMemo(() => {\n    let newCoords = coords;\n    if (hasArea) {\n      const maxY = Math.max(...yScale.range());\n      newCoords = data.map((item: any) => ({\n        x: xScale(item.x),\n        x1: 0,\n        y: maxY,\n        y1: maxY,\n        y0: maxY\n      })) as ChartInternalShallowDataShape[];\n    }\n\n    const linePath = getLinePath(newCoords);\n\n    let strokeDasharray = '';\n    let strokeDashoffset = 0;\n    if (!hasArea && pathLength !== null) {\n      strokeDasharray = `${pathLength} ${pathLength}`;\n      strokeDashoffset = pathLength;\n    }\n\n    return {\n      d: linePath === null ? undefined : linePath,\n      strokeDasharray,\n      strokeDashoffset\n    };\n  }, [coords, data, getLinePath, hasArea, pathLength, xScale, yScale]);\n\n  const stroke = color(data, index);\n  const extras = constructFunctionProps(rest, data);\n  const showLine = hasArea || pathLength !== null;\n\n  const strokeFill = useMemo(() => {\n    if (gradient) {\n      return `url(#gradient-${id})`;\n    }\n    return stroke;\n  }, [gradient, id]);\n\n  // framer-motion freaks out when these are added for area\n  if (hasArea) {\n    delete enter.strokeDashoffset;\n    delete exit.strokeDashoffset;\n  }\n\n  return (\n    <Fragment>\n      {showLine && (\n        <MotionPath\n          {...extras}\n          pointerEvents=\"none\"\n          stroke={strokeFill}\n          strokeWidth={strokeWidth}\n          fill=\"none\"\n          transition={transition}\n          custom={{\n            enter,\n            exit\n          }}\n          style={{\n            ...extras.style,\n            ...generateGlowStyles({ glow, colorSchemeColor: strokeFill })\n          }}\n        />\n      )}\n      {!hasArea && (\n        <path opacity=\"0\" d={enter.d} ref={ghostPathRef} pointerEvents=\"none\" />\n      )}\n      {gradient && (\n        <CloneElement<GradientProps>\n          element={gradient}\n          id={`gradient-${id}`}\n          color={stroke}\n        />\n      )}\n    </Fragment>\n  );\n};\n\nLine.defaultProps = {\n  showZeroStroke: true,\n  strokeWidth: 3\n};\n","import React, {\n  Fragment,\n  ReactElement,\n  FC,\n  useCallback,\n  useState\n} from 'react';\nimport { PointSeries, PointSeriesProps } from './PointSeries';\nimport { Area, AreaProps } from './Area';\nimport { MarkLine, MarkLineProps } from '../../common/MarkLine';\nimport {\n  ChartInternalDataShape,\n  ChartInternalNestedDataShape,\n  ChartInternalShallowDataShape\n} from '../../common/data';\nimport { CloneElement } from 'reablocks';\nimport {\n  TooltipArea,\n  TooltipAreaProps,\n  TooltipAreaEvent\n} from '../../common/Tooltip';\nimport { Line, LineProps } from './Line';\nimport { InterpolationTypes } from '../../common/utils/interpolation';\nimport { getColor, ColorSchemeType } from '../../common/color';\nimport { identifier } from 'safe-identifier';\nimport { LinearValueMarker, LinearValueMarkerProps } from '../../common';\n\nexport type AreaChartTypes =\n  | 'standard'\n  | 'grouped'\n  | 'stacked'\n  | 'stackedNormalized';\n\nexport interface AreaSeriesProps {\n  /**\n   * Id set internally by `AreaChart`.\n   */\n  id: string;\n\n  /**\n   * D3 scale for X Axis. Set internally by `AreaChart`.\n   */\n  xScale: any;\n\n  /**\n   * D3 scale for Y Axis. Set internally by `AreaChart`.\n   */\n  yScale: any;\n\n  /**\n   * Parsed data shape. Set internally by `AreaChart`.\n   */\n  data: ChartInternalDataShape[];\n\n  /**\n   * Height of the chart. Set internally by `AreaChart`.\n   */\n  height: number;\n\n  /**\n   * Width of the chart. Set internally by `AreaChart`.\n   */\n  width: number;\n\n  /**\n   * Whether to animate the enter/update/exit.\n   */\n  animated: boolean;\n\n  /**\n   * Type of area chart to render.\n   */\n  type: AreaChartTypes;\n\n  /**\n   * Interpolation type for the area/line.\n   */\n  interpolation: InterpolationTypes;\n\n  /**\n   * Tooltip for the chart area.\n   */\n  tooltip: ReactElement<TooltipAreaProps, typeof TooltipArea>;\n\n  /**\n   * Markline for the chart.\n   */\n  markLine: ReactElement<MarkLineProps, typeof MarkLine> | null;\n\n  /**\n   * Symbols used to show points.\n   */\n  symbols: ReactElement<PointSeriesProps, typeof PointSeries> | null;\n\n  /**\n   * Line that is rendered.\n   */\n  line: ReactElement<LineProps, typeof Line> | null;\n\n  /**\n   * Area that is rendered.\n   */\n  area: ReactElement<AreaProps, typeof Area> | null;\n\n  /**\n   * Color scheme for the series.\n   */\n  colorScheme: ColorSchemeType;\n\n  /**\n   * Whether the chart has been zoomed or not. Set internally by `AreaChart`.\n   */\n  isZoomed: boolean;\n\n  /**\n   * Value markers line for the chart.\n   */\n  valueMarkers:\n    | ReactElement<LinearValueMarkerProps, typeof LinearValueMarker>[]\n    | null;\n}\n\n// For area charts, often symbols exceed the area\n// and we want to add a little bit of padding to prevent clipping\nconst PADDING = 25;\nconst HALF_PADDING = PADDING / 2;\n\nexport const AreaSeries: FC<Partial<AreaSeriesProps>> = ({\n  data,\n  height,\n  id,\n  width,\n  isZoomed,\n  tooltip,\n  xScale,\n  yScale,\n  type,\n  markLine,\n  symbols,\n  animated,\n  area,\n  interpolation,\n  line,\n  colorScheme,\n  valueMarkers\n}) => {\n  const [activeValues, setActiveValues] = useState<any | null>(null);\n  const [activePoint, setActivePoint] = useState<any | null>(null);\n\n  const onValueEnter = useCallback((event: TooltipAreaEvent) => {\n    setActivePoint(event.pointX);\n    setActiveValues(event.value);\n  }, []);\n\n  const onValueLeave = useCallback(() => {\n    setActivePoint(undefined);\n    setActiveValues(undefined);\n  }, []);\n\n  const isMulti =\n    type === 'grouped' || type === 'stacked' || type === 'stackedNormalized';\n\n  const getPointColor = useCallback(\n    (point, index: number) => {\n      const key = Array.isArray(point) ? point?.[0]?.key : point?.key;\n\n      return getColor({\n        data,\n        colorScheme,\n        active: activeValues,\n        point,\n        index,\n        key\n      });\n    },\n    [activeValues, colorScheme, data]\n  );\n\n  const renderArea = useCallback(\n    (data: ChartInternalShallowDataShape[], index = 0, total = 1) => (\n      <Fragment>\n        {line && (\n          <CloneElement<LineProps>\n            element={line}\n            xScale={xScale}\n            yScale={yScale}\n            data={data}\n            width={width}\n            index={index}\n            hasArea={area !== null}\n            animated={animated}\n            interpolation={interpolation}\n            color={getPointColor}\n          />\n        )}\n        {area && (\n          <CloneElement<AreaProps>\n            element={area}\n            id={`${id}-area-${index}`}\n            xScale={xScale}\n            yScale={yScale}\n            data={data}\n            index={index}\n            total={total}\n            animated={animated}\n            interpolation={interpolation}\n            color={getPointColor}\n          />\n        )}\n      </Fragment>\n    ),\n    [\n      animated,\n      area,\n      getPointColor,\n      id,\n      interpolation,\n      line,\n      width,\n      xScale,\n      yScale\n    ]\n  );\n\n  const renderSymbols = useCallback(\n    (data: ChartInternalShallowDataShape[], index = 0) => {\n      const visible = symbols !== null;\n      const activeSymbols =\n        (symbols && symbols.props.activeValues) || activeValues;\n\n      // Animations are only valid for Area\n      const isAnimated = area !== undefined && animated && !activeSymbols;\n\n      return (\n        <Fragment>\n          {visible && (\n            <CloneElement<PointSeriesProps>\n              element={symbols}\n              key={`point-series-${id}`}\n              id={id}\n              height={height}\n              width={width}\n              activeValues={activeSymbols}\n              xScale={xScale}\n              yScale={yScale}\n              index={index}\n              data={data}\n              animated={isAnimated}\n              color={() => getPointColor(data, index)}\n            />\n          )}\n        </Fragment>\n      );\n    },\n    [\n      activeValues,\n      animated,\n      area,\n      getPointColor,\n      height,\n      id,\n      symbols,\n      width,\n      xScale,\n      yScale\n    ]\n  );\n\n  const renderMarkLine = useCallback(\n    () => (\n      <>\n        {activeValues && markLine && (\n          <CloneElement<MarkLineProps>\n            element={markLine}\n            height={height}\n            pointX={activePoint}\n          />\n        )}\n      </>\n    ),\n    [activePoint, activeValues, height, markLine]\n  );\n\n  const renderSingleSeries = useCallback(\n    (data: ChartInternalShallowDataShape[]) => (\n      <Fragment>\n        {renderArea(data)}\n        {renderMarkLine()}\n        {renderSymbols(data)}\n      </Fragment>\n    ),\n    [renderArea, renderMarkLine, renderSymbols]\n  );\n\n  const renderMultiSeries = useCallback(\n    (data: ChartInternalNestedDataShape[]) => (\n      <Fragment>\n        {data\n          .map((point, index) => (\n            <Fragment key={identifier(`${point.key}`)}>\n              {renderArea(point.data, index, data.length)}\n            </Fragment>\n          ))\n          .reverse()}\n        {renderMarkLine()}\n        {data\n          .map((point, index) => (\n            <Fragment key={identifier(`${point.key}`)}>\n              {renderSymbols(point.data, index)}\n            </Fragment>\n          ))\n          .reverse()}\n      </Fragment>\n    ),\n    [renderArea, renderMarkLine, renderSymbols]\n  );\n\n  const renderValueMarkers = useCallback(\n    () => (\n      <>\n        {valueMarkers?.length &&\n          valueMarkers.map((marker) => {\n            const isVertical = marker?.props?.direction === 'vertical';\n            const size = isVertical ? height : width;\n            const value = isVertical\n              ? xScale(marker.props.value)\n              : yScale(marker.props.value);\n            return (\n              <CloneElement<LinearValueMarkerProps>\n                key={marker.key}\n                element={marker}\n                size={size}\n                value={value}\n              />\n            );\n          })}\n      </>\n    ),\n    [valueMarkers, width, yScale]\n  );\n\n  return (\n    <Fragment>\n      <defs>\n        <clipPath id={`${id}-path`}>\n          <rect\n            width={isZoomed ? width : width + PADDING}\n            height={height + PADDING}\n            x={isZoomed ? 0 : -HALF_PADDING}\n            y={-HALF_PADDING}\n          />\n        </clipPath>\n      </defs>\n      <CloneElement<TooltipAreaProps>\n        element={tooltip}\n        xScale={xScale}\n        yScale={yScale}\n        data={data}\n        height={height}\n        width={width}\n        color={getPointColor}\n        onValueEnter={onValueEnter}\n        onValueLeave={onValueLeave}\n      >\n        <g clipPath={`url(#${id}-path)`}>\n          {isMulti && renderMultiSeries(data as ChartInternalNestedDataShape[])}\n          {!isMulti &&\n            renderSingleSeries(data as ChartInternalShallowDataShape[])}\n          {renderValueMarkers()}\n        </g>\n      </CloneElement>\n    </Fragment>\n  );\n};\n\nAreaSeries.defaultProps = {\n  colorScheme: 'cybertron',\n  animated: true,\n  interpolation: 'linear',\n  type: 'standard',\n  line: <Line />,\n  area: <Area />,\n  markLine: <MarkLine />,\n  tooltip: <TooltipArea />,\n  symbols: <PointSeries />\n};\n","import React, { FC } from 'react';\nimport { AreaSeriesProps, AreaSeries } from './AreaSeries';\nimport { formatValue } from '../../common/utils/formatting';\nimport {\n  TooltipTemplate,\n  TooltipArea,\n  ChartTooltip\n} from '../../common/Tooltip';\nimport { CloneElement } from 'reablocks';\nimport { PointSeriesProps } from './PointSeries';\nimport { ScatterPointProps } from '../../ScatterPlot';\n\nexport const StackedNormalizedAreaSeries: FC<Partial<AreaSeriesProps>> = ({\n  type,\n  symbols,\n  ...rest\n}) => (\n  <AreaSeries\n    {...rest}\n    type=\"stackedNormalized\"\n    symbols={\n      symbols && (\n        <CloneElement<PointSeriesProps>\n          element={symbols}\n          {...symbols.props}\n          point={\n            <CloneElement<ScatterPointProps>\n              element={symbols.props.point}\n              {...symbols.props.point.props}\n              tooltip={null}\n            />\n          }\n        />\n      )\n    }\n  />\n);\n\nStackedNormalizedAreaSeries.defaultProps = {\n  ...AreaSeries.defaultProps,\n  type: 'stackedNormalized',\n  tooltip: (\n    <TooltipArea\n      tooltip={\n        <ChartTooltip\n          content={(series, color) => {\n            if (!series) {\n              return null;\n            }\n\n            const value = {\n              ...series,\n              data: series.data.map((d) => ({\n                ...d,\n                value: `${formatValue(d.value)}  ${formatValue(\n                  Math.floor((d.y1 - d.y0) * 100)\n                )}%`\n              }))\n            };\n\n            return <TooltipTemplate color={color} value={value} />;\n          }}\n        />\n      }\n    />\n  )\n};\n","import React, { FC } from 'react';\nimport { AreaSeriesProps, AreaSeries } from './AreaSeries';\nimport { CloneElement } from 'reablocks';\nimport { PointSeriesProps } from './PointSeries';\nimport { ScatterPointProps } from '../../ScatterPlot';\n\nexport const StackedAreaSeries: FC<Partial<AreaSeriesProps>> = ({\n  type,\n  symbols,\n  ...rest\n}) => (\n  <AreaSeries\n    {...rest}\n    type=\"stacked\"\n    symbols={\n      symbols && (\n        <CloneElement<PointSeriesProps>\n          element={symbols}\n          {...symbols.props}\n          point={\n            <CloneElement<ScatterPointProps>\n              element={symbols.props.point}\n              {...symbols.props.point.props}\n              tooltip={null}\n            />\n          }\n        />\n      )\n    }\n  />\n);\n\nStackedAreaSeries.defaultProps = {\n  ...AreaSeries.defaultProps,\n  type: 'stacked'\n};\n","import React, {\n  Fragment,\n  useEffect,\n  ReactElement,\n  FC,\n  useCallback,\n  useMemo,\n  useState,\n  useRef\n} from 'react';\nimport classNames from 'classnames';\nimport { AreaSeries, AreaSeriesProps } from './AreaSeries';\nimport {\n  isAxisVisible,\n  LinearAxisProps,\n  LinearXAxis,\n  LinearYAxis,\n  LinearAxis\n} from '../common/Axis/LinearAxis';\nimport { getXScale, getYScale } from '../common/scales';\nimport { GridlineSeries, GridlineSeriesProps } from '../common/Gridline';\nimport {\n  ChartDataShape,\n  ChartNestedDataShape,\n  buildStackData,\n  buildShallowChartData,\n  ChartShallowDataShape,\n  buildNestedChartData\n} from '../common/data';\nimport css from './AreaChart.module.css';\nimport { ChartBrushProps, ChartBrush } from '../common/Brush';\nimport {\n  ZoomPanChangeEvent,\n  ChartZoomPanProps,\n  ChartZoomPan\n} from '../common/ZoomPan';\nimport {\n  ChartContainerChildProps,\n  ChartContainer,\n  ChartProps\n} from '../common/containers/ChartContainer';\nimport { CloneElement } from 'reablocks';\n\nexport interface AreaChartProps extends ChartProps {\n  /**\n   * Data the chart will receive to render.\n   */\n  data: ChartDataShape[];\n\n  /**\n   * The series component that renders the area/line/circles components.\n   */\n  series: ReactElement<AreaSeriesProps, typeof AreaSeries>;\n\n  /**\n   * The linear axis component for the Y Axis of the chart.\n   */\n  yAxis: ReactElement<LinearAxisProps, typeof LinearAxis>;\n\n  /**\n   * The linear axis component for the X Axis of the chart.\n   */\n  xAxis: ReactElement<LinearAxisProps, typeof LinearAxis>;\n\n  /**\n   * The chart's background gridlines component.\n   */\n  gridlines: ReactElement<GridlineSeriesProps, typeof GridlineSeries> | null;\n\n  /**\n   * The chart's brush component.\n   */\n  brush: ReactElement<ChartBrushProps, typeof ChartBrush> | null;\n\n  /**\n   * The chart's zoom pan component.\n   */\n  zoomPan: ReactElement<ChartZoomPanProps, typeof ChartZoomPan> | null;\n\n  /**\n   * Any secondary axis components. Useful for multi-axis charts.\n   */\n  secondaryAxis?: ReactElement<LinearAxisProps, typeof LinearAxis>[];\n}\n\nexport const AreaChart: FC<Partial<AreaChartProps>> = ({\n  xAxis,\n  yAxis,\n  id,\n  data,\n  width,\n  height,\n  margins,\n  className,\n  containerClassName,\n  series,\n  gridlines,\n  brush,\n  zoomPan,\n  secondaryAxis\n}) => {\n  const zoom: any = zoomPan ? zoomPan.props : {};\n  const [zoomDomain, setZoomDomain] = useState<any>(zoom.domain);\n  const [preventAnimation, setPreventAnimation] = useState<boolean>(false);\n  const [isZoomed, setIsZoomed] = useState<boolean>(!!zoom.domain);\n  // eslint-disable-next-line\n  const [zoomControlled] = useState<boolean>(!zoom.hasOwnProperty('domain'));\n\n  const timeoutRef = useRef<any | null>(null);\n\n  const seriesType = series.props.type;\n  const isMultiSeries =\n    seriesType === 'stacked' ||\n    seriesType === 'stackedNormalized' ||\n    seriesType === 'grouped';\n\n  const animated = preventAnimation === true ? false : series.props.animated;\n\n  useEffect(() => {\n    if (zoomPan) {\n      const zoom = zoomPan.props;\n      if (!zoomControlled && zoom.domain !== zoomDomain) {\n        setZoomDomain(zoom.domain);\n        setIsZoomed(!!zoom.domain);\n      }\n    }\n  }, [zoomControlled, zoomDomain, zoomPan]);\n\n  const aggregatedData = useMemo(() => {\n    if (seriesType === 'stacked' || seriesType === 'stackedNormalized') {\n      return buildStackData(\n        data as ChartNestedDataShape[],\n        seriesType === 'stackedNormalized'\n      );\n    } else if (seriesType === 'grouped') {\n      return buildNestedChartData(data as ChartNestedDataShape[], true);\n    } else {\n      return buildShallowChartData(data as ChartShallowDataShape[]);\n    }\n  }, [data, seriesType]);\n\n  const getScales = useCallback(\n    (chartWidth: number, chartHeight: number) => {\n      const xScale = getXScale({\n        width: chartWidth,\n        type: xAxis.props.type,\n        roundDomains: xAxis.props.roundDomains,\n        data: aggregatedData,\n        domain: zoomDomain || xAxis.props.domain,\n        isMultiSeries\n      });\n\n      const yScale = getYScale({\n        roundDomains: yAxis.props.roundDomains,\n        type: yAxis.props.type,\n        height: chartHeight,\n        data: aggregatedData,\n        domain: yAxis.props.domain,\n        isMultiSeries\n      });\n\n      return { xScale, yScale };\n    },\n    [\n      aggregatedData,\n      isMultiSeries,\n      xAxis.props.domain,\n      xAxis.props.roundDomains,\n      xAxis.props.type,\n      yAxis.props.domain,\n      yAxis.props.roundDomains,\n      yAxis.props.type,\n      zoomDomain\n    ]\n  );\n\n  const onZoomPan = useCallback(\n    (event: ZoomPanChangeEvent) => {\n      if (zoomControlled) {\n        setZoomDomain(event.domain);\n        setIsZoomed(event.isZoomed);\n        setPreventAnimation(true);\n\n        clearTimeout(timeoutRef.current);\n        timeoutRef.current = setTimeout(() => setPreventAnimation(false));\n      }\n    },\n    [zoomControlled]\n  );\n\n  const renderChart = useCallback(\n    ({\n      chartHeight,\n      chartWidth,\n      id,\n      updateAxes,\n      chartSized\n    }: ChartContainerChildProps) => {\n      const { xScale, yScale } = getScales(chartWidth, chartHeight);\n      const disableBrush = aggregatedData.length <= 1;\n\n      return (\n        <Fragment>\n          {chartSized && gridlines && (\n            <CloneElement<GridlineSeriesProps>\n              element={gridlines}\n              height={chartHeight}\n              width={chartWidth}\n              yScale={yScale}\n              xScale={xScale}\n              yAxis={yAxis.props}\n              xAxis={xAxis.props}\n            />\n          )}\n          <CloneElement<LinearAxisProps>\n            element={xAxis}\n            height={chartHeight}\n            width={chartWidth}\n            scale={xScale}\n            visibility={chartSized ? 'visible' : 'hidden'}\n            onDimensionsChange={(event) => updateAxes('horizontal', event)}\n          />\n          <CloneElement<LinearAxisProps>\n            element={yAxis}\n            height={chartHeight}\n            width={chartWidth}\n            scale={yScale}\n            visibility={chartSized ? 'visible' : 'hidden'}\n            onDimensionsChange={(event) => updateAxes('vertical', event)}\n          />\n          {secondaryAxis &&\n            secondaryAxis.map((axis, i) => (\n              <CloneElement<LinearAxisProps>\n                key={i}\n                element={axis}\n                height={chartHeight}\n                width={chartWidth}\n                visibility={chartSized ? 'visible' : 'hidden'}\n                onDimensionsChange={(event) => updateAxes('horizontal', event)}\n              />\n            ))}\n          {chartSized && (\n            <CloneElement<ChartBrushProps>\n              disabled={disableBrush}\n              element={brush}\n              height={chartHeight}\n              width={chartWidth}\n              scale={xScale}\n            >\n              <CloneElement<ChartZoomPanProps>\n                element={zoomPan}\n                onZoomPan={onZoomPan}\n                height={chartHeight}\n                width={chartWidth}\n                axisType={xAxis.props.type}\n                roundDomains={xAxis.props.roundDomains}\n                data={aggregatedData}\n                domain={zoomDomain}\n              >\n                <CloneElement<AreaSeriesProps>\n                  element={series}\n                  id={`area-series-${id}`}\n                  data={aggregatedData}\n                  height={chartHeight}\n                  width={chartWidth}\n                  yScale={yScale}\n                  xScale={xScale}\n                  isZoomed={isZoomed}\n                  animated={animated}\n                />\n              </CloneElement>\n            </CloneElement>\n          )}\n        </Fragment>\n      );\n    },\n    [\n      aggregatedData,\n      animated,\n      brush,\n      getScales,\n      gridlines,\n      isZoomed,\n      onZoomPan,\n      secondaryAxis,\n      series,\n      xAxis,\n      yAxis,\n      zoomDomain,\n      zoomPan\n    ]\n  );\n\n  return (\n    <ChartContainer\n      id={id}\n      width={width}\n      height={height}\n      margins={margins}\n      containerClassName={containerClassName}\n      xAxisVisible={isAxisVisible(xAxis.props)}\n      yAxisVisible={isAxisVisible(yAxis.props)}\n      className={classNames(\n        css.areaChart,\n        className,\n        series.type as unknown as string\n      )}\n    >\n      {renderChart}\n    </ChartContainer>\n  );\n};\n\nAreaChart.defaultProps = {\n  data: [],\n  xAxis: <LinearXAxis type=\"time\" />,\n  yAxis: <LinearYAxis type=\"value\" />,\n  series: <AreaSeries />,\n  gridlines: <GridlineSeries />,\n  brush: null,\n  zoomPan: null\n};\n","import React, { FC } from 'react';\nimport { AreaChart, AreaChartProps } from './AreaChart';\nimport { ChartNestedDataShape } from '../common/data';\nimport { StackedAreaSeries } from './AreaSeries';\n\nexport interface StackedAreaChartProps extends AreaChartProps {\n  data: ChartNestedDataShape[];\n}\n\nexport const StackedAreaChart: FC<Partial<StackedAreaChartProps>> = (props) => (\n  <AreaChart {...props} />\n);\n\nStackedAreaChart.defaultProps = {\n  series: <StackedAreaSeries />\n};\n","import React, { FC } from 'react';\nimport { AreaChart, AreaChartProps } from './AreaChart';\nimport { ChartNestedDataShape } from '../common/data';\nimport { StackedNormalizedAreaSeries } from './AreaSeries';\nimport {\n  LinearYAxis,\n  LinearYAxisTickSeries,\n  LinearYAxisTickLabel\n} from '../common/Axis/LinearAxis';\n\nexport interface StackedNormalizedAreaChartProps extends AreaChartProps {\n  data: ChartNestedDataShape[];\n}\n\nexport const StackedNormalizedAreaChart: FC<\n  Partial<StackedNormalizedAreaChartProps>\n> = (props) => <AreaChart {...props} />;\n\nStackedNormalizedAreaChart.defaultProps = {\n  series: <StackedNormalizedAreaSeries />,\n  yAxis: (\n    <LinearYAxis\n      type=\"value\"\n      tickSeries={\n        <LinearYAxisTickSeries\n          label={\n            <LinearYAxisTickLabel\n              rotation={false}\n              format={(data) => `${data * 100}%`}\n            />\n          }\n        />\n      }\n    />\n  )\n};\n","import React, {\n  Fragment,\n  ReactElement,\n  useCallback,\n  FC,\n  useRef,\n  useMemo,\n  useState\n} from 'react';\nimport chroma from 'chroma-js';\nimport { Gradient, GradientProps } from '../../common/Gradient';\nimport classNames from 'classnames';\nimport { ChartInternalShallowDataShape, Direction } from '../../common/data';\nimport { RangeLinesProps, RangeLines } from './RangeLines';\nimport { CloneElement } from 'reablocks';\nimport { Mask, MaskProps } from '../../common/Mask';\nimport {\n  constructFunctionProps,\n  PropFunctionTypes\n} from '../../common/utils/functions';\nimport { motion } from 'framer-motion';\nimport { DEFAULT_TRANSITION } from '../../common/Motion';\nimport { BarLabelProps, BarLabel } from './BarLabel';\nimport { formatValue, getAriaLabel } from '../../common/utils/formatting';\nimport { GuideBarProps, GuideBar } from './GuideBar';\nimport { ChartTooltipProps, ChartTooltip } from '../../common/Tooltip';\nimport { Glow } from '../../common/Glow';\nimport { ClickEvent } from '../../common/types';\nimport { generateGlowStyles } from '../../common/Glow/utils';\n\nexport type BarType =\n  | 'standard'\n  | 'grouped'\n  | 'stacked'\n  | 'stackedNormalized'\n  | 'stackedDiverging'\n  | 'marimekko'\n  | 'waterfall';\n\nexport type BarProps = {\n  /**\n   * Whether the bar is active or not.\n   */\n  active: boolean;\n\n  /**\n   * Chroma brightness factor to brighten the active bar. See\n   * https://gka.github.io/chroma.js/#color-brighten for more info.\n   */\n  activeBrightness?: number;\n\n  /**\n   * D3 scale for X Axis. Set internally by `BarChart`.\n   */\n  xScale: any;\n\n  /**\n   * D3 scale for Y Axis. Set internally by `BarChart`.\n   */\n  yScale: any;\n\n  /**\n   * D3 scale for X Multi-Group Axis. Set internally by `BarChart`.\n   */\n  xScale1: any;\n\n  /**\n   * Parsed data shape. Set internally by `BarChart`.\n   */\n  data: ChartInternalShallowDataShape;\n\n  /**\n   * Id set internally by `BarChart`.\n   */\n  id: string;\n\n  /**\n   * Gradient shades for the bar.\n   */\n  gradient: ReactElement<GradientProps, typeof Gradient> | null;\n\n  /**\n   * SVG rx attribute for the bar.\n   */\n  rx: number;\n\n  /**\n   * SVG ry attribute for the bar.\n   */\n  ry: number;\n\n  /**\n   * Width of the bar. Set internally by `BarSeries`.\n   */\n  width: number;\n\n  /**\n   * Padding for the bar groups.\n   */\n  padding: number;\n\n  /**\n   * Total number of bars used for animation. Set internally by `BarSeries`.\n   */\n  barCount: number;\n\n  /**\n   * Color callback for the bar.\n   */\n  color: any;\n\n  /**\n   * Cursor for the bar element.\n   */\n  cursor: string;\n\n  /**\n   * Index of the bar. Set internally by `BarSeries`.\n   */\n  barIndex: number;\n\n  /**\n   * Index of the group. Set internally by `BarSeries`.\n   */\n  groupIndex?: number;\n\n  /**\n   * Whether to animate the enter/update/exit. Set internally by `BarSeries`.\n   */\n  animated: boolean;\n\n  /**\n   * Whether this is categorical chart or not. Set internally by `BarSeries`.\n   */\n  isCategorical: boolean;\n\n  /**\n   * Rangelines element. for the bar.\n   */\n  rangeLines: ReactElement<RangeLinesProps, typeof RangeLines> | null;\n\n  /**\n   * Mask element for the bar.\n   */\n  mask: ReactElement<MaskProps, typeof Mask> | null;\n\n  /**\n   * Tooltip element.\n   */\n  tooltip: ReactElement<ChartTooltipProps, typeof ChartTooltip> | null;\n\n  /**\n   * Direction of the chart. Set internally by `BarSeries`.\n   */\n  layout: Direction;\n\n  /**\n   * Type of bar chart. Set internally by `BarSeries`.\n   */\n  type: BarType;\n\n  /**\n   * Label element.\n   */\n  label: ReactElement<BarLabelProps, typeof BarLabel> | null;\n\n  /**\n   * Guide bar component.\n   */\n  guide: ReactElement<GuideBarProps, typeof GuideBar> | null;\n\n  /**\n   * Force a min height on the bar.\n   */\n  minHeight?: number;\n\n  /**\n   * Glow styling for the bar.\n   */\n  glow?: Glow;\n\n  /**\n   * Event for when the bar is clicked.\n   */\n  onClick?: (event: ClickEvent) => void;\n\n  /**\n   * Event for when the bar has mouse enter.\n   */\n  onMouseEnter?: (event) => void;\n\n  /**\n   * Event for when the bar has mouse leave.\n   */\n  onMouseLeave?: (event) => void;\n\n  /**\n   * Event for when a bar has mouse move.\n   */\n  onMouseMove?: (event) => void;\n} & PropFunctionTypes;\n\ninterface BarCoordinates {\n  width: number;\n  height: number;\n  x: number;\n  y: number;\n}\n\nexport const Bar: FC<Partial<BarProps>> = ({\n  activeBrightness,\n  id,\n  gradient,\n  data,\n  barIndex,\n  color,\n  yScale,\n  barCount,\n  glow,\n  xScale,\n  groupIndex,\n  minHeight,\n  rangeLines,\n  animated,\n  active,\n  type,\n  tooltip,\n  layout,\n  mask,\n  label,\n  cursor,\n  rx,\n  ry,\n  isCategorical,\n  className,\n  style,\n  width,\n  padding,\n  guide,\n  xScale1,\n  onMouseEnter,\n  onClick,\n  onMouseMove,\n  onMouseLeave\n}) => {\n  const isVertical = useMemo(() => layout === 'vertical', [layout]);\n  const rect = useRef<SVGGElement | null>(null);\n  const [internalActive, setInternalActive] = useState<boolean>(active);\n\n  const calculateLinearScalePadding = useCallback(\n    (scale, offset: number, size: number) => {\n      // This function calculates the padding on a linear scale used by the marimekko chart.\n      const totalSize = scale.range()[1];\n      const sizeMinusPadding = totalSize - padding * (barCount - 1);\n      const multiplier = sizeMinusPadding / totalSize;\n      offset = offset * multiplier + groupIndex! * padding;\n      size = size * multiplier;\n\n      return { size, offset };\n    },\n    [barCount, groupIndex, padding]\n  );\n\n  const getExit = useCallback(\n    ({ x, y, width, height }: BarCoordinates) => {\n      let newX = isVertical ? x : Math.min(...xScale.range());\n      let newY = isVertical ? Math.max(...yScale.range()) : y;\n      const newHeight = isVertical ? 0 : height;\n      const newWidth = isVertical ? width : 0;\n\n      if (type === 'stackedDiverging') {\n        if (isVertical) {\n          newY = newY / 2;\n        } else {\n          newX = newX / 2;\n        }\n      }\n\n      return {\n        x: newX,\n        y: newY,\n        height: newHeight,\n        width: newWidth\n      };\n    },\n    [isVertical, type, xScale, yScale]\n  );\n\n  const getKeyCoords = useCallback(\n    (\n      v,\n      v0,\n      v1,\n      scale,\n      sizeOverride: number,\n      isCategorical: boolean,\n      padding: number\n    ) => {\n      let offset;\n      let size;\n\n      if (isCategorical) {\n        if (scale.bandwidth) {\n          offset = scale(v);\n          size = scale.bandwidth();\n\n          if (sizeOverride) {\n            if (offset) {\n              offset = offset + size / 2 - sizeOverride / 2;\n            } else {\n              // Stacked bar charts don't have offsets...\n              offset = size / 2 - sizeOverride / 2;\n            }\n\n            size = sizeOverride;\n          }\n        } else {\n          if (sizeOverride) {\n            throw new Error('Not a valid option for this scale type');\n          }\n\n          offset = scale(v0);\n          size = scale((v1 as any) - (v0 as any));\n\n          if (padding) {\n            const calc = calculateLinearScalePadding(scale, offset, size);\n            offset = calc.offset;\n            size = calc.size;\n          }\n        }\n      } else {\n        if (sizeOverride) {\n          throw new Error('Not a valid option for this scale type');\n        }\n\n        const c0 = scale(v0);\n        const c1 = scale(v1);\n        const delta = c1 - c0;\n        offset = c0;\n        size = Math.max(delta - 1, 0);\n      }\n\n      return {\n        offset: isNaN(offset) ? 0 : offset,\n        size: isNaN(size) ? 0 : size\n      };\n    },\n    [calculateLinearScalePadding]\n  );\n\n  const getValueCoords = useCallback(\n    (v0, v1, scale) => {\n      const c0 = scale(v0);\n      const c1 = scale(v1);\n      const size = Math.abs(c0 - c1);\n      const minSize = Math.max(minHeight || 0, size);\n      const offset = Math.min(c0, c1);\n\n      return {\n        offset: isNaN(offset) ? 0 : offset,\n        size: isNaN(minSize) ? 0 : minSize\n      };\n    },\n    [minHeight]\n  );\n\n  const getCoords = useCallback(\n    (data: ChartInternalShallowDataShape) => {\n      let newYScale = yScale;\n      let newXScale = xScale;\n\n      if (xScale1) {\n        if (isVertical) {\n          newXScale = xScale1;\n        } else {\n          newYScale = xScale1;\n        }\n      }\n\n      if (isVertical) {\n        const xCoords = getKeyCoords(\n          data.x,\n          data.x0,\n          data.x1,\n          newXScale,\n          width,\n          isCategorical,\n          padding\n        );\n        const yCoords = getValueCoords(data.y0, data.y1, newYScale);\n\n        return {\n          x: xCoords.offset,\n          width: xCoords.size,\n          y: yCoords.offset,\n          height: yCoords.size\n        } as BarCoordinates;\n      } else {\n        const yCoords = getKeyCoords(\n          data.y,\n          data.y0,\n          data.y1,\n          newYScale,\n          width,\n          isCategorical,\n          padding\n        );\n        const xCoords = getValueCoords(data.x0, data.x1, newXScale);\n\n        return {\n          x: xCoords.offset,\n          width: xCoords.size,\n          y: yCoords.offset,\n          height: yCoords.size\n        } as BarCoordinates;\n      }\n    },\n    [\n      getKeyCoords,\n      getValueCoords,\n      isCategorical,\n      isVertical,\n      padding,\n      width,\n      xScale,\n      xScale1,\n      yScale\n    ]\n  );\n\n  const onMouseEnterInternal = useCallback(\n    (event) => {\n      // Only tooltip bars rely on this...\n      if (tooltip) {\n        setInternalActive(true);\n      }\n\n      onMouseEnter?.({\n        value: data,\n        nativeEvent: event\n      });\n    },\n    [data, onMouseEnter, tooltip]\n  );\n\n  const onMouseLeaveInternal = useCallback(\n    (event) => {\n      // Only tooltip bars rely on this...\n      if (tooltip) {\n        setInternalActive(false);\n      }\n\n      onMouseLeave?.({\n        value: data,\n        nativeEvent: event\n      });\n    },\n    [data, onMouseLeave, tooltip]\n  );\n\n  const onMouseClick = useCallback(\n    (event) => {\n      onClick?.({\n        value: data,\n        nativeEvent: event\n      });\n    },\n    [data, onClick]\n  );\n\n  const getFill = useCallback(\n    (color: string) => {\n      if (mask) {\n        return `url(#mask-pattern-${id})`;\n      } else {\n        if (gradient) {\n          return `url(#gradient-${id})`;\n        }\n\n        return color;\n      }\n    },\n    [gradient, id, mask]\n  );\n\n  const tooltipData = useMemo(() => {\n    const xAttr = isCategorical ? 'x' : 'x0';\n    let x = data[xAttr]!;\n\n    // Stacked diverging negative numbers\n    // in horizontal layouts need to pull x0\n    if ((data.x0 as number) < 0) {\n      x = data.x0;\n    }\n\n    const matches = isVertical\n      ? data.key && data.key !== x\n      : data.key && data.key !== data.y;\n\n    if (matches) {\n      x = `${data.key}  ${x}`;\n    }\n\n    return {\n      y: data.y,\n      x\n    };\n  }, [data, isCategorical, isVertical]);\n\n  const ariaLabelData = useMemo(() => getAriaLabel(tooltipData), [tooltipData]);\n\n  const getTransition = useCallback(\n    (index: number) => {\n      if (animated) {\n        let delay = 0;\n        if (layout === 'vertical') {\n          delay = (index / barCount) * 0.5;\n        } else {\n          delay = ((barCount - index) / barCount) * 0.5;\n        }\n\n        return {\n          ...DEFAULT_TRANSITION,\n          delay: delay\n        };\n      } else {\n        return {\n          type: false,\n          delay: 0\n        };\n      }\n    },\n    [animated, barCount, layout]\n  );\n\n  const renderBar = useCallback(\n    (currentColorShade: string, coords: BarCoordinates, index: number) => {\n      const maskPath = mask ? `url(#mask-${id})` : '';\n      const fill = getFill(currentColorShade);\n      const initialExit = getExit(coords);\n      const extras = constructFunctionProps({ className, style }, data);\n      const transition = getTransition(index);\n\n      // UGH: https://github.com/framer/motion/issues/384\n      const initial = {\n        ...initialExit,\n        attrX: initialExit.x,\n        attrY: initialExit.y,\n        fill\n      };\n\n      delete initial.x;\n      delete initial.y;\n\n      const animate = {\n        ...coords,\n        attrX: coords.x,\n        attrY: coords.y,\n        fill\n      };\n\n      delete animate.x;\n      delete animate.y;\n\n      return (\n        <g ref={rect}>\n          <motion.rect\n            className={classNames(extras.className)}\n            style={{\n              ...extras.style,\n              ...generateGlowStyles({\n                glow,\n                colorSchemeColor: currentColorShade\n              }),\n              cursor\n            }}\n            mask={maskPath}\n            rx={rx}\n            ry={ry}\n            initial={initial}\n            animate={animate}\n            exit={initial}\n            transition={transition}\n            onMouseEnter={onMouseEnterInternal}\n            onMouseLeave={onMouseLeaveInternal}\n            onClick={onMouseClick}\n            onMouseMove={onMouseMove}\n            tabIndex={0}\n            aria-label={ariaLabelData}\n            role=\"graphics-document\"\n          />\n        </g>\n      );\n    },\n    [\n      className,\n      cursor,\n      data,\n      getExit,\n      getFill,\n      getTransition,\n      glow,\n      id,\n      mask,\n      onMouseClick,\n      onMouseEnterInternal,\n      onMouseLeaveInternal,\n      onMouseMove,\n      rx,\n      ry,\n      style,\n      tooltipData\n    ]\n  );\n\n  const renderGuideBar = useCallback(() => {\n    if (!guide) {\n      return null;\n    }\n\n    // If we are stacked, only render the first bar\n    if (type === 'stacked' && barIndex !== 0) {\n      return null;\n    }\n\n    // No reason to show them since they are always 100% tall\n    if (type === 'stackedNormalized' || type === 'marimekko') {\n      console.error('Guide bars are not supported for these chart types');\n      return null;\n    }\n\n    const valueScale = isVertical ? yScale : xScale;\n    const [start, end] = valueScale.domain();\n    const attr = isVertical ? 'y' : 'x';\n\n    // For stacked diverging we need to flip the points for positive / negative bars\n    const attrStart = type === 'stackedDiverging' ? '0' : '1';\n    const endPoint = type === 'stackedDiverging' ? start : end;\n    const startPoint =\n      type === 'stackedDiverging' && (data[attr]! as number) > 0\n        ? end\n        : endPoint;\n\n    const coords = getCoords({\n      ...data,\n      [attr]: endPoint,\n      [`${attr}${attrStart}`]: startPoint\n    });\n\n    return (\n      <CloneElement<GuideBarProps>\n        element={guide}\n        {...coords}\n        active={active}\n      />\n    );\n  }, [\n    active,\n    barIndex,\n    data,\n    getCoords,\n    guide,\n    isVertical,\n    type,\n    xScale,\n    yScale\n  ]);\n\n  const isActive = tooltip ? internalActive : active;\n  const stroke = color(data, barIndex);\n  const coords = getCoords(data);\n  const currentColorShade = active\n    ? chroma(stroke).brighten(activeBrightness).hex()\n    : stroke;\n  const rangeLineColor = (rangeLines && rangeLines.props.color) || stroke;\n  const rangeLineColorShade = active\n    ? chroma(rangeLineColor).brighten(activeBrightness)\n    : rangeLineColor;\n  const index = groupIndex !== undefined ? groupIndex : barIndex;\n  const scale = isVertical ? yScale : xScale;\n  const barLabel = isVertical ? tooltipData.y : tooltipData.x;\n  const placement = layout === 'vertical' ? 'top' : 'right';\n\n  return (\n    <Fragment>\n      {renderGuideBar()}\n      {renderBar(currentColorShade, coords, index)}\n      {rangeLines && (\n        <CloneElement<RangeLinesProps>\n          element={rangeLines}\n          {...coords}\n          index={index}\n          data={data}\n          scale={scale}\n          color={rangeLineColorShade}\n          barCount={barCount}\n          animated={animated}\n          layout={layout}\n          type={type}\n        />\n      )}\n      {mask && (\n        <Fragment>\n          <Mask id={`mask-${id}`} fill={`url(#gradient-${id})`} />\n          <CloneElement<MaskProps>\n            element={mask}\n            id={`mask-pattern-${id}`}\n            fill={stroke}\n          />\n        </Fragment>\n      )}\n      {gradient && (\n        <CloneElement<GradientProps>\n          element={gradient}\n          id={`gradient-${id}`}\n          direction={layout}\n          color={currentColorShade}\n        />\n      )}\n      {label && (\n        <CloneElement<BarLabelProps>\n          element={label}\n          {...coords}\n          text={formatValue(barLabel)}\n          index={index}\n          data={data}\n          scale={scale}\n          fill={label.props.fill || currentColorShade}\n          barCount={barCount}\n          animated={animated}\n          layout={layout}\n          type={type}\n        />\n      )}\n      {tooltip && (\n        <CloneElement<ChartTooltipProps>\n          element={tooltip}\n          visible={!!isActive}\n          reference={rect}\n          color={color}\n          value={tooltipData}\n          placement={(tooltip.props as any).placement || placement}\n          data={data}\n        />\n      )}\n    </Fragment>\n  );\n};\n\nBar.defaultProps = {\n  activeBrightness: 0.5,\n  rx: 0,\n  ry: 0,\n  cursor: 'auto',\n  rangeLines: null,\n  label: null,\n  tooltip: null,\n  layout: 'vertical',\n  guide: null,\n  gradient: <Gradient />\n};\n","import React, {\n  Fragment,\n  ReactElement,\n  useMemo,\n  useRef,\n  FC,\n  useState,\n  useCallback\n} from 'react';\nimport { Bar, BarProps, BarType } from './Bar';\nimport {\n  ChartInternalDataShape,\n  ChartInternalNestedDataShape,\n  ChartInternalShallowDataShape,\n  Direction\n} from '../../common/data';\nimport { getColor, ColorSchemeType } from '../../common/color';\nimport { CloneElement } from 'reablocks';\nimport {\n  TooltipAreaProps,\n  TooltipArea,\n  ChartTooltip,\n  TooltipAreaEvent\n} from '../../common/Tooltip';\nimport { LinearValueMarker, LinearValueMarkerProps } from '../../common';\n\ntype BarElement = ReactElement<BarProps, typeof Bar>;\n\nexport interface BarSeriesProps {\n  /**\n   * Parsed data shape. Set internally by `BarChart`.\n   */\n  data: ChartInternalDataShape[];\n\n  /**\n   * Id of the bar chart. Set internally by `BarChart`.\n   */\n  id: string;\n\n  /**\n   * D3 scale for X Axis. Set internally by `BarChart`.\n   */\n  xScale: any;\n\n  /**\n   * D3 scale for Y Axis. Set internally by `BarChart`.\n   */\n  yScale: any;\n\n  /**\n   * D3 scale for X Multi-Group Axis. Set internally by `BarChart`.\n   */\n  xScale1: any;\n\n  /**\n   * Bar element.\n   */\n  bar: BarElement | BarElement[];\n\n  /**\n   * Type of the chart.\n   */\n  type: BarType;\n\n  /**\n   * Color scheme for the chart.\n   */\n  colorScheme: ColorSchemeType;\n\n  /**\n   * Whether the chart is animated or not.\n   */\n  animated: boolean;\n\n  /**\n   * Amount of padding between each bar.\n   */\n  padding: number;\n\n  /**\n   * Amount of padding between each group.\n   */\n  groupPadding: number;\n\n  /**\n   * Whether the chart is categorical or not. Set internally by `BarChart`.\n   */\n  isCategorical: boolean;\n\n  /**\n   * Direction of the chart\n   */\n  layout: Direction;\n\n  /**\n   * The size of each bin/bucket in the bar chart.\n   */\n  binSize?: number;\n\n  /**\n   * Height of the chart. Set internally by `BarChart`.\n   */\n  height: number;\n\n  /**\n   * Width of the chart. Set internally by `BarChart`.\n   */\n  width: number;\n\n  /**\n   * Tooltip for the chart area.\n   */\n  tooltip: ReactElement<TooltipAreaProps, typeof TooltipArea> | null;\n\n  /**\n   * Value markers line for the chart.\n   */\n  valueMarkers:\n    | ReactElement<LinearValueMarkerProps, typeof LinearValueMarker>[]\n    | null;\n}\n\nexport const BarSeries: FC<Partial<BarSeriesProps>> = ({\n  data,\n  tooltip,\n  xScale,\n  yScale,\n  height,\n  width,\n  colorScheme,\n  xScale1,\n  bar,\n  padding,\n  animated,\n  isCategorical,\n  layout,\n  type,\n  id,\n  valueMarkers\n}) => {\n  const ref = useRef<any | null>(null);\n  const [activeValues, setActiveValues] = useState<any | null>(null);\n  const isVertical = useMemo(() => layout === 'vertical', [layout]);\n\n  const isMultiSeries = useMemo(() => {\n    return (\n      type === 'grouped' ||\n      type === 'stacked' ||\n      type === 'marimekko' ||\n      type === 'stackedNormalized' ||\n      type === 'stackedDiverging'\n    );\n  }, [type]);\n\n  const getTransform = useCallback(\n    (data: ChartInternalNestedDataShape) => {\n      let xPos = 0;\n      let yPos = 0;\n      if (type !== 'marimekko') {\n        if (layout === 'vertical') {\n          const val = xScale(data.key);\n          xPos = val;\n        } else {\n          const val = yScale(data.key);\n          yPos = val;\n        }\n      }\n\n      return `translate(${xPos}, ${yPos})`;\n    },\n    [layout, type, xScale, yScale]\n  );\n\n  const getBarColor = useCallback(\n    (point, index: number) => {\n      let key = 'key';\n      if (isMultiSeries) {\n        if (layout === 'vertical') {\n          key = 'x';\n        } else {\n          key = 'y';\n        }\n      }\n\n      // histograms...\n      if (point[key] === undefined) {\n        key = 'x0';\n      }\n\n      return getColor({\n        colorScheme,\n        point,\n        index,\n        data,\n        isMultiSeries,\n        attribute: key\n      });\n    },\n    [colorScheme, data, isMultiSeries, layout]\n  );\n\n  const onMouseMove = useCallback((event) => {\n    // Manuallly call mouse move so we don't have to kill bar pointer events\n    ref.current?.triggerMouseMove(event);\n  }, []);\n\n  const onValueEnter = useCallback((event: TooltipAreaEvent) => {\n    setActiveValues(event.value);\n  }, []);\n\n  const onValueLeave = useCallback(() => {\n    setActiveValues(null);\n  }, []);\n\n  const renderBar = useCallback(\n    (\n      data: ChartInternalShallowDataShape,\n      barIndex: number,\n      barCount: number,\n      groupIndex?: number\n    ) => {\n      const active = activeValues && activeValues.x === data.key;\n\n      let newYScale = yScale;\n      let newXScale = xScale;\n\n      if (xScale1) {\n        if (isVertical) {\n          newXScale = xScale1;\n        } else {\n          newYScale = xScale1;\n        }\n      }\n\n      // Histograms dont have keys\n      let key = barIndex.toString();\n      if (data.key) {\n        key = `${data.key!.toString()}-${groupIndex}-${data.x}`;\n      }\n\n      let barElements = Array.isArray(bar) ? bar[barIndex] : bar;\n      if (!bar) {\n        barElements = <Bar />;\n      }\n\n      return (\n        <Fragment key={key}>\n          <CloneElement<BarProps>\n            element={barElements}\n            id={`${id}-bar-${groupIndex}-${barIndex}`}\n            animated={animated}\n            active={active}\n            xScale={newXScale}\n            xScale1={xScale1}\n            yScale={newYScale}\n            padding={padding}\n            barCount={barCount}\n            groupIndex={groupIndex}\n            barIndex={barIndex}\n            data={data}\n            isCategorical={isCategorical}\n            color={getBarColor}\n            layout={layout}\n            type={type}\n            onMouseMove={onMouseMove}\n          />\n        </Fragment>\n      );\n    },\n    [\n      activeValues,\n      animated,\n      bar,\n      getBarColor,\n      id,\n      isCategorical,\n      isVertical,\n      layout,\n      onMouseMove,\n      padding,\n      type,\n      xScale,\n      xScale1,\n      yScale\n    ]\n  );\n\n  const renderBarGroup = useCallback(\n    (\n      data: ChartInternalShallowDataShape[],\n      barCount: number,\n      groupIndex?: number\n    ) => {\n      return (\n        <Fragment>\n          {data.map((barData, barIndex) =>\n            renderBar(barData, barIndex, barCount, groupIndex)\n          )}\n        </Fragment>\n      );\n    },\n    [renderBar]\n  );\n\n  const renderValueMarkers = useCallback(\n    () => (\n      <>\n        {valueMarkers?.length &&\n          valueMarkers.map((marker) => (\n            <CloneElement<LinearValueMarkerProps>\n              key={marker.key}\n              element={marker}\n              size={layout === 'vertical' ? width : height}\n              value={\n                layout === 'vertical'\n                  ? yScale(marker.props.value)\n                  : xScale(marker.props.value)\n              }\n              isHorizontal={layout === 'vertical'}\n            />\n          ))}\n      </>\n    ),\n    [height, layout, valueMarkers, width, xScale, yScale]\n  );\n\n  return (\n    <CloneElement<TooltipAreaProps>\n      element={tooltip}\n      childRef={ref}\n      xScale={xScale}\n      yScale={yScale}\n      data={data}\n      height={height}\n      width={width}\n      inverse={false}\n      isHorizontal={layout === 'horizontal'}\n      color={getBarColor}\n      onValueEnter={onValueEnter}\n      onValueLeave={onValueLeave}\n      isContinous={false}\n    >\n      {isMultiSeries &&\n        (data as ChartInternalNestedDataShape[]).map((groupData, index) => (\n          <g transform={getTransform(groupData)} key={`bar-group-${index}`}>\n            {renderBarGroup(\n              groupData.data as ChartInternalShallowDataShape[],\n              data.length,\n              index\n            )}\n          </g>\n        ))}\n      {!isMultiSeries &&\n        renderBarGroup(data as ChartInternalShallowDataShape[], data.length)}\n      {renderValueMarkers()}\n    </CloneElement>\n  );\n};\n\nBarSeries.defaultProps = {\n  type: 'standard',\n  padding: 0.1,\n  groupPadding: 16,\n  animated: true,\n  tooltip: (\n    <TooltipArea\n      tooltip={\n        <ChartTooltip\n          followCursor={true}\n          modifiers={{\n            offset: '5px, 5px'\n          }}\n        />\n      }\n    />\n  ),\n  colorScheme: 'cybertron',\n  bar: <Bar />,\n  layout: 'vertical'\n};\n","import React, { FC, useMemo } from 'react';\nimport { ChartInternalShallowDataShape, Direction } from '../../common/data';\nimport { motion } from 'framer-motion';\nimport { DEFAULT_TRANSITION } from '../../common/Motion';\nimport { BarType } from './Bar';\n\nexport interface RangeLinesProps {\n  /**\n   * Height of the bar.\n   */\n  height: number;\n\n  /**\n   * Width of the bar.\n   */\n  width: number;\n\n  /**\n   * SVG x attribute for the bar.\n   */\n  x: number;\n\n  /**\n   * SVG y attribute for the bar.\n   */\n  y: number;\n\n  /**\n   * Group index or index of the bar. Set internally by `BarSeries`.\n   */\n  index: number;\n\n  /**\n   * Stroke width of the range line.\n   */\n  strokeWidth: number;\n\n  /**\n   * D3 scale for Axis. Set internally by `BarChart`.\n   */\n  scale: any;\n\n  /**\n   * Position of the range line.\n   */\n  position: 'top' | 'bottom';\n\n  /**\n   * Parsed data shape. Set internally by `BarChart`.\n   */\n  data: ChartInternalShallowDataShape;\n\n  /**\n   * Color for the range line.\n   */\n  color: string;\n\n  /**\n   * Total number of bars used for animation. Set internally by `BarSeries`.\n   */\n  barCount: number;\n\n  /**\n   * Direction of the chart. Set internally by `BarSeries`.\n   */\n  layout: Direction;\n\n  /**\n   * Whether to animate the enter/update/exit. Set internally by `BarSeries`.\n   */\n  animated: boolean;\n\n  /**\n   * Type of bar chart. Set internally by `BarSeries`.\n   */\n  type: BarType;\n}\n\nexport const RangeLines: FC<Partial<RangeLinesProps>> = ({\n  layout,\n  color,\n  x,\n  y,\n  scale,\n  type,\n  height,\n  position,\n  strokeWidth,\n  width,\n  animated,\n  index,\n  barCount,\n  data\n}) => {\n  const isVertical = useMemo(() => layout === 'vertical', [layout]);\n  const rangeLineHeight = useMemo(\n    () => Math.min(strokeWidth, isVertical ? height : width),\n    [height, isVertical, strokeWidth, width]\n  );\n\n  const [newWidth, newHeight] = useMemo(\n    () => [\n      isVertical ? width : rangeLineHeight,\n      isVertical ? rangeLineHeight : height\n    ],\n    [height, isVertical, rangeLineHeight, width]\n  );\n\n  const enterProps = useMemo(() => {\n    let newY = y;\n    let newX = x;\n\n    // If its diverging and the value is negative, we\n    // need to reverse the type...\n    const isTop = position === 'top';\n    const direction = isVertical\n      ? (data.y as number) < 0 && isTop\n        ? 'bottom'\n        : position\n      : (data.x0 as number) < 0 && isTop\n        ? 'bottom'\n        : position;\n\n    if (isVertical) {\n      if (direction === 'top') {\n        newY = y;\n      } else {\n        newY = y + height - rangeLineHeight;\n      }\n    } else {\n      if (direction === 'top') {\n        newX = x + width - rangeLineHeight;\n      } else {\n        newX = x;\n      }\n    }\n\n    return {\n      x: newX,\n      y: newY,\n      opacity: 1\n    };\n  }, [\n    data.x0,\n    data.y,\n    height,\n    isVertical,\n    position,\n    rangeLineHeight,\n    width,\n    x,\n    y\n  ]);\n\n  const exitProps = useMemo(() => {\n    let newY = y;\n    let newX = x;\n\n    if (isVertical) {\n      const maxY = Math.max(...scale.range());\n      if (position === 'top') {\n        newY = maxY;\n      } else {\n        newY = maxY + height - rangeLineHeight;\n      }\n    } else {\n      const minX = Math.min(...scale.range());\n      if (position === 'top') {\n        newX = minX;\n      } else {\n        newX = minX + width - rangeLineHeight;\n      }\n    }\n\n    if (type === 'stackedDiverging') {\n      if (isVertical) {\n        newY = newY / 2;\n      } else {\n        newX = newX / 2;\n      }\n    }\n\n    return {\n      y: newY,\n      x: newX,\n      opacity: 0\n    };\n  }, [height, isVertical, position, rangeLineHeight, scale, type, width, x, y]);\n\n  const delay = useMemo(() => {\n    let delay = 0;\n    if (animated) {\n      if (layout === 'vertical') {\n        return (index / barCount) * 0.5;\n      } else {\n        return ((barCount - index) / barCount) * 0.5;\n      }\n    }\n\n    return delay;\n  }, [animated, barCount, index, layout]);\n\n  // UGH: https://github.com/framer/motion/issues/384\n  const initial = useMemo(() => {\n    const r = {\n      ...exitProps,\n      attrX: exitProps.x,\n      attrY: exitProps.y\n    };\n\n    delete r.x;\n    delete r.y;\n\n    return r;\n  }, [exitProps]);\n\n  const animate = useMemo(() => {\n    const r = {\n      ...enterProps,\n      attrX: enterProps.x,\n      attrY: enterProps.y\n    };\n\n    delete r.x;\n    delete r.y;\n\n    return r;\n  }, [enterProps]);\n\n  return (\n    <motion.rect\n      pointerEvents=\"none\"\n      fill={color}\n      width={newWidth}\n      height={newHeight}\n      initial={initial}\n      animate={animate}\n      exit={initial}\n      transition={{\n        ...DEFAULT_TRANSITION,\n        delay\n      }}\n    />\n  );\n};\n\nRangeLines.defaultProps = {\n  position: 'top',\n  strokeWidth: 1,\n  layout: 'vertical'\n};\n","import React, { FC } from 'react';\nimport { BarSeriesProps, BarSeries } from './BarSeries';\nimport { Bar } from './Bar';\nimport { RangeLines } from './RangeLines';\nimport { Gradient, GradientStop } from '../../common';\n\nexport const StackedBarSeries: FC<Partial<BarSeriesProps>> = (props) => (\n  <BarSeries type=\"stackedNormalized\" {...props} />\n);\n\nStackedBarSeries.defaultProps = {\n  ...BarSeries.defaultProps,\n  type: 'stacked',\n  bar: (\n    <Bar\n      gradient={\n        <Gradient\n          stops={[\n            <GradientStop offset=\"5%\" stopOpacity={0.1} key=\"start\" />,\n            <GradientStop offset=\"90%\" stopOpacity={0.7} key=\"stop\" />\n          ]}\n        />\n      }\n      rangeLines={<RangeLines position=\"top\" strokeWidth={3} />}\n    />\n  )\n};\n","import React, { FC } from 'react';\nimport { BarSeriesProps, BarSeries } from './BarSeries';\nimport { Bar } from './Bar';\nimport { RangeLines } from './RangeLines';\nimport {\n  ChartTooltip,\n  TooltipTemplate,\n  TooltipArea\n} from '../../common/Tooltip';\nimport { formatValue } from '../../common/utils/formatting';\nimport { Gradient, GradientStop } from '../../common/Gradient';\n\nexport const StackedNormalizedBarSeries: FC<Partial<BarSeriesProps>> = (\n  props\n) => <BarSeries type=\"stackedNormalized\" {...props} />;\n\nStackedNormalizedBarSeries.defaultProps = {\n  ...BarSeries.defaultProps,\n  type: 'stackedNormalized',\n  tooltip: (\n    <TooltipArea\n      tooltip={\n        <ChartTooltip\n          followCursor={true}\n          modifiers={{\n            offset: '5px, 5px'\n          }}\n          content={(point, color) => {\n            point.data = point.data.map((d) => {\n              // Handle horz case\n              const start = isNaN(d.y0) ? d.x0 : d.y0;\n              const end = isNaN(d.y1) ? d.x1 : d.y1;\n\n              return {\n                ...d,\n                value: `${formatValue(Math.floor((end - start) * 100))}%`\n              };\n            });\n\n            return <TooltipTemplate value={point} color={color} />;\n          }}\n        />\n      }\n    />\n  ),\n  bar: (\n    <Bar\n      gradient={\n        <Gradient\n          stops={[\n            <GradientStop offset=\"5%\" stopOpacity={0.1} key=\"start\" />,\n            <GradientStop offset=\"90%\" stopOpacity={0.7} key=\"stop\" />\n          ]}\n        />\n      }\n      rangeLines={<RangeLines position=\"top\" strokeWidth={3} />}\n    />\n  )\n};\n","import React, { FC } from 'react';\nimport { BarSeriesProps, BarSeries } from './BarSeries';\nimport { Bar } from './Bar';\nimport { RangeLines } from './RangeLines';\nimport {\n  ChartTooltip,\n  TooltipTemplate,\n  TooltipArea\n} from '../../common/Tooltip';\nimport { formatValue } from '../../common/utils/formatting';\nimport { Gradient, GradientStop } from '../../common/Gradient';\n\nexport const MarimekkoBarSeries: FC<Partial<BarSeriesProps>> = (props) => (\n  <BarSeries type=\"marimekko\" {...props} />\n);\n\nMarimekkoBarSeries.defaultProps = {\n  ...BarSeries.defaultProps,\n  type: 'marimekko',\n  padding: 10,\n  tooltip: (\n    <TooltipArea\n      tooltip={\n        <ChartTooltip\n          followCursor={true}\n          modifiers={{\n            offset: '5px, 5px'\n          }}\n          content={(point, color) => {\n            const data = {\n              ...point,\n              data: point.data.map((d) => ({\n                ...d,\n                value: `${formatValue(d.value)}  ${formatValue(\n                  Math.floor((d.y1 - d.y0) * 100)\n                )}%`\n              }))\n            };\n\n            return <TooltipTemplate value={data} color={color} />;\n          }}\n        />\n      }\n    />\n  ),\n  bar: (\n    <Bar\n      padding={10}\n      gradient={\n        <Gradient\n          stops={[\n            <GradientStop offset=\"5%\" stopOpacity={0.1} key=\"start\" />,\n            <GradientStop offset=\"90%\" stopOpacity={0.7} key=\"stop\" />\n          ]}\n        />\n      }\n      rangeLines={<RangeLines position=\"top\" strokeWidth={3} />}\n    />\n  )\n};\n","import React, { FC, useMemo } from 'react';\nimport { ChartInternalShallowDataShape, Direction } from '../../common/data';\nimport { BarType } from './Bar';\nimport { motion } from 'framer-motion';\nimport { DEFAULT_TRANSITION } from '../../common/Motion';\n\nexport interface BarLabelProps {\n  /**\n   * Text of the label. Set internally by `Bar`.\n   */\n  text: string;\n\n  /**\n   * Height of the bar.\n   */\n  height: number;\n\n  /**\n   * Width of the bar.\n   */\n  width: number;\n\n  /**\n   * SVG x attribute for the bar.\n   */\n  x: number;\n\n  /**\n   * SVG y attribute for the bar.\n   */\n  y: number;\n\n  /**\n   * Group index or index of the bar. Set internally by `BarSeries`.\n   */\n  index: number;\n\n  /**\n   * D3 scale for Axis. Set internally by `BarChart`.\n   */\n  scale: any;\n\n  /**\n   * Position of the label.\n   */\n  position: 'top' | 'center' | 'bottom';\n\n  /**\n   * Parsed data shape. Set internally by `BarChart`.\n   */\n  data: ChartInternalShallowDataShape;\n\n  /**\n   * Color of the text.\n   */\n  fill: string;\n\n  /**\n   * Number of the bars in the bar group. Set internally by `BarSeries`.\n   */\n  barCount: number;\n\n  /**\n   * Layout of bar chart to render. Set internally by `BarSeries`.\n   */\n  layout: Direction;\n\n  /**\n   * Whether to animate the enter/update/exit. Set internally by `BarSeries`.\n   */\n  animated: boolean;\n\n  /**\n   * Type of bar chart to render. Set internally by `BarSeries`.\n   */\n  type: BarType;\n\n  /**\n   * Font size of the text.\n   */\n  fontSize: number;\n\n  /**\n   * Font family of the text.\n   */\n  fontFamily: string;\n\n  /**\n   * Padding of the label.\n   */\n  padding: number;\n\n  /**\n   * Class name to apply to the text.\n   */\n  className?: any;\n}\n\nexport const BarLabel: FC<Partial<BarLabelProps>> = ({\n  fontSize,\n  fontFamily,\n  fill,\n  layout,\n  className,\n  text,\n  x,\n  y,\n  height,\n  position,\n  width,\n  data,\n  padding,\n  scale,\n  type,\n  animated,\n  index,\n  barCount\n}) => {\n  const isVertical = useMemo(() => layout === 'vertical', [layout]);\n  const textAnchor = isVertical ? 'middle' : 'start';\n\n  const enterProps = useMemo(() => {\n    let newY = y;\n    let newX = x;\n\n    // If its diverging and the value is negative, we\n    // need to reverse the type...\n    const isTop = position === 'top';\n    const direction = isVertical\n      ? (data.y as number) < 0 && isTop\n        ? 'bottom'\n        : position\n      : (data.x0 as number) < 0 && isTop\n        ? 'bottom'\n        : position;\n\n    if (isVertical) {\n      if (direction === 'top') {\n        newY = y - padding;\n      } else if (direction === 'center') {\n        newY = y + height / 2;\n      } else if (direction === 'bottom') {\n        newY = y + height - padding;\n      }\n      newX = newX + width / 2;\n    } else {\n      if (direction === 'top') {\n        newX = x + width + padding;\n      } else if (direction === 'center') {\n        newX = x + width / 2;\n      } else if (direction === 'bottom') {\n        newX = x + padding;\n      }\n      newY = newY + height / 2;\n    }\n\n    return {\n      translateX: newX,\n      translateY: newY,\n      opacity: 1\n    };\n  }, [data.x0, data.y, height, isVertical, padding, position, width, x, y]);\n\n  const exitProps = useMemo(() => {\n    let newY = y;\n    let newX = x;\n\n    if (isVertical) {\n      const maxY = Math.max(...scale.range());\n      if (position === 'top') {\n        newY = maxY;\n      } else {\n        newY = maxY + height + padding;\n      }\n\n      newX = newX + width / 2;\n    } else {\n      const minX = Math.min(...scale.range());\n      if (position === 'top') {\n        newX = minX;\n      } else {\n        newX = minX + width + padding;\n      }\n\n      newY = newY + height / 2;\n    }\n\n    if (type === 'stackedDiverging') {\n      if (isVertical) {\n        newY = newY / 2;\n      } else {\n        newX = newX / 2;\n      }\n    }\n\n    return {\n      translateY: newY,\n      translateX: newX,\n      opacity: 0\n    };\n  }, [height, isVertical, padding, position, scale, type, width, x, y]);\n\n  const delay = useMemo(() => {\n    let delay = 0;\n    if (animated) {\n      if (layout === 'vertical') {\n        return (index / barCount) * 0.5;\n      } else {\n        return ((barCount - index) / barCount) * 0.5;\n      }\n    }\n\n    return delay;\n  }, [animated, barCount, index, layout]);\n\n  return (\n    <motion.g\n      initial={exitProps}\n      animate={enterProps}\n      exit={exitProps}\n      transition={{\n        ...DEFAULT_TRANSITION,\n        delay\n      }}\n      fontSize={fontSize}\n      fontFamily={fontFamily}\n    >\n      <text fill={fill} className={className} textAnchor={textAnchor}>\n        {text}\n      </text>\n    </motion.g>\n  );\n};\n\nBarLabel.defaultProps = {\n  position: 'top',\n  layout: 'vertical',\n  fontSize: 13,\n  padding: 5,\n  fontFamily: 'sans-serif',\n  fill: '#000'\n};\n","import React, { FC } from 'react';\nimport { BarSeriesProps, BarSeries } from './BarSeries';\nimport {\n  ChartTooltip,\n  TooltipTemplate,\n  TooltipArea\n} from '../../common/Tooltip';\nimport { formatValue } from '../../common/utils/formatting';\nimport { schemes } from '../../common/color';\n\nexport const HistogramBarSeries: FC<Partial<BarSeriesProps>> = ({\n  type,\n  ...rest\n}) => <BarSeries {...rest} />;\n\nHistogramBarSeries.defaultProps = {\n  ...BarSeries.defaultProps,\n  colorScheme: schemes.cybertron[0],\n  tooltip: (\n    <TooltipArea\n      tooltip={\n        <ChartTooltip\n          followCursor={true}\n          modifiers={{\n            offset: '5px, 5px'\n          }}\n          content={(point, color) => {\n            const data = {\n              ...point,\n              x: `${formatValue(point.x0)} - ${formatValue(point.x1)}`,\n              value: point.y\n            };\n\n            return <TooltipTemplate value={data} color={color} />;\n          }}\n        />\n      }\n    />\n  )\n};\n","import React, { FC } from 'react';\nimport { motion } from 'framer-motion';\n\nexport interface GuideBarProps extends SVGRect {\n  active: boolean;\n  fill?: string;\n  opacity?: number;\n}\n\nexport const GuideBar: FC<Partial<GuideBarProps>> = ({\n  active,\n  opacity = 0.15,\n  ...rest\n}) => {\n  const { x, y, ...other } = rest;\n\n  return (\n    <motion.rect\n      {...other}\n      pointerEvents=\"none\"\n      initial=\"hidden\"\n      animate={active ? 'visible' : 'hidden'}\n      variants={{\n        hidden: { opacity: 0, attrX: x, attrY: y },\n        visible: { opacity, attrX: x, attrY: y }\n      }}\n    />\n  );\n};\n\nGuideBar.defaultProps = {\n  fill: '#eee',\n  opacity: 0.15\n};\n","import React, { Fragment, ReactElement, FC, useMemo, useCallback } from 'react';\nimport classNames from 'classnames';\nimport {\n  isAxisVisible,\n  LinearAxisProps,\n  LinearXAxisTickSeries,\n  LinearXAxis,\n  LinearYAxis,\n  LinearAxis\n} from '../common/Axis';\nimport { BarSeries, BarSeriesProps } from './BarSeries';\nimport {\n  ChartDataShape,\n  ChartNestedDataShape,\n  buildBarStackData,\n  buildMarimekkoData,\n  buildWaterfall,\n  ChartShallowDataShape,\n  buildNestedChartData,\n  buildShallowChartData,\n  StackTypes\n} from '../common/data';\nimport { GridlineSeries, GridlineSeriesProps } from '../common/Gridline';\nimport {\n  getXScale,\n  getYScale,\n  getGroupScale,\n  getInnerScale,\n  getMarimekkoScale,\n  getMarimekkoGroupScale\n} from '../common/scales';\nimport { ChartBrushProps, ChartBrush } from '../common/Brush';\nimport css from './BarChart.module.css';\nimport {\n  ChartContainer,\n  ChartContainerChildProps,\n  ChartProps\n} from '../common/containers/ChartContainer';\nimport { CloneElement } from 'reablocks';\n\nexport interface BarChartProps extends ChartProps {\n  /**\n   * Data the chart will receive to render.\n   */\n  data: ChartDataShape[];\n\n  /**\n   * The series component that renders the bar components.\n   */\n  series: ReactElement<BarSeriesProps, typeof BarSeries>;\n\n  /**\n   * The linear axis component for the Y Axis of the chart.\n   */\n  yAxis: ReactElement<LinearAxisProps, typeof LinearAxis>;\n\n  /**\n   * The linear axis component for the X Axis of the chart.\n   */\n  xAxis: ReactElement<LinearAxisProps, typeof LinearAxis>;\n\n  /**\n   * The chart's background gridlines component.\n   */\n  gridlines: ReactElement<GridlineSeriesProps, typeof GridlineSeries> | null;\n\n  /**\n   * The chart's brush component.\n   */\n  brush: ReactElement<ChartBrushProps, typeof ChartBrush> | null;\n\n  /**\n   * Any secondary axis components. Useful for multi-axis charts.\n   */\n  secondaryAxis?: ReactElement<LinearAxisProps, typeof LinearAxis>[];\n}\n\nexport const BarChart: FC<Partial<BarChartProps>> = ({\n  id,\n  width,\n  height,\n  margins,\n  className,\n  data,\n  xAxis,\n  yAxis,\n  series,\n  brush,\n  gridlines,\n  secondaryAxis,\n  containerClassName\n}) => {\n  const isVertical = useMemo(\n    () => series.props.layout === 'vertical',\n    [series]\n  );\n  const keyAxis = useMemo(\n    () => (isVertical ? xAxis : yAxis),\n    [yAxis, xAxis, isVertical]\n  );\n  const isDiverging = useMemo(\n    () => series.props.type === 'stackedDiverging',\n    [series.props.type]\n  );\n\n  const getMarimekkoGroupScales = useCallback(\n    (aggregatedData, axis, width: number) => {\n      const keyScale = getMarimekkoScale(width, axis.props.roundDomains);\n\n      const groupScale = getMarimekkoGroupScale({\n        width,\n        padding: series.props.padding,\n        data: aggregatedData,\n        valueScale: keyScale\n      });\n\n      return {\n        keyScale,\n        groupScale\n      };\n    },\n    [series.props.padding]\n  );\n\n  const getMultiGroupScales = useCallback(\n    (aggregatedData, height: number, width: number) => {\n      const { groupPadding, layout } = series.props;\n\n      const groupScale = getGroupScale({\n        dimension: isVertical ? width : height,\n        direction: layout,\n        padding: groupPadding,\n        data: aggregatedData\n      });\n\n      const keyScale = getInnerScale({\n        groupScale: groupScale,\n        padding: series.props.padding,\n        data: aggregatedData,\n        prop: isVertical ? 'x' : 'y'\n      });\n\n      return {\n        groupScale,\n        keyScale\n      };\n    },\n    [isVertical, series.props]\n  );\n\n  const getKeyScale = useCallback(\n    (aggregatedData, axis, isMultiSeries: boolean, width: number) => {\n      return getXScale({\n        width,\n        type: axis.props.type,\n        roundDomains: axis.props.roundDomains,\n        data: aggregatedData,\n        padding: series.props.padding,\n        domain: axis.props.domain,\n        isMultiSeries,\n        isDiverging\n      });\n    },\n    [isDiverging, series]\n  );\n\n  const getValueScale = useCallback(\n    (aggregatedData, axis, isMultiSeries: boolean, height: number) => {\n      return getYScale({\n        roundDomains: axis.props.roundDomains,\n        padding: series.props.padding,\n        type: axis.props.type,\n        height,\n        data: aggregatedData,\n        domain: axis.props.domain,\n        isMultiSeries,\n        isDiverging\n      });\n    },\n    [isDiverging, series]\n  );\n\n  const getScalesAndData = useCallback(\n    (chartHeight: number, chartWidth: number) => {\n      const { type, layout } = series.props;\n      const isMarimekko = type === 'marimekko';\n      const isGrouped = type === 'grouped';\n      const isStacked =\n        type === 'stacked' ||\n        type === 'stackedNormalized' ||\n        type === 'stackedDiverging';\n      const isMultiSeries = isGrouped || isStacked;\n\n      let aggregatedData;\n      if (isStacked) {\n        let distroType: StackTypes = 'default';\n        if (type === 'stackedNormalized') {\n          distroType = 'expand';\n        } else if (type === 'stackedDiverging') {\n          distroType = 'diverging';\n        }\n\n        aggregatedData = buildBarStackData(\n          data as ChartNestedDataShape[],\n          distroType,\n          layout\n        );\n      } else if (type === 'waterfall') {\n        aggregatedData = buildWaterfall(\n          data as ChartShallowDataShape[],\n          layout,\n          series.props.binSize\n        );\n      } else if (isMarimekko) {\n        aggregatedData = buildMarimekkoData(data as ChartNestedDataShape[]);\n      } else if (isGrouped) {\n        aggregatedData = buildNestedChartData(\n          data as ChartNestedDataShape[],\n          false,\n          layout\n        );\n      } else {\n        aggregatedData = buildShallowChartData(\n          data as ChartShallowDataShape[],\n          layout,\n          series.props.binSize\n        );\n      }\n\n      let yScale;\n      let xScale;\n      let xScale1;\n\n      if (isVertical) {\n        if (isGrouped) {\n          const { keyScale, groupScale } = getMultiGroupScales(\n            aggregatedData,\n            chartHeight,\n            chartWidth\n          );\n          xScale = groupScale;\n          xScale1 = keyScale;\n        } else if (isMarimekko) {\n          const { keyScale, groupScale } = getMarimekkoGroupScales(\n            aggregatedData,\n            xAxis,\n            chartWidth\n          );\n          xScale = groupScale;\n          xScale1 = keyScale;\n        } else {\n          xScale = getKeyScale(\n            aggregatedData,\n            xAxis,\n            isMultiSeries,\n            chartWidth\n          );\n        }\n\n        yScale = getValueScale(\n          aggregatedData,\n          yAxis,\n          isMultiSeries,\n          chartHeight\n        );\n      } else {\n        if (isGrouped) {\n          const { keyScale, groupScale } = getMultiGroupScales(\n            aggregatedData,\n            chartHeight,\n            chartWidth\n          );\n          yScale = groupScale;\n          xScale1 = keyScale;\n          xScale = getKeyScale(\n            aggregatedData,\n            xAxis,\n            isMultiSeries,\n            chartWidth\n          );\n        } else if (isMarimekko) {\n          throw new Error(\n            'Marimekko is currently not supported for horizontal layouts'\n          );\n        } else {\n          xScale = getKeyScale(\n            aggregatedData,\n            xAxis,\n            isMultiSeries,\n            chartWidth\n          );\n          yScale = getValueScale(\n            aggregatedData,\n            yAxis,\n            isMultiSeries,\n            chartHeight\n          );\n        }\n      }\n\n      return { xScale, xScale1, yScale, aggregatedData };\n    },\n    [\n      getKeyScale,\n      data,\n      getMarimekkoGroupScales,\n      getMultiGroupScales,\n      getValueScale,\n      isVertical,\n      series.props,\n      xAxis,\n      yAxis\n    ]\n  );\n\n  const renderChart = useCallback(\n    (containerProps: ChartContainerChildProps) => {\n      const { chartHeight, chartWidth, id, updateAxes, chartSized } =\n        containerProps;\n      const { xScale, xScale1, yScale, aggregatedData } = getScalesAndData(\n        chartHeight,\n        chartWidth\n      );\n\n      const isCategorical = keyAxis.props.type === 'category';\n      const disableBrush = aggregatedData.length <= 1;\n\n      return (\n        <Fragment>\n          {chartSized && gridlines && (\n            <CloneElement<GridlineSeriesProps>\n              element={gridlines}\n              height={chartHeight}\n              width={chartWidth}\n              yScale={yScale}\n              xScale={xScale}\n              yAxis={yAxis.props}\n              xAxis={xAxis.props}\n            />\n          )}\n          <CloneElement<LinearAxisProps>\n            element={xAxis}\n            height={chartHeight}\n            width={chartWidth}\n            scale={xScale}\n            visibility={chartSized ? 'visible' : 'hidden'}\n            onDimensionsChange={(event) =>\n              updateAxes(isVertical ? 'horizontal' : 'vertical', event)\n            }\n          />\n          <CloneElement<LinearAxisProps>\n            element={yAxis}\n            height={chartHeight}\n            width={chartWidth}\n            scale={yScale}\n            visibility={chartSized ? 'visible' : 'hidden'}\n            onDimensionsChange={(event) =>\n              updateAxes(isVertical ? 'vertical' : 'horizontal', event)\n            }\n          />\n          {secondaryAxis &&\n            secondaryAxis.map((axis, i) => (\n              <CloneElement<LinearAxisProps>\n                key={i}\n                element={axis}\n                height={chartHeight}\n                width={chartWidth}\n                visibility={chartSized ? 'visible' : 'hidden'}\n                onDimensionsChange={(event) => updateAxes('horizontal', event)}\n              />\n            ))}\n          {chartSized && (\n            <CloneElement<ChartBrushProps>\n              disabled={disableBrush}\n              element={brush}\n              height={chartHeight}\n              width={chartWidth}\n              scale={xScale}\n            >\n              <CloneElement<BarSeriesProps>\n                element={series}\n                id={`bar-series-${id}`}\n                data={aggregatedData}\n                height={chartHeight}\n                width={chartWidth}\n                isCategorical={isCategorical}\n                xScale={xScale}\n                xScale1={xScale1}\n                yScale={yScale}\n              />\n            </CloneElement>\n          )}\n        </Fragment>\n      );\n    },\n    [\n      brush,\n      getScalesAndData,\n      gridlines,\n      isVertical,\n      keyAxis,\n      secondaryAxis,\n      series,\n      xAxis,\n      yAxis\n    ]\n  );\n\n  return (\n    <ChartContainer\n      id={id}\n      width={width}\n      height={height}\n      margins={margins}\n      containerClassName={containerClassName}\n      xAxisVisible={isAxisVisible(xAxis.props)}\n      yAxisVisible={isAxisVisible(yAxis.props)}\n      className={classNames(css.barChart, className, css[series.props.type])}\n    >\n      {renderChart}\n    </ChartContainer>\n  );\n};\n\nBarChart.defaultProps = {\n  data: [],\n  xAxis: (\n    <LinearXAxis\n      type=\"category\"\n      tickSeries={<LinearXAxisTickSeries tickSize={20} />}\n    />\n  ),\n  yAxis: <LinearYAxis type=\"value\" />,\n  series: <BarSeries />,\n  gridlines: <GridlineSeries />,\n  brush: null\n};\n","import React, { FC } from 'react';\nimport { BarChart, BarChartProps } from './BarChart';\nimport { ChartNestedDataShape } from '../common/data';\nimport { MarimekkoBarSeries } from './BarSeries';\nimport {\n  LinearXAxis,\n  LinearXAxisTickSeries,\n  LinearYAxis,\n  LinearYAxisTickSeries,\n  LinearYAxisTickLabel\n} from '../common/Axis/LinearAxis';\n\nexport interface MarimekkoChartProps extends BarChartProps {\n  data: ChartNestedDataShape[];\n}\n\nexport const MarimekkoChart: FC<Partial<MarimekkoChartProps>> = (props) => (\n  <BarChart {...props} />\n);\n\nMarimekkoChart.defaultProps = {\n  series: <MarimekkoBarSeries />,\n  xAxis: (\n    <LinearXAxis\n      type=\"category\"\n      tickSeries={<LinearXAxisTickSeries tickSize={15} />}\n    />\n  ),\n  yAxis: (\n    <LinearYAxis\n      type=\"value\"\n      tickSeries={\n        <LinearYAxisTickSeries\n          label={\n            <LinearYAxisTickLabel\n              rotation={false}\n              format={(data) => `${data * 100}%`}\n            />\n          }\n        />\n      }\n    />\n  )\n};\n","import React, { FC } from 'react';\nimport { BarChart, BarChartProps } from './BarChart';\nimport { ChartNestedDataShape } from '../common/data';\nimport { StackedBarSeries } from './BarSeries';\n\nexport interface StackedBarChartProps extends BarChartProps {\n  data: ChartNestedDataShape[];\n}\n\nexport const StackedBarChart: FC<Partial<StackedBarChartProps>> = (props) => (\n  <BarChart {...props} />\n);\n\nStackedBarChart.defaultProps = {\n  series: <StackedBarSeries />\n};\n","import React, { FC } from 'react';\nimport { ChartNestedDataShape } from '../common/data';\nimport { BarChartProps, BarChart } from './BarChart';\nimport { StackedNormalizedBarSeries } from './BarSeries';\nimport {\n  LinearYAxis,\n  LinearYAxisTickSeries,\n  LinearYAxisTickLabel\n} from '../common/Axis/LinearAxis';\n\nexport interface StackedNormalizedBarChartProps extends BarChartProps {\n  data: ChartNestedDataShape[];\n}\n\nexport const StackedNormalizedBarChart: FC<\n  Partial<StackedNormalizedBarChartProps>\n> = (props) => <BarChart {...props} />;\n\nStackedNormalizedBarChart.defaultProps = {\n  series: <StackedNormalizedBarSeries />,\n  yAxis: (\n    <LinearYAxis\n      type=\"value\"\n      tickSeries={\n        <LinearYAxisTickSeries\n          label={\n            <LinearYAxisTickLabel\n              rotation={false}\n              format={(data) => `${data * 100}%`}\n            />\n          }\n        />\n      }\n    />\n  )\n};\n","import React, { FC } from 'react';\nimport { ChartShallowDataShape } from '../common/data';\nimport { BarChartProps, BarChart } from './BarChart';\nimport { HistogramBarSeries } from './BarSeries';\n\nexport interface HistogramBarChartProps extends BarChartProps {\n  data: ChartShallowDataShape[];\n}\n\nexport const HistogramBarChart: FC<Partial<HistogramBarChartProps>> = (\n  props\n) => <BarChart {...props} />;\n\nHistogramBarChart.defaultProps = {\n  series: <HistogramBarSeries />\n};\n","import React, { FC } from 'react';\nimport { AreaSeries, Line, AreaSeriesProps } from '../AreaChart';\n\nexport type LineSeriesProps = AreaSeriesProps;\n\nexport const LineSeries: FC<Partial<LineSeriesProps>> = (props) => (\n  <AreaSeries {...props} />\n);\n\nLineSeries.defaultProps = {\n  ...AreaSeries.defaultProps,\n  area: null,\n  line: <Line strokeWidth={3} />\n};\n","import React, { FC } from 'react';\nimport { AreaChart, AreaChartProps } from '../AreaChart';\nimport { LineSeries } from './LineSeries';\n\nexport type LineChartProps = AreaChartProps;\n\nexport const LineChart: FC<Partial<LineChartProps>> = (props) => (\n  <AreaChart {...props} />\n);\n\nLineChart.defaultProps = {\n  ...AreaChart.defaultProps,\n  series: <LineSeries />\n};\n","import React, { Fragment, ReactElement, FC, useCallback } from 'react';\nimport {\n  geoNaturalEarth1,\n  geoPath,\n  GeoProjection,\n  GeoPath,\n  geoMercator\n} from 'd3-geo';\nimport {\n  ChartProps,\n  ChartContainer,\n  ChartContainerChildProps\n} from '../common/containers/ChartContainer';\nimport { CloneElement } from 'reablocks';\nimport { MapMarkerProps, MapMarker } from './MapMarker';\nimport { motion } from 'framer-motion';\n\ntype MarkerElement = ReactElement<MapMarkerProps, typeof MapMarker>;\n\nexport interface MapProps extends ChartProps {\n  markers?: MarkerElement[];\n  data: any;\n  fill?: string;\n  /**\n   * Determines how the map transforms spherical geometry to planar geometry\n   */\n  projection?: 'mercator' | 'natural-earth';\n}\n\nexport const Map: FC<MapProps> = ({\n  id,\n  width,\n  height,\n  margins,\n  className,\n  containerClassName,\n  markers,\n  data,\n  fill,\n  projection = 'mercator'\n}) => {\n  const getProjection = useCallback(\n    ({ chartWidth, chartHeight }: ChartContainerChildProps) => {\n      if (projection === 'natural-earth') {\n        return geoNaturalEarth1()\n          .fitSize([chartWidth, chartHeight], data)\n          .center([0, 0]);\n      }\n      return geoMercator()\n        .fitSize([chartWidth, chartHeight], data)\n        .center([0, 35]);\n    },\n    [data, projection]\n  );\n\n  const renderMarker = useCallback(\n    (marker: MarkerElement, index: number, projection: GeoProjection) => {\n      const position = projection(marker.props.coordinates);\n\n      if (!position) {\n        console.warn(\n          `Position for ${marker.props.coordinates.toString()} not found.`\n        );\n        return null;\n      }\n\n      return (\n        <CloneElement<MapMarkerProps>\n          element={marker}\n          cx={position[0]}\n          cy={position[1]}\n          index={index}\n        />\n      );\n    },\n    []\n  );\n\n  const renderCountry = useCallback(\n    (point, index: number, path: GeoPath) => {\n      // Exclude ATA\n      if (point.id === '010') {\n        return null;\n      }\n\n      return <path key={`path-${index}`} d={path(point)!} fill={fill} />;\n    },\n    [fill]\n  );\n\n  const renderChart = useCallback(\n    (containerProps: ChartContainerChildProps) => {\n      if (!data) {\n        return null;\n      }\n\n      const geoProjection = getProjection(containerProps);\n      const path = geoPath().projection(geoProjection);\n\n      return (\n        <motion.g\n          initial={{\n            opacity: 0\n          }}\n          animate={{\n            opacity: 1\n          }}\n        >\n          {data.features.map((point, index) =>\n            renderCountry(point, index, path)\n          )}\n          {markers &&\n            markers.map((marker, index) => (\n              <Fragment key={`marker-${index}`}>\n                {renderMarker(marker, index, geoProjection)}\n              </Fragment>\n            ))}\n        </motion.g>\n      );\n    },\n    [data, getProjection, markers, renderCountry, renderMarker]\n  );\n\n  return (\n    <ChartContainer\n      id={id}\n      width={width}\n      height={height}\n      margins={margins}\n      containerClassName={containerClassName}\n      xAxisVisible={false}\n      yAxisVisible={false}\n      className={className}\n    >\n      {(props) => renderChart(props)}\n    </ChartContainer>\n  );\n};\n\nMap.defaultProps = {\n  fill: 'rgba(255, 255, 255, 0.3)'\n};\n","import React, { Fragment, useRef, useState, FC, useMemo } from 'react';\nimport { Tooltip } from 'reablocks';\nimport { motion } from 'framer-motion';\nimport css from './MapMarker.module.css';\nimport { tooltipTheme } from '../common';\n\nexport interface MapMarkerProps {\n  coordinates: [number, number];\n  index: number;\n  cy?: number;\n  cx?: number;\n  size?: number;\n  tooltip?: any;\n  onClick?: () => void;\n}\n\n// Set padding modifier for the tooltips\nconst modifiers = {\n  offset: {\n    offset: '0, 3px'\n  }\n};\n\nexport const MapMarker: FC<Partial<MapMarkerProps>> = ({\n  size = 3,\n  index,\n  tooltip,\n  cx,\n  cy,\n  onClick = () => undefined\n}) => {\n  const ref = useRef<SVGCircleElement | null>(null);\n  const [active, setActive] = useState<boolean>(false);\n\n  const ariaLabelData = useMemo(\n    () => (typeof tooltip === 'string' ? tooltip : 'map marker'),\n    [tooltip]\n  );\n\n  return (\n    <Fragment>\n      <motion.circle\n        initial={{\n          opacity: 0,\n          scale: 0.02\n        }}\n        animate={{\n          opacity: 1,\n          scale: 1\n        }}\n        transition={{\n          delay: index! * 0.3\n        }}\n        ref={ref}\n        className={css.marker}\n        cx={cx}\n        cy={cy}\n        r={size}\n        onMouseEnter={() => setActive(true)}\n        onMouseLeave={() => setActive(false)}\n        onClick={onClick}\n        tabIndex={0}\n        aria-label={ariaLabelData}\n        role=\"graphics-document\"\n      />\n      {tooltip && (\n        <Tooltip\n          theme={tooltipTheme}\n          visible={active}\n          reference={ref}\n          modifiers={modifiers}\n          content={tooltip}\n        />\n      )}\n    </Fragment>\n  );\n};\n","import { useEffect, useMemo, useRef } from 'react';\nimport { DEFAULT_TRANSITION } from '../../common/Motion';\nimport { useMotionValue, useSpring } from 'framer-motion';\nimport { interpolate } from 'd3-interpolate';\n\nexport const useInterpolate = ({ data, animated, arc }) => {\n  const exit = useMemo(() => {\n    const startAngle = data.startAngle;\n    const endAngle = animated ? startAngle : data.endAngle;\n\n    return {\n      ...data,\n      startAngle,\n      endAngle\n    };\n  }, [data, animated]);\n\n  const prevData = useRef(exit);\n  const d = useMotionValue(exit);\n  const spring = useSpring(0, DEFAULT_TRANSITION);\n\n  useEffect(() => {\n    const interpolator = interpolate(prevData.current, data);\n    const prevSpring = spring.get();\n\n    spring.set(prevSpring + 1);\n\n    return spring.on('change', (v) => {\n      const newData = interpolator(v - prevSpring);\n      prevData.current = newData;\n\n      d.set(arc(newData));\n    });\n  }, [arc, d, data, exit, spring]);\n\n  return d;\n};\n","import { PointerEvent, useCallback, useRef } from 'react';\n\nexport interface HoverIntentOptions {\n  interval?: number;\n  sensitivity?: number;\n  timeout?: number;\n  disabled?: boolean;\n  onPointerOver: (event: PointerEvent<SVGElement>) => void;\n  onPointerOut: (event: PointerEvent<SVGElement>) => void;\n}\n\nexport interface HoverIntentResult {\n  pointerOut: (event: PointerEvent<SVGElement>) => void;\n  pointerOver: (event: PointerEvent<SVGElement>) => void;\n}\n\n/**\n * Hover intent identifies if the user actually is\n * intending to over by measuring the position of the mouse\n * once a pointer enters and determining if in a duration if\n * the mouse moved inside a certain threshold and fires the events.\n */\nexport const useHoverIntent = ({\n  sensitivity = 7,\n  interval = 50,\n  timeout = 10,\n  disabled,\n  onPointerOver,\n  onPointerOut\n}: HoverIntentOptions | undefined): HoverIntentResult => {\n  const mouseOver = useRef<boolean>(false);\n  const timer = useRef<any | null>(null);\n  const state = useRef<number>(0);\n  const coords = useRef({\n    x: null,\n    y: null,\n    px: null,\n    py: null\n  });\n\n  const onMouseMove = useCallback((event: MouseEvent) => {\n    coords.current.x = event.clientX;\n    coords.current.y = event.clientY;\n  }, []);\n\n  const comparePosition = useCallback(\n    (event: PointerEvent<SVGElement>) => {\n      timer.current = clearTimeout(timer.current);\n      const { px, x, py, y } = coords.current;\n\n      if (Math.abs(px - x) + Math.abs(py - y) < sensitivity) {\n        state.current = 1;\n        onPointerOver(event);\n      } else {\n        coords.current.px = x;\n        coords.current.py = y;\n        timer.current = setTimeout(() => comparePosition(event), interval);\n      }\n    },\n    [interval, onPointerOver, sensitivity]\n  );\n\n  const cleanup = useCallback(() => {\n    clearTimeout(timer.current);\n    document.removeEventListener('mousemove', onMouseMove, false);\n  }, [onMouseMove]);\n\n  const pointerOver = useCallback(\n    (event: PointerEvent<SVGElement>) => {\n      if (!disabled) {\n        mouseOver.current = true;\n        cleanup();\n\n        if (state.current !== 1) {\n          coords.current.px = event.nativeEvent.x;\n          coords.current.py = event.nativeEvent.y;\n          document.addEventListener('mousemove', onMouseMove, false);\n          timer.current = setTimeout(() => comparePosition(event), timeout);\n        }\n      }\n    },\n    [cleanup, comparePosition, disabled, onMouseMove, timeout]\n  );\n\n  const delay = useCallback(\n    (event: PointerEvent<SVGElement>) => {\n      timer.current = clearTimeout(timer.current);\n      state.current = 0;\n      onPointerOut(event);\n    },\n    [onPointerOut]\n  );\n\n  const pointerOut = useCallback(\n    (event: PointerEvent<SVGElement>) => {\n      mouseOver.current = false;\n      cleanup();\n\n      if (state.current === 1) {\n        timer.current = setTimeout(() => delay(event), timeout);\n      }\n    },\n    [cleanup, delay, timeout]\n  );\n\n  return {\n    pointerOver,\n    pointerOut\n  };\n};\n","import React, { ReactElement, useState, FC, useRef, useMemo } from 'react';\nimport chroma from 'chroma-js';\nimport { motion } from 'framer-motion';\nimport { CloneElement } from 'reablocks';\nimport { ArcData } from '../PieChart';\nimport { ChartTooltip, ChartTooltipProps } from '../../common/Tooltip';\nimport { useInterpolate } from './useInterpolate';\nimport { useHoverIntent } from '../../common/utils/useHoverIntent';\nimport { Gradient, GradientProps } from '../../common/Gradient';\nimport { getAriaLabel } from '../../common';\n\nexport interface PieArcMouseEvent {\n  value: ArcData['data'];\n  nativeEvent: React.MouseEvent<SVGPathElement>;\n}\n\nexport interface PieArcProps {\n  /**\n   * Unique id for arc\n   */\n  id?: string;\n\n  /**\n   * The arc generator function returning an arc path\n   * @param data\n   */\n  arc?: (data: ArcData) => string | null;\n\n  /**\n   * Data is the datum passed to the arc generator function\n   */\n  data?: ArcData;\n\n  /**\n   * Color\n   */\n  color?: string;\n\n  /**\n   * Animate\n   */\n  animated?: boolean;\n\n  /**\n   * Tooltip component\n   */\n  tooltip?: ReactElement<ChartTooltipProps, typeof ChartTooltip> | null;\n\n  /**\n   * The cursor type used when hovering\n   */\n  cursor?: string;\n\n  /**\n   * Disable the arc\n   */\n  disabled?: boolean;\n\n  /**\n   * Gradient shades for the bar.\n   */\n  gradient?: ReactElement<GradientProps, typeof Gradient> | null;\n\n  /**\n   * OnClick event handler\n   * @param e Click event\n   */\n  onClick?: (e: PieArcMouseEvent) => void;\n\n  /**\n   * MouseEnter event handler\n   * @param e MouseEnter event\n   */\n  onMouseEnter?: (e: PieArcMouseEvent) => void;\n\n  /**\n   * MouseLeave event handler\n   * @param e MouseLeave event\n   */\n  onMouseLeave?: (e: PieArcMouseEvent) => void;\n}\n\nexport const PieArc: FC<PieArcProps> = ({\n  id,\n  color,\n  data,\n  arc,\n  cursor,\n  animated,\n  gradient,\n  disabled,\n  onClick,\n  onMouseEnter,\n  onMouseLeave,\n  tooltip\n}) => {\n  const arcRef = useRef<SVGPathElement | null>(null);\n  const d = useInterpolate({ animated, arc, data });\n  const [active, setActive] = useState<boolean>(false);\n  const fill = useMemo(\n    () => (active ? chroma(color).brighten(0.5) : color),\n    [color, active]\n  );\n\n  const { pointerOut, pointerOver } = useHoverIntent({\n    onPointerOver: (event) => {\n      if (!disabled) {\n        setActive(true);\n        onMouseEnter?.({\n          value: data.data,\n          nativeEvent: event as any\n        });\n      }\n    },\n    onPointerOut: (event) => {\n      if (!disabled) {\n        setActive(false);\n        onMouseLeave?.({\n          value: data.data,\n          nativeEvent: event as any\n        });\n      }\n    }\n  });\n\n  const internalFill = useMemo(() => {\n    if (gradient) {\n      return `url(#gradient-${id})`;\n    }\n\n    return color;\n  }, [gradient, id, color]);\n\n  const tooltipData = useMemo(\n    () => ({ y: data.data.data, x: data.data.key }),\n    [data]\n  );\n  const ariaLabelData = useMemo(() => getAriaLabel(tooltipData), [tooltipData]);\n\n  return (\n    <g\n      ref={arcRef}\n      tabIndex={0}\n      aria-label={ariaLabelData}\n      role=\"graphics-document\"\n    >\n      <motion.path\n        role=\"graphics-symbol\"\n        d={d}\n        style={{ cursor }}\n        fill={internalFill}\n        onPointerOver={pointerOver}\n        onPointerOut={pointerOut}\n        onClick={(event) => {\n          if (!disabled) {\n            onClick?.({\n              value: data.data,\n              nativeEvent: event\n            });\n          }\n        }}\n      />\n      {gradient && (\n        <CloneElement<GradientProps>\n          element={gradient}\n          id={`gradient-${id}`}\n          direction=\"horizontal\"\n          color={fill}\n        />\n      )}\n      {!tooltip?.props?.disabled && (\n        <CloneElement<ChartTooltipProps>\n          element={tooltip}\n          visible={!!active}\n          reference={arcRef}\n          value={tooltipData}\n        />\n      )}\n    </g>\n  );\n};\n\nPieArc.defaultProps = {\n  cursor: 'initial',\n  animated: true,\n  disabled: false,\n  tooltip: <ChartTooltip />\n};\n","type Coordinate = [number, number];\n\n/**\n * Finds intermediate point between two points so that this three points\n * can be nicely connected by two lines. One of this lines must be horizontal\n */\nexport function findBreakPoint(\n  [startX, startY]: Coordinate,\n  [endX, endY]: Coordinate\n): Coordinate {\n  let breakPoint: Coordinate = [0, 0];\n\n  // whether we should create breakpoint near pie or near label\n  const breakPointCondition = (endY - startY) * Math.sign(startY) >= 0;\n\n  if (breakPointCondition) {\n    // extend the line starting from startY till the endY\n    let scale = Math.abs(endY / startY) || 1;\n    const minScale = 1;\n    const maxScale = Math.abs(endX / startX) || 1;\n\n    scale = Math.max(Math.min(maxScale, scale), minScale);\n\n    breakPoint = [startX * scale, endY];\n  } else {\n    // some arbitrary scale to ensure that break point will be placed\n    // at some horizontal distance from the end point\n    let scale = 0.85;\n    const minScale = Math.abs(startX / endX) || 1;\n    const maxScale = 1;\n\n    scale = Math.max(Math.min(maxScale, scale), minScale);\n\n    breakPoint = [endX * scale, startY];\n  }\n\n  return breakPoint;\n}\n","import React, { FC } from 'react';\nimport { motion } from 'framer-motion';\nimport { arc } from 'd3-shape';\nimport { ArcData } from '../PieChart';\nimport { ChartInternalDataTypes } from '../../common/data/types';\nimport { formatValue } from '../../common/utils/formatting';\nimport { findBreakPoint } from './findBreakPoint';\n\nexport interface PieArcLabelProps {\n  /**\n   * Data set by the parent component\n   */\n  data: ArcData;\n\n  /**\n   * A function returning the centroid of the corresponding `PieArc`\n   * @param d PieArcDatum\n   */\n  centroid: (d: ArcData) => [number, number];\n\n  /**\n   * A Formatting function for the label value\n   * @param v The label value\n   */\n  format?: (\n    // have added any because not sure whether this change won't be breaking\n    v: any & ArcData['data'] & { textAnchor: 'start' | 'end' }\n  ) => React.ReactNode;\n\n  /**\n   * FontFill color\n   */\n  fontFill: string;\n\n  /**\n   * FontSize\n   */\n  fontSize: number;\n\n  /**\n   * FontFamily\n   */\n  fontFamily: string;\n\n  /**\n   * Line stroke of the label connector\n   */\n  lineStroke: string;\n\n  /**\n   * Outer radius of the corresponding `PieArc`\n   */\n  outerRadius: number;\n\n  /**\n   * y Padding of the label\n   */\n  padding: string;\n\n  /**\n   * The label position set by the parent component\n   */\n  position: [number, number];\n\n  /**\n   * Width of the label\n   */\n  width?: number;\n\n  /**\n   * Height of the label\n   */\n  height?: number;\n}\n\nconst getTextAnchor = ({ startAngle, endAngle }: ArcData) =>\n  // we could also use the sign of position[0]\n  startAngle + (endAngle - startAngle) / 2 < Math.PI ? 'start' : 'end';\n\nexport const PieArcLabel: FC<Partial<PieArcLabelProps>> = ({\n  centroid,\n  data,\n  lineStroke,\n  padding,\n  fontSize,\n  fontFill,\n  format,\n  fontFamily,\n  position,\n  outerRadius,\n  width,\n  height\n}) => {\n  const textAnchor = getTextAnchor(data);\n  const text: React.ReactNode = format\n    ? format({ ...data.data, textAnchor })\n    : formatValue(data.data.key as ChartInternalDataTypes);\n  const [posX, posY] = position;\n  // we want to have at least some pixels of straight line (margin)\n  // from pie section till we start to change line direction\n  const minRadius = outerRadius + 4;\n\n  const startPoint = centroid(data);\n  const innerPoint = arc<ArcData>()\n    .innerRadius(minRadius)\n    .outerRadius(minRadius)\n    .centroid(data);\n  const breakPoint = findBreakPoint(innerPoint, position);\n\n  return (\n    <motion.g\n      initial={{ opacity: 0 }}\n      animate={{ opacity: 1 }}\n      exit={{ opacity: 0 }}\n      transition={{\n        duration: 0.1\n      }}\n    >\n      {typeof text === 'string' ? (\n        <>\n          <title>{text}</title>\n          <text\n            dy={padding}\n            fill={fontFill}\n            fontSize={fontSize}\n            fontFamily={fontFamily}\n            textAnchor={textAnchor}\n            style={{\n              shapeRendering: 'crispEdges',\n              transform: `translate3d(${posX}px,${posY}px, 0)`\n            }}\n          >\n            {text}\n          </text>\n        </>\n      ) : (\n        <foreignObject\n          width={width}\n          height={height}\n          style={{\n            transform: `translate3d(${\n              textAnchor === 'start' ? posX : posX - width\n            }px,${posY - height / 2}px, 0)`,\n            color: fontFill,\n            fontFamily,\n            fontSize\n          }}\n        >\n          {text}\n        </foreignObject>\n      )}\n      <polyline\n        fill=\"none\"\n        stroke={lineStroke}\n        points={`${startPoint},${innerPoint},${breakPoint},${position}`}\n      />\n    </motion.g>\n  );\n};\n\nPieArcLabel.defaultProps = {\n  format: undefined,\n  lineStroke: 'rgba(127,127,127,0.5)',\n  fontFill: '#8F979F',\n  fontSize: 11,\n  fontFamily: 'sans-serif',\n  padding: '.35em',\n  height: 11\n};\n","import { max } from 'd3-array';\nimport { arc } from 'd3-shape';\nimport { ArcData } from '../PieChart';\n\nconst factor = 1.2;\nconst midAngle = (d: ArcData) => d.startAngle + (d.endAngle - d.startAngle) / 2;\nconst labelVisible = (arc: ArcData) =>\n  arc.endAngle - arc.startAngle > Math.PI / 30;\n\nfunction shouldDisplayLabel(displayAllLabels: boolean, arcData: ArcData) {\n  return displayAllLabels || labelVisible(arcData);\n}\n\nexport function calculateOuterRadius(\n  outerRadius: number,\n  data: ArcData[],\n  point: ArcData,\n  explode: boolean,\n) {\n  if (!explode || data === undefined) {\n    return outerRadius;\n  }\n\n  const maxVal = max(data, (d: ArcData) => d.value);\n\n  return (outerRadius * point.value) / maxVal;\n}\n\nexport function calculateCentroid(\n  data: ArcData[],\n  innerRadius: number,\n  outerRadius: number,\n  explode: boolean\n) {\n  return (point: ArcData) => {\n    const newOuter = calculateOuterRadius(outerRadius, data, point, explode);\n\n    return arc<any, ArcData>()\n      .innerRadius(innerRadius)\n      .outerRadius(newOuter)\n      .centroid(point);\n  };\n}\n\nexport function calculateRadius(\n  height,\n  width,\n  label,\n  arcWidth,\n  doughnut\n) {\n  const minDimension = Math.min(width, height);\n\n  let outerRadius = minDimension / 2;\n  let labelWidth = 0;\n\n  if (label) {\n    labelWidth = label.props.width;\n\n    if (labelWidth) {\n      const outerArcRadius = width / 2 - labelWidth;\n\n      outerRadius = Math.min(outerArcRadius / factor, height / 2);\n    } else {\n      outerRadius = minDimension / 3;\n      labelWidth = width / 2 - outerRadius * factor;\n    }\n  }\n\n  const innerRadius = doughnut ? outerRadius * (1 - arcWidth) : 0;\n\n  return {\n    outerRadius,\n    innerRadius,\n    labelWidth\n  };\n}\n\nexport function calculateInnerArc(\n  data: ArcData[],\n  innerRadius: number,\n  outerRadius: number,\n  cornerRadius: number,\n  padAngle: number,\n  padRadius: number,\n  explode: boolean\n) {\n  return (point: ArcData) => {\n    const newOuter = calculateOuterRadius(outerRadius, data, point, explode);\n\n    return arc<any, ArcData>()\n      .innerRadius(innerRadius)\n      .outerRadius(newOuter)\n      .cornerRadius(cornerRadius)\n      .padRadius(padRadius)\n      .padAngle(padAngle)(point);\n  };\n}\n\nexport function calculateLabelPositions(\n  data: ArcData[],\n  outerRadius: number,\n  minDistance: number,\n  cornerRadius: number,\n  padAngle: number,\n  padRadius: number,\n  displayAllLabels: boolean\n): Array<[number, number] | null> {\n  const outerArcRadius = outerRadius * factor;\n  const outerArc = arc<any, ArcData>()\n    .innerRadius(outerArcRadius)\n    .outerRadius(outerArcRadius)\n    .cornerRadius(cornerRadius)\n    .padAngle(padAngle)\n    .padRadius(padRadius);\n\n  const positions: Array<[number, number] | null> = data.map((d) => {\n    if (!shouldDisplayLabel(displayAllLabels, d)) {\n      return null;\n    }\n\n    const pos = outerArc.centroid(d);\n\n    // reposition the labels to the left/right from outerArc centroid\n    // so that all labels won't collide with pie\n    // when we will vertically reposition them\n    pos[0] = outerArcRadius * (midAngle(d) < Math.PI ? 1 : -1);\n\n    return pos;\n  });\n\n  for (let i = 0; i < data.length - 1; i++) {\n    if (!positions[i]) {\n      continue;\n    }\n\n    const [aPosX, aPosY] = positions[i];\n\n    for (let j = i + 1; j < data.length; j++) {\n      if (!positions[j]) {\n        continue;\n      }\n\n      const [bPosX, bPosY] = positions[j];\n\n      // if they're on the same side (both with - or + sign)\n      if (bPosX * aPosX > 0) {\n        // if they're overlapping\n        const overlap = minDistance - Math.abs(bPosY - aPosY);\n\n        if (overlap > 0) {\n          // push the second up or down\n          positions[j][1] += Math.sign(bPosX) * overlap;\n        }\n      }\n    }\n  }\n\n  return positions;\n}\n","import React, { FC, Fragment, ReactElement } from 'react';\nimport { CloneElement } from 'reablocks';\nimport { ArcData } from '../PieChart';\nimport { PieArc, PieArcProps } from './PieArc';\nimport { PieArcLabel, PieArcLabelProps } from './PieArcLabel';\nimport { getColor, ColorSchemeType } from '../../common/color';\nimport {\n  calculateCentroid,\n  calculateInnerArc,\n  calculateLabelPositions,\n  calculateRadius\n} from './radiusUtils';\nimport { identifier } from 'safe-identifier';\n\nexport interface PieArcSeriesProps {\n  /**\n   * Unique id for the series.\n   */\n  id?: string;\n\n  /**\n   * Animated set by the `PieArc` components.\n   */\n  animated: boolean;\n\n  /**\n   * Outer radius set by the parent component.\n   */\n  outerRadius: number;\n\n  /**\n   * Inner radius set by the parent component.\n   */\n  innerRadius: number;\n\n  /**\n   * Pad Angle between adjacent arcs, see https://github.com/d3/d3-shape#arc_padAngle\n   */\n  padAngle: number;\n\n  /**\n   * Pad Radius between adjacent arcs, see https://github.com/d3/d3-shape#arc_padRadius\n   */\n  padRadius: number;\n\n  /**\n   * Corner Radius of the arcs, see https://github.com/d3/d3-shape#arc_cornerRadius\n   */\n  cornerRadius: number;\n\n  /**\n   * Data set by the parent component.\n   */\n  data: ArcData[];\n\n  /**\n   * Width of the arc\n   */\n  arcWidth: number;\n\n  /**\n   * Doughnut, render as a donut shape\n   */\n  doughnut: boolean;\n\n  /**\n   * Explode: OuterRadius will be adjusted by the data property\n   */\n  explode: boolean;\n\n  /**\n   * Display all labels shows labels even if there is little space\n   */\n  displayAllLabels: boolean;\n\n  /**\n   * Label component\n   */\n  label?: ReactElement<PieArcLabelProps, typeof PieArcLabel> | null;\n\n  /**\n   * Arc Component\n   */\n  arc: ReactElement<PieArcProps, typeof PieArc>;\n\n  /**\n   * Color scheme\n   */\n  colorScheme: ColorSchemeType;\n\n  /**\n   * Height set by the parent component\n   */\n  height: number;\n\n  /**\n   * Width set by the parent component\n   */\n  width: number;\n}\n\nexport const PieArcSeries: FC<Partial<PieArcSeriesProps>> = ({\n  doughnut,\n  arcWidth,\n  label,\n  colorScheme,\n  width,\n  displayAllLabels,\n  height,\n  explode,\n  id,\n  animated,\n  cornerRadius,\n  padAngle,\n  padRadius,\n  arc,\n  data\n}) => {\n  const { outerRadius, innerRadius, labelWidth } = calculateRadius(\n    height,\n    width,\n    label,\n    arcWidth,\n    doughnut\n  );\n\n  const innerArc = calculateInnerArc(\n    data,\n    innerRadius,\n    outerRadius,\n    cornerRadius,\n    padAngle,\n    padRadius,\n    explode\n  );\n\n  const positions = label\n    ? calculateLabelPositions(\n      data,\n      outerRadius,\n      // 4 is for vertical margins between labels\n      label.props.height + 4,\n      cornerRadius,\n      padAngle,\n      padRadius,\n      displayAllLabels\n    )\n    : [];\n\n  const centroid = calculateCentroid(data, innerRadius, outerRadius, explode);\n\n  function renderItem(arcData: ArcData, index: number) {\n    const safeKey = identifier(arcData.data.key.toString());\n    const color = getColor({\n      data,\n      colorScheme,\n      point: arcData.data,\n      index\n    });\n\n    return (\n      <Fragment key={safeKey}>\n        {positions[index] && (\n          <CloneElement<PieArcLabelProps>\n            id={id}\n            element={label}\n            data={arcData}\n            centroid={centroid}\n            outerRadius={outerRadius}\n            width={labelWidth}\n            position={positions[index]}\n          />\n        )}\n        <CloneElement<PieArcProps>\n          element={arc}\n          id={`${id}-arc-${safeKey}`}\n          data={arcData}\n          animated={animated}\n          arc={innerArc}\n          color={color}\n        />\n      </Fragment>\n    );\n  }\n\n  return <>{data.map(renderItem)}</>;\n};\n\nPieArcSeries.defaultProps = {\n  animated: true,\n  colorScheme: 'cybertron',\n  innerRadius: 0,\n  cornerRadius: 0,\n  padAngle: 0,\n  padRadius: 0,\n  explode: false,\n  displayAllLabels: false,\n  arcWidth: 0.25,\n  label: <PieArcLabel />,\n  arc: <PieArc />\n};\n","import React, { FC, ReactElement, useCallback, useMemo } from 'react';\nimport classNames from 'classnames';\nimport { PieArcDatum } from 'd3-shape';\nimport { pie } from 'd3-shape';\nimport { CloneElement, useId } from 'reablocks';\nimport {\n  ChartProps,\n  ChartContainer,\n  ChartContainerChildProps\n} from '../common/containers';\nimport { ChartShallowDataShape } from '../common/data';\nimport { PieArcSeries, PieArcSeriesProps } from './PieArcSeries';\n\nexport type ArcData = PieArcDatum<ChartShallowDataShape>;\n\nexport interface PieChartProps extends ChartProps {\n  /**\n   * Data the chart will receive to render.\n   */\n  data?: ChartShallowDataShape[];\n\n  /**\n   * Whether the chart is disabled.\n   */\n  disabled?: boolean;\n\n  /**\n   * Whether to display labels even if their value has a small display radius.\n   */\n  displayAllLabels?: boolean;\n\n  /**\n   * The series component that renders the arc components.\n   */\n  series?: ReactElement<PieArcSeriesProps, typeof PieArcSeries>;\n}\n\nexport const PieChart: FC<PieChartProps> = ({\n  id,\n  width,\n  height,\n  className,\n  containerClassName,\n  displayAllLabels,\n  data = [],\n  margins,\n  series\n}) => {\n  const newId = useId(id);\n\n  const internalData = useMemo(() => {\n    const pieLayout = pie<void, ChartShallowDataShape>().value(\n      (d: ChartShallowDataShape) => Number(d.data)\n    );\n\n    // Explode sort doesn't work right...\n    if (!series.props.explode) {\n      pieLayout.sort(null);\n    }\n\n    return pieLayout(data);\n  }, [data, series]);\n\n  const renderSeries = useCallback(\n    ({ chartWidth, chartHeight }: ChartContainerChildProps) => {\n      return (\n        <CloneElement<PieArcSeriesProps>\n          element={series}\n          id={newId}\n          data={internalData}\n          height={chartHeight}\n          width={chartWidth}\n          displayAllLabels={displayAllLabels}\n        />\n      );\n    },\n    [displayAllLabels, internalData, newId, series]\n  );\n\n  return (\n    <ChartContainer\n      id={id}\n      width={width}\n      height={height}\n      margins={margins}\n      containerClassName={containerClassName}\n      xAxisVisible={false}\n      yAxisVisible={false}\n      center={true}\n      className={classNames(className)}\n    >\n      {renderSeries}\n    </ChartContainer>\n  );\n};\n\nPieChart.defaultProps = {\n  margins: 10,\n  series: <PieArcSeries />\n};\n","import { SankeyNode, SankeyLink } from 'd3-sankey';\n\nexport interface NodeExtra {\n  /**\n   * ID of the node. If not provided, the node's index will be used.\n   */\n  id?: string;\n\n  /**\n   * Title of the node.\n   */\n  title: string;\n\n  /**\n   * Color of the node.\n   */\n  color?: string;\n}\n\nexport interface LinkExtra {\n  /**\n   * Color of the link.\n   */\n  color?: string;\n}\n\nexport type SankeyNodeExtra = SankeyNode<NodeExtra, LinkExtra>;\n\nexport type SankeyLinkExtra = SankeyLink<NodeExtra, LinkExtra>;\n\nexport const DEFAULT_COLOR = 'rgba(255, 255, 255, 0.2)';\n\nexport const LABEL_PADDING_PERCENT = 0.1;\n","import React, {\n  FC,\n  Fragment,\n  ReactElement,\n  useCallback,\n  useMemo,\n  useState\n} from 'react';\nimport {\n  sankey,\n  sankeyLeft,\n  sankeyRight,\n  sankeyCenter,\n  sankeyJustify\n} from 'd3-sankey';\nimport {\n  ChartProps,\n  ChartContainer,\n  ChartContainerChildProps\n} from '../common/containers/ChartContainer';\nimport { CloneElement, useId } from 'reablocks';\n\nimport { getColor, ColorSchemeType } from '../common/color';\nimport { SankeyNodeProps, SankeyNode } from './SankeyNode';\nimport { SankeyLinkProps, SankeyLink } from './SankeyLink';\nimport {\n  SankeyNodeExtra,\n  SankeyLinkExtra,\n  LABEL_PADDING_PERCENT\n} from './utils';\nimport { SankeyLabelPosition } from './SankeyLabel';\n\nconst JUSTIFICATION = {\n  justify: sankeyJustify,\n  center: sankeyCenter,\n  left: sankeyLeft,\n  right: sankeyRight\n};\n\nexport type Justification = 'justify' | 'center' | 'left' | 'right';\n\nexport type NodeElement = ReactElement<SankeyNodeProps, typeof SankeyNode>;\n\nexport type LinkElement = ReactElement<SankeyLinkProps, typeof SankeyLink>;\n\nexport interface SankeyProps extends ChartProps {\n  /**\n   * Whether to animate the enter/update/exit. Set internally by `SankeyNode` and `SankeyLink`.\n   */\n  animated?: boolean;\n\n  /**\n   * Color scheme for the nodes. Set internally by `SankeyNode`.\n   */\n  colorScheme?: ColorSchemeType;\n\n  /**\n   * The node alignment method.\n   */\n  justification?: Justification;\n\n  /**\n   * Width of the node.\n   */\n  nodeWidth?: number;\n\n  /**\n   * Vertical padding between nodes in the same column.\n   */\n  nodePadding?: number;\n\n  /**\n   * Label position.\n   */\n  labelPosition?: SankeyLabelPosition;\n\n  /**\n   * Sort function for the nodes.\n   *\n   * If sort is specified, sets the node sort method and returns this Sankey generator.\n   * If sort is not specified, returns the current node sort method, which defaults\n   * to undefined, indicating that vertical order of nodes within each column will\n   * be determined automatically by the layout. If sort is null, the order is fixed\n   * by the input. Otherwise, the specified sort function determines the order;\n   * the function is passed two nodes, and must return a value less than 0 if the\n   * first node should be above the second, and a value greater than 0 if the second\n   * node should be above the first, or 0 if the order is not specified.\n   *\n   * Reference: https://github.com/d3/d3-sankey#sankey_nodeSort\n   */\n  nodeSort?: (a: any, b: any) => number;\n\n  /**\n   * Nodes that are rendered.\n   */\n  nodes: NodeElement[];\n\n  /**\n   * Links that are rendered.\n   */\n  links: LinkElement[];\n}\n\nexport const Sankey: FC<SankeyProps> = ({\n  width,\n  height,\n  margins,\n  className,\n  animated,\n  links,\n  justification,\n  nodeWidth,\n  nodePadding,\n  labelPosition,\n  nodeSort,\n  colorScheme,\n  nodes,\n  containerClassName,\n  ...rest\n}) => {\n  const id = useId(rest.id);\n  const [activeNodes, setActiveNodes] = useState<SankeyNodeExtra[]>([]);\n  const [activeLinks, setActiveLinks] = useState<SankeyLinkExtra[]>([]);\n\n  const getNodeColor = useCallback(\n    (node: NodeElement, index: any) => {\n      if (colorScheme) {\n        return getColor({\n          data: nodes,\n          colorScheme,\n          point: nodes[index],\n          index\n        });\n      } else {\n        return node.props.color;\n      }\n    },\n    [colorScheme, nodes]\n  );\n\n  const onNodeActive = useCallback((node: SankeyNodeExtra) => {\n    const activeNodes: SankeyNodeExtra[] = [node];\n    const activeLinks: SankeyLinkExtra[] = [];\n\n    if (node.sourceLinks) {\n      activeLinks.push(...node.sourceLinks);\n      node.sourceLinks.forEach((sourceLink) => {\n        const sourceLinkTarget = sourceLink.target as SankeyNodeExtra;\n        if (sourceLinkTarget.index !== node.index) {\n          activeNodes.push(sourceLinkTarget);\n        }\n      });\n    }\n\n    if (node.targetLinks) {\n      activeLinks.push(...node.targetLinks);\n      node.targetLinks.forEach((targetLink) => {\n        const targetLinkSource = targetLink.source as SankeyNodeExtra;\n        if (targetLinkSource.index !== node.index) {\n          activeNodes.push(targetLinkSource);\n        }\n      });\n    }\n\n    setActiveNodes(activeNodes);\n    setActiveLinks(activeLinks);\n  }, []);\n\n  const onLinkActive = useCallback((link: SankeyLinkExtra) => {\n    const activeNodes: SankeyNodeExtra[] = [\n      link.source as SankeyNodeExtra,\n      link.target as SankeyNodeExtra\n    ];\n    const activeLinks: SankeyLinkExtra[] = [link];\n\n    setActiveNodes(activeNodes);\n    setActiveLinks(activeLinks);\n  }, []);\n\n  const onInactive = useCallback(() => {\n    setActiveNodes([]);\n    setActiveLinks([]);\n  }, []);\n\n  const nodeMap = useMemo(() => {\n    // Not sure what this is for\n    const nodeMap = new Map<string, NodeElement>();\n    nodes.forEach((node: any) => node && nodeMap.set(node.props.title, node));\n\n    return nodeMap;\n  }, [nodes]);\n\n  const renderNode = useCallback(\n    (\n      computedNode: SankeyNodeExtra,\n      index: number,\n      chartWidth: number,\n      node?: NodeElement\n    ) => {\n      const active = activeNodes.some(\n        (node) => node.index === computedNode.index\n      );\n      const disabled = activeNodes.length > 0 && !active;\n      const labelPadding =\n        labelPosition === 'outside' ? LABEL_PADDING_PERCENT : 0;\n\n      return (\n        <CloneElement<SankeyNodeProps>\n          element={node}\n          key={`node-${index}`}\n          active={active}\n          animated={animated}\n          disabled={disabled}\n          chartWidth={chartWidth}\n          onMouseEnter={() => onNodeActive(computedNode)}\n          onMouseLeave={() => onInactive()}\n          labelPosition={labelPosition}\n          labelPadding={labelPadding}\n          {...computedNode}\n        />\n      );\n    },\n    [activeNodes, animated, onInactive, onNodeActive, labelPosition]\n  );\n\n  const renderLink = useCallback(\n    (computedLink: SankeyLinkExtra, index: number) => {\n      const active = activeLinks.some(\n        (link) => link.index === computedLink.index\n      );\n      const disabled = activeLinks.length > 0 && !active;\n\n      return (\n        <CloneElement<SankeyLinkProps>\n          element={links[index]}\n          active={active}\n          animated={animated}\n          key={`link-${index}`}\n          chartId={`sankey-${id}`}\n          disabled={disabled}\n          {...computedLink}\n          onMouseEnter={() => onLinkActive(computedLink)}\n          onMouseLeave={() => onInactive()}\n        />\n      );\n    },\n    [activeLinks, id, animated, links, onInactive, onLinkActive]\n  );\n\n  const getNodesAndLinks = useCallback(\n    (chartWidth: number, chartHeight: number) => {\n      const labelPadding =\n        labelPosition === 'outside' ? LABEL_PADDING_PERCENT : 0;\n      const padding = labelPadding * chartWidth;\n\n      const sankeyChart = sankey()\n        .extent([\n          [1 + padding, 1],\n          [chartWidth - padding, chartHeight]\n        ])\n        .nodeWidth(nodeWidth)\n        .nodePadding(nodePadding)\n        .nodeSort(nodeSort)\n        .nodeAlign(JUSTIFICATION[justification])\n        .nodeId((node: any) => node.id || node.index);\n\n      const nodesCopy: any = nodes.map((node, index) => ({\n        id: node.props.id,\n        title: node.props.title,\n        color: getNodeColor(node, index)\n      }));\n\n      const linksCopy = links.map((link) => ({\n        source: link.props.source,\n        target: link.props.target,\n        value: link.props.value\n      }));\n\n      const { nodes: sankeyNodes, links: sankeyLinks } = sankeyChart({\n        nodes: nodesCopy,\n        links: linksCopy\n      });\n\n      /*\n      // NOTE: Not sure what this is doing\n      sankeyNodes.sort((a, b) => {\n        const aX0 = a && a.x0 ? a.x0 : 0;\n        const aY0 = a && a.y0 ? a.y0 : 0;\n        const bX0 = b && b.x0 ? b.x0 : 0;\n        const bY0 = b && b.y0 ? b.y0 : 0;\n        return aX0 - bX0 || aY0 - bY0;\n      });\n      */\n\n      return { sankeyNodes, sankeyLinks };\n    },\n    [\n      getNodeColor,\n      nodeSort,\n      justification,\n      links,\n      nodePadding,\n      nodeWidth,\n      nodes,\n      labelPosition\n    ]\n  );\n\n  const renderChart = useCallback(\n    ({ id, chartWidth, chartHeight, chartSized }: ChartContainerChildProps) => {\n      if (!chartSized) {\n        return null;\n      }\n\n      const { sankeyNodes, sankeyLinks } = getNodesAndLinks(\n        chartWidth,\n        chartHeight\n      );\n\n      return (\n        <Fragment key=\"group\">\n          {sankeyLinks.map((link, index) =>\n            renderLink(link as SankeyLinkExtra, index)\n          )}\n          {sankeyNodes.map((node: SankeyNodeExtra, index) =>\n            renderNode(node, index, chartWidth, nodeMap.get(node.title))\n          )}\n        </Fragment>\n      );\n    },\n    [getNodesAndLinks, nodeMap, renderLink, renderNode]\n  );\n\n  return (\n    <ChartContainer\n      id={id}\n      width={width}\n      containerClassName={containerClassName}\n      height={height}\n      margins={margins}\n      className={className}\n    >\n      {renderChart}\n    </ChartContainer>\n  );\n};\n\nSankey.defaultProps = {\n  animated: true,\n  justification: 'justify',\n  nodeWidth: 15,\n  nodePadding: 10,\n  nodePosition: 'inside'\n};\n","import React, { FC } from 'react';\nimport classNames from 'classnames';\nimport { SankeyNodeExtra } from '../utils';\nimport css from './SankeyLabel.module.css';\nimport ellipsize from 'ellipsize';\n\nexport type SankeyLabelPosition = 'inside' | 'outside';\n\nexport interface SankeyLabelFormatProps {\n  x: number;\n  y: number;\n  textAnchor: string;\n  node: SankeyNodeExtra;\n}\n\nexport interface SankeyLabelProps {\n  /**\n   * Whether the element is active or not. Set internally by `Sankey`.\n   */\n  active: boolean;\n\n  /**\n   * Whether the label is disabled. Set internally by `Sankey`.\n   */\n  disabled: boolean;\n\n  /**\n   * Width of the chart. Set internally by `Sankey`.\n   */\n  chartWidth?: number;\n\n  /**\n   * CSS class to apply.\n   */\n  className?: string;\n\n  /**\n   * Fill color.\n   */\n  fill: string;\n\n  /**\n   * Label position. Set internally by `Sankey`.\n   */\n  position?: SankeyLabelPosition;\n\n   /**\n   * Percentage of total width occupied by labels on \n   * either side of the graph inside the container.\n   * Used for auto-ellipsizing labels\n   * Set internally by `Sankey`.\n   */\n   labelPadding?: number;\n\n  /**\n   * Node data. Set internally by `Sankey`.\n   */\n  node?: SankeyNodeExtra;\n\n  /**\n   * Opacity callback. Used internally by `Sankey`.\n   */\n  opacity: (active: boolean, disabled: boolean) => number;\n\n  /**\n   * Padding between the label and the node.\n   */\n  padding?: string | number;\n\n  /**\n   * Whether to show the label or not.\n   */\n  visible: boolean;\n\n  /**\n   * Width of the node set by the 'Sankey'.\n   */\n  nodeWidth: number;\n\n  /**\n   * Custom formatting for the label.\n   */\n  format?: (value: SankeyLabelFormatProps) => any;\n\n  /**\n   * Specify the number of characters at which the text would be ellipsized.\n   * Defaults to 'auto' based on available width and max cut-off at `LABEL_TRUNCATE_LENGTH=10`\n   */\n  ellipsis?: number | 'none' | 'auto'\n}\n\nconst LABEL_PADDING = 5;\nconst LABEL_TRUNCATE_LENGTH = 10;\n\nexport const SankeyLabel: FC<Partial<SankeyLabelProps>> = ({\n  active,\n  chartWidth,\n  className,\n  nodeWidth,\n  disabled,\n  fill,\n  format,\n  node,\n  position,\n  opacity,\n  padding,\n  visible,\n  ellipsis,\n  labelPadding\n}) => {\n  const x0 = node?.x0 || 0;\n  const x1 = node?.x1 || 0;\n  const y0 = node?.y0 || 0;\n  const y1 = node?.y1 || 0;\n  const paddedWidth = nodeWidth + LABEL_PADDING;\n\n  const width = chartWidth || 0;\n  const showRightSide = x0 < width / 2;\n  let x = showRightSide ? x1 + paddedWidth : x0 - paddedWidth;\n  const y = (y1 + y0) / 2;\n\n  let textAnchor = showRightSide ? 'start' : 'end';\n  if (position === 'outside') {\n    textAnchor = showRightSide ? 'end' : 'start';\n    x = showRightSide ? x1 - paddedWidth : x0 + paddedWidth;\n  }\n\n  if (!visible || !node) {\n    return null;\n  }\n\n  let truncatedTitle = '';\n  if (ellipsis === 'auto') {\n    // This math somehow works for now!\n    const avaialableWidth = showRightSide ? x: width-x;\n    truncatedTitle = ellipsize(node.title, Math.min(LABEL_TRUNCATE_LENGTH, avaialableWidth/(labelPadding*100)));\n  } else if (ellipsis === 'none') {\n    truncatedTitle = node.title;\n  } else {\n    truncatedTitle = ellipsize(node.title, ellipsis);\n  }\n\n  return (\n    <text\n      className={classNames(css.label, className)}\n      x={x}\n      y={y}\n      dy=\"0.35em\"\n      textAnchor={textAnchor}\n      fill={fill}\n      opacity={opacity(active, disabled)}\n      style={{ padding }}\n    >\n      {typeof format === 'function'\n        ? format({ x, y, textAnchor, node })\n        : truncatedTitle}\n    </text>\n  );\n};\n\nSankeyLabel.defaultProps = {\n  active: false,\n  fill: '#fff',\n  position: 'inside',\n  opacity: (active, disabled) => (active ? 1 : disabled ? 0.2 : 0.9),\n  visible: true,\n  ellipsis: 'auto'\n};\n","import React, {\n  Fragment,\n  ReactElement,\n  useCallback,\n  useState,\n  useMemo,\n  useRef,\n  FC\n} from 'react';\nimport classNames from 'classnames';\nimport { motion } from 'framer-motion';\nimport { sankeyLinkHorizontal } from 'd3-sankey';\nimport { CloneElement } from 'reablocks';\nimport { formatValue } from '../../common/utils/formatting';\nimport { Tooltip, TooltipProps } from 'reablocks';\nimport {\n  NodeExtra,\n  SankeyNodeExtra,\n  SankeyLinkExtra,\n  DEFAULT_COLOR\n} from '../utils';\nimport css from './SankeyLink.module.css';\nimport { useHoverIntent } from '../../common/utils/useHoverIntent';\nimport { tooltipTheme } from '../../common';\n\nexport interface SankeyLinkProps extends SankeyLinkExtra {\n  /**\n   * Color of the link.\n   */\n  color?: string;\n\n  /**\n   * Whether the element is active or not. Set internally by `Sankey`.\n   */\n  active: boolean;\n\n  /**\n   * Whether to animate the enter/update/exit.\n   */\n  animated: boolean;\n\n  /**\n   * Id of Sankey chart. Set internally by `Sankey`.\n   */\n  chartId: string;\n\n  /**\n   * CSS class to apply.\n   */\n  className?: string;\n\n  /**\n   * Whether the node is disabled. Set internally by `Sankey`.\n   */\n  disabled: boolean;\n\n  /**\n   * Whether to use gradient or not.\n   */\n  gradient?: boolean;\n\n  /**\n   * Opacity callback for the link.\n   */\n  opacity: (active: boolean, disabled: boolean) => number;\n\n  /**\n   * CSS styles to apply.\n   */\n  style?: object;\n\n  /**\n   * Tooltip element.\n   */\n  tooltip?: ReactElement<TooltipProps, typeof Tooltip> | null;\n\n  /**\n   * Width of the link. Set internally by `Sankey`.\n   */\n  width: number;\n\n  /**\n   * Event for when the link is clicked.\n   */\n  onClick?: (event: React.MouseEvent<SVGPathElement>) => void;\n\n  /**\n   * Event for when the link has mouse enter.\n   */\n  onMouseEnter?: (event: React.MouseEvent<SVGPathElement>) => void;\n\n  /**\n   * Event for when the link has mouse leave.\n   */\n  onMouseLeave?: (event: React.MouseEvent<SVGPathElement>) => void;\n}\n\nexport const SankeyLink: FC<Partial<SankeyLinkProps>> = ({\n  gradient,\n  index,\n  source,\n  target,\n  tooltip,\n  chartId,\n  value,\n  active,\n  className,\n  disabled,\n  opacity,\n  style,\n  width,\n  color,\n  y0,\n  y1,\n  onClick,\n  onMouseEnter,\n  onMouseLeave\n}) => {\n  const linkSource = source as SankeyNodeExtra;\n  const linkTarget = target as SankeyNodeExtra;\n\n  const [hovered, setHovered] = useState<boolean>(false);\n  const linkRef = useRef<SVGPathElement | null>(null);\n\n  const getLink = useCallback(() => {\n    return { index, y0, y1, value, width, source, target };\n  }, [index, source, target, value, width, y0, y1]);\n\n  const stroke = useMemo(() => {\n    if (gradient) {\n      return `url(#${chartId}-gradient-${index})`;\n    } else if (color) {\n      return color;\n    }\n\n    return DEFAULT_COLOR;\n  }, [chartId, gradient, index, color]);\n\n  const enterProps = useMemo(() => {\n    const path = sankeyLinkHorizontal();\n    const d = path(getLink()) as string;\n    const strokeWidth = Math.max(1, width);\n    return { d, strokeWidth };\n  }, [getLink, width]);\n\n  const exitProps = useMemo(() => {\n    const path = sankeyLinkHorizontal();\n    const d = path({ ...getLink(), width: 0 }) as string;\n    return { d, strokeWidth: 0 };\n  }, [getLink]);\n\n  const renderTooltipContent = useCallback(() => {\n    return (\n      <div className={css.tooltip}>\n        <div className={css.tooltipLabel}>\n          {`${(source as NodeExtra).title}  ${(target as NodeExtra).title}`}\n        </div>\n        <div className={css.tooltipValue}>{formatValue(value)}</div>\n      </div>\n    );\n  }, [source, target, value]);\n\n  const { pointerOut, pointerOver } = useHoverIntent({\n    onPointerOver: (event) => {\n      setHovered(true);\n      onMouseEnter?.(event as any);\n    },\n    onPointerOut: (event) => {\n      setHovered(false);\n      onMouseLeave?.(event as any);\n    }\n  });\n\n  const ariaLabelData = useMemo(\n    () =>\n      `${(source as NodeExtra).title}  ${\n        (target as NodeExtra).title\n      }: ${formatValue(value)}`,\n    [source, target, value]\n  );\n\n  return (\n    <Fragment>\n      {gradient && (\n        <linearGradient\n          id={`${chartId}-gradient-${index}`}\n          gradientUnits=\"userSpaceOnUse\"\n          x1={linkSource.x1}\n          x2={linkTarget.x0}\n        >\n          <stop offset=\"0%\" stopColor={linkSource.color} />\n          <stop offset=\"100%\" stopColor={linkTarget.color} />\n        </linearGradient>\n      )}\n      <g ref={linkRef}>\n        <motion.path\n          key={`sankey-link-${enterProps.d}-${index}`}\n          className={classNames(css.link, className)}\n          style={style}\n          initial={exitProps}\n          animate={enterProps}\n          exit={exitProps}\n          transition={{\n            duration: 0.5\n          }}\n          stroke={stroke}\n          strokeOpacity={opacity(active, disabled)}\n          onClick={onClick}\n          onPointerOver={pointerOver}\n          onPointerOut={pointerOut}\n          aria-label={ariaLabelData}\n          role=\"graphics-document\"\n        />\n      </g>\n      {!tooltip?.props?.disabled && (\n        <CloneElement<TooltipProps>\n          content={renderTooltipContent}\n          element={tooltip}\n          visible={hovered}\n          reference={linkRef}\n        />\n      )}\n    </Fragment>\n  );\n};\n\nSankeyLink.defaultProps = {\n  active: false,\n  animated: true,\n  disabled: false,\n  gradient: true,\n  opacity: (active, disabled) => (active ? 0.5 : disabled ? 0.1 : 0.35),\n  tooltip: (\n    <Tooltip\n      theme={tooltipTheme}\n      followCursor={true}\n      modifiers={{\n        offset: {\n          offset: '0, 5px'\n        }\n      }}\n    />\n  ),\n  width: 0\n};\n","import React, {\n  Fragment,\n  ReactElement,\n  useCallback,\n  FC,\n  useState,\n  useRef,\n  useMemo\n} from 'react';\nimport classNames from 'classnames';\nimport { motion } from 'framer-motion';\nimport { ChartInternalDataTypes } from '../../common/data';\nimport { CloneElement } from 'reablocks';\nimport { formatValue } from '../../common/utils/formatting';\nimport { Tooltip, TooltipProps } from 'reablocks';\nimport {\n  SankeyLabel,\n  SankeyLabelPosition,\n  SankeyLabelProps\n} from '../SankeyLabel';\nimport { SankeyNodeExtra, DEFAULT_COLOR } from '../utils';\nimport css from './SankeyNode.module.css';\nimport { useHoverIntent } from '../../common/utils/useHoverIntent';\nimport { tooltipTheme } from '../../common';\n\nexport interface SankeyNodeProps extends SankeyNodeExtra {\n  /**\n   * ID of the node. If not provided, the node's index will be used.\n   */\n  id?: string;\n\n  /**\n   * Title of the node.\n   */\n  title: string;\n\n  /**\n   * Color of the node.\n   */\n  color?: string;\n\n  /**\n   * Whether the element is active or not. Set internally by `Sankey`.\n   */\n  active: boolean;\n\n  /**\n   * Whether to animate the enter/update/exit.\n   */\n  animated: boolean;\n\n  /**\n   * Width of the chart. Set internally by `Sankey`.\n   */\n  chartWidth?: number;\n\n  /**\n   * CSS class to apply.\n   */\n  className?: string;\n\n  /**\n   * Whether the node is disabled. Set internally by `Sankey`.\n   */\n  disabled: boolean;\n\n  /**\n   * Label element.\n   */\n  label: ReactElement<SankeyLabelProps, typeof SankeyLabel>;\n\n  /**\n   * Label position. Set internally by `Sankey`.\n   */\n  labelPosition?: SankeyLabelPosition;\n\n  /**\n   * Percentage of total width occupied by labels on\n   * either side of the graph inside the container.\n   * Set internally by `Sankey`.\n   */\n  labelPadding?: number;\n\n  /**\n   * Opacity callback for the node.\n   */\n  opacity: (active: boolean, disabled: boolean) => number;\n\n  /**\n   * CSS styles to apply.\n   */\n  style?: React.StyleHTMLAttributes<SVGRectElement>;\n\n  /**\n   * Tooltip element.\n   */\n  tooltip?: ReactElement<TooltipProps, typeof Tooltip> | null;\n\n  /**\n   * Width of the node. Set internally by `Sankey`.\n   */\n  width?: number;\n\n  /**\n   * Event for when the node is clicked.\n   */\n  onClick?: (event: React.MouseEvent<SVGRectElement>) => void;\n\n  /**\n   * Event for when the node has mouse enter.\n   */\n  onMouseEnter?: (event: React.MouseEvent<SVGRectElement>) => void;\n\n  /**\n   * Event for when the node has mouse leave.\n   */\n  onMouseLeave?: (event: React.MouseEvent<SVGRectElement>) => void;\n}\n\nexport const SankeyNode: FC<Partial<SankeyNodeProps>> = ({\n  active,\n  chartWidth,\n  label,\n  labelPosition,\n  labelPadding,\n  tooltip,\n  title,\n  value,\n  className,\n  color,\n  disabled,\n  index,\n  opacity,\n  style,\n  width,\n  x0,\n  x1,\n  y0,\n  y1,\n  id,\n  sourceLinks,\n  targetLinks,\n  onClick,\n  onMouseEnter,\n  onMouseLeave\n}) => {\n  const node = {\n    id,\n    title,\n    color,\n    sourceLinks,\n    targetLinks,\n    value,\n    index,\n    x0,\n    x1,\n    y0,\n    y1\n  };\n  const nodeWidth = width || (x1 && x0 && x1 - x0 > 0 ? x1 - x0 : 0);\n  const nodeHeight = y1 && y0 && y1 - y0 > 0 ? y1 - y0 : 0;\n\n  const [hovered, setHovered] = useState<boolean>(false);\n  const rectRef = useRef<SVGRectElement | null>(null);\n\n  const renderTooltipContent = useCallback(() => {\n    return (\n      <div className={css.tooltip}>\n        <div className={css.tooltipLabel}>{title}</div>\n        <div className={css.tooltipValue}>\n          {formatValue(value as ChartInternalDataTypes)}\n        </div>\n      </div>\n    );\n  }, [title, value]);\n\n  const { pointerOut, pointerOver } = useHoverIntent({\n    onPointerOver: (event) => {\n      setHovered(true);\n      onMouseEnter?.(event as any);\n    },\n    onPointerOut: (event) => {\n      setHovered(false);\n      onMouseLeave?.(event as any);\n    }\n  });\n\n  const ariaLabelData = useMemo(\n    () => `${title}: ${formatValue(value as ChartInternalDataTypes)}`,\n    [title, value]\n  );\n\n  return (\n    <Fragment>\n      <motion.g\n        ref={rectRef}\n        tabIndex={0}\n        aria-label={ariaLabelData}\n        role=\"graphics-document\"\n      >\n        <motion.rect\n          key={`sankey-node-${x0}-${x1}-${y0}-${y1}-${index}`}\n          className={classNames(css.node, className)}\n          fillOpacity={opacity(active, disabled)}\n          style={style}\n          width={nodeWidth}\n          height={nodeHeight}\n          fill={color}\n          initial={{\n            opacity: 0,\n            attrX: x0,\n            attrY: y0\n          }}\n          animate={{\n            opacity: 1,\n            attrX: x0,\n            attrY: y0\n          }}\n          exit={{\n            opacity: 0,\n            attrX: x0,\n            attrY: y0\n          }}\n          transition={{\n            duration: 0.1\n          }}\n          onClick={onClick}\n          onPointerOver={pointerOver}\n          onPointerOut={pointerOut}\n        />\n      </motion.g>\n      {label !== null && (\n        <CloneElement<SankeyLabelProps>\n          active={active}\n          element={label}\n          disabled={disabled}\n          chartWidth={chartWidth}\n          nodeWidth={nodeWidth}\n          node={node}\n          position={labelPosition}\n          labelPadding={labelPadding}\n        />\n      )}\n      {!tooltip?.props?.disabled && (\n        <CloneElement<TooltipProps>\n          content={renderTooltipContent}\n          element={tooltip}\n          visible={hovered}\n          reference={rectRef}\n        />\n      )}\n    </Fragment>\n  );\n};\n\nSankeyNode.defaultProps = {\n  active: false,\n  animated: true,\n  color: DEFAULT_COLOR,\n  disabled: false,\n  label: <SankeyLabel />,\n  opacity: (active, disabled) => (active ? 1 : disabled ? 0.2 : 0.9),\n  tooltip: (\n    <Tooltip\n      theme={tooltipTheme}\n      followCursor={true}\n      modifiers={{\n        offset: {\n          offset: '0, 5px'\n        }\n      }}\n    />\n  )\n};\n","import React, { FC } from 'react';\nimport { LineChart, LineChartProps } from '../LineChart';\nimport { ChartShallowDataShape } from '../common/data';\nimport { AreaSeries, Line } from '../AreaChart';\nimport { PointSeries } from '../AreaChart';\nimport {\n  LinearXAxis,\n  LinearYAxis,\n  LinearYAxisTickSeries,\n  LinearXAxisTickSeries\n} from '../common/Axis/LinearAxis';\n\nexport interface SparklineChartProps extends LineChartProps {\n  data: ChartShallowDataShape[];\n}\n\nexport const SparklineChart: FC<Partial<SparklineChartProps>> = (props) => <LineChart {...props} />;\n\nSparklineChart.defaultProps = {\n  gridlines: null,\n  series: (\n    <AreaSeries\n      symbols={<PointSeries show=\"hover\" />}\n      interpolation=\"smooth\"\n      markLine={null}\n      area={null}\n      line={<Line strokeWidth={2} />}\n    />\n  ),\n  yAxis: (\n    <LinearYAxis\n      scaled={true}\n      type=\"value\"\n      axisLine={null}\n      tickSeries={<LinearYAxisTickSeries line={null} label={null} />}\n    />\n  ),\n  xAxis: (\n    <LinearXAxis\n      type=\"time\"\n      scaled={true}\n      axisLine={null}\n      tickSeries={<LinearXAxisTickSeries line={null} label={null} />}\n    />\n  )\n};\n","import React, { FC } from 'react';\nimport {\n  AreaChart,\n  AreaChartProps,\n  AreaSeries,\n  Area,\n  Line\n} from '../AreaChart';\nimport { ChartShallowDataShape } from '../common/data';\nimport { PointSeries } from '../AreaChart';\nimport {\n  LinearYAxisTickSeries,\n  LinearYAxis,\n  LinearXAxis,\n  LinearXAxisTickSeries\n} from '../common/Axis/LinearAxis';\nimport { GradientStop, Gradient } from '../common/Gradient';\nimport { Stripes } from '../common/Mask';\n\nexport interface AreaSparklineChartProps extends AreaChartProps {\n  data: ChartShallowDataShape[];\n}\n\nexport const AreaSparklineChart: FC<Partial<AreaSparklineChartProps>> = (\n  props\n) => <AreaChart {...props} />;\n\nAreaSparklineChart.defaultProps = {\n  gridlines: null,\n  series: (\n    <AreaSeries\n      symbols={<PointSeries show=\"hover\" />}\n      interpolation=\"smooth\"\n      markLine={null}\n      area={\n        <Area\n          mask={<Stripes />}\n          gradient={\n            <Gradient\n              stops={[\n                <GradientStop offset=\"10%\" stopOpacity={0} key=\"start\" />,\n                <GradientStop offset=\"80%\" stopOpacity={1} key=\"stop\" />\n              ]}\n            />\n          }\n        />\n      }\n      line={<Line strokeWidth={3} />}\n    />\n  ),\n  yAxis: (\n    <LinearYAxis\n      type=\"value\"\n      scaled={true}\n      axisLine={null}\n      tickSeries={<LinearYAxisTickSeries line={null} label={null} />}\n    />\n  ),\n  xAxis: (\n    <LinearXAxis\n      type=\"time\"\n      scaled={true}\n      axisLine={null}\n      tickSeries={<LinearXAxisTickSeries line={null} label={null} />}\n    />\n  )\n};\n","import React, { FC } from 'react';\nimport { BarChart, BarChartProps } from '../BarChart';\nimport { ChartShallowDataShape } from '../common/data';\nimport {\n  LinearXAxis,\n  LinearYAxis,\n  LinearYAxisTickSeries,\n  LinearXAxisTickSeries\n} from '../common/Axis';\nimport { BarSeries } from '../BarChart';\nimport { schemes } from '../common/color';\n\nexport interface BarSparklineChartProps extends BarChartProps {\n  data: ChartShallowDataShape[];\n}\n\nexport const BarSparklineChart: FC<Partial<BarSparklineChartProps>> = (props) => <BarChart {...props} />;\n\nBarSparklineChart.defaultProps = {\n  gridlines: null,\n  series: <BarSeries colorScheme={schemes.cybertron[0]} />,\n  yAxis: (\n    <LinearYAxis\n      type=\"value\"\n      axisLine={null}\n      tickSeries={<LinearYAxisTickSeries line={null} label={null} />}\n    />\n  ),\n  xAxis: (\n    <LinearXAxis\n      type=\"category\"\n      axisLine={null}\n      tickSeries={<LinearXAxisTickSeries line={null} label={null} />}\n    />\n  )\n};\n","import React, { FC } from 'react';\nimport {\n  StackedBarChart,\n  StackedBarSeries,\n  Bar,\n  BarChartProps\n} from '../BarChart';\nimport {\n  Gradient,\n  GradientStop,\n  LinearYAxis,\n  LinearXAxis,\n  LinearYAxisTickSeries,\n  LinearXAxisTickSeries,\n  TooltipArea,\n  ChartTooltip,\n  TooltipTemplate,\n  formatValue,\n  ChartNestedDataShape\n} from '../common';\n\nexport interface SonarChartProps extends BarChartProps {\n  data: ChartNestedDataShape[];\n}\n\nexport const SonarChart: FC<Partial<SonarChartProps>> = (props) => (\n  <StackedBarChart\n    {...props}\n    margins={0}\n    gridlines={null}\n    series={\n      <StackedBarSeries\n        type=\"stackedDiverging\"\n        colorScheme=\"rgb(17, 207, 247)\"\n        tooltip={\n          <TooltipArea\n            tooltip={\n              <ChartTooltip\n                followCursor={true}\n                modifiers={{\n                  offset: '5px, 5px'\n                }}\n                content={(data, color) => (\n                  <TooltipTemplate\n                    color={color}\n                    value={{\n                      x: formatValue(data.x),\n                      y: `${formatValue(Math.abs(data.data[0].y))}`\n                    }}\n                  />\n                )}\n              />\n            }\n          />\n        }\n        bar={[\n          <Bar\n            key=\"first\"\n            width={1}\n            rangeLines={null}\n            minHeight={1}\n            gradient={\n              <Gradient\n                stops={[\n                  <GradientStop offset=\"5%\" stopOpacity={0.7} key=\"start\" />,\n                  <GradientStop offset=\"90%\" stopOpacity={1} key=\"stop\" />\n                ]}\n              />\n            }\n          />,\n          <Bar\n            key=\"second\"\n            width={1}\n            rangeLines={null}\n            minHeight={1}\n            gradient={\n              <Gradient\n                stops={[\n                  <GradientStop offset=\"5%\" stopOpacity={1} key=\"stop\" />,\n                  <GradientStop offset=\"90%\" stopOpacity={0.7} key=\"start\" />\n                ]}\n              />\n            }\n          />\n        ]}\n      />\n    }\n    yAxis={\n      <LinearYAxis\n        type=\"value\"\n        axisLine={null}\n        tickSeries={<LinearYAxisTickSeries line={null} label={null} />}\n      />\n    }\n    xAxis={\n      <LinearXAxis\n        type=\"category\"\n        axisLine={null}\n        tickSeries={<LinearXAxisTickSeries line={null} label={null} />}\n      />\n    }\n  />\n);\n","import React, { ReactElement, useCallback, FC, useMemo, Fragment } from 'react';\nimport { ChartInternalShallowDataShape } from '../../common/data';\nimport {\n  radialArea,\n  curveCardinalClosed,\n  curveLinearClosed,\n  curveCardinal,\n  curveLinear\n} from 'd3-shape';\nimport { RadialGradient, RadialGradientProps } from '../../common/Gradient';\nimport { CloneElement } from 'reablocks';\nimport { RadialInterpolationTypes } from '../../common/utils/interpolation';\nimport { MotionPath, DEFAULT_TRANSITION } from '../../common/Motion';\n\nexport interface RadialAreaProps {\n  /**\n   * Parsed data shape. Set internally by `RadialAreaChart`.\n   */\n  data: ChartInternalShallowDataShape[];\n\n  /**\n   * Whether to animate the enter/update/exit.\n   */\n  animated: boolean;\n\n  /**\n   * D3 scale for X Axis. Set internally by `RadialAreaChart`.\n   */\n  xScale: any;\n\n  /**\n   * D3 scale for Y Axis. Set internally by `RadialAreaChart`.\n   */\n  yScale: any;\n\n  /**\n   * Interpolation for the area. Set internally by `RadialAreaSeries`.\n   */\n  interpolation: RadialInterpolationTypes;\n\n  /**\n   * Color for the area. Set internally by `RadialAreaSeries`.\n   */\n  color: any;\n\n  /**\n   * Id set internally by `RadialAreaSeries`.\n   */\n  id: string;\n\n  /**\n   * The inner radius for the chart center.\n   */\n  innerRadius: number;\n\n  /**\n   * The outer radius for the chart center.\n   */\n  outerRadius: number;\n\n  /**\n   * CSS classes to apply.\n   */\n  className?: string;\n\n  /**\n   * Index of the area in the series. Set internally by `RadialAreaSeries`.\n   */\n  index: number;\n\n  /**\n   * Gradient to apply to the area.\n   */\n  gradient: ReactElement<RadialGradientProps, typeof RadialGradient> | null;\n\n  /**\n   * Whether the curve should be closed. Set to true by deafult\n   */\n  isClosedCurve: boolean;\n}\n\nexport const RadialArea: FC<Partial<RadialAreaProps>> = ({\n  id,\n  data,\n  className,\n  yScale,\n  color,\n  animated,\n  index,\n  outerRadius,\n  xScale,\n  innerRadius,\n  interpolation,\n  gradient,\n  isClosedCurve\n}) => {\n  const transition = useMemo(\n    () =>\n      animated\n        ? {\n          ...DEFAULT_TRANSITION,\n          delay: index * 0.05\n        }\n        : {\n          type: false,\n          delay: 0\n        },\n    [animated, index]\n  );\n\n  const getFill = useCallback(\n    (c: string) => {\n      if (!gradient) {\n        return c;\n      }\n\n      return `url(#${id}-gradient)`;\n    },\n    [id, gradient]\n  );\n\n  const getPath = useCallback(\n    (d: ChartInternalShallowDataShape[]) => {\n      const curve =\n        interpolation === 'smooth'\n          ? isClosedCurve\n            ? curveCardinalClosed\n            : curveCardinal\n          : isClosedCurve\n            ? curveLinearClosed\n            : curveLinear;\n\n      const radialFn = radialArea()\n        .angle((dd: any) => xScale(dd.x))\n        .innerRadius((_) => innerRadius!)\n        .outerRadius((d: any) => yScale(d.y))\n        .curve(curve);\n\n      return radialFn(d as any);\n    },\n    [interpolation, isClosedCurve, xScale, innerRadius, yScale]\n  );\n\n  const enter = useMemo(\n    () => ({\n      d: getPath(data!),\n      opacity: 1\n    }),\n    [data, getPath]\n  );\n\n  const exit = useMemo(() => {\n    const [yStart] = yScale.domain();\n    return {\n      d: getPath(data!.map((d) => ({ ...d, y: yStart }))),\n      opacity: 0\n    };\n  }, [data, getPath, yScale]);\n\n  const fill = color(data, 0);\n\n  return (\n    <Fragment>\n      <MotionPath\n        custom={{\n          enter,\n          exit\n        }}\n        transition={transition}\n        pointerEvents=\"none\"\n        className={className}\n        fill={getFill(color)}\n      />\n      {gradient && (\n        <CloneElement<RadialGradientProps>\n          element={gradient}\n          id={`${id}-gradient`}\n          radius={outerRadius}\n          color={fill}\n        />\n      )}\n    </Fragment>\n  );\n};\n\nRadialArea.defaultProps = {\n  gradient: <RadialGradient />,\n  isClosedCurve: true\n};\n","import React, { useCallback, useMemo, FC } from 'react';\nimport { ChartInternalShallowDataShape } from '../../common/data';\nimport { radialLine, curveCardinalClosed, curveLinearClosed, curveCardinal, curveLinear } from 'd3-shape';\nimport { RadialInterpolationTypes } from '../../common/utils/interpolation';\nimport { MotionPath, DEFAULT_TRANSITION } from '../../common/Motion';\n\nexport interface RadialLineProps {\n  /**\n   * Parsed data shape. Set internally by `RadialAreaChart`.\n   */\n  data: ChartInternalShallowDataShape[];\n\n  /**\n   * Whether to animate the enter/update/exit. Set internally by `RadialAreaSeries`.\n   */\n  animated: boolean;\n\n  /**\n   * D3 scale for X Axis. Set internally by `RadialAreaChart`.\n   */\n  xScale: any;\n\n  /**\n   * D3 scale for Y Axis. Set internally by `RadialAreaChart`.\n   */\n  yScale: any;\n\n  /**\n   * Color for the area. Set internally by `RadialAreaSeries`.\n   */\n  color: any;\n\n  /**\n   * Interpolation for the area. Set internally by `RadialAreaSeries`.\n   */\n  interpolation: RadialInterpolationTypes;\n\n  /**\n   * Index of the area in the series. Set internally by `RadialAreaSeries`.\n   */\n  index: number;\n\n  /**\n   * Stroke width of the line.\n   */\n  strokeWidth: number;\n\n  /**\n   * CSS classes to apply.\n   */\n  className?: string;\n\n  /**\n   * Internal property to identify if there is a area or not.\n   */\n  hasArea: boolean;\n  \n  /**\n   * Whether the curve should be closed. Set to true by deafult\n   */\n  isClosedCurve: boolean;\n}\n\nexport const RadialLine: FC<Partial<RadialLineProps>> = ({\n  xScale,\n  yScale,\n  className,\n  index,\n  hasArea,\n  color,\n  data,\n  interpolation,\n  strokeWidth,\n  animated,\n  isClosedCurve\n}) => {\n  const fill = color(data, index);\n\n  const getPath = useCallback(\n    (preData: ChartInternalShallowDataShape[]) => {\n      const curve =\n        interpolation === 'smooth' ? (isClosedCurve ? curveCardinalClosed : curveCardinal) : isClosedCurve ? curveLinearClosed : curveLinear;\n\n      const radialFn = radialLine()\n        .angle((d: any) => xScale(d.x))\n        .radius((d: any) => yScale(d.y))\n        .curve(curve);\n\n      return radialFn(preData as any);\n    },\n    [interpolation, isClosedCurve, xScale, yScale]\n  );\n\n  const transition = useMemo(\n    () =>\n      animated\n        ? {\n          ...DEFAULT_TRANSITION,\n          delay: hasArea ? 0 : index * 0.05\n        }\n        : {\n          type: false,\n          delay: 0\n        },\n    [animated, index, hasArea]\n  );\n\n  const enter = useMemo(\n    () => ({\n      d: getPath(data!),\n      opacity: 1\n    }),\n    [data, getPath]\n  );\n\n  const exit = useMemo(() => {\n    const [yStart] = yScale.domain();\n    return {\n      d: getPath(data!.map((d) => ({ ...d, y: yStart }))),\n      opacity: 0\n    };\n  }, [data, yScale, getPath]);\n\n  return (\n    <MotionPath\n      custom={{\n        enter,\n        exit\n      }}\n      transition={transition}\n      className={className}\n      pointerEvents=\"none\"\n      stroke={fill}\n      fill=\"none\"\n      strokeWidth={strokeWidth}\n    />\n  );\n};\n\nRadialLine.defaultProps = {\n  strokeWidth: 2,\n  animated: true,\n  isClosedCurve: true\n};\n","import React, { FC, useCallback, Fragment, ReactElement } from 'react';\nimport {\n  ChartShallowDataShape,\n  buildShallowChartData,\n  ChartInternalShallowDataShape\n} from '../common/data';\nimport { scaleBand, scaleTime } from 'd3-scale';\nimport { getYDomain, getXDomain } from '../common/utils/domains';\nimport {\n  RadialScatterSeries,\n  RadialScatterSeriesProps\n} from './RadialScatterSeries';\nimport {\n  ChartProps,\n  ChartContainer,\n  ChartContainerChildProps\n} from '../common/containers';\nimport { CloneElement } from 'reablocks';\nimport { RadialAxisProps, RadialAxis } from '../common/Axis/RadialAxis';\nimport { getRadialYScale } from '../common/scales';\nimport { uniqueBy } from '../common';\n\nexport interface RadialScatterPlotProps extends ChartProps {\n  /**\n   * Data the chart will receive to render.\n   */\n  data: ChartShallowDataShape[];\n\n  /**\n   * The series component that renders the scatter components.\n   */\n  series: ReactElement<RadialScatterSeriesProps, typeof RadialScatterSeries>;\n\n  /**\n   * The radial axis component for the chart.\n   */\n  axis: ReactElement<RadialAxisProps, typeof RadialAxis> | null;\n\n  /**\n   * The inner radius for the chart center.\n   */\n  innerRadius: number;\n}\n\nexport const RadialScatterPlot: FC<Partial<RadialScatterPlotProps>> = ({\n  id,\n  width,\n  height,\n  margins,\n  className,\n  containerClassName,\n  innerRadius,\n  series,\n  axis,\n  data\n}) => {\n  const getScales = useCallback(\n    (\n      aggregatedData: ChartInternalShallowDataShape[],\n      outer: number,\n      inner: number\n    ) => {\n      let xScale;\n      if (axis?.props.type === 'category') {\n        const xDomain = uniqueBy<ChartInternalShallowDataShape>(\n          aggregatedData,\n          (dd) => dd.x\n        );\n        xScale = scaleBand()\n          .range([0, 2 * Math.PI])\n          .domain(xDomain as any[]);\n      } else {\n        const xDomain = getXDomain({ data: aggregatedData });\n        xScale = scaleTime()\n          .range([0, 2 * Math.PI])\n          .domain(xDomain);\n      }\n\n      const yDomain = getYDomain({ data: aggregatedData, scaled: false });\n      const yScale = getRadialYScale(inner, outer, yDomain);\n\n      return {\n        yScale,\n        xScale\n      };\n    },\n    []\n  );\n\n  const renderChart = useCallback(\n    (containerProps: ChartContainerChildProps) => {\n      const { chartWidth, chartHeight, id } = containerProps;\n      const outerRadius = Math.min(chartWidth, chartHeight) / 2;\n      const aggregatedData = buildShallowChartData(data);\n      const { yScale, xScale } = getScales(\n        aggregatedData,\n        outerRadius,\n        innerRadius\n      );\n\n      return (\n        <Fragment>\n          {axis && (\n            <CloneElement<RadialAxisProps>\n              element={axis}\n              xScale={xScale}\n              height={chartHeight}\n              width={chartWidth}\n              innerRadius={innerRadius}\n            />\n          )}\n          <CloneElement<RadialScatterSeriesProps>\n            element={series}\n            id={id}\n            data={aggregatedData}\n            xScale={xScale}\n            yScale={yScale}\n          />\n        </Fragment>\n      );\n    },\n    [data, getScales, innerRadius, series, axis]\n  );\n\n  return (\n    <ChartContainer\n      id={id}\n      containerClassName={containerClassName}\n      width={width}\n      height={height}\n      margins={margins}\n      xAxisVisible={false}\n      yAxisVisible={false}\n      center={true}\n      className={className}\n    >\n      {renderChart}\n    </ChartContainer>\n  );\n};\n","import React, {\n  ReactNode,\n  useRef,\n  Fragment,\n  ReactElement,\n  FC,\n  useState,\n  useMemo\n} from 'react';\nimport { ChartInternalShallowDataShape } from '../../common/data';\nimport { radialLine } from 'd3-shape';\nimport classNames from 'classnames';\nimport { ChartTooltip, ChartTooltipProps } from '../../common/Tooltip';\nimport { CloneElement } from 'reablocks';\nimport { motion } from 'framer-motion';\nimport { DEFAULT_TRANSITION } from '../../common/Motion';\nimport { schemes } from '../../common/color';\nimport css from './RadialScatterPoint.module.css';\nimport { getAriaLabel } from '../../common';\n\nexport interface RadialScatterPointProps {\n  /**\n   * Parsed data shape. Set internally by `RadialScatterPlot`.\n   */\n  data: ChartInternalShallowDataShape;\n\n  /**\n   * Index of the element in the series. Set internally by `RadialScatterSeries`.\n   */\n  index: number;\n\n  /**\n   * Whether the element is active or not. Set internally by `RadialScatterSeries`.\n   */\n  animated: boolean;\n\n  /**\n   * D3 scale for X Axis. Set internally by `RadialScatterPlot`.\n   */\n  xScale: any;\n\n  /**\n   * D3 scale for Y Axis. Set internally by `RadialScatterPlot`.\n   */\n  yScale: any;\n\n  /**\n   * Fill for the element.\n   */\n  fill: string;\n\n  /**\n   * Id set internally by `RadialScatterPlot`.\n   */\n  id: string;\n\n  /**\n   * Color of the circle.\n   */\n  color: any;\n\n  /**\n   * CSS classes to apply.\n   */\n  className?: any;\n\n  /**\n   * Whether the element is active or not. Set internally by `RadialScatterSeries`.\n   */\n  active?: boolean;\n\n  /**\n   * Whether the elment is visiblbe or not.\n   */\n  visible?: (value, index) => boolean;\n\n  /**\n   * Symbol element to render.\n   */\n  symbol: (value) => ReactNode;\n\n  /**\n   * Size of the circle element.\n   */\n  size?: ((d) => number) | number;\n\n  /**\n   * Tooltip element.\n   */\n  tooltip: ReactElement<ChartTooltipProps, typeof ChartTooltip> | null;\n\n  /**\n   * Event for when a symbol is clicked.\n   */\n  onClick: (event) => void;\n\n  /**\n   * Event for when the symbol has mouse enter.\n   */\n  onMouseEnter: (event) => void;\n\n  /**\n   * Event for when the symbol has mouse leave.\n   */\n  onMouseLeave: (event) => void;\n}\n\nexport const RadialScatterPoint: FC<Partial<RadialScatterPointProps>> = ({\n  size,\n  data,\n  color,\n  index,\n  symbol,\n  active,\n  tooltip,\n  yScale,\n  xScale,\n  animated,\n  className,\n  visible,\n  ...rest\n}) => {\n  const ref = useRef<any>(null);\n  const [hovered, setHovered] = useState<boolean>(false);\n\n  function onMouseEnter(event: React.MouseEvent) {\n    setHovered(true);\n    rest.onMouseEnter({\n      value: data,\n      nativeEvent: event\n    });\n  }\n\n  function onMouseLeave(event: React.MouseEvent) {\n    setHovered(false);\n    rest.onMouseLeave({\n      value: data,\n      nativeEvent: event\n    });\n  }\n\n  function onClick(event: React.MouseEvent) {\n    rest.onClick({\n      value: data,\n      nativeEvent: event\n    });\n  }\n\n  function getTranslate(data: ChartInternalShallowDataShape) {\n    const fn = radialLine()\n      .radius((d: any) => yScale(d.y))\n      .angle((d: any) => xScale(d.x));\n\n    // Parse the generated path to get point coordinates\n    // Ref: https://bit.ly/2CnZcPl\n    const path = fn([data] as any);\n\n    if (path) {\n      const [translateX, translateY] = path.slice(1).slice(0, -1).split(',');\n\n      return {\n        translateX: parseFloat(translateX),\n        translateY: parseFloat(translateY)\n      };\n    }\n  }\n\n  function getTransition() {\n    if (animated) {\n      return {\n        ...DEFAULT_TRANSITION,\n        delay: index * 0.005\n      };\n    } else {\n      return {\n        type: false,\n        delay: 0\n      };\n    }\n  }\n\n  const fill = typeof color === 'function' ? color(data, index) : color;\n  const transform = getTranslate(data);\n  const sizeVal = typeof size === 'function' ? size(data) : size;\n  const transition = getTransition();\n\n  const [yStart] = yScale.domain();\n  const exitTransform = getTranslate({ ...data, y: yStart });\n\n  const ariaLabelData = useMemo(() => getAriaLabel(data), [data]);\n\n  const isVisible = visible ? visible?.(data, index) : active;\n\n  return (\n    <Fragment>\n      <motion.g\n        initial={{ ...exitTransform, opacity: 0 }}\n        animate={{ ...transform, opacity: 1 }}\n        exit={{ ...exitTransform, opacity: 0 }}\n        transition={transition}\n        ref={ref}\n        onMouseEnter={onMouseEnter}\n        onMouseLeave={onMouseLeave}\n        onClick={onClick}\n        className={classNames(className, {\n          [css.inactive]: !active,\n          [css.hidden]: !isVisible\n        })}\n        tabIndex={0}\n        aria-label={ariaLabelData}\n        role=\"graphics-document\"\n      >\n        {symbol && symbol(data)}\n        {!symbol && <circle r={sizeVal} fill={fill} />}\n      </motion.g>\n      {tooltip && (\n        <CloneElement<ChartTooltipProps>\n          element={tooltip}\n          visible={hovered}\n          reference={ref}\n          value={data}\n        />\n      )}\n    </Fragment>\n  );\n};\n\nRadialScatterPoint.defaultProps = {\n  size: 3,\n  color: schemes.cybertron[0],\n  tooltip: <ChartTooltip />,\n  active: true,\n  onClick: () => undefined,\n  onMouseEnter: () => undefined,\n  onMouseLeave: () => undefined\n};\n","import React, {\n  useState,\n  FC,\n  Fragment,\n  ReactElement,\n  useEffect,\n  useCallback\n} from 'react';\nimport { ChartInternalShallowDataShape } from '../../common/data';\nimport {\n  RadialScatterPoint,\n  RadialScatterPointProps\n} from './RadialScatterPoint';\nimport { CloneElement } from 'reablocks';\nimport { identifier } from 'safe-identifier';\nimport { RadialValueMarker, RadialValueMarkerProps } from '../../common';\n\nexport interface RadialScatterSeriesProps {\n  /**\n   * Point that is rendered.\n   */\n  point: ReactElement<RadialScatterPointProps, typeof RadialScatterPoint>;\n\n  /**\n   * D3 scale for X Axis. Set internally by `RadialScatterPlot`.\n   */\n  xScale: any;\n\n  /**\n   * D3 scale for Y Axis. Set internally by `RadialScatterPlot`.\n   */\n  yScale: any;\n\n  /**\n   * Parsed data shape. Set internally by `RadialScatterPlot`.\n   */\n  data: ChartInternalShallowDataShape[];\n\n  /**\n   * Id set internally by `RadialScatterPlot`.\n   */\n  id: string;\n\n  /**\n   * Whether to animate the enter/update/exit.\n   */\n  animated: boolean;\n\n  /**\n   * Active element ids to highlight.\n   */\n  activeIds?: string[];\n\n  /**\n   * When to show the point.\n   */\n  show: boolean;\n\n  /**\n   * Value markers line for the chart.\n   */\n  valueMarkers:\n    | ReactElement<RadialValueMarkerProps, typeof RadialValueMarker>[]\n    | null;\n}\n\nexport const RadialScatterSeries: FC<Partial<RadialScatterSeriesProps>> = ({\n  data,\n  point,\n  xScale,\n  yScale,\n  animated,\n  activeIds,\n  show = true,\n  valueMarkers\n}) => {\n  const [internalActiveIds, setInternalActiveIds] = useState<string[] | null>(\n    activeIds\n  );\n\n  useEffect(() => {\n    setInternalActiveIds(activeIds || []);\n  }, [activeIds]);\n\n  const onMouseEnter = useCallback(\n    ({ value }) => {\n      // Only perform this on unmanaged activations\n      if (!activeIds) {\n        setInternalActiveIds([value.id]);\n      }\n    },\n    [activeIds]\n  );\n\n  const onMouseLeave = useCallback(() => {\n    // Only perform this on unmanaged activations\n    if (!activeIds) {\n      setInternalActiveIds([]);\n    }\n  }, [activeIds]);\n\n  const isVisible = useCallback(() => show, [show]);\n\n  const renderPoint = useCallback(\n    (d: ChartInternalShallowDataShape, index: number) => {\n      let dataId;\n      if (d.id) {\n        dataId = d.id;\n      } else {\n        console.warn(\n          'No \\'id\\' property provided for scatter point; provide one via \\'id\\'.'\n        );\n      }\n\n      const key = identifier(`${dataId || index}`);\n      const active =\n        !(internalActiveIds && internalActiveIds.length) ||\n        internalActiveIds.includes(dataId);\n\n      const pointVisible = point.props?.visible;\n\n      return (\n        <CloneElement<RadialScatterPointProps>\n          /* Trick to pass isVisible callback, directly cannot be passed when point is a cloned element already */\n          {...(pointVisible ? {} : { visible: isVisible })}\n          element={point}\n          key={key}\n          data={d}\n          index={index}\n          active={active}\n          xScale={xScale}\n          yScale={yScale}\n          animated={animated}\n          onMouseEnter={onMouseEnter}\n          onMouseLeave={onMouseLeave}\n        />\n      );\n    },\n    [\n      isVisible,\n      point,\n      internalActiveIds,\n      xScale,\n      yScale,\n      animated,\n      onMouseEnter,\n      onMouseLeave\n    ]\n  );\n\n  const renderValueMarkers = useCallback(\n    () => (\n      <>\n        {valueMarkers?.length &&\n          valueMarkers.map((marker) => (\n            <CloneElement<RadialValueMarkerProps>\n              key={marker.key}\n              element={marker}\n              value={yScale(marker.props.value)}\n            />\n          ))}\n      </>\n    ),\n    [valueMarkers, yScale]\n  );\n\n  return (\n    <Fragment>\n      {renderValueMarkers()}\n      {data.map(renderPoint)}\n    </Fragment>\n  );\n};\n\nRadialScatterSeries.defaultProps = {\n  point: <RadialScatterPoint />,\n  animated: true\n};\n","import React, { useCallback, ReactElement, FC } from 'react';\nimport {\n  RadialScatterSeries,\n  RadialScatterPoint,\n  RadialScatterPointProps\n} from '../../RadialScatterPlot';\nimport { ChartInternalShallowDataShape } from '../../common/data';\nimport { CloneElement } from 'reablocks';\nimport isEqual from 'react-fast-compare';\n\nexport interface RadialPointSeriesProps {\n  /**\n   * Whether the points are animated or not.\n   */\n  animated: boolean;\n\n  /**\n   * Color scheme.\n   */\n  color: any;\n\n  /**\n   * Index of the area in the series. Set internally by `RadialAreaSeries`.\n   */\n  index: number;\n\n  /**\n   * Active values set by parent.\n   */\n  activeValues?: any;\n\n  /**\n   * Parsed data object.\n   */\n  data: ChartInternalShallowDataShape[];\n\n  /**\n   * D3 X-Scale.\n   */\n  yScale: any;\n\n  /**\n   * D3 Y-Scale.\n   */\n  xScale: any;\n\n  /**\n   * When to show the point.\n   */\n  show: boolean | 'hover' | 'first' | 'last';\n\n  /**\n   * Point react component.\n   */\n  point: ReactElement<RadialScatterPointProps, typeof RadialScatterPoint>;\n}\n\nexport const RadialPointSeries: FC<Partial<RadialPointSeriesProps>> = ({\n  data,\n  xScale,\n  yScale,\n  animated,\n  color,\n  activeValues,\n  show,\n  point\n}) => {\n  const isVisible = useCallback(\n    (point: ChartInternalShallowDataShape, index: number) => {\n      const isActive =\n        activeValues && point && isEqual(activeValues.x, point.x);\n\n      if (show === 'hover') {\n        return isActive;\n      } else if (show === 'first') {\n        if (activeValues) {\n          return isActive;\n        } else {\n          return index === 0;\n        }\n      } else if (show === 'last') {\n        if (activeValues) {\n          return isActive;\n        } else {\n          return index === data!.length - 1;\n        }\n      }\n\n      return show;\n    },\n    [data, activeValues, show]\n  );\n\n  return (\n    <RadialScatterSeries\n      animated={animated}\n      data={data}\n      xScale={xScale}\n      yScale={yScale}\n      point={\n        <CloneElement<RadialScatterPointProps>\n          element={point}\n          color={color}\n          tooltip={null}\n          visible={isVisible}\n        />\n      }\n    />\n  );\n};\n\nRadialPointSeries.defaultProps = {\n  show: 'hover',\n  type: 'standard',\n  point: <RadialScatterPoint />\n};\n","import React, {\n  FC,\n  Fragment,\n  ReactElement,\n  useCallback,\n  useState\n} from 'react';\nimport {\n  ChartInternalNestedDataShape,\n  ChartInternalShallowDataShape\n} from '../../common/data';\nimport { getColor, ColorSchemeType, schemes } from '../../common/color';\nimport { CloneElement } from 'reablocks';\nimport { RadialAreaProps, RadialArea } from './RadialArea';\nimport { RadialLine, RadialLineProps } from './RadialLine';\nimport { RadialInterpolationTypes } from '../../common/utils/interpolation';\nimport { RadialPointSeries, RadialPointSeriesProps } from './RadialPointSeries';\nimport { TooltipAreaProps, TooltipArea } from '../../common/Tooltip';\nimport { RadialValueMarker, RadialValueMarkerProps } from '../../common';\n\nexport type RadialPointSeriesType = 'standard' | 'grouped';\n\nexport interface RadialAreaSeriesProps {\n  /**\n   * Parsed data shape. Set internally by `RadialAreaChart`.\n   */\n  data: ChartInternalShallowDataShape[];\n\n  /**\n   * The type of the chart.\n   */\n  type?: RadialPointSeriesType;\n\n  /**\n   * Color scheme for the series.\n   */\n  colorScheme: ColorSchemeType;\n\n  /**\n   * The outer radius for the chart center.\n   */\n  outerRadius: number;\n\n  /**\n   * The inner radius for the chart center.\n   */\n  innerRadius: number;\n\n  /**\n   * D3 scale for X Axis. Set internally by `RadialAreaChart`.\n   */\n  xScale: any;\n\n  /**\n   * D3 scale for Y Axis. Set internally by `RadialAreaChart`.\n   */\n  yScale: any;\n\n  /**\n   * Id set internally by `RadialAreaChart`.\n   */\n  id: string;\n\n  /**\n   * interpolation set internally by `RadialAreaChart`.\n   */\n  interpolation: RadialInterpolationTypes;\n\n  /**\n   * Whether to animate the enter/update/exit.\n   */\n  animated: boolean;\n\n  /**\n   * Height of the chart. Set internally by `RadialAreaChart`.\n   */\n  height: number;\n\n  /**\n   * Width of the chart. Set internally by `RadialAreaChart`.\n   */\n  width: number;\n\n  /**\n   * Area that is rendered.\n   */\n  area: ReactElement<RadialAreaProps, typeof RadialArea> | null;\n\n  /**\n   * Line that is rendered.\n   */\n  line: ReactElement<RadialLineProps, typeof RadialLine> | null;\n\n  /**\n   * Symbols used to show points.\n   */\n  symbols: ReactElement<\n    RadialPointSeriesProps,\n    typeof RadialPointSeries\n  > | null;\n\n  /**\n   * Tooltip for the chart area.\n   */\n  tooltip: ReactElement<TooltipAreaProps, typeof TooltipArea>;\n\n  /**\n   * Start angle for the first value.\n   */\n  startAngle?: number;\n\n  /**\n   * End angle for the last value.\n   */\n  endAngle?: number;\n\n  /**\n   * Whether the curve should be closed. Set to true by deafult\n   */\n  isClosedCurve: boolean;\n\n  /**\n   * Value markers line for the chart.\n   */\n  valueMarkers:\n    | ReactElement<RadialValueMarkerProps, typeof RadialValueMarker>[]\n    | null;\n}\n\nexport const RadialAreaSeries: FC<Partial<RadialAreaSeriesProps>> = ({\n  area,\n  line,\n  symbols,\n  tooltip,\n  xScale,\n  yScale,\n  data,\n  id,\n  animated,\n  width,\n  height,\n  innerRadius,\n  outerRadius,\n  type,\n  colorScheme,\n  interpolation,\n  startAngle,\n  endAngle,\n  isClosedCurve,\n  valueMarkers\n}) => {\n  const [activeValues, setActiveValues] = useState<any | null>(null);\n  const isMulti = type === 'grouped';\n\n  const getColorForPoint = useCallback(\n    (point: ChartInternalShallowDataShape, index: number) => {\n      const key = Array.isArray(point) ? point?.[0]?.key : point?.key;\n\n      return getColor({\n        colorScheme,\n        data,\n        index,\n        point,\n        key\n      });\n    },\n    [colorScheme, data]\n  );\n\n  const renderArea = useCallback(\n    (point: ChartInternalShallowDataShape[], index = 0) => (\n      <>\n        {area && (\n          <CloneElement<RadialAreaProps>\n            element={area}\n            id={`${id}-radial-area-${index}`}\n            xScale={xScale}\n            yScale={yScale}\n            animated={animated}\n            color={getColorForPoint}\n            index={index}\n            data={point}\n            interpolation={interpolation}\n            outerRadius={outerRadius}\n            innerRadius={innerRadius}\n            isClosedCurve={isClosedCurve}\n          />\n        )}\n        {line && (\n          <CloneElement<RadialLineProps>\n            element={line}\n            xScale={xScale}\n            yScale={yScale}\n            hasArea={area !== null}\n            index={index}\n            animated={animated}\n            interpolation={interpolation}\n            color={getColorForPoint}\n            data={point}\n            isClosedCurve={isClosedCurve}\n          />\n        )}\n      </>\n    ),\n    [\n      animated,\n      area,\n      getColorForPoint,\n      id,\n      innerRadius,\n      interpolation,\n      isClosedCurve,\n      line,\n      outerRadius,\n      xScale,\n      yScale\n    ]\n  );\n\n  const renderSymbols = useCallback(\n    (data: ChartInternalShallowDataShape[], index = 0) => {\n      // Animations are only valid for Area\n      const activeSymbols =\n        (symbols && symbols.props.activeValues) || activeValues;\n      const isAnimated = area !== undefined && animated && !activeSymbols;\n\n      return (\n        <CloneElement<RadialPointSeriesProps>\n          element={symbols}\n          activeValues={activeValues}\n          xScale={xScale}\n          index={index}\n          yScale={yScale}\n          data={data}\n          animated={isAnimated}\n          color={getColorForPoint}\n        />\n      );\n    },\n    [activeValues, animated, area, getColorForPoint, symbols, xScale, yScale]\n  );\n\n  const renderSingleSeries = useCallback(\n    (points: ChartInternalShallowDataShape[]) => (\n      <Fragment>\n        {renderArea(points)}\n        {symbols && renderSymbols(points)}\n      </Fragment>\n    ),\n    [renderArea, renderSymbols, symbols]\n  );\n\n  const renderMultiSeries = useCallback(\n    (points: ChartInternalNestedDataShape[]) => (\n      <Fragment>\n        {points\n          .map((point, index) => (\n            <Fragment key={`${point.key!.toString()}`}>\n              {renderArea(point.data, index)}\n            </Fragment>\n          ))\n          .reverse()}\n        {points\n          .map((point, index) => (\n            <Fragment key={`${point.key!.toString()}`}>\n              {renderSymbols(point.data, index)}\n            </Fragment>\n          ))\n          .reverse()}\n      </Fragment>\n    ),\n    [renderArea, renderSymbols]\n  );\n\n  const renderValueMarkers = useCallback(\n    () => (\n      <>\n        {valueMarkers?.length &&\n          valueMarkers.map((marker) => (\n            <CloneElement<RadialValueMarkerProps>\n              key={marker.key}\n              element={marker}\n              value={yScale(marker.props.value)}\n            />\n          ))}\n      </>\n    ),\n    [valueMarkers, yScale]\n  );\n\n  return (\n    <CloneElement<TooltipAreaProps>\n      element={tooltip}\n      xScale={xScale}\n      yScale={yScale}\n      data={data}\n      height={height}\n      width={width}\n      isRadial={true}\n      innerRadius={innerRadius}\n      outerRadius={outerRadius}\n      color={getColorForPoint}\n      onValueEnter={(event) => setActiveValues(event.value)}\n      onValueLeave={() => setActiveValues(null)}\n      startAngle={startAngle}\n      endAngle={endAngle}\n    >\n      <g clipPath={`url(#${id}-path)`}>\n        {isMulti &&\n          renderMultiSeries(data as unknown as ChartInternalNestedDataShape[])}\n        {!isMulti &&\n          renderSingleSeries(data as ChartInternalShallowDataShape[])}\n        {renderValueMarkers()}\n      </g>\n    </CloneElement>\n  );\n};\n\nRadialAreaSeries.defaultProps = {\n  colorScheme: schemes.cybertron,\n  interpolation: 'smooth',\n  type: 'standard',\n  animated: true,\n  area: <RadialArea />,\n  line: <RadialLine />,\n  symbols: <RadialPointSeries />,\n  tooltip: <TooltipArea />,\n  startAngle: 0,\n  endAngle: 2 * Math.PI,\n  isClosedCurve: true\n};\n","import React, { Fragment, ReactElement, FC, useCallback } from 'react';\nimport {\n  ChartInternalShallowDataShape,\n  buildShallowChartData,\n  ChartDataShape,\n  buildNestedChartData,\n  ChartNestedDataShape,\n  ChartShallowDataShape\n} from '../common/data';\nimport { scaleTime, scaleBand, scalePoint } from 'd3-scale';\nimport { getYDomain, getXDomain } from '../common/utils/domains';\nimport {\n  ChartProps,\n  ChartContainer,\n  ChartContainerChildProps\n} from '../common/containers';\nimport { CloneElement } from 'reablocks';\nimport { RadialAreaSeries, RadialAreaSeriesProps } from './RadialAreaSeries';\nimport { RadialAxis, RadialAxisProps } from '../common/Axis/RadialAxis';\nimport { getRadialYScale } from '../common/scales/radial';\nimport { uniqueBy } from '../common/utils';\n\nexport interface RadialAreaChartProps extends ChartProps {\n  /**\n   * Data the chart will receive to render.\n   */\n  data: ChartDataShape[];\n\n  /**\n   * The series component that renders the area components.\n   */\n  series: ReactElement<RadialAreaSeriesProps, typeof RadialAreaSeries>;\n\n  /**\n   * The radial axis component for the chart.\n   */\n  innerRadius: number;\n\n  /**\n   * The inner radius for the chart center.\n   */\n  axis: ReactElement<RadialAxisProps, typeof RadialAxis> | null;\n\n  /**\n   * Start angle for the first value.\n   */\n  startAngle?: number;\n\n  /**\n   * End angle for the last value.\n   */\n  endAngle?: number;\n\n  /**\n   * Whether the curve should be closed. Set to true by deafult\n   */\n  isClosedCurve?: boolean;\n}\n\nexport const RadialAreaChart: FC<Partial<RadialAreaChartProps>> = ({\n  id,\n  width,\n  height,\n  className,\n  data,\n  containerClassName,\n  innerRadius,\n  series,\n  axis,\n  margins,\n  startAngle,\n  endAngle,\n  isClosedCurve\n}) => {\n  const getXScale = useCallback(\n    (points) => {\n      const isFullCircle = Math.abs(endAngle - startAngle) >= 2 * Math.PI;\n      let xScale;\n      if (axis?.props.type === 'category') {\n        const isMultiSeries = series.props.type === 'grouped';\n\n        let xDomain;\n        if (isMultiSeries) {\n          xDomain = uniqueBy<ChartInternalShallowDataShape>(\n            points,\n            (dd) => dd.data,\n            (dd) => dd.x\n          );\n        } else {\n          xDomain = uniqueBy<ChartInternalShallowDataShape>(\n            points,\n            (dd) => dd.x\n          );\n        }\n\n        if (isFullCircle) {\n          xScale = scaleBand()\n            .range([0, 2 * Math.PI])\n            .domain(xDomain as any[]);\n        } else {\n          // scaleBand() excludes the end value from the band:\n          //  https://www.d3indepth.com/scales/#scaleband\n          xScale = scalePoint()\n            .range([startAngle, endAngle])\n            .domain(xDomain as any[]);\n        }\n      } else {\n        const xDomain = getXDomain({ data: points });\n\n        xScale = scaleTime().range([startAngle, endAngle]).domain(xDomain);\n      }\n\n      return xScale;\n    },\n    [axis?.props.type, endAngle, series.props.type, startAngle]\n  );\n\n  const getScales = useCallback(\n    (preData: ChartDataShape[], outerRadius: number, innerRadius: number) => {\n      const isMultiSeries = series.props.type === 'grouped';\n\n      let d;\n      if (isMultiSeries) {\n        d = buildNestedChartData(preData as ChartNestedDataShape[], true);\n      } else {\n        d = buildShallowChartData(preData as ChartShallowDataShape[]);\n      }\n\n      const xScale = getXScale(d);\n      const yDomain = getYDomain({ data: d, scaled: false });\n      const yScale = getRadialYScale(innerRadius, outerRadius, yDomain);\n\n      return {\n        yScale,\n        xScale,\n        result: d\n      };\n    },\n    [getXScale, series.props.type]\n  );\n\n  const renderChart = useCallback(\n    (containerProps: ChartContainerChildProps) => {\n      const { chartWidth, chartHeight, id } = containerProps;\n      const outerRadius = Math.min(chartWidth, chartHeight) / 2;\n      const { yScale, xScale, result } = getScales(\n        data!,\n        outerRadius,\n        innerRadius\n      );\n\n      return (\n        <Fragment>\n          {axis && (\n            <CloneElement<RadialAxisProps>\n              element={axis}\n              xScale={xScale}\n              height={chartHeight}\n              width={chartWidth}\n              innerRadius={innerRadius}\n              startAngle={startAngle}\n              endAngle={endAngle}\n            />\n          )}\n          <CloneElement<RadialAreaSeriesProps>\n            element={series}\n            id={id}\n            data={result}\n            xScale={xScale}\n            yScale={yScale}\n            height={chartHeight}\n            width={chartWidth}\n            outerRadius={outerRadius}\n            innerRadius={innerRadius}\n            startAngle={startAngle}\n            endAngle={endAngle}\n            isClosedCurve={isClosedCurve}\n          />\n        </Fragment>\n      );\n    },\n    [\n      getScales,\n      data,\n      innerRadius,\n      axis,\n      startAngle,\n      endAngle,\n      series,\n      isClosedCurve\n    ]\n  );\n\n  return (\n    <ChartContainer\n      id={id}\n      width={width}\n      height={height}\n      containerClassName={containerClassName}\n      margins={margins}\n      xAxisVisible={false}\n      yAxisVisible={false}\n      center={true}\n      className={className}\n    >\n      {renderChart}\n    </ChartContainer>\n  );\n};\n\nRadialAreaChart.defaultProps = {\n  innerRadius: 0.1,\n  series: <RadialAreaSeries />,\n  axis: <RadialAxis />,\n  margins: 75,\n  startAngle: 0,\n  endAngle: 2 * Math.PI,\n  isClosedCurve: true\n};\n","const pi = Math.PI,\n    tau = 2 * pi,\n    epsilon = 1e-6,\n    tauEpsilon = tau - epsilon;\n\nfunction append(strings) {\n  this._ += strings[0];\n  for (let i = 1, n = strings.length; i < n; ++i) {\n    this._ += arguments[i] + strings[i];\n  }\n}\n\nfunction appendRound(digits) {\n  let d = Math.floor(digits);\n  if (!(d >= 0)) throw new Error(`invalid digits: ${digits}`);\n  if (d > 15) return append;\n  const k = 10 ** d;\n  return function(strings) {\n    this._ += strings[0];\n    for (let i = 1, n = strings.length; i < n; ++i) {\n      this._ += Math.round(arguments[i] * k) / k + strings[i];\n    }\n  };\n}\n\nexport class Path {\n  constructor(digits) {\n    this._x0 = this._y0 = // start of current subpath\n    this._x1 = this._y1 = null; // end of current subpath\n    this._ = \"\";\n    this._append = digits == null ? append : appendRound(digits);\n  }\n  moveTo(x, y) {\n    this._append`M${this._x0 = this._x1 = +x},${this._y0 = this._y1 = +y}`;\n  }\n  closePath() {\n    if (this._x1 !== null) {\n      this._x1 = this._x0, this._y1 = this._y0;\n      this._append`Z`;\n    }\n  }\n  lineTo(x, y) {\n    this._append`L${this._x1 = +x},${this._y1 = +y}`;\n  }\n  quadraticCurveTo(x1, y1, x, y) {\n    this._append`Q${+x1},${+y1},${this._x1 = +x},${this._y1 = +y}`;\n  }\n  bezierCurveTo(x1, y1, x2, y2, x, y) {\n    this._append`C${+x1},${+y1},${+x2},${+y2},${this._x1 = +x},${this._y1 = +y}`;\n  }\n  arcTo(x1, y1, x2, y2, r) {\n    x1 = +x1, y1 = +y1, x2 = +x2, y2 = +y2, r = +r;\n\n    // Is the radius negative? Error.\n    if (r < 0) throw new Error(`negative radius: ${r}`);\n\n    let x0 = this._x1,\n        y0 = this._y1,\n        x21 = x2 - x1,\n        y21 = y2 - y1,\n        x01 = x0 - x1,\n        y01 = y0 - y1,\n        l01_2 = x01 * x01 + y01 * y01;\n\n    // Is this path empty? Move to (x1,y1).\n    if (this._x1 === null) {\n      this._append`M${this._x1 = x1},${this._y1 = y1}`;\n    }\n\n    // Or, is (x1,y1) coincident with (x0,y0)? Do nothing.\n    else if (!(l01_2 > epsilon));\n\n    // Or, are (x0,y0), (x1,y1) and (x2,y2) collinear?\n    // Equivalently, is (x1,y1) coincident with (x2,y2)?\n    // Or, is the radius zero? Line to (x1,y1).\n    else if (!(Math.abs(y01 * x21 - y21 * x01) > epsilon) || !r) {\n      this._append`L${this._x1 = x1},${this._y1 = y1}`;\n    }\n\n    // Otherwise, draw an arc!\n    else {\n      let x20 = x2 - x0,\n          y20 = y2 - y0,\n          l21_2 = x21 * x21 + y21 * y21,\n          l20_2 = x20 * x20 + y20 * y20,\n          l21 = Math.sqrt(l21_2),\n          l01 = Math.sqrt(l01_2),\n          l = r * Math.tan((pi - Math.acos((l21_2 + l01_2 - l20_2) / (2 * l21 * l01))) / 2),\n          t01 = l / l01,\n          t21 = l / l21;\n\n      // If the start tangent is not coincident with (x0,y0), line to.\n      if (Math.abs(t01 - 1) > epsilon) {\n        this._append`L${x1 + t01 * x01},${y1 + t01 * y01}`;\n      }\n\n      this._append`A${r},${r},0,0,${+(y01 * x20 > x01 * y20)},${this._x1 = x1 + t21 * x21},${this._y1 = y1 + t21 * y21}`;\n    }\n  }\n  arc(x, y, r, a0, a1, ccw) {\n    x = +x, y = +y, r = +r, ccw = !!ccw;\n\n    // Is the radius negative? Error.\n    if (r < 0) throw new Error(`negative radius: ${r}`);\n\n    let dx = r * Math.cos(a0),\n        dy = r * Math.sin(a0),\n        x0 = x + dx,\n        y0 = y + dy,\n        cw = 1 ^ ccw,\n        da = ccw ? a0 - a1 : a1 - a0;\n\n    // Is this path empty? Move to (x0,y0).\n    if (this._x1 === null) {\n      this._append`M${x0},${y0}`;\n    }\n\n    // Or, is (x0,y0) not coincident with the previous point? Line to (x0,y0).\n    else if (Math.abs(this._x1 - x0) > epsilon || Math.abs(this._y1 - y0) > epsilon) {\n      this._append`L${x0},${y0}`;\n    }\n\n    // Is this arc empty? Were done.\n    if (!r) return;\n\n    // Does the angle go the wrong way? Flip the direction.\n    if (da < 0) da = da % tau + tau;\n\n    // Is this a complete circle? Draw two arcs to complete the circle.\n    if (da > tauEpsilon) {\n      this._append`A${r},${r},0,1,${cw},${x - dx},${y - dy}A${r},${r},0,1,${cw},${this._x1 = x0},${this._y1 = y0}`;\n    }\n\n    // Is this arc non-empty? Draw an arc!\n    else if (da > epsilon) {\n      this._append`A${r},${r},0,${+(da >= pi)},${cw},${this._x1 = x + r * Math.cos(a1)},${this._y1 = y + r * Math.sin(a1)}`;\n    }\n  }\n  rect(x, y, w, h) {\n    this._append`M${this._x0 = this._x1 = +x},${this._y0 = this._y1 = +y}h${w = +w}v${+h}h${-w}Z`;\n  }\n  toString() {\n    return this._;\n  }\n}\n\nexport function path() {\n  return new Path;\n}\n\n// Allow instanceof d3.path\npath.prototype = Path.prototype;\n\nexport function pathRound(digits = 3) {\n  return new Path(+digits);\n}\n","import React, { useEffect, useRef, useState } from 'react';\nimport { motion, useMotionValue, useSpring } from 'framer-motion';\nimport { interpolate } from 'd3-interpolate';\nimport { DEFAULT_TRANSITION } from '../../common/Motion';\n\nexport const MotionBar = ({ custom, transition, arc, ...rest }) => {\n  const d = useMotionValue('');\n  const currentYRef = useRef(custom.exit.y);\n  const spring = useSpring(0, DEFAULT_TRANSITION);\n\n  useEffect(() => {\n    const interpolator = interpolate(currentYRef.current, custom.enter.y);\n    const prevSpring = spring.get();\n    let timeoutId;\n\n    if (transition?.delay) {\n      timeoutId = setTimeout(() => {\n        spring.set(prevSpring + 1);\n      }, transition.delay * 1000);\n    } else {\n      spring.set(prevSpring + 1);\n    }\n\n    const unsubscribe = spring.onChange((v) => {\n      currentYRef.current = interpolator(v - prevSpring);\n      d.set(arc({ ...custom.enter, y: currentYRef.current }));\n    });\n\n    return () => {\n      if (timeoutId) {\n        clearTimeout(timeoutId);\n      }\n      unsubscribe();\n    };\n  }, [arc, custom.enter, d, spring, transition.delay]);\n\n  const { d: enterD, ...enterRest } = custom.enter;\n  const { d: exitD, ...exitRest } = custom.exit;\n\n  return (\n    <motion.path\n      {...rest}\n      initial={exitRest}\n      exit={exitRest}\n      animate={enterRest}\n      transition={transition}\n      d={transition.type !== false ? d : enterD}\n      tabIndex={0}\n    />\n  );\n};\n","import React, { FC } from 'react';\nimport { motion } from 'framer-motion';\n\nexport interface RadialGuideBarProps {\n  active: boolean;\n  path: string;\n  fill?: string;\n  opacity?: number;\n}\n\nexport const RadialGuideBar: FC<Partial<RadialGuideBarProps>> = ({\n  active,\n  path,\n  fill = '#eee',\n  opacity = 0.2\n}) => (\n  <motion.path\n    d={path}\n    fill={fill}\n    pointerEvents=\"none\"\n    initial=\"hidden\"\n    animate={active ? 'visible' : 'hidden'}\n    variants={{\n      hidden: { opacity: 0 },\n      visible: { opacity }\n    }}\n  />\n);\n\nRadialGuideBar.defaultProps = {\n  fill: '#eee',\n  opacity: 0.2\n};\n","import React, {\n  FC,\n  Fragment,\n  ReactElement,\n  useCallback,\n  useMemo,\n  useRef\n} from 'react';\nimport { ChartInternalShallowDataShape } from '../../common/data';\nimport { arc } from 'd3-shape';\nimport { Gradient } from '../../common/Gradient';\nimport bind from 'memoize-bind';\nimport chroma from 'chroma-js';\nimport { path } from 'd3-path';\nimport { DEFAULT_TRANSITION } from '../../common/Motion';\nimport { MotionBar } from './MotionBar';\nimport { RadialGuideBar, RadialGuideBarProps } from './RadialGuideBar';\nimport { CloneElement } from 'reablocks';\nimport { scaleBand, scaleLinear } from 'd3-scale';\n\nexport interface RadialBarProps {\n  /**\n   * Parsed data shape. Set internally by `RadialBarChart`.\n   */\n  data: ChartInternalShallowDataShape;\n\n  /**\n   * The inner radius for the chart center.\n   */\n  innerRadius: number;\n\n  /**\n   * Index of the element in the series. Set internally by `RadialBarSeries`.\n   */\n  index: number;\n\n  /**\n   * Whether the element is active or not. Set internally by `RadialBarSeries`.\n   */\n  animated: boolean;\n\n  /**\n   * D3 scale for X Axis. Set internally by `RadialBarChart`.\n   */\n  xScale: any;\n\n  /**\n   * D3 scale for Y Axis. Set internally by `RadialBarChart`.\n   */\n  yScale: any;\n\n  /**\n   * Color of the bar.\n   */\n  color: any;\n\n  /**\n   * Whether to use gradient or not.\n   */\n  gradient: boolean;\n\n  /**\n   * Id set internally by `RadialBarSeries`.\n   */\n  id: string;\n\n  /**\n   * Total number of bars used for animation. Set internally by `RadialBarSeries`.\n   */\n  barCount: number;\n\n  /**\n   * Total number of nested bars inside each group. Set internally by `RadialBarSeries`.\n   */\n  innerBarCount: number;\n\n  /**\n   * Index of the group. Set internally by `BarSeries`.\n   */\n  groupIndex?: number;\n\n  /**\n   * CSS classes to apply.\n   */\n  className?: string;\n\n  /**\n   * Whether the bar is curved or not.\n   */\n  curved: boolean;\n\n  /**\n   * Guide bar component.\n   */\n  guide: ReactElement<RadialGuideBarProps, typeof RadialGuideBar> | null;\n\n  /**\n   * Active caused by hover.\n   */\n  active: boolean;\n\n  /**\n   * Event for when a symbol is clicked.\n   */\n  onClick: (event) => void;\n\n  /**\n   * Event for when the symbol has mouse enter.\n   */\n  onMouseEnter: (event) => void;\n\n  /**\n   * Event for when the symbol has mouse leave.\n   */\n  onMouseLeave: (event) => void;\n}\n\nexport const RadialBar: FC<Partial<RadialBarProps>> = ({\n  animated,\n  innerRadius,\n  xScale,\n  yScale,\n  curved,\n  id,\n  gradient,\n  barCount,\n  innerBarCount,\n  groupIndex,\n  className,\n  data,\n  active,\n  guide,\n  index,\n  color,\n  onClick,\n  onMouseEnter,\n  onMouseLeave\n}) => {\n  const previousEnter = useRef<any | null>(null);\n  const fill = color(data, index);\n  const currentColorShade = active ? chroma(fill).brighten(0.5) : fill;\n\n  const transition = useMemo(() => {\n    if (animated) {\n      return {\n        ...DEFAULT_TRANSITION,\n        delay: (index / barCount) * 0.9\n      };\n    } else {\n      return {\n        type: false,\n        delay: 0\n      };\n    }\n  }, [animated, barCount, index]);\n\n  const getFill = useCallback(\n    (color: string) => {\n      if (!gradient) {\n        return color;\n      }\n\n      return `url(#${id}-gradient)`;\n    },\n    [gradient, id]\n  );\n\n  const getArc = useCallback(\n    (data: ChartInternalShallowDataShape) => {\n      const outerRadius = yScale(data.y);\n\n      if (curved) {\n        const startAngle = xScale(data.x);\n        const endAngle = startAngle + xScale.bandwidth();\n\n        const arcFn = arc()\n          .innerRadius(innerRadius)\n          .outerRadius(outerRadius)\n          .startAngle(startAngle)\n          .endAngle(endAngle)\n          .padAngle(0.01)\n          .padRadius(innerRadius);\n\n        return arcFn(data as any);\n      } else {\n        const isMultiSeries = groupIndex !== undefined;\n        const xScaleDomain = xScale.domain();\n        const xScaleRange = xScale.range();\n        const isFullCircle =\n          Math.abs(xScaleRange[1] - xScaleRange[0]) >= 2 * Math.PI;\n\n        let xScaleBandwidth;\n        let rotateMid;\n        let startAngle;\n        let endAngle;\n        if (isFullCircle) {\n          xScaleBandwidth = xScale.bandwidth();\n\n          // Align groups centrally about the label axis\n          rotateMid =\n            isMultiSeries && xScaleBandwidth ? xScaleBandwidth / 2 : 0;\n          startAngle = xScale(data.x) - Math.PI * 0.5 - rotateMid;\n          endAngle = startAngle + xScaleBandwidth;\n        } else {\n          xScaleBandwidth = scaleBand()\n            .domain(xScaleDomain)\n            .range(xScaleRange)\n            .bandwidth();\n          rotateMid =\n            isMultiSeries && xScaleBandwidth ? xScaleBandwidth / 2 : 0;\n\n          if (index === 0) {\n            // Squeeze in the first group aligning the first bar in the group with the start margin\n            startAngle = xScale(data.x) - Math.PI * 0.5;\n            endAngle = startAngle + xScaleBandwidth - rotateMid;\n          } else if (index === barCount - 1) {\n            // Squeeze in the last group aligning the last bar in the group with the end margin\n            endAngle = xScaleRange[1] - Math.PI * 0.5;\n            startAngle = endAngle - xScaleBandwidth + rotateMid;\n          } else {\n            // Other groups are center aligned with the label axis\n            startAngle = xScale(data.x) - Math.PI * 0.5 - rotateMid;\n            endAngle = startAngle + xScaleBandwidth;\n          }\n        }\n\n        const innerAngleDistance = endAngle - startAngle;\n        const arcLength = innerRadius * innerAngleDistance;\n        const outerAngleDistance = arcLength / outerRadius;\n        const halfAngleDistanceDelta =\n          (innerAngleDistance - outerAngleDistance) / 2;\n\n        const innerDiff = innerAngleDistance / innerBarCount;\n        const innerStart = isMultiSeries\n          ? startAngle + groupIndex * innerDiff\n          : startAngle;\n        const innerEnd = isMultiSeries ? innerStart + innerDiff : endAngle;\n        const outerDiff = outerAngleDistance / innerBarCount;\n        const halfAngleDiffDistanceDelta = isMultiSeries\n          ? (innerDiff - outerDiff) / 2\n          : halfAngleDistanceDelta;\n\n        const pathFn = path();\n        pathFn.arc(0, 0, innerRadius, innerStart, innerEnd);\n        pathFn.arc(\n          0,\n          0,\n          outerRadius,\n          innerEnd - halfAngleDiffDistanceDelta,\n          innerStart + halfAngleDiffDistanceDelta,\n          true\n        );\n\n        return pathFn.toString();\n      }\n    },\n    [\n      barCount,\n      curved,\n      groupIndex,\n      index,\n      innerBarCount,\n      innerRadius,\n      xScale,\n      yScale\n    ]\n  );\n\n  const renderBar = useCallback(\n    (color: string) => {\n      const fill = getFill(color);\n\n      // Track previous props\n      const prev = previousEnter.current\n        ? { ...previousEnter.current }\n        : undefined;\n      previousEnter.current = { ...data };\n\n      const [yStart, yEnd] = yScale.domain();\n      const exit = {\n        ...data,\n        y: yStart\n      };\n\n      const guidePath = getArc({\n        ...data,\n        y: yEnd\n      }) as string;\n\n      return (\n        <Fragment>\n          {guide && (\n            <CloneElement<RadialGuideBarProps>\n              element={guide}\n              active={active}\n              path={guidePath}\n            />\n          )}\n          <MotionBar\n            arc={getArc}\n            custom={{\n              enter: data,\n              exit,\n              previousEnter: prev\n            }}\n            transition={transition}\n            fill={fill}\n            className={className}\n            onMouseEnter={(event) =>\n              onMouseEnter?.({\n                value: data,\n                nativeEvent: event\n              })\n            }\n            onMouseLeave={(event) =>\n              onMouseLeave?.({\n                value: data,\n                nativeEvent: event\n              })\n            }\n            onClick={(event) =>\n              onClick?.({\n                value: data,\n                nativeEvent: event\n              })\n            }\n          />\n        </Fragment>\n      );\n    },\n    [\n      active,\n      className,\n      data,\n      getArc,\n      getFill,\n      guide,\n      onClick,\n      onMouseEnter,\n      onMouseLeave,\n      transition,\n      yScale\n    ]\n  );\n\n  return (\n    <Fragment>\n      {renderBar(currentColorShade)}\n      {gradient && <Gradient id={`${id}-gradient`} color={currentColorShade} />}\n    </Fragment>\n  );\n};\n\nRadialBar.defaultProps = {\n  gradient: true,\n  curved: false,\n  guide: <RadialGuideBar />,\n  onClick: () => undefined,\n  onMouseEnter: () => undefined,\n  onMouseLeave: () => undefined\n};\n","import React, {\n  FC,\n  Fragment,\n  ReactElement,\n  useState,\n  useCallback,\n  useMemo\n} from 'react';\nimport {\n  ChartInternalDataShape,\n  ChartInternalNestedDataShape,\n  ChartInternalShallowDataShape\n} from '../../common/data';\nimport { RadialBar, RadialBarProps } from './RadialBar';\nimport { CloneElement } from 'reablocks';\nimport { ColorSchemeType, getColor, schemes } from '../../common/color';\nimport {\n  TooltipAreaProps,\n  TooltipArea,\n  ChartTooltip\n} from '../../common/Tooltip';\nimport isEqual from 'react-fast-compare';\nimport { RadialValueMarker, RadialValueMarkerProps } from '../../common';\n\nexport type RadialBarSeriesType = 'standard' | 'grouped';\nexport interface RadialBarSeriesProps {\n  /**\n   * Parsed data shape. Set internally by `RadialBarChart`.\n   */\n  data: ChartInternalDataShape[];\n\n  /**\n   * Color scheme for the series.\n   */\n  colorScheme: ColorSchemeType;\n\n  /**\n   * The inner radius for the chart center.\n   */\n  innerRadius: number;\n\n  /**\n   * The outer radius for the chart center.\n   */\n  outerRadius: number;\n\n  /**\n   * D3 scale for X Axis. Set internally by `RadialBarChart`.\n   */\n  xScale: any;\n\n  /**\n   * D3 scale for Y Axis. Set internally by `RadialBarChart`.\n   */\n  yScale: any;\n\n  /**\n   * Id set internally by `RadialBarChart`.\n   */\n  id: string;\n\n  /**\n   * Bar that is rendered.\n   */\n  bar: ReactElement<RadialBarProps, typeof RadialBar>;\n\n  /**\n   * Whether to animate the enter/update/exit.\n   */\n  animated: boolean;\n\n  /**\n   * Height of the chart. Set internally by `RadialBarChart`.\n   */\n  height: number;\n\n  /**\n   * Width of the chart. Set internally by `RadialBarChart`.\n   */\n  width: number;\n\n  /**\n   * Tooltip for the chart area.\n   */\n  tooltip: ReactElement<TooltipAreaProps, typeof TooltipArea>;\n\n  /**\n   * Start angle for the first value.\n   */\n  startAngle?: number;\n\n  /**\n   * End angle for the last value.\n   */\n  endAngle?: number;\n\n  /**\n   * The type of the chart.\n   */\n  type?: RadialBarSeriesType;\n\n  /**\n   * Value markers line for the chart.\n   */\n  valueMarkers:\n    | ReactElement<RadialValueMarkerProps, typeof RadialValueMarker>[]\n    | null;\n}\n\nexport const RadialBarSeries: FC<Partial<RadialBarSeriesProps>> = ({\n  data,\n  id,\n  innerRadius,\n  outerRadius,\n  xScale,\n  yScale,\n  height,\n  width,\n  tooltip,\n  colorScheme,\n  bar,\n  animated,\n  startAngle,\n  endAngle,\n  type,\n  valueMarkers\n}) => {\n  const [activeValues, setActiveValues] = useState<any | null>(null);\n  const isMultiSeries = useMemo(() => type === 'grouped', [type]);\n\n  const renderBar = useCallback(\n    (\n      point: ChartInternalShallowDataShape,\n      innerBarCount: number,\n      index: number,\n      barCount: number,\n      groupIndex?: number\n    ) => {\n      const active = activeValues && data && isEqual(activeValues.x, point.x);\n\n      return (\n        <Fragment key={index}>\n          <CloneElement<RadialBarProps>\n            element={bar}\n            id={`radialbar-${id}-${index}`}\n            index={index}\n            data={point}\n            xScale={xScale}\n            active={active}\n            yScale={yScale}\n            innerRadius={innerRadius}\n            color={(point) => getColor({ data, point, index: 0, colorScheme })}\n            barCount={barCount}\n            innerBarCount={innerBarCount}\n            groupIndex={groupIndex}\n            animated={animated}\n            startAngle={startAngle}\n            endAngle={endAngle}\n          />\n        </Fragment>\n      );\n    },\n    [\n      activeValues,\n      animated,\n      bar,\n      colorScheme,\n      data,\n      endAngle,\n      id,\n      innerRadius,\n      startAngle,\n      xScale,\n      yScale\n    ]\n  );\n\n  const renderBarGroup = useCallback(\n    (\n      data: ChartInternalShallowDataShape[],\n      innerBarCount: number,\n      barCount: number,\n      groupIndex?: number\n    ) => {\n      return (\n        <Fragment>\n          {data.map((barData, barIndex) =>\n            renderBar(barData, innerBarCount, barIndex, barCount, groupIndex)\n          )}\n        </Fragment>\n      );\n    },\n    [renderBar]\n  );\n\n  const renderValueMarkers = useCallback(\n    () => (\n      <>\n        {valueMarkers?.length &&\n          valueMarkers.map((marker) => (\n            <CloneElement<RadialValueMarkerProps>\n              key={marker.key}\n              element={marker}\n              value={yScale(marker.props.value)}\n            />\n          ))}\n      </>\n    ),\n    [valueMarkers, yScale]\n  );\n\n  return (\n    <CloneElement<TooltipAreaProps>\n      element={tooltip}\n      xScale={xScale}\n      yScale={yScale}\n      data={data}\n      height={height}\n      width={width}\n      isRadial={true}\n      innerRadius={innerRadius}\n      outerRadius={outerRadius}\n      onValueEnter={(event) => setActiveValues(event.value)}\n      onValueLeave={() => setActiveValues(null)}\n      color={(point, index) => getColor({ data, point, index, colorScheme })}\n      startAngle={startAngle}\n      endAngle={endAngle}\n    >\n      {isMultiSeries\n        ? (data as ChartInternalNestedDataShape[]).map((groupData, index) => (\n          <g key={`bar-group-${index}`}>\n            {renderBarGroup(\n                groupData.data as ChartInternalShallowDataShape[],\n                data.length,\n                groupData.data.length,\n                index\n            )}\n          </g>\n        ))\n        : renderBarGroup(\n            data as ChartInternalShallowDataShape[],\n            1,\n            data.length\n        )}\n      {renderValueMarkers()}\n    </CloneElement>\n  );\n};\n\nRadialBarSeries.defaultProps = {\n  colorScheme: schemes.cybertron[0],\n  tooltip: <TooltipArea tooltip={<ChartTooltip followCursor={true} />} />,\n  bar: <RadialBar />,\n  animated: true,\n  startAngle: 0,\n  endAngle: 2 * Math.PI,\n  type: 'standard'\n};\n","import React, { useCallback, FC, Fragment, ReactElement } from 'react';\nimport {\n  ChartShallowDataShape,\n  ChartInternalShallowDataShape,\n  buildShallowChartData,\n  ChartDataShape,\n  buildNestedChartData,\n  ChartNestedDataShape\n} from '../common/data';\nimport { scaleBand, scalePoint } from 'd3-scale';\nimport { getYDomain } from '../common/utils/domains';\nimport { RadialBarSeries, RadialBarSeriesProps } from './RadialBarSeries';\nimport {\n  ChartProps,\n  ChartContainer,\n  ChartContainerChildProps\n} from '../common/containers';\nimport { CloneElement } from 'reablocks';\nimport { RadialAxis, RadialAxisProps } from '../common/Axis/RadialAxis';\nimport { getRadialYScale } from '../common/scales';\nimport { uniqueBy } from '../common/utils/array';\n\nexport interface RadialBarChartProps extends ChartProps {\n  /**\n   * Data the chart will receive to render.\n   */\n  data: ChartDataShape[];\n\n  /**\n   * The series component that renders the bar components.\n   */\n  series: ReactElement<RadialBarSeriesProps, typeof RadialBarSeries>;\n\n  /**\n   * The radial axis component for the chart.\n   */\n  axis: ReactElement<RadialAxisProps, typeof RadialAxis> | null;\n\n  /**\n   * The inner radius for the chart center.\n   */\n  innerRadius: number;\n\n  /**\n   * Start angle for the first value.\n   */\n  startAngle?: number;\n\n  /**\n   * End angle for the last value.\n   */\n  endAngle?: number;\n}\n\nexport const RadialBarChart: FC<Partial<RadialBarChartProps>> = ({\n  id,\n  width,\n  height,\n  margins,\n  className,\n  containerClassName,\n  data,\n  innerRadius,\n  series,\n  axis,\n  startAngle,\n  endAngle\n}) => {\n  const getXScale = useCallback(\n    (points) => {\n      const isFullCircle = Math.abs(endAngle - startAngle) >= 2 * Math.PI;\n      let xScale;\n      if (axis?.props.type === 'category') {\n        const isMultiSeries = series.props.type === 'grouped';\n\n        let xDomain;\n        if (isMultiSeries) {\n          xDomain = uniqueBy<ChartInternalShallowDataShape>(\n            points,\n            (dd) => dd.data,\n            (dd) => dd.x\n          );\n        } else {\n          xDomain = uniqueBy<ChartInternalShallowDataShape>(\n            points,\n            (dd) => dd.x\n          );\n        }\n\n        if (isFullCircle) {\n          xScale = scaleBand()\n            .range([0, 2 * Math.PI])\n            .domain(xDomain as any[]);\n        } else {\n          // scaleBand() excludes the end value from the band:\n          //  https://www.d3indepth.com/scales/#scaleband\n          xScale = scalePoint()\n            .range([startAngle, endAngle])\n            .domain(xDomain as any[]);\n        }\n      } else {\n        const xDomain = uniqueBy(points, (d) => d.x);\n\n        xScale = scaleBand()\n          .range([startAngle, endAngle])\n          .domain(xDomain as any[]);\n      }\n\n      return xScale;\n    },\n    [axis?.props.type, endAngle, series.props.type, startAngle]\n  );\n\n  const getScales = useCallback(\n    (preData: ChartDataShape[], innerRadius: number, outerRadius: number) => {\n      const isMultiSeries = series.props.type === 'grouped';\n      let newData;\n      if (isMultiSeries) {\n        newData = buildNestedChartData(preData as ChartNestedDataShape[], true);\n      } else {\n        newData = buildShallowChartData(preData as ChartShallowDataShape[]);\n      }\n\n      const yDomain = getYDomain({ data: newData, scaled: false });\n\n      const yScale = getRadialYScale(innerRadius, outerRadius, yDomain);\n\n      const xScale = getXScale(newData);\n\n      return {\n        xScale,\n        yScale,\n        newData\n      };\n    },\n    [getXScale, series.props.type]\n  );\n\n  const renderChart = useCallback(\n    ({ chartWidth, chartHeight, id }: ChartContainerChildProps) => {\n      const outerRadius = Math.min(chartWidth, chartHeight) / 2;\n      const { yScale, xScale, newData } = getScales(\n        data,\n        innerRadius,\n        outerRadius\n      );\n\n      return (\n        <Fragment>\n          {axis && (\n            <CloneElement<RadialAxisProps>\n              element={axis}\n              xScale={xScale}\n              height={chartHeight}\n              width={chartWidth}\n              innerRadius={innerRadius}\n              startAngle={startAngle}\n              endAngle={endAngle}\n            />\n          )}\n          <CloneElement<RadialBarSeriesProps>\n            element={series}\n            id={id}\n            data={newData}\n            height={chartHeight}\n            width={chartWidth}\n            xScale={xScale}\n            yScale={yScale}\n            innerRadius={innerRadius}\n            outerRadius={outerRadius}\n            startAngle={startAngle}\n            endAngle={endAngle}\n          />\n        </Fragment>\n      );\n    },\n    [axis, data, endAngle, getScales, innerRadius, series, startAngle]\n  );\n\n  return (\n    <ChartContainer\n      id={id}\n      width={width}\n      height={height}\n      margins={margins}\n      xAxisVisible={false}\n      yAxisVisible={false}\n      center={true}\n      className={className}\n      containerClassName={containerClassName}\n    >\n      {renderChart}\n    </ChartContainer>\n  );\n};\n\nRadialBarChart.defaultProps = {\n  innerRadius: 10,\n  margins: 75,\n  axis: <RadialAxis />,\n  series: <RadialBarSeries />,\n  startAngle: 0,\n  endAngle: 2 * Math.PI\n};\n","import React, { FC, ReactElement, useMemo } from 'react';\nimport { arc } from 'd3-shape';\nimport { PieArc, ArcData } from '../../PieChart';\nimport { ChartShallowDataShape } from '../../common/data';\nimport { ChartTooltip, ChartTooltipProps } from '../../common/Tooltip';\nimport { Gradient, GradientProps } from '../../common/Gradient';\n\nexport interface RadialGaugeArcProps {\n  /**\n   * ID generated by the chart.\n   */\n  id?: string;\n\n  /**\n   * Data set by the `RadialGaugeSeries` components.\n   */\n  data?: ChartShallowDataShape;\n\n  /**\n   * Start angle set by the `RadialGaugeSeries` components.\n   */\n  startAngle: number;\n\n  /**\n   * End angle set by the `RadialGaugeSeries` components.\n   */\n  endAngle: number;\n\n  /**\n   * Inner radius set by the `RadialGaugeSeries` components.\n   */\n  innerRadius: number;\n\n  /**\n   * Outer radius set by the `RadialGaugeSeries` components.\n   */\n  outerRadius: number;\n\n  /**\n   * Color set by the `RadialGaugeSeries` components.\n   */\n  color: any;\n\n  /**\n   * Corner Radius of the arcs, see https://github.com/d3/d3-shape#arc_cornerRadius\n   */\n  cornerRadius?: number;\n\n  /**\n   * Pad Angle between adjacent arcs, see https://github.com/d3/d3-shape#arc_padAngle\n   */\n  padAngle?: number;\n\n  /**\n   * Pad Radius between adjacent arcs, see https://github.com/d3/d3-shape#arc_padRadius\n   */\n  padRadius?: number;\n\n  /**\n   * Animation set by the `RadialGaugeSeries` component.\n   */\n  animated: boolean;\n\n  /**\n   * Disable the interactions.\n   */\n  disabled: boolean;\n\n  /**\n   * Fill the arc.\n   */\n  fill?: string;\n\n  /**\n   * Gradient shades for the bar.\n   */\n  gradient: ReactElement<GradientProps, typeof Gradient> | null;\n\n  /**\n   * Tooltip component.\n   */\n  tooltip: ReactElement<ChartTooltipProps, typeof ChartTooltip> | null;\n\n  /**\n   * Event for when the arc is clicked.\n   */\n  onClick: (event) => void;\n\n  /**\n   * Event for when the arc has mouse enter.\n   */\n  onMouseEnter: (event) => void;\n\n  /**\n   * Event for when the arc has mouse leave.\n   */\n  onMouseLeave: (event) => void;\n}\n\nexport const RadialGaugeArc: FC<Partial<RadialGaugeArcProps>> = ({\n  data,\n  gradient,\n  startAngle,\n  id,\n  endAngle,\n  innerRadius,\n  outerRadius,\n  cornerRadius,\n  padAngle,\n  color,\n  animated,\n  disabled,\n  fill,\n  onClick,\n  onMouseEnter,\n  onMouseLeave,\n  tooltip\n}) => {\n  /**\n   * This function will generate the arcs\n   * https://github.com/d3/d3-shape#arcs\n   */\n  const arcGenerator = useMemo(() => {\n    return arc<ArcData>()\n      .innerRadius(innerRadius)\n      .outerRadius(outerRadius)\n      .cornerRadius(cornerRadius);\n  }, [innerRadius, outerRadius, cornerRadius]);\n\n  const arcElement = useMemo(() => {\n    const arcData: ArcData = {\n      // @ts-ignore Data must be passed\n      data: data || {},\n      startAngle,\n      endAngle,\n      padAngle\n    };\n\n    return (\n      <PieArc\n        id={id}\n        arc={arcGenerator}\n        data={arcData}\n        animated={animated}\n        color={color}\n        gradient={gradient}\n        disabled={disabled}\n        tooltip={tooltip}\n        onClick={onClick}\n        onMouseEnter={onMouseEnter}\n        onMouseLeave={onMouseLeave}\n      />\n    );\n  }, [\n    id,\n    arcGenerator,\n    startAngle,\n    endAngle,\n    padAngle,\n    data,\n    animated,\n    color,\n    gradient,\n    disabled,\n    tooltip,\n    onClick,\n    onMouseEnter,\n    onMouseLeave\n  ]);\n\n  return (\n    <g>\n      {fill && <circle fill={fill} r={outerRadius} />}\n      {arcElement}\n    </g>\n  );\n};\n\nRadialGaugeArc.defaultProps = {\n  cornerRadius: 0,\n  padAngle: 0,\n  padRadius: 0,\n  color: '#353d44',\n  animated: true,\n  disabled: false,\n  tooltip: <ChartTooltip />\n};\n","import React, { FC } from 'react';\nimport {\n  ChartShallowDataShape,\n  ChartInternalDataTypes\n} from '../../../common/data';\nimport { formatValue } from '../../../common/utils';\nimport classNames from 'classnames';\nimport css from './RadialGaugeLabel.module.css';\n\nexport interface RadialGaugeLabelProps {\n  /**\n   * Data set by the `RadialGaugeSeries` component.\n   */\n  data: ChartShallowDataShape;\n\n  /**\n   * Offset set by the `RadialGaugeSeries` component.\n   */\n  offset: number;\n\n  /**\n   * Classname to apply to the label.\n   */\n  className?: any;\n\n  /**\n   * Label click event.\n   */\n  onClick: (event: { data; nativeEvent }) => void;\n}\n\nexport const RadialGaugeLabel: FC<Partial<RadialGaugeLabelProps>> = ({\n  data,\n  className,\n  offset,\n  onClick = () => undefined\n}) => {\n  const label = formatValue(data.key as ChartInternalDataTypes);\n\n  return (\n    <text\n      x=\"0\"\n      y={offset}\n      textAnchor=\"middle\"\n      // This is only valid when placed below the chart\n      alignmentBaseline={'text-after-edge'}\n      onClick={(nativeEvent) => onClick({ data, nativeEvent })}\n      className={classNames(className, css.valueLabel)}\n    >\n      {label}\n    </text>\n  );\n};\n","import React, { FC } from 'react';\nimport { ChartShallowDataShape } from '../../../common/data';\nimport classNames from 'classnames';\nimport css from './RadialGaugeValueLabel.module.css';\nimport { useCount } from '../../../common/Count';\n\nexport interface RadialGaugeValueLabelProps {\n  /**\n   * Data set by the `RadialGaugeSeries` component.\n   */\n  data: ChartShallowDataShape;\n\n  /**\n   * Classname to apply to the value label.\n   */\n  className?: any;\n}\n\nexport const RadialGaugeValueLabel: FC<Partial<RadialGaugeValueLabelProps>> = ({\n  data,\n  className\n}) => {\n  const ref = useCount({\n    to: data.data as number\n  });\n\n  return (\n    <text\n      dy=\"-0.5em\"\n      x=\"0\"\n      y=\"15\"\n      textAnchor=\"middle\"\n      className={classNames(className, css.valueLabel)}\n      ref={ref}\n    />\n  );\n};\n","import React, { FC } from 'react';\nimport { RadialGaugeArc, RadialGaugeArcProps } from './RadialGaugeArc';\n\nexport const RadialGaugeOuterArc: FC<Partial<RadialGaugeArcProps>> = (\n  props\n) => <RadialGaugeArc {...props} />;\n\nRadialGaugeOuterArc.defaultProps = {\n  animated: false,\n  disabled: true\n};\n","import React, {\n  cloneElement,\n  FC,\n  Fragment,\n  ReactElement,\n  useCallback,\n  useMemo\n} from 'react';\nimport { range, min } from 'd3-array';\nimport { scaleBand } from 'd3-scale';\nimport { ChartDataShape, ChartShallowDataShape } from '../../common';\nimport { ColorSchemeType, getColor } from '../../common/color';\nimport { RadialGaugeArc, RadialGaugeArcProps } from './RadialGaugeArc';\nimport { RadialGaugeLabel, RadialGaugeLabelProps } from './RadialGaugeLabel';\nimport {\n  RadialGaugeValueLabel,\n  RadialGaugeValueLabelProps\n} from './RadialGaugeValueLabel';\nimport { RadialGaugeOuterArc } from './RadialGaugeOuterArc';\nimport { identifier } from 'safe-identifier';\n\nexport interface RadialGaugeSeriesProps {\n  /**\n   * Unique id for the series.\n   */\n  id?: string;\n\n  /**\n   * Data to render set by `RadialGauge` component.\n   */\n  data: ChartShallowDataShape[];\n\n  /**\n   * D3 scale function set by `RadialGauge` component.\n   */\n  scale: any;\n\n  /**\n   * Start angle set by `RadialGauge` component.\n   */\n  startAngle: number;\n\n  /**\n   * Start angle set by `RadialGauge` component.\n   */\n  endAngle: number;\n\n  /**\n   * The \"thickness\" of the arcs\n   */\n  arcWidth?: number;\n\n  /**\n   * Width set by `RadialGauge` component.\n   */\n  width: number;\n\n  /**\n   * Height set by `RadialGauge` component.\n   */\n  height: number;\n\n  /**\n   * Padding between each gauge.\n   */\n  padding: number;\n\n  /**\n   * Color scheme to apply.\n   */\n  colorScheme: ColorSchemeType;\n\n  /**\n   * Arc component.\n   */\n  innerArc: ReactElement<RadialGaugeArcProps, typeof RadialGaugeArc>;\n\n  /**\n   * Outer arc component. This is the 'fill' element.\n   */\n  outerArc: ReactElement<RadialGaugeArcProps, typeof RadialGaugeArc> | null;\n\n  /**\n   * Label component.\n   */\n  label: ReactElement<RadialGaugeLabelProps, typeof RadialGaugeLabel> | null;\n\n  /**\n   * Value label component.\n   */\n  valueLabel: ReactElement<\n    RadialGaugeValueLabelProps,\n    typeof RadialGaugeValueLabel\n  > | null;\n\n  /**\n   * Min width for a gauge. Only applicable in multi-series gauges.\n   */\n  minGaugeWidth: number;\n}\n\nexport const RadialGaugeSeries: FC<Partial<RadialGaugeSeriesProps>> = ({\n  data,\n  scale,\n  startAngle,\n  endAngle,\n  arcWidth,\n  outerArc,\n  innerArc,\n  label,\n  valueLabel,\n  colorScheme,\n  id,\n  padding,\n  minGaugeWidth,\n  ...props\n}) => {\n  const { columns, width, height, xScale, yScale } = useMemo(() => {\n    let rows = 1;\n    let columns = data.length;\n\n    if (props.width / data.length < minGaugeWidth) {\n      while (props.width / columns < minGaugeWidth) {\n        rows += 1;\n        columns = Math.ceil(data.length / rows);\n      }\n    }\n\n    const xScale: any = scaleBand();\n    xScale.domain(range(columns));\n    xScale.rangeRound([0, props.width], 0.1);\n\n    const yScale: any = scaleBand();\n    yScale.domain(range(rows));\n    yScale.rangeRound([0, props.height], 0.1);\n\n    return {\n      columns,\n      xScale,\n      yScale,\n      width: xScale.bandwidth(),\n      height: yScale.bandwidth()\n    };\n  }, [data.length, minGaugeWidth, props.height, props.width]);\n\n  const renderGauge = useCallback(\n    (point: ChartShallowDataShape, index: number) => {\n      const dataEndAngle = scale(point.data as number);\n\n      const outerRadius =\n        (min([width - padding * 2, height - padding * 2]) as number) / 2;\n\n      const innerRadius = outerRadius - arcWidth;\n\n      const labelOffset = height / 2;\n\n      const x = xScale(index % columns);\n      const y = yScale(Math.floor(index / columns));\n\n      const xOffset = x + width / 2;\n      const yOffset = y + height / 2;\n      const key = identifier(point.key?.toLocaleString());\n\n      return (\n        <g\n          key={key}\n          transform={`translate(${xOffset}, ${yOffset})`}\n        >\n          {outerArc &&\n            cloneElement(outerArc, {\n              id: `${id}-${key}-outer`,\n              outerRadius,\n              innerRadius,\n              startAngle,\n              endAngle\n            })}\n          {innerArc &&\n            cloneElement(innerArc, {\n              id: `${id}-${key}-inner`,\n              outerRadius,\n              innerRadius,\n              startAngle,\n              endAngle: dataEndAngle,\n              data: point,\n              color: getColor({\n                data,\n                colorScheme,\n                point,\n                index\n              })\n            })}\n          {valueLabel && cloneElement(valueLabel, { data: point })}\n          {label && cloneElement(label, { data: point, offset: labelOffset })}\n        </g>\n      );\n    },\n    [\n      id,\n      arcWidth,\n      colorScheme,\n      columns,\n      data,\n      endAngle,\n      height,\n      innerArc,\n      label,\n      outerArc,\n      padding,\n      scale,\n      startAngle,\n      valueLabel,\n      width,\n      xScale,\n      yScale\n    ]\n  );\n\n  return <Fragment>{data.map(renderGauge)}</Fragment>;\n};\n\nRadialGaugeSeries.defaultProps = {\n  arcWidth: 5,\n  outerArc: <RadialGaugeOuterArc />,\n  innerArc: <RadialGaugeArc />,\n  label: <RadialGaugeLabel />,\n  valueLabel: <RadialGaugeValueLabel />,\n  colorScheme: ['#00ECB1'],\n  padding: 20,\n  minGaugeWidth: 50\n};\n","import React, { FC, JSX, useMemo } from 'react';\nimport { arc } from 'd3-shape';\n\nimport {\n  ChartNestedDataShape,\n  ChartShallowDataShape,\n  ChartTooltip,\n  ColorSchemeType,\n  getColor\n} from '../../common';\nimport { ArcData, PieArc } from '../../PieChart';\nimport { RadialGaugeArcProps } from './RadialGaugeArc';\n\nexport type RadialGaugeStackedArcProps = Omit<\n  RadialGaugeArcProps,\n  'endAngle' | 'data' | 'color'\n> & {\n  /**\n   * Data set by the `StackedRadialGaugeSeries` components.\n   */\n  data: ChartNestedDataShape;\n\n  /**\n   * D3 scale function set by `RadialGauge` component.\n   */\n  scale: (x: number) => number;\n\n  /**\n   * Color scheme to apply set by 'StackedRadialGaugeSeries' component.\n   */\n  colorScheme: ColorSchemeType;\n};\n\nexport const RadialGaugeStackedArc: FC<Partial<RadialGaugeStackedArcProps>> = ({\n  id,\n  data,\n  scale,\n  innerRadius,\n  outerRadius,\n  cornerRadius,\n  padAngle,\n  startAngle,\n  colorScheme,\n  ...restProps\n}) => {\n  const arcGenerator = useMemo(() => {\n    return arc<ArcData>()\n      .innerRadius(innerRadius)\n      .outerRadius(outerRadius)\n      .cornerRadius(cornerRadius);\n  }, [innerRadius, outerRadius, cornerRadius]);\n\n  const stackedArcs = useMemo(() => {\n    let prevEndAngle = startAngle;\n\n    function renderArc(\n      point: ChartShallowDataShape,\n      index: number\n    ): JSX.Element {\n      const value = point.data as number;\n      const startArcAngle = prevEndAngle;\n      const endArcAngle = startArcAngle + scale(value) - startAngle;\n      prevEndAngle = endArcAngle;\n\n      const arcData: ArcData = {\n        data: point,\n        startAngle: startArcAngle,\n        endAngle: endArcAngle,\n        padAngle,\n        value,\n        index\n      };\n\n      const color = getColor({\n        colorScheme,\n        data: [data],\n        point: point,\n        index,\n        active: [data],\n        isMultiSeries: true\n      });\n\n      return (\n        <PieArc\n          {...restProps}\n          id={point.key.toLocaleString()}\n          key={point.key.toLocaleString()}\n          arc={arcGenerator}\n          data={arcData}\n          color={color}\n        />\n      );\n    }\n\n    return data.data.map(renderArc);\n  }, [arcGenerator, colorScheme, data, padAngle, restProps, scale, startAngle]);\n\n  return <g key={id}>{stackedArcs}</g>;\n};\n\nRadialGaugeStackedArc.defaultProps = {\n  cornerRadius: 0,\n  padAngle: 0,\n  padRadius: 0,\n  animated: true,\n  disabled: false,\n  tooltip: <ChartTooltip />\n};\n","import React, { FC } from 'react';\nimport classNames from 'classnames';\nimport css from './StackedRadialGaugeValueLabel.module.css';\n\nexport interface StackedRadialGaugeValueLabelProps {\n  /**\n   * A label shown at the center\n   */\n  label: string;\n\n  /**\n   * A class name to apply\n   */\n  className?: string;\n\n  /**\n   * A y offset to apply to the label\n   */\n  yOffset?: number;\n}\n\nexport const StackedRadialGaugeValueLabel: FC<\n  Partial<StackedRadialGaugeValueLabelProps>\n> = ({ label, className, yOffset }) => (\n  <>\n    {label && (\n      <text\n        x=\"0\"\n        y={yOffset}\n        textAnchor=\"middle\"\n        alignmentBaseline=\"middle\"\n        className={classNames(className, css.stackedValueLabel)}\n      >\n        {label}\n      </text>\n    )}\n  </>\n);\n\nStackedRadialGaugeValueLabel.defaultProps = {\n  yOffset: 0\n};\n","import React, { cloneElement, FC, ReactElement, useCallback } from 'react';\nimport { range } from 'd3-array';\nimport { scaleBand } from 'd3-scale';\nimport {\n  ChartDataShape,\n  ChartNestedDataShape,\n  ChartShallowDataShape\n} from '../../common/data';\nimport { ColorSchemeType, getColor } from '../../common/color';\nimport { RadialGaugeArc, RadialGaugeArcProps } from './RadialGaugeArc';\nimport {\n  RadialGaugeStackedArc,\n  RadialGaugeStackedArcProps\n} from './RadialGaugeStackedArc';\nimport {\n  StackedRadialGaugeValueLabel,\n  StackedRadialGaugeValueLabelProps\n} from './StackedRadialGaugeValueLabel';\nimport {\n  StackedRadialGaugeDescriptionLabel,\n  StackedRadialGaugeDescriptionLabelProps\n} from './StackedRadialGaugeDescriptionLabel';\n\nexport interface StackedRadialGaugeSeriesProps {\n  /**\n   * Data to render set by `RadialGauge` component.\n   */\n  data: ChartDataShape[];\n\n  /**\n   * D3 scale function set by `RadialGauge` component.\n   */\n  scale: any;\n\n  /**\n   * Start angle set by `RadialGauge` component.\n   */\n  startAngle: number;\n\n  /**\n   * Start angle set by `RadialGauge` component.\n   */\n  endAngle: number;\n\n  /**\n   * Width set by `RadialGauge` component.\n   */\n  width: number;\n\n  /**\n   * Height set by `RadialGauge` component.\n   */\n  height: number;\n\n  /**\n   * Color scheme to apply.\n   */\n  colorScheme: ColorSchemeType;\n\n  /**\n   * Arc component.\n   */\n  innerArc: ReactElement<RadialGaugeArcProps, typeof RadialGaugeArc>;\n\n  /**\n   * Stacked Arc component.\n   */\n  stackedInnerArc: ReactElement<\n    RadialGaugeStackedArcProps,\n    typeof RadialGaugeStackedArc\n  >;\n\n  /**\n   * Outer arc component. This is the 'fill' element.\n   */\n  outerArc: ReactElement<RadialGaugeArcProps, typeof RadialGaugeArc> | null;\n\n  /**\n   * Label component.\n   */\n  label: ReactElement<\n    StackedRadialGaugeValueLabelProps,\n    typeof StackedRadialGaugeValueLabel\n  > | null;\n\n  /**\n   * Description label component.\n   */\n  descriptionLabel: ReactElement<\n    StackedRadialGaugeDescriptionLabelProps,\n    typeof StackedRadialGaugeDescriptionLabel\n  > | null;\n\n  /**\n   * A factor from 0 to 1 determining how much of the Gauge should be filled with arcs\n   */\n  fillFactor: number;\n\n  /**\n   * Padding between the stacked arcs, following d3 bandwidth innerPadding\n   */\n  arcPadding: number;\n}\n\nconst isChartNestedData = (\n  point: ChartDataShape\n): point is ChartNestedDataShape => {\n  return Array.isArray(point.data);\n};\n\nexport const StackedRadialGaugeSeries: FC<\n  Partial<StackedRadialGaugeSeriesProps>\n> = ({\n  data,\n  width,\n  height,\n  scale,\n  startAngle,\n  endAngle,\n  outerArc,\n  innerArc,\n  stackedInnerArc,\n  label,\n  descriptionLabel,\n  colorScheme,\n  fillFactor,\n  arcPadding\n}) => {\n  const radius = Math.min(width, height) / 2;\n  const innerRadius = radius * (1 - Math.min(fillFactor, 1));\n\n  const rAxis = scaleBand()\n    .domain(range(data.length))\n    .range([innerRadius, radius])\n    .paddingInner(arcPadding);\n\n  const renderOuterArc = useCallback(\n    (outerRadius: number, innerRadius: number) => {\n      return (\n        outerArc &&\n        cloneElement(outerArc, {\n          outerRadius,\n          innerRadius,\n          startAngle,\n          endAngle\n        })\n      );\n    },\n    [outerArc, startAngle, endAngle]\n  );\n\n  const renderInnerArc = useCallback(\n    (\n      outerRadius: number,\n      innerRadius: number,\n      dataEndAngle: number,\n      point: ChartShallowDataShape,\n      index: number\n    ) => {\n      const color = getColor({ data, colorScheme, point, index });\n\n      return (\n        innerArc &&\n        cloneElement(innerArc, {\n          outerRadius,\n          innerRadius,\n          startAngle,\n          endAngle: dataEndAngle,\n          data: point,\n          color\n        })\n      );\n    },\n    [innerArc, startAngle, data, colorScheme]\n  );\n\n  const renderStackedArc = useCallback(\n    (outerRadius: number, innerRadius: number, point: ChartNestedDataShape, index: number) => {\n      return (\n        <>\n          {stackedInnerArc &&\n            cloneElement(stackedInnerArc, {\n              outerRadius,\n              innerRadius,\n              colorScheme,\n              startAngle,\n              scale: scale?.[index] ?? scale?.[index] ?? scale,\n              data: point\n            })}\n        </>\n      );\n    },\n    [stackedInnerArc, colorScheme, startAngle, scale]\n  );\n\n  const renderStackedGauges = useCallback(\n    (point: ChartDataShape, index: number) => {\n      const outerRadius = rAxis(index as any);\n      const innerRadius = outerRadius - rAxis.bandwidth();\n\n      return (\n        <g key={point.key.toLocaleString()}>\n          {renderOuterArc(outerRadius, innerRadius)}\n          {isChartNestedData(point)\n            ? renderStackedArc(outerRadius, innerRadius, point, index)\n            : renderInnerArc(\n              outerRadius,\n              innerRadius,\n              scale?.[index]?.(point.data) ?? scale?.[0]?.(point.data) ?? scale(point.data),\n              point,\n              index\n            )}\n        </g>\n      );\n    },\n    [rAxis, renderOuterArc, renderStackedArc, renderInnerArc, scale]\n  );\n\n  return (\n    <>\n      <g transform={`translate(${width / 2}, ${height / 2})`}>\n        {data.map(renderStackedGauges)}\n        {descriptionLabel}\n        {label}\n      </g>\n    </>\n  );\n};\n\nStackedRadialGaugeSeries.defaultProps = {\n  outerArc: <RadialGaugeArc disabled={true} animated={false} />,\n  innerArc: <RadialGaugeArc animated={true} />,\n  stackedInnerArc: <RadialGaugeStackedArc animated={true} />,\n  label: <StackedRadialGaugeValueLabel />,\n  colorScheme: ['#00ECB1'],\n  fillFactor: 0.2,\n  arcPadding: 0.15\n};\n","import React, { FC } from 'react';\nimport classNames from 'classnames';\nimport css from './StackedRadialGaugeDescriptionLabel.module.css';\n\nexport interface StackedRadialGaugeDescriptionLabelProps {\n  /**\n   * A label shown at the center\n   */\n  label: string;\n\n  /**\n   * A class name to apply\n   */\n  className?: string;\n\n  /**\n   * A y offset to apply to the label\n   */\n  yOffset?: number;\n}\n\nexport const StackedRadialGaugeDescriptionLabel: FC<\n  Partial<StackedRadialGaugeDescriptionLabelProps>\n> = ({ label, className, yOffset }) => (\n  <>\n    {label && (\n      <text\n        x=\"0\"\n        y={yOffset - 20}\n        textAnchor=\"middle\"\n        alignmentBaseline=\"middle\"\n        className={classNames(className, css.stackedDescriptionLabel)}\n      >\n        {label}\n      </text>\n    )}\n  </>\n);\n\nStackedRadialGaugeDescriptionLabel.defaultProps = {\n  yOffset: 0\n};\n","import React, { cloneElement, FC, ReactElement, useCallback } from 'react';\nimport { scaleLinear } from 'd3-scale';\nimport {\n  ChartContainer,\n  ChartContextProps,\n  ChartProps\n} from '../common/containers';\nimport { ChartDataShape } from '../common/data';\nimport {\n  RadialGaugeSeries,\n  RadialGaugeSeriesProps,\n  StackedRadialGaugeSeries,\n  StackedRadialGaugeSeriesProps\n} from './RadialGaugeSeries';\nimport { useId } from 'reablocks';\n\nexport interface RadialGaugeProps extends ChartProps {\n  /**\n   * Data the chart will receive to render.\n   */\n  data: ChartDataShape[];\n\n  /**\n   * Min value to scale on.\n   */\n  minValue?: number | number[];\n\n  /**\n   * Max value to scale on.\n   */\n  maxValue?: number | number[];\n\n  /**\n   * Start angle for the first value.\n   */\n  startAngle?: number;\n\n  /**\n   * End angle for the last value.\n   */\n  endAngle?: number;\n\n  /**\n   * Gauge series component to render.\n   */\n  series?: ReactElement<\n    RadialGaugeSeriesProps | StackedRadialGaugeSeriesProps,\n    typeof RadialGaugeSeries | typeof StackedRadialGaugeSeries\n  >;\n}\n\nexport const RadialGauge: FC<RadialGaugeProps> = ({\n  id,\n  width,\n  height,\n  margins,\n  className,\n  data,\n  minValue,\n  maxValue,\n  startAngle,\n  endAngle,\n  series,\n  containerClassName\n}) => {\n  const newId = useId(id);\n\n  const renderSeries = useCallback(\n    ({ chartHeight, chartWidth }: ChartContextProps) => {\n      let scale;\n\n      if (Array.isArray(maxValue)) {\n        scale = maxValue.map((max, index) =>\n          scaleLinear()\n            .domain([minValue?.[index] ?? minValue?.[0] ?? minValue, max])\n            .range([startAngle, endAngle])\n        );\n      } else if (Array.isArray(minValue)) {\n        scale = minValue.map((min, index) =>\n          scaleLinear()\n            .domain([min, maxValue?.[index] ?? maxValue?.[0] ?? maxValue])\n            .range([startAngle, endAngle])\n        );\n      } else {\n        scale = scaleLinear()\n          .domain([minValue, maxValue])\n          .range([startAngle, endAngle]);\n      }\n\n      return cloneElement(series, {\n        id: newId,\n        scale,\n        data,\n        startAngle,\n        endAngle,\n        width: chartWidth,\n        height: chartHeight\n      });\n    },\n    [data, endAngle, maxValue, minValue, series, startAngle, newId]\n  );\n\n  return (\n    <ChartContainer\n      id={id}\n      width={width}\n      height={height}\n      margins={margins}\n      xAxisVisible={false}\n      yAxisVisible={false}\n      className={className}\n      containerClassName={containerClassName}\n    >\n      {renderSeries}\n    </ChartContainer>\n  );\n};\n\nRadialGauge.defaultProps = {\n  minValue: 0,\n  maxValue: 100,\n  startAngle: 0,\n  endAngle: Math.PI * 2,\n  series: <RadialGaugeSeries />\n};\n","import React, {\n  FC,\n  Fragment,\n  MouseEvent,\n  ReactElement,\n  useMemo,\n  useState,\n  useRef,\n  ReactNode\n} from 'react';\nimport { ChartTooltip, ChartTooltipProps } from '../../common/Tooltip';\nimport { CloneElement } from 'reablocks';\nimport {\n  constructFunctionProps,\n  PropFunctionTypes\n} from '../../common/utils/functions';\nimport chroma from 'chroma-js';\nimport classNames from 'classnames';\nimport { motion } from 'framer-motion';\nimport { DEFAULT_TRANSITION } from '../../common/Motion';\nimport { ChartInternalShallowDataShape } from '../../common/data';\nimport css from './HeatmapCell.module.css';\nimport { useHoverIntent } from '../../common/utils/useHoverIntent';\nimport { getAriaLabel } from '../../common';\n\nexport type HeatmapCellProps = {\n  /**\n   * X Position set by `HeatmapSeries`.\n   */\n  x: number;\n\n  /**\n   * Y Position set by `HeatmapSeries`.\n   */\n  y: number;\n\n  /**\n   * rx SVG Attribute.\n   */\n  rx: number;\n\n  /**\n   * ry SVG Attribute.\n   */\n  ry: number;\n\n  /**\n   * Height of cell set by `HeatmapSeries`.\n   */\n  height: number;\n\n  /**\n   * Width of cell set by `HeatmapSeries`.\n   */\n  width: number;\n\n  /**\n   * Total count of cells set by `HeatmapSeries`.\n   */\n  cellCount: number;\n\n  /**\n   * Tooltip component.\n   */\n  tooltip: ReactElement<ChartTooltipProps, typeof ChartTooltip> | null;\n\n  /**\n   * Fill color set by `HeatmapSeries`.\n   */\n  fill: string;\n\n  /**\n   * Stroke color set by `HeatmapSeries`.\n   */\n  stroke: string;\n\n  /**\n   * Symbol element to render.\n   */\n  symbol?: (data: ChartInternalShallowDataShape) => ReactNode;\n\n  /**\n   * Data object set by `Heatmap`.\n   */\n  data: ChartInternalShallowDataShape;\n\n  /**\n   * Whether cell is animated or not set by `HeatmapSeries`.\n   */\n  animated: boolean;\n\n  /**\n   * Cell index set by `HeatmapSeries`.\n   */\n  cellIndex: number;\n\n  /**\n   * Cursor style attribute.\n   */\n  cursor: string;\n\n  /**\n   * Event for when the bar is clicked.\n   */\n  onClick: (event) => void;\n\n  /**\n   * Event for when the bar has mouse enter.\n   */\n  onMouseEnter: (event) => void;\n\n  /**\n   * Event for when the bar has mouse leave.\n   */\n  onMouseLeave: (event) => void;\n} & PropFunctionTypes;\n\ninterface HeatmapCellState {\n  active?: boolean;\n}\n\n// Set padding modifier for the tooltips\nconst modifiers = {\n  offset: {\n    offset: '0, 3px'\n  }\n};\n\nexport const HeatmapCell: FC<Partial<HeatmapCellProps>> = ({\n  rx,\n  ry,\n  cursor,\n  tooltip,\n  onClick,\n  onMouseEnter,\n  onMouseLeave,\n  data,\n  animated,\n  cellIndex,\n  cellCount,\n  fill,\n  stroke,\n  symbol,\n  x,\n  y,\n  style,\n  className,\n  ...rest\n}) => {\n  const [active, setActive] = useState(false);\n  const rect = useRef<SVGRectElement | null>(null);\n\n  const { pointerOut, pointerOver } = useHoverIntent({\n    onPointerOver: (event) => {\n      setActive(true);\n      onMouseEnter({\n        value: data,\n        nativeEvent: event\n      });\n    },\n    onPointerOut: (event) => {\n      setActive(false);\n      onMouseLeave({\n        value: data,\n        nativeEvent: event\n      });\n    }\n  });\n\n  const onMouseClick = (event: MouseEvent) => {\n    onClick({\n      value: data,\n      nativeEvent: event\n    });\n  };\n\n  const tooltipData = useMemo(\n    () => ({\n      y: data.value,\n      x: `${data.key}  ${data.x}`,\n      data\n    }),\n    [data]\n  );\n\n  const transition = useMemo(() => {\n    if (animated) {\n      return {\n        ...DEFAULT_TRANSITION,\n        delay: (cellIndex / cellCount) * 0.005\n      };\n    } else {\n      return {\n        type: false,\n        delay: 0\n      };\n    }\n  }, [animated, cellIndex, cellCount]);\n\n  const extras = constructFunctionProps({ style, className }, data);\n  const isTransparent = fill === 'transparent';\n  const appliedStroke =\n    active && !isTransparent\n      ? chroma(stroke || fill).brighten(1)\n      : stroke || fill;\n\n  const ariaLabelData = useMemo(\n    () => getAriaLabel({ ...tooltipData, data: null }),\n    [tooltipData]\n  );\n\n  const renderedSymbol = useMemo(\n    () => (symbol ? symbol(data!) : null),\n    [data, symbol]\n  );\n\n  return (\n    <Fragment>\n      <g ref={rect}>\n        {renderedSymbol ? (\n          <motion.g\n            {...rest}\n            fill={fill}\n            stroke={appliedStroke}\n            style={{ ...extras.style, cursor }}\n            className={extras?.className}\n            transform={`translate(${x}, ${y})`}\n            initial={{\n              opacity: 0\n            }}\n            animate={{\n              opacity: 1\n            }}\n            exit={{\n              opacity: 0\n            }}\n            transition={transition}\n            onPointerOver={pointerOver}\n            onPointerOut={pointerOut}\n            onClick={onMouseClick}\n            tabIndex={0}\n            aria-label={ariaLabelData}\n            role=\"graphics-document\"\n          >\n            {renderedSymbol}\n          </motion.g>\n        ) : (\n          <motion.rect\n            {...rest}\n            fill={fill}\n            stroke={appliedStroke}\n            x={x}\n            y={y}\n            rx={rx}\n            ry={ry}\n            style={{ ...extras.style, cursor }}\n            className={classNames(css.cell, extras.className)}\n            initial={{\n              opacity: 0\n            }}\n            animate={{\n              opacity: 1\n            }}\n            exit={{\n              opacity: 0\n            }}\n            transition={transition}\n            onPointerOver={pointerOver}\n            onPointerOut={pointerOut}\n            onClick={onMouseClick}\n            tabIndex={0}\n            aria-label={ariaLabelData}\n            role=\"graphics-document\"\n          />\n        )}\n      </g>\n      {tooltip && !(tooltip.props as any).disabled && !isTransparent && (\n        <CloneElement<ChartTooltipProps>\n          element={tooltip}\n          visible={active}\n          modifiers={(tooltip.props as any).modifiers || modifiers}\n          reference={rect}\n          value={tooltipData}\n        />\n      )}\n    </Fragment>\n  );\n};\n\nHeatmapCell.defaultProps = {\n  rx: 2,\n  ry: 2,\n  cursor: 'auto',\n  tooltip: <ChartTooltip />,\n  onClick: () => undefined,\n  onMouseEnter: () => undefined,\n  onMouseLeave: () => undefined\n};\n","import React, { FC, ReactElement, Fragment } from 'react';\nimport { HeatmapCell, HeatmapCellProps } from './HeatmapCell';\nimport { CloneElement } from 'reablocks';\nimport { ColorSchemeType } from '../../common/color';\nimport { ChartInternalNestedDataShape } from '../../common/data';\nimport {\n  ColorSchemeStyleArray,\n  createColorSchemeValueScales,\n  getColorSchemeStyles\n} from '../../common/color/helper';\n\nexport interface HeatmapSeriesProps {\n  /**\n   * Padding between cells.\n   */\n  padding: number;\n\n  /**\n   * Id set by `Heatmap`.\n   */\n  id: string;\n\n  /**\n   * Parsed data set by `Heatmap`.\n   */\n  data: ChartInternalNestedDataShape[];\n\n  /**\n   * D3 scale for X Axis. Set internally by `Heatmap`.\n   */\n  xScale: any;\n\n  /**\n   * D3 scale for Y Axis. Set internally by `Heatmap`.\n   */\n  yScale: any;\n\n  /**\n   * Color scheme for the chart.\n   */\n  colorScheme: ColorSchemeType | ColorSchemeStyleArray;\n\n  /**\n   * Color for the empty cell of the chart.\n   */\n  emptyColor: string;\n\n  /**\n   * Whether the chart is animated or not.\n   */\n  animated: boolean;\n\n  /**\n   * Cell component that will be rendered.\n   */\n  cell: ReactElement<HeatmapCellProps, typeof HeatmapCell>;\n\n  /**\n   * Selected cell(s) in active state\n   */\n  selections?: any;\n}\n\nexport const HeatmapSeries: FC<Partial<HeatmapSeriesProps>> = ({\n  animated,\n  emptyColor,\n  colorScheme,\n  cell: cellElement,\n  xScale,\n  yScale,\n  data,\n  id,\n  selections\n}) => {\n  const valueScales = createColorSchemeValueScales(\n    data,\n    colorScheme,\n    emptyColor,\n    selections\n  );\n  const height = yScale.bandwidth();\n  const width = xScale.bandwidth();\n  const cellCount = [...yScale.domain(), ...xScale.domain()].length;\n\n  const renderCell = ({\n    row,\n    cell,\n    rowIndex,\n    cellIndex,\n    width,\n    height,\n    cellCount\n  }) => {\n    const x = xScale(row.key);\n    const y = yScale(cell.x);\n    const style = getColorSchemeStyles(cell, valueScales);\n\n    return (\n      <CloneElement<HeatmapCellProps>\n        key={`${id}-${rowIndex}-${cellIndex}`}\n        element={cellElement}\n        animated={animated}\n        cellIndex={rowIndex + cellIndex}\n        cellCount={cellCount}\n        x={x}\n        y={y}\n        fill={style?.fill}\n        stroke={style?.stroke}\n        width={width}\n        height={height}\n        data={cell}\n        style={style}\n      />\n    );\n  };\n\n  return (\n    <Fragment>\n      {data.map((row, rowIndex) =>\n        row.data.map((cell, cellIndex) =>\n          renderCell({\n            height,\n            width,\n            cellCount,\n            row,\n            cell,\n            rowIndex,\n            cellIndex\n          })\n        )\n      )}\n    </Fragment>\n  );\n};\n\nHeatmapSeries.defaultProps = {\n  padding: 0.1,\n  animated: true,\n  emptyColor: 'rgba(200,200,200,0.08)',\n  colorScheme: ['rgba(28, 107, 86, 0.5)', '#2da283'],\n  cell: <HeatmapCell />\n};\n","import React, { useCallback, Fragment, ReactElement, FC } from 'react';\nimport {\n  ChartProps,\n  ChartContainer,\n  ChartContainerChildProps\n} from '../common/containers/ChartContainer';\nimport { ChartNestedDataShape, buildNestedChartData } from '../common/data';\nimport { CloneElement } from 'reablocks';\nimport {\n  isAxisVisible,\n  LinearAxisProps,\n  LinearXAxis,\n  LinearYAxis,\n  LinearYAxisTickSeries,\n  LinearXAxisTickSeries,\n  LinearYAxisTickLabel,\n  LinearXAxisTickLabel,\n  LinearAxis\n} from '../common/Axis';\nimport { HeatmapSeries, HeatmapSeriesProps } from './HeatmapSeries';\nimport { scaleBand } from 'd3-scale';\nimport { uniqueBy } from '../common/utils/array';\n\nexport interface HeatmapProps extends ChartProps {\n  /**\n   * Data the chart will receive to render.\n   */\n  data: ChartNestedDataShape[];\n\n  /**\n   * The series component that renders the cell components.\n   */\n  series: ReactElement<HeatmapSeriesProps, typeof HeatmapSeries>;\n\n  /**\n   * The linear axis component for the Y Axis of the chart.\n   */\n  yAxis: ReactElement<LinearAxisProps, typeof LinearAxis>;\n\n  /**\n   * The linear axis component for the X Axis of the chart.\n   */\n  xAxis: ReactElement<LinearAxisProps, typeof LinearAxis>;\n\n  /**\n   * Any secondary axis components. Useful for multi-axis charts.\n   */\n  secondaryAxis?: ReactElement<LinearAxisProps, typeof LinearAxis>[];\n}\n\nexport const Heatmap: FC<Partial<HeatmapProps>> = ({\n  data,\n  margins,\n  series,\n  yAxis,\n  xAxis,\n  secondaryAxis,\n  id,\n  width,\n  height,\n  className,\n  containerClassName\n}) => {\n  const getScalesData = useCallback(\n    (chartHeight: number, chartWidth: number) => {\n      const nestedData = buildNestedChartData(data);\n\n      const xDomain: any =\n        xAxis.props.domain || uniqueBy(nestedData, (d) => d.key);\n\n      const xScale = scaleBand()\n        .range([0, chartWidth])\n        .domain(xDomain)\n        .paddingInner(series.props.padding || 0.1);\n\n      const yDomain: any =\n        yAxis.props.domain ||\n        uniqueBy(\n          nestedData,\n          (d) => d.data,\n          (d) => d.x\n        );\n\n      const yScale = scaleBand()\n        .domain(yDomain)\n        .range([chartHeight, 0])\n        .paddingInner(series.props.padding || 0.1);\n\n      return {\n        yScale,\n        xScale,\n        data: nestedData\n      };\n    },\n    [data, xAxis, yAxis, series]\n  );\n\n  const renderChart = useCallback(\n    (containerProps: ChartContainerChildProps) => {\n      const { chartWidth, chartHeight, updateAxes, id, chartSized } =\n        containerProps;\n      const {\n        xScale,\n        yScale,\n        data: scalesData\n      } = getScalesData(chartHeight, chartWidth);\n\n      return (\n        <Fragment>\n          <CloneElement<LinearAxisProps>\n            element={xAxis}\n            height={chartHeight}\n            width={chartWidth}\n            scale={xScale}\n            visibility={chartSized ? 'visible' : 'hidden'}\n            onDimensionsChange={(event) => updateAxes('horizontal', event)}\n          />\n          <CloneElement<LinearAxisProps>\n            element={yAxis}\n            height={chartHeight}\n            width={chartWidth}\n            scale={yScale}\n            visibility={chartSized ? 'visible' : 'hidden'}\n            onDimensionsChange={(event) => updateAxes('vertical', event)}\n          />\n          {secondaryAxis &&\n            secondaryAxis.map((axis, i) => (\n              <CloneElement<LinearAxisProps>\n                key={i}\n                element={axis}\n                height={chartHeight}\n                width={chartWidth}\n                visibility={chartSized ? 'visible' : 'hidden'}\n                onDimensionsChange={(event) => updateAxes('horizontal', event)}\n              />\n            ))}\n          {chartSized && (\n            <CloneElement<HeatmapSeriesProps>\n              element={series}\n              id={`heat-series-${id}`}\n              data={scalesData}\n              xScale={xScale}\n              yScale={yScale}\n            />\n          )}\n        </Fragment>\n      );\n    },\n    [getScalesData, secondaryAxis, series, xAxis, yAxis]\n  );\n\n  return (\n    <ChartContainer\n      id={id}\n      width={width}\n      height={height}\n      margins={margins}\n      containerClassName={containerClassName}\n      xAxisVisible={isAxisVisible(xAxis.props)}\n      yAxisVisible={isAxisVisible(yAxis.props)}\n      className={className}\n    >\n      {renderChart}\n    </ChartContainer>\n  );\n};\n\nHeatmap.defaultProps = {\n  data: [],\n  margins: 10,\n  series: <HeatmapSeries padding={0.3} />,\n  yAxis: (\n    <LinearYAxis\n      type=\"category\"\n      axisLine={null}\n      tickSeries={\n        <LinearYAxisTickSeries\n          line={null}\n          label={<LinearYAxisTickLabel padding={5} />}\n        />\n      }\n    />\n  ),\n  xAxis: (\n    <LinearXAxis\n      type=\"category\"\n      axisLine={null}\n      tickSeries={\n        <LinearXAxisTickSeries\n          line={null}\n          label={<LinearXAxisTickLabel padding={5} />}\n        />\n      }\n    />\n  )\n};\n","import { range, min } from 'd3-array';\nimport { ChartShallowDataShape } from '../common/data';\n\nexport type CalendarView = 'year' | 'month';\n\nconst getFirstOfMonth = (date: Date) =>\n  new Date(date.getFullYear(), date.getMonth(), 1);\n\nexport const addWeeksToDate = (date: Date, weeks: number) => {\n  const d = new Date(date.getTime());\n  d.setDate(d.getDate() + weeks * 7);\n  return d;\n};\n\nconst getStartOfDay = (date: Date) => {\n  const d = new Date(date.getTime());\n  d.setHours(0, 0, 0, 0);\n  return d;\n};\n\nconst getNewDayFromDay = (date: Date, num: number) => {\n  const d = new Date(date.getTime());\n  d.setDate(d.getDate() + num);\n  return d;\n};\n\nexport const weekDays: string[] = (() => {\n  const base = new Date(Date.UTC(2017, 0, 2));\n  return range(7).map(() => {\n    const name = base.toLocaleDateString('default', { weekday: 'short' });\n    base.setDate(base.getDate() + 1);\n    return name;\n  });\n})();\n\nexport const buildDataScales = (\n  rawData: ChartShallowDataShape[],\n  view: CalendarView\n) => {\n  // Get the most recent date to get the range from\n  // From the end date, lets find the start year/month of that\n  // From that start year/month, lets find the end year/month for our bounds\n  const startDate = min(rawData, (d) => d.key) || new Date();\n  const start = getFirstOfMonth(startDate);\n  const endDomain = view === 'year' ? 53 : 5;\n  const end = addWeeksToDate(start, endDomain);\n\n  // Base on the view type, swap out some ranges\n  const xDomainRange = view === 'year' ? 53 : 5;\n\n  // Build our x/y domains for days of week + number of weeks in year\n  const yDomain = range(7).reverse();\n  const xDomain = range(xDomainRange);\n\n  // Filter out dates that are not in the start/end ranges\n  // and turn them into something our chart can read\n  const dates = rawData\n    .filter(\n      (d) =>\n        (d.key as Date).getTime() > start.getTime() ||\n        (d.key as Date).getTime() < end.getTime()\n    )\n    .map((d) => ({\n      key: getStartOfDay(d.key as Date),\n      data: d.data\n    }));\n\n  // Find the first day of the duration and subtract the delta\n  const firstDayOfStart = start.getDay();\n  const curDate = getNewDayFromDay(start, -firstDayOfStart);\n  const rows: any[] = [];\n\n  // Build out the dataset for the n duration\n  for (let week = 0; week < xDomainRange; week++) {\n    const row = {\n      key: week,\n      data: [] as any\n    };\n\n    for (let day = 0; day <= 6; day++) {\n      const dayValue = dates.find((d) => d.key.getTime() === curDate.getTime());\n\n      row.data.push({\n        key: day,\n        data: dayValue?.data ?? undefined,\n        metadata: {\n          date: new Date(curDate.getTime()),\n          start: start,\n          end: end\n        }\n      });\n\n      curDate.setDate(curDate.getDate() + 1);\n    }\n\n    rows.push(row);\n  }\n\n  return {\n    data: rows,\n    yDomain,\n    xDomain,\n    start\n  };\n};\n","import React, { FC, useMemo } from 'react';\nimport { ChartShallowDataShape } from '../common/data';\nimport { Heatmap, HeatmapProps } from './Heatmap';\nimport {\n  LinearXAxis,\n  LinearYAxis,\n  LinearYAxisTickSeries,\n  LinearXAxisTickSeries,\n  LinearYAxisTickLabel,\n  LinearXAxisTickLabel\n} from '../common/Axis';\nimport { HeatmapSeries, HeatmapCell } from './HeatmapSeries';\nimport { ChartTooltip } from '../common/Tooltip';\nimport { formatValue } from '../common/utils/formatting';\nimport {\n  buildDataScales,\n  CalendarView,\n  addWeeksToDate,\n  weekDays\n} from './calendarUtils';\n\nexport interface CalendarHeatmapProps extends Omit<HeatmapProps, 'data'> {\n  /**\n   * Chart data shape.\n   */\n  data: ChartShallowDataShape[];\n\n  /**\n   * Height of the component.\n   */\n  height: number;\n\n  /**\n   * Width of the component.\n   */\n  width: number;\n\n  /**\n   * View of the calendar renderer.\n   */\n  view: CalendarView;\n}\n\n// Format the xAxis label for the start + n week\nconst xAxisLabelFormat = (start: Date) => (weeks: number) =>\n  addWeeksToDate(start, weeks).toLocaleString('default', { month: 'long' });\n\nexport const CalendarHeatmap: FC<Partial<CalendarHeatmapProps>> = ({\n  view,\n  data,\n  ...rest\n}) => {\n  const {\n    data: domainData,\n    yDomain,\n    xDomain,\n    start\n  } = useMemo(() => buildDataScales(data, view), [data, view]);\n\n  // For month, only pass 1 tick value\n  const xTickValues = view === 'year' ? undefined : [1];\n\n  // Get the yAxis label formatting based on view type\n  const yAxisLabelFormat = view === 'year' ? (d) => weekDays[d] : () => null;\n\n  return (\n    <Heatmap\n      {...rest}\n      data={domainData}\n      yAxis={\n        <LinearYAxis\n          type=\"category\"\n          axisLine={null}\n          domain={yDomain}\n          tickSeries={\n            <LinearYAxisTickSeries\n              tickSize={20}\n              line={null}\n              label={\n                <LinearYAxisTickLabel padding={5} format={yAxisLabelFormat} />\n              }\n            />\n          }\n        />\n      }\n      xAxis={\n        <LinearXAxis\n          type=\"category\"\n          axisLine={null}\n          domain={xDomain}\n          tickSeries={\n            <LinearXAxisTickSeries\n              line={null}\n              tickValues={xTickValues}\n              label={\n                <LinearXAxisTickLabel\n                  padding={5}\n                  align=\"end\"\n                  format={xAxisLabelFormat(start)}\n                />\n              }\n            />\n          }\n        />\n      }\n    />\n  );\n};\n\nCalendarHeatmap.defaultProps = {\n  view: 'year',\n  series: (\n    <HeatmapSeries\n      padding={0.3}\n      emptyColor=\"transparent\"\n      cell={\n        <HeatmapCell\n          tooltip={\n            <ChartTooltip\n              content={(d) =>\n                `${formatValue(d.data.metadata.date)}  ${formatValue(\n                  d.data.value\n                )}`\n              }\n            />\n          }\n        />\n      }\n    />\n  )\n};\n","import React, { FC } from 'react';\nimport { Bar, BarProps } from '../BarChart';\nimport { ChartTooltip, TooltipTemplate } from '../common/Tooltip';\n\nexport type LinearGaugeBarProps = BarProps;\n\nexport const LinearGaugeBar: FC<Partial<LinearGaugeBarProps>> = (props) => (\n  <Bar {...props} />\n);\n\nLinearGaugeBar.defaultProps = {\n  tooltip: (\n    <ChartTooltip\n      placement=\"top\"\n      content={(data) => (\n        <TooltipTemplate value={{ y: data.value, x: data.y }} />\n      )}\n    />\n  )\n};\n","import React, { FC } from 'react';\n\nexport interface LinearGaugeOuterBarProps extends SVGRect {\n  /**\n   * Height of the chart. Set by `LinearGauge` component.\n   */\n  height: number;\n\n  /**\n   * Width of the chart. Set by `LinearGauge` component.\n   */\n  width: number;\n\n  /**\n   * Fill for the bar element.\n   */\n  fill: string;\n}\n\nexport const LinearGaugeOuterBar: FC<Partial<LinearGaugeOuterBarProps>> = ({\n  height,\n  width,\n  fill,\n  ...rest\n}) => (\n  <rect\n    {...rest}\n    fill={fill}\n    width={Math.max(width!, 0)}\n    height={Math.max(height!, 0)}\n  />\n);\n\nLinearGaugeOuterBar.defaultProps = {\n  fill: '#484848'\n};\n","import React, { Fragment, ReactElement, FC } from 'react';\nimport { BarSeries, BarSeriesProps } from '../BarChart';\nimport { LinearGaugeBar, LinearGaugeBarProps } from './LinearGaugeBar';\nimport {\n  LinearGaugeOuterBar,\n  LinearGaugeOuterBarProps\n} from './LinearGaugeOuterBar';\nimport { CloneElement } from 'reablocks';\n\nexport interface LinearGaugeSeriesProps extends Omit<BarSeriesProps, 'bar'> {\n  /**\n   * Height of the chart. Set by `LinearGauge` component.\n   */\n  height: number;\n\n  /**\n   * Width of the chart. Set by `LinearGauge` component.\n   */\n  width: number;\n\n  /**\n   * Whether its a multi-series or not. Set by `LinearGauge` component.\n   */\n  isMultiSeries: boolean;\n\n  /**\n   * Bar element. Only applicable for single series.\n   */\n  bar: ReactElement<LinearGaugeBarProps, typeof LinearGaugeBar>;\n\n  /**\n   * Outer bar element. Only applicable for single series.\n   */\n  outerBar: ReactElement<LinearGaugeOuterBarProps, typeof LinearGaugeOuterBar>;\n}\n\nexport const LinearGaugeSeries: FC<Partial<LinearGaugeSeriesProps>> = ({\n  height,\n  width,\n  bar,\n  outerBar,\n  isMultiSeries,\n  ...rest\n}) => (\n  <Fragment>\n    {!isMultiSeries && outerBar && (\n      <CloneElement<LinearGaugeOuterBarProps>\n        element={outerBar}\n        height={height}\n        width={width}\n      />\n    )}\n    <BarSeries\n      {...rest}\n      layout=\"horizontal\"\n      tooltip={null}\n      bar={<CloneElement<LinearGaugeOuterBarProps> element={bar} />}\n    />\n  </Fragment>\n);\n\nLinearGaugeSeries.defaultProps = {\n  outerBar: <LinearGaugeOuterBar />,\n  bar: <LinearGaugeBar />\n};\n","import React, { FC, Fragment, ReactElement, useCallback, useMemo } from 'react';\nimport {\n  ChartProps,\n  ChartContainer,\n  ChartContainerChildProps\n} from '../common/containers';\nimport {\n  ChartShallowDataShape,\n  buildBarStackData,\n  ChartInternalNestedDataShape,\n  buildShallowChartData,\n  ChartNestedDataShape\n} from '../common/data';\nimport { getXScale, getYScale } from '../common/scales';\nimport { CloneElement } from 'reablocks';\nimport { LinearGaugeSeries, LinearGaugeSeriesProps } from './LinearGaugeSeries';\n\nexport interface LinearGaugeProps extends ChartProps {\n  /**\n   * Data the chart will receive to render.\n   */\n  data: ChartShallowDataShape | ChartShallowDataShape[];\n\n  /**\n   * The series component that renders the bar components.\n   */\n  series: ReactElement<LinearGaugeSeriesProps, typeof LinearGaugeSeries>;\n\n  /**\n   * Min value to scale on. Only applicable for single-series.\n   */\n  minValue: number;\n\n  /**\n   * Max value to scale on. Only applicable for single-series.\n   */\n  maxValue: number;\n}\n\nexport const LinearGauge: FC<Partial<LinearGaugeProps>> = ({\n  id,\n  width,\n  height,\n  margins,\n  className,\n  containerClassName,\n  series,\n  data,\n  minValue,\n  maxValue\n}) => {\n  const transformedData = useMemo(() => {\n    if (Array.isArray(data)) {\n      return buildBarStackData(\n        [\n          {\n            key: 'default',\n            data\n          }\n        ] as ChartNestedDataShape[],\n        'expand',\n        'horizontal'\n      );\n    } else {\n      return buildShallowChartData([data], 'horizontal');\n    }\n  }, [data]);\n\n  const getScales = useCallback(\n    (\n      isMultiSeries: boolean,\n      data: ChartInternalNestedDataShape[],\n      width: number,\n      height: number,\n      minValue: number,\n      maxValue: number\n    ) => {\n      const domain = !isMultiSeries ? [minValue, maxValue] : undefined;\n\n      const keyScale = getXScale({\n        width,\n        type: 'value',\n        data,\n        domain,\n        isMultiSeries\n      });\n\n      const valueScale = getYScale({\n        type: 'category',\n        height,\n        data,\n        isMultiSeries\n      });\n\n      return {\n        keyScale,\n        valueScale\n      };\n    },\n    []\n  );\n\n  const renderChart = useCallback(\n    ({ chartHeight, chartWidth, id, chartSized }: ChartContainerChildProps) => {\n      const isMultiSeries = Array.isArray(data);\n      const type = isMultiSeries ? 'stackedNormalized' : 'standard';\n      const { keyScale, valueScale } = getScales(\n        isMultiSeries,\n        transformedData as ChartInternalNestedDataShape[],\n        chartWidth,\n        chartHeight,\n        minValue,\n        maxValue\n      );\n\n      return (\n        <Fragment>\n          {chartSized && (\n            <CloneElement<LinearGaugeSeriesProps>\n              element={series}\n              id={`linear-gauge-series-${id}`}\n              data={transformedData}\n              isCategorical={true}\n              xScale={keyScale}\n              yScale={valueScale}\n              type={type}\n              height={chartHeight}\n              width={chartWidth}\n              isMultiSeries={isMultiSeries}\n            />\n          )}\n        </Fragment>\n      );\n    },\n    [data, getScales, maxValue, minValue, series, transformedData]\n  );\n\n  return (\n    <ChartContainer\n      id={id}\n      width={width}\n      height={height}\n      margins={margins}\n      className={className}\n      containerClassName={containerClassName}\n    >\n      {renderChart}\n    </ChartContainer>\n  );\n};\n\nLinearGauge.defaultProps = {\n  minValue: 0,\n  maxValue: 100,\n  series: <LinearGaugeSeries />\n};\n","import { useEffect } from 'react';\nimport { DEFAULT_TRANSITION } from '../common/Motion';\nimport { useMotionValue, useSpring } from 'framer-motion';\nimport { interpolate } from 'd3-interpolate';\n\nexport const useInterpolate = ({ data, animated }) => {\n  const transition = animated\n    ? { ...DEFAULT_TRANSITION }\n    : {\n        delay: 0,\n        type: false\n      };\n\n  const d = useMotionValue(data.path);\n  const spring = useSpring(0, { stiffness: 300, damping: 30 });\n\n  useEffect(() => {\n    const interpolator = interpolate(d.get(), data.path);\n    const prevSpring = spring.get();\n    spring.set(1 + prevSpring);\n\n    return spring.on('change', (v) => d.set(interpolator(v - prevSpring)));\n  }, [d, data.path, spring]);\n\n  return { transition, d };\n};\n","import React, {\n  FC,\n  useRef,\n  ReactElement,\n  useState,\n  Fragment,\n  useMemo\n} from 'react';\nimport { IVennLayout } from '@upsetjs/venn.js';\nimport { ChartTooltip, ChartTooltipProps } from '../common/Tooltip';\nimport { CloneElement } from 'reablocks';\nimport { motion } from 'framer-motion';\nimport { useInterpolate } from './useInterpolate';\nimport { Mask, MaskProps } from '../common/Mask';\nimport { Gradient, GradientProps } from '../common/Gradient';\nimport { useHoverIntent } from '../common/utils/useHoverIntent';\nimport { Glow, getAriaLabel } from '../common';\nimport { generateGlowStyles } from '../common/Glow/utils';\n\nexport interface VennArcProps {\n  /**\n   * Whether the shape is active or not.\n   */\n  active?: boolean | null;\n\n  /**\n   * Id set by the parent.\n   */\n  id: string;\n\n  /**\n   * Whether the chart is animated or not.\n   */\n  animated?: boolean;\n\n  /**\n   * Fill color for the arc.\n   */\n  fill: string;\n\n  /**\n   * Stroke for the arc.\n   */\n  stroke?:\n    | string\n    | ((\n        data: IVennLayout<any>[],\n        index: number,\n        isActive: boolean | null,\n        isHovered: boolean | null\n      ) => string);\n\n  /**\n   * The internal data object built by venn.js\n   */\n  data: IVennLayout<any>;\n\n  /**\n   * Whether the chart is disabled.\n   */\n  disabled?: boolean;\n\n  /**\n   * Stroke on the arc.\n   */\n  strokeWidth?: number;\n\n  /**\n   * Initial style of arc.\n   */\n  initialStyle?: any;\n\n  /**\n   * Active style of arc.\n   */\n  activeStyle?: any;\n\n  /**\n   * Inactive style of arc.\n   */\n  inactiveStyle?: any;\n\n  /**\n   * CSS Styles for the arc.\n   */\n  style?: any;\n\n  /**\n   * Tooltip element.\n   */\n  tooltip?: ReactElement<ChartTooltipProps, typeof ChartTooltip> | null;\n\n  /**\n   * Mask element for the arc.\n   */\n  mask: ReactElement<MaskProps, typeof Mask> | null;\n\n  /**\n   * Gradient shades for the arc.\n   */\n  gradient: ReactElement<GradientProps, typeof Gradient> | null;\n\n  /**\n   * Glow styling for the arc.\n   */\n  glow: Glow;\n\n  /**\n   * Event for when the arc is clicked.\n   */\n  onClick: (event) => void;\n\n  /**\n   * Event for when the arc has mouse enter.\n   */\n  onMouseEnter: (event) => void;\n\n  /**\n   * Event for when the arc has mouse leave.\n   */\n  onMouseLeave: (event) => void;\n}\n\nexport const VennArc: FC<Partial<VennArcProps>> = ({\n  data,\n  fill,\n  disabled,\n  animated,\n  stroke,\n  mask,\n  id,\n  style,\n  active,\n  inactiveStyle,\n  activeStyle,\n  initialStyle,\n  strokeWidth,\n  gradient,\n  glow,\n  tooltip,\n  onClick,\n  onMouseEnter,\n  onMouseLeave\n}) => {\n  const [internalActive, setInternalActive] = useState<boolean>(false);\n  const arcRef = useRef<any | null>(null);\n  const { transition, d } = useInterpolate({ animated, data });\n  const currentStyle = active\n    ? activeStyle\n    : active === null\n      ? inactiveStyle\n      : initialStyle;\n\n  const arcFill =\n    gradient && !mask\n      ? `url(#gradient-${id})`\n      : mask\n        ? `url(#mask-pattern-${id})`\n        : fill;\n\n  const { pointerOut, pointerOver } = useHoverIntent({\n    onPointerOver: (event) => {\n      if (!disabled) {\n        setInternalActive(true);\n        onMouseEnter?.({\n          value: data.data,\n          nativeEvent: event\n        });\n      }\n    },\n    onPointerOut: (event) => {\n      if (!disabled) {\n        setInternalActive(false);\n        onMouseLeave?.({\n          value: data.data,\n          nativeEvent: event\n        });\n      }\n    }\n  });\n\n  const tooltipData = useMemo(\n    () => ({ y: data.data.size, x: data.data?.sets?.join(' | ') }),\n    [data]\n  );\n  const ariaLabelData = useMemo(() => getAriaLabel(tooltipData), [tooltipData]);\n\n  return (\n    <g\n      title={data.data.key}\n      onPointerOver={pointerOver}\n      onPointerOut={pointerOut}\n      onClick={(event) => {\n        if (!disabled) {\n          onClick?.({\n            value: data.data,\n            nativeEvent: event\n          });\n        }\n      }}\n      tabIndex={0}\n      aria-label={ariaLabelData}\n      role=\"graphics-document\"\n    >\n      <motion.path\n        ref={arcRef}\n        fill={arcFill}\n        id={`${id}-arc`}\n        strokeWidth={strokeWidth}\n        stroke={stroke as string}\n        transition={transition}\n        d={d}\n        initial={initialStyle}\n        animate={currentStyle}\n        style={{\n          ...style,\n          ...generateGlowStyles({\n            glow,\n            colorSchemeColor: typeof stroke === 'string' ? stroke : null\n          })\n        }}\n      />\n      {mask && (\n        <Fragment>\n          <Mask id={`mask-${id}`} fill={`url(#gradient-${id})`} />\n          <CloneElement<MaskProps>\n            element={mask}\n            id={`mask-pattern-${id}`}\n            fill={fill}\n          />\n        </Fragment>\n      )}\n      {gradient && (\n        <CloneElement<GradientProps>\n          element={gradient}\n          id={`gradient-${id}`}\n          color={fill}\n        />\n      )}\n      {tooltip && !tooltip.props.disabled && (\n        <CloneElement<ChartTooltipProps>\n          element={tooltip}\n          visible={!!internalActive}\n          reference={arcRef}\n          value={tooltipData}\n        />\n      )}\n    </g>\n  );\n};\n\nVennArc.defaultProps = {\n  active: false,\n  inactiveStyle: { opacity: 0.3 },\n  activeStyle: { opacity: 0.8 },\n  initialStyle: { opacity: 0.6 },\n  strokeWidth: 3,\n  gradient: <Gradient />,\n  tooltip: <ChartTooltip />,\n  onClick: () => undefined,\n  onMouseEnter: () => undefined,\n  onMouseLeave: () => undefined\n};\n","import React, { FC } from 'react';\nimport { motion } from 'framer-motion';\nimport { wrapText } from '../common/utils/wrapText';\nimport { DEFAULT_TRANSITION } from '../common/Motion';\n\nexport interface VennLabelProps {\n  /**\n   * Whether the shape is active or not.\n   */\n  active?: boolean | null;\n\n  /**\n   * Set by the parent element.\n   */\n  id?: string;\n\n  /**\n   * Show all labels or just the large ones. Default false.\n   */\n  showAll?: boolean;\n\n  /**\n   * The label type to show.\n   */\n  labelType: 'key' | 'value';\n\n  /**\n   * Should wrap text or not.\n   */\n  wrap?: boolean;\n\n  /**\n   * The internal data object built by venn.js\n   */\n  data: any;\n\n  /**\n   * Font size of the text.\n   */\n  fontSize?: number;\n\n  /**\n   * Font family of the text.\n   */\n  fontFamily?: string;\n\n  /**\n   * Fill of the text.\n   */\n  fill?: string;\n\n  /**\n   * Whether the chart is animated or not.\n   */\n  animated?: boolean;\n\n  /**\n   * Format label.\n   */\n  format?: (data) => any;\n}\n\nexport const VennLabel: FC<Partial<VennLabelProps>> = ({\n  data,\n  format,\n  id,\n  active,\n  labelType,\n  showAll,\n  wrap,\n  animated,\n  fill,\n  fontSize,\n  fontFamily\n}) => {\n  // If the text area is very large, then lets just skip showing the label\n  if (!showAll && !data.arcs?.filter((a) => a.large).length) {\n    return null;\n  }\n\n  const key =\n    labelType === 'key' ? data.data?.sets?.join(' | ') : data.data.size;\n\n  const transition = animated ? DEFAULT_TRANSITION : { delay: 0, type: false };\n  const text = wrap\n    ? wrapText({\n      key,\n      x: data.text.x,\n      fontFamily,\n      fontSize,\n      width: data?.circles?.[0]?.radius\n    })\n    : key;\n\n  return (\n    <motion.text\n      id={`${id}-text`}\n      fill={fill}\n      pointerEvents=\"none\"\n      fontFamily={fontFamily}\n      fontSize={fontSize}\n      initial={\n        {\n          attrX: data.text.x,\n          attrY: data.text.y,\n          opacity: 1\n        } as any\n      }\n      animate={\n        {\n          attrX: data.text.x,\n          attrY: data.text.y,\n          opacity: active === null ? 0.3 : 1\n        } as any\n      }\n      transition={transition}\n      textAnchor=\"middle\"\n    >\n      {format ? format(data) : text}\n    </motion.text>\n  );\n};\n\nVennLabel.defaultProps = {\n  labelType: 'key',\n  showAll: false,\n  wrap: true,\n  animated: true,\n  fontSize: 11,\n  fontFamily: 'sans-serif'\n};\n","import React, { FC, Fragment, isValidElement } from 'react';\nimport { motion } from 'framer-motion';\nimport { DEFAULT_TRANSITION } from '../common/Motion';\n\nexport interface VennOuterLabelProps {\n  /**\n   * The internal data object built by venn.js\n   */\n  data: any;\n\n  /**\n   * Font size of the text.\n   */\n  fontSize?: number;\n\n  /**\n   * Font family of the text.\n   */\n  fontFamily?: string;\n\n  /**\n   * Fill of the text.\n   */\n  fill?: string;\n\n  /**\n   * Whether the chart is animated or not.\n   */\n  animated?: boolean;\n\n  /**\n   * Format label.\n   */\n  format?: (data) => any;\n}\n\nexport const VennOuterLabel: FC<Partial<VennOuterLabelProps>> = ({\n  data,\n  format,\n  animated,\n  fill,\n  fontSize,\n  fontFamily\n}) => {\n  const transition = animated ? DEFAULT_TRANSITION : { delay: 0, type: false };\n  const text = data.set.data.key;\n\n  const label = format ? format(data) : text;\n  const isElement = isValidElement(label);\n  const showIcon = isElement && data.set.icon;\n\n  // TODO: framer-motion doesn't seem to like the translates on the g\n  // initial={pos} animate={pos}\n  const pos = {\n    x: showIcon ? data.set.icon.x : data.set.text.x,\n    y: showIcon ? data.set.icon.y : data.set.text.y\n  };\n\n  return (\n    <Fragment>\n      {isElement ? (\n        <g style={{ transform: `translate(${pos.x}px, ${pos.y}px)` }}>\n          {label}\n        </g>\n      ) : (\n        <motion.text\n          fill={fill}\n          style={{ pointerEvents: 'none', fontFamily, fontSize }}\n          textAnchor={data.set.align === 'middle' ? 'center' : data.set.align}\n          alignmentBaseline={data.set.verticalAlign}\n          initial={\n            {\n              attrX: pos.x,\n              attrY: pos.y\n            } as any\n          }\n          animate={\n            {\n              attrX: pos.x,\n              attrY: pos.y\n            } as any\n          }\n          transition={transition}\n        >\n          {label}\n        </motion.text>\n      )}\n    </Fragment>\n  );\n};\n\nVennOuterLabel.defaultProps = {\n  animated: true,\n  fill: '#000',\n  fontSize: 14,\n  fontFamily: 'sans-serif'\n};\n","import React, {\n  FC,\n  Fragment,\n  ReactElement,\n  useCallback,\n  useState,\n  useMemo\n} from 'react';\nimport { IVennLayout } from '@upsetjs/venn.js';\nimport { ColorSchemeType, getColor } from '../common/color';\nimport { VennArc, VennArcProps } from './VennArc';\nimport { VennLabel, VennLabelProps } from './VennLabel';\nimport { motion } from 'framer-motion';\nimport { CloneElement } from 'reablocks';\nimport chroma from 'chroma-js';\nimport { VennOuterLabel, VennOuterLabelProps } from './VennOuterLabel';\nimport invert from 'invert-color';\nimport { DEFAULT_TRANSITION } from '../common/Motion';\nimport { identifier } from 'safe-identifier';\n\nexport interface VennSeriesProps {\n  /**\n   * Id set by the parent.\n   */\n  id: string;\n\n  /**\n   * Active managed selections.\n   */\n  selections?: string[];\n\n  /**\n   * The internal data object built by venn.js\n   */\n  data: IVennLayout<any>[];\n\n  /**\n   * Color scheme for the chart.\n   */\n  colorScheme: ColorSchemeType;\n\n  /**\n   * Whether the chart is disabled.\n   */\n  disabled?: boolean;\n\n  /**\n   * Whether the chart is animated or not.\n   */\n  animated?: boolean;\n\n  /**\n   * Label element.\n   */\n  label?: ReactElement<VennLabelProps, typeof VennLabel> | null;\n\n  /**\n   * Label element.\n   */\n  outerLabel?: ReactElement<VennOuterLabelProps, typeof VennOuterLabel> | null;\n\n  /**\n   * Arc element.\n   */\n  arc?: ReactElement<VennArcProps, typeof VennArc> | null;\n}\n\nexport const VennSeries: FC<Partial<VennSeriesProps>> = ({\n  data,\n  id,\n  selections,\n  animated,\n  disabled,\n  colorScheme,\n  outerLabel,\n  arc,\n  label\n}) => {\n  const transition = animated ? DEFAULT_TRANSITION : { type: false, delay: 0 };\n  const [actives, setActives] = useState<string[]>([]);\n  const [hovered, setHovered] = useState<string | null>(null);\n\n  const onActivate = useCallback(\n    (point: string) => {\n      setHovered(point);\n\n      setActives(\n        data\n          .filter((d) => d.data?.key.indexOf(point) > -1)\n          .map((d) => d.data?.key)\n      );\n    },\n    [data]\n  );\n\n  const renderArc = useCallback(\n    (d: IVennLayout<any> & { set?: any }, index: number) => {\n      // Get the colors of the fill\n      const fill = getColor({\n        data,\n        colorScheme,\n        point: d.data,\n        index\n      });\n\n      const textFill = fill\n        ? invert(chroma(fill).darken(0.5).hex(), true)\n        : 'white';\n\n      const arcFill = arc.props.fill || fill;\n\n      const key = d?.data?.key;\n      const safeKey = identifier(d.data?.key);\n      const isSelected = selections?.includes(key);\n\n      // Get the state of the arc\n      const isHovered = hovered === key || isSelected;\n      const isActive =\n        isSelected ||\n        actives.includes(key) ||\n        (actives.length > 0 ? null : false);\n\n      const getStrokeColor = () => {\n        if (typeof arc.props.stroke === 'function') {\n          return arc.props.stroke(data, index, isActive, isHovered);\n        }\n        if (arc.props.stroke !== undefined) {\n          return arc.props.stroke;\n        }\n\n        // fallback to fill (determined by colorScheme) if stroke is undefined\n        return fill;\n      };\n\n      const stroke = getStrokeColor();\n\n      const arcStroke =\n        stroke ||\n        chroma(arcFill)\n          .darken(isActive ? 0.8 : 0.5)\n          .hex();\n\n      return (\n        <Fragment key={safeKey}>\n          <CloneElement<VennArcProps>\n            element={arc}\n            id={`${id}-${safeKey}`}\n            data={d}\n            fill={arcFill}\n            stroke={arcStroke}\n            disabled={disabled}\n            animated={animated}\n            active={isActive}\n            onMouseEnter={() => onActivate(key)}\n            onMouseLeave={() => {\n              setActives([]);\n              setHovered(null);\n            }}\n          />\n          {label && (\n            <CloneElement<VennLabelProps>\n              element={label}\n              data={d}\n              id={`${id}-${safeKey}`}\n              active={isActive}\n              animated={animated}\n              fill={textFill}\n              {...label.props}\n            />\n          )}\n          {d.set && outerLabel && (\n            <CloneElement<VennLabelProps>\n              element={outerLabel}\n              data={d}\n              animated={animated}\n            />\n          )}\n        </Fragment>\n      );\n    },\n    [\n      data,\n      colorScheme,\n      arc,\n      selections,\n      hovered,\n      actives,\n      id,\n      disabled,\n      animated,\n      label,\n      outerLabel,\n      onActivate\n    ]\n  );\n\n  const topArcs = useMemo(() => {\n    const result = [];\n\n    if (actives.length > 0) {\n      result.push(...actives.filter((s) => s !== hovered));\n    }\n\n    if (selections?.length) {\n      result.push(\n        ...selections.filter((s) => !actives.includes(s) && s !== hovered)\n      );\n    }\n\n    if (hovered) {\n      result.push(hovered);\n    }\n\n    return result;\n  }, [hovered, actives, selections]);\n\n  return (\n    <motion.g\n      initial={{ opacity: 0, scale: 0 }}\n      animate={{ opacity: 1, scale: 1 }}\n      transition={transition}\n    >\n      {data.map(renderArc)}\n      {topArcs.length > 0 &&\n        topArcs.map((a) => (\n          <use\n            key={a}\n            xlinkHref={`#${id}-${a}-arc`}\n            style={{ pointerEvents: 'none' }}\n          />\n        ))}\n      {data.map((d, index) => (\n        <use\n          key={index}\n          xlinkHref={`#${id}-${identifier(d.data?.key)}-text`}\n          style={{ pointerEvents: 'none' }}\n        />\n      ))}\n    </motion.g>\n  );\n};\n\nVennSeries.defaultProps = {\n  animated: true,\n  disabled: false,\n  colorScheme: 'cybertron',\n  outerLabel: <VennOuterLabel />,\n  arc: <VennArc />,\n  label: <VennLabel />\n};\n","import venn0 from './venn0.json';\nimport venn1 from './venn1.json';\nimport venn2 from './venn2.json';\nimport venn3 from './venn3.json';\nimport venn4 from './venn4.json';\nimport venn5 from './venn5.json';\n\nexport interface BoundingBox {\n  width: number;\n  height: number;\n}\n\n// Static shapes for rendering\nconst shapes = [venn0, venn1, venn2, venn3, venn4, venn5];\n\n/**\n * Sort helper.\n * Reference: https://stackoverflow.com/a/64449554/1288340\n */\nconst upto = (limit) => Array.from({ length: limit }, (_, i) => i);\n\n/**\n * Detect ellipse.\n * Reference: https://github.com/upsetjs/chartjs-chart-venn/blob/master/src/model/generate.ts#L4\n */\nfunction isEllipse(d) {\n  return typeof d.rx === 'number';\n}\n\n/**\n * Generate all combinations of a given array.\n * Reference: https://stackoverflow.com/questions/5752002/find-all-possible-subset-combos-in-an-array\n */\nfunction combinations(array: string[]) {\n  return (new Array(1 << array.length) as any)\n    .fill()\n    .map((_e1, i) => array.filter((_e2, j) => i & (1 << j)));\n}\n\n/**\n * Given a array set, lookup the data.\n */\nfunction lookup(combo: string[], data: any[]) {\n  const key = combo.join('|');\n  const found = data.find((d) => d.key === key);\n\n  return {\n    key,\n    sets: combo,\n    size: found?.size || 0\n  };\n}\n\n/**\n * Build the data combinations for the layout.\n */\nfunction buildData(data: any[]) {\n  // Collect all unique sets and sort by size\n  const uniqueSets = data\n    .filter((d) => d.sets.length === 1)\n    .sort((a, b) => b.size - a.size);\n\n  // Map our unique sets\n  const uniqueSetKeys = uniqueSets.map((u) => u.key);\n\n  // Build all combos and return 1+ combos\n  const sets: any[] = combinations(uniqueSetKeys);\n  const filteredSets = sets.slice(1, sets.length);\n\n  // Sort the child sets based on the parent\n  const result = filteredSets.map((d) =>\n    [...d].sort((a, b) => uniqueSetKeys.indexOf(a) - uniqueSetKeys.indexOf(b))\n  );\n\n  // Sort the data based on index of keys and length\n  // Reference: https://stackoverflow.com/a/64449554/1288340\n  result.sort(\n    (a, b) =>\n      a.length - b.length ||\n      upto(a.length).reduce(\n        (diff, i) =>\n          diff || uniqueSetKeys.indexOf(a[i]) - uniqueSetKeys.indexOf(b[i]),\n        0\n      )\n  );\n\n  // reshape the data key so they will match combos\n  const keyedData = data.map((d) => {\n    const sets = [...d.sets].sort(\n      (a, b) => uniqueSetKeys.indexOf(a) - uniqueSetKeys.indexOf(b)\n    );\n    const key = sets.join('|');\n\n    return {\n      size: d.size,\n      sets,\n      key\n    };\n  });\n\n  return {\n    uniqueCount: uniqueSets.length,\n    data: result.map((r) => lookup(r, keyedData))\n  };\n}\n\n/**\n * Generate the arc slice path.\n * Reference: https://github.com/upsetjs/chartjs-chart-venn/blob/master/src/model/generate.ts#L4\n */\nexport function generateArcSlicePath(s: any, refs: any[]) {\n  return `M ${s.x1},${s.y1} ${s.arcs\n    .map((arc) => {\n      const ref = refs[arc.ref];\n      const rx = isEllipse(ref) ? ref.rx : ref.r;\n      const ry = isEllipse(ref) ? ref.ry : ref.r;\n      const rot = isEllipse(ref) ? ref.rotation : 0;\n      return `A ${rx} ${ry} ${rot} ${arc.large ? 1 : 0} ${arc.sweep ? 1 : 0} ${\n        arc.x2\n      } ${arc.y2}`;\n    })\n    .join(' ')}`;\n}\n\n/**\n * Build the layout for the given chart.\n * Reference: https://github.com/upsetjs/chartjs-chart-venn/blob/master/src/model/generate.ts#L4\n */\nfunction buildLayout({ data, uniqueCount }, box: BoundingBox) {\n  const shape = shapes[Math.min(shapes.length - 1, uniqueCount)];\n  const f = Math.min(box.width / shape.bb.width, box.height / shape.bb.height);\n  const x = f * -shape.bb.x + (box.width - f * shape.bb.width) / 2 + 0;\n  const y = f * -shape.bb.y + (box.height - f * shape.bb.height) / 2 + 0;\n  const mx = (v: number) => x + f * v;\n  const my = (v: number) => y + f * v;\n\n  const shapeSets = shape.sets.map((c, i) => ({\n    ...c,\n    ...{\n      data: data[i],\n      cx: mx(c.cx),\n      cy: my(c.cy),\n      text: {\n        x: mx(c.text.x),\n        y: my(c.text.y)\n      },\n      ...(c.icon\n        ? {\n          icon: {\n            x: mx(c.icon.x),\n            y: my(c.icon.y)\n          }\n        }\n        : {})\n    },\n    ...(isEllipse(c)\n      ? {\n        rx: c.rx * f,\n        ry: c.ry * f\n      }\n      : {\n        r: c.r * f\n      })\n  }));\n\n  const intersections = shape.intersections.map((c, i) => ({\n    text: {\n      x: mx(c.text.x),\n      y: my(c.text.y)\n    },\n    x1: mx(c.x1),\n    y1: my(c.y1),\n    data: data[i],\n    set: shapeSets[i],\n    arcs: c.arcs.map((a) => ({\n      ...a,\n      x2: mx(a.x2),\n      y2: my(a.y2)\n    }))\n  }));\n\n  return intersections.map((i) => ({\n    ...i,\n    path: generateArcSlicePath(i, shapeSets)\n  }));\n}\n\n/**\n * Generate the star euler layout.\n * Adapted from: https://github.com/upsetjs/chartjs-chart-venn\n */\nexport function starEulerLayout(data: any[], bb: BoundingBox) {\n  return buildLayout(buildData(data), bb);\n}\n","import React, { FC, Fragment, ReactElement, useCallback } from 'react';\nimport {\n  ChartContainer,\n  ChartContainerChildProps,\n  ChartProps\n} from '../common/containers';\nimport { layout } from '@upsetjs/venn.js';\nimport { VennSeries, VennSeriesProps } from './VennSeries';\nimport { CloneElement } from 'reablocks';\nimport { starEulerLayout } from './starEuler';\n\nexport interface VennDiagramData {\n  /**\n   * List of Keys for the data.\n   */\n  key: string[];\n\n  /**\n   * Size of the data keys.\n   */\n  data: number;\n}\n\nexport interface VennDiagramProps extends ChartProps {\n  /**\n   * Type of the chart.\n   */\n  type?: 'venn' | 'euler' | 'starEuler';\n\n  /**\n   * Data the chart will receive to render.\n   */\n  data: VennDiagramData[];\n\n  /**\n   * The series component that renders the arc and label components.\n   */\n  series?: ReactElement<VennSeriesProps, typeof VennSeries> | null;\n\n  /**\n   * Whether the chart is disabled.\n   */\n  disabled?: boolean;\n}\n\nexport const VennDiagram: FC<VennDiagramProps> = ({\n  id,\n  type,\n  width,\n  height,\n  margins,\n  className,\n  containerClassName,\n  data,\n  disabled,\n  series\n}) => {\n  const renderChart = useCallback(\n    (containerProps: ChartContainerChildProps) => {\n      const normalized = data.map((d) => ({\n        key: d.key.join('|'),\n        sets: d.key,\n        size: d.data\n      }));\n\n      let layoutData;\n      if (type === 'starEuler') {\n        layoutData = starEulerLayout(normalized, {\n          height: containerProps.height,\n          width: containerProps.width\n        });\n      } else {\n        layoutData = layout(normalized, {\n          height: containerProps.height,\n          width: containerProps.width,\n          distinct: type !== 'euler'\n        });\n      }\n\n      return (\n        <CloneElement<VennSeriesProps>\n          element={series}\n          data={layoutData}\n          disabled={disabled}\n          id={containerProps.id}\n        />\n      );\n    },\n    [data, disabled, series, type]\n  );\n\n  return (\n    <ChartContainer\n      id={id}\n      width={width}\n      height={height}\n      margins={margins}\n      containerClassName={containerClassName}\n      xAxisVisible={false}\n      yAxisVisible={false}\n      center={false}\n      className={className}\n    >\n      {renderChart}\n    </ChartContainer>\n  );\n};\n\nVennDiagram.defaultProps = {\n  type: 'venn',\n  series: <VennSeries />\n};\n","import React, {\n  FC,\n  Fragment,\n  MouseEventHandler,\n  ReactElement,\n  useMemo,\n  useRef,\n  useState\n} from 'react';\nimport { HierarchyCircularNode } from 'd3-hierarchy';\nimport { ChartTooltip, ChartTooltipProps } from '../common/Tooltip';\nimport { CloneElement } from 'reablocks';\nimport { motion } from 'framer-motion';\nimport { Gradient, GradientProps } from '../common/Gradient';\nimport { Mask, MaskProps } from '../common/Mask';\nimport { DEFAULT_TRANSITION } from '../common/Motion';\nimport { useHoverIntent } from '../common/utils/useHoverIntent';\nimport { Glow } from '../common/Glow';\nimport { generateGlowStyles } from '../common/Glow/utils';\nimport { getAriaLabel } from '../common';\n\nexport interface BubbleProps {\n  /**\n   * Id set by the parent.\n   */\n  id: string;\n\n  /**\n   * The internal data object built by d3\n   */\n  data: HierarchyCircularNode<any>;\n\n  /**\n   * Fill for the bubble.\n   */\n  fill: string;\n\n  /**\n   * Whether the chart is animated or not.\n   */\n  animated?: boolean;\n\n  /**\n   * Tooltip element.\n   */\n  tooltip?: ReactElement<ChartTooltipProps, typeof ChartTooltip> | null;\n\n  /**\n   * Mask element for the bubble.\n   */\n  mask: ReactElement<MaskProps, typeof Mask> | null;\n\n  /**\n   * Glow styling for the bubble.\n   */\n  glow?: Glow;\n\n  /**\n   * Gradient shades for the bubble.\n   */\n  gradient: ReactElement<GradientProps, typeof Gradient> | null;\n\n  /**\n   * Event for when the bubble is clicked.\n   */\n  onClick?: (\n    event: React.MouseEvent<SVGCircleElement>,\n    currentItem?: HierarchyCircularNode<any>\n  ) => void;\n\n  /**\n   * Event for when the mouse enters bubble.\n   */\n  onMouseEnter?: (event) => void;\n\n  /**\n   * Event for when the mouse leaves the bubble.\n   */\n  onMouseLeave?: (event) => void;\n}\n\nexport const Bubble: FC<Partial<BubbleProps>> = ({\n  id,\n  data,\n  fill,\n  mask,\n  gradient,\n  glow,\n  onClick,\n  onMouseEnter,\n  onMouseLeave,\n  animated,\n  tooltip = <ChartTooltip />\n}) => {\n  const [internalActive, setInternalActive] = useState<boolean>(false);\n  const bubbleRef = useRef<any | null>(null);\n  const transition = animated ? DEFAULT_TRANSITION : { type: false, delay: 0 };\n\n  const { pointerOut, pointerOver } = useHoverIntent({\n    onPointerOver: (event) => {\n      setInternalActive(true);\n      onMouseEnter?.(event);\n    },\n    onPointerOut: (event) => {\n      setInternalActive(false);\n      onMouseLeave?.(event);\n    }\n  });\n\n  const arcFill =\n    gradient && !mask\n      ? `url(#gradient-${id})`\n      : mask\n        ? `url(#mask-pattern-${id})`\n        : fill;\n\n  const tooltipData = useMemo(\n    () => ({ y: data.data.data, x: data.data.key }),\n    [data]\n  );\n  const ariaLabelData = useMemo(() => getAriaLabel(tooltipData), [tooltipData]);\n\n  return (\n    <Fragment>\n      <motion.circle\n        id={`${id}-bubble`}\n        ref={bubbleRef}\n        fill={arcFill}\n        style={generateGlowStyles({ glow })}\n        initial={{\n          r: data.r,\n          cx: data.x,\n          cy: data.y\n        }}\n        animate={{\n          r: data.r,\n          cx: data.x,\n          cy: data.y\n        }}\n        transition={transition}\n        onClick={(event) => onClick && onClick(event, data)}\n        onPointerOver={pointerOver}\n        onPointerOut={pointerOut}\n        tabIndex={0}\n        aria-label={ariaLabelData}\n        role=\"graphics-document\"\n      />\n      {mask && (\n        <Fragment>\n          <Mask id={`mask-${id}`} fill={`url(#gradient-${id})`} />\n          <CloneElement<MaskProps>\n            element={mask}\n            id={`mask-pattern-${id}`}\n            fill={fill}\n          />\n        </Fragment>\n      )}\n      {gradient && (\n        <CloneElement<GradientProps>\n          element={gradient}\n          id={`gradient-${id}`}\n          color={fill}\n        />\n      )}\n      {tooltip && !tooltip.props.disabled && (\n        <CloneElement<ChartTooltipProps>\n          element={tooltip}\n          visible={!!internalActive}\n          reference={bubbleRef}\n          value={tooltipData}\n        />\n      )}\n    </Fragment>\n  );\n};\n","import React, { FC, isValidElement } from 'react';\nimport { HierarchyCircularNode } from 'd3-hierarchy';\nimport { motion } from 'framer-motion';\nimport { wrapText } from '../common/utils/wrapText';\nimport { DEFAULT_TRANSITION } from '../common/Motion';\n\nexport interface BubbleLabelProps {\n  /**\n   * Id set by the parent.\n   */\n  id: string;\n\n  /**\n   * The internal data object built by d3\n   */\n  data: HierarchyCircularNode<any>;\n\n  /**\n   * Font size of the text.\n   */\n  fontSize?: number;\n\n  /**\n   * Font family of the text.\n   */\n  fontFamily?: string;\n\n  /**\n   * Fill of the text.\n   */\n  fill?: string;\n\n  /**\n   * Should wrap text or not.\n   */\n  wrap?: boolean;\n\n  /**\n   * Whether the chart is animated or not.\n   */\n  animated?: boolean;\n\n  /**\n   * Format label.\n   */\n  format?: (data) => any;\n}\n\nexport const BubbleLabel: FC<Partial<BubbleLabelProps>> = ({\n  id,\n  data,\n  format,\n  wrap,\n  fill,\n  fontSize,\n  fontFamily,\n  animated\n}) => {\n  const transition = animated ? DEFAULT_TRANSITION : { type: false, delay: 0 };\n  let isElement = false;\n  let label;\n\n  if (format) {\n    label = format(data);\n    isElement = isValidElement(label);\n  }\n\n  if (!isElement) {\n    const text = wrap\n      ? wrapText({\n        key: data.data.key,\n        fontFamily,\n        fontSize,\n        width: data.r\n      })\n      : data.data.key;\n\n    return (\n      <motion.text\n        initial={{\n          x: data.x,\n          y: data.y\n        }}\n        animate={{\n          x: data.x,\n          y: data.y\n        }}\n        transition={transition}\n        id={`${id}-text`}\n        style={{ pointerEvents: 'none', fontFamily, fontSize }}\n        fill={fill}\n        textAnchor=\"middle\"\n      >\n        {text}\n      </motion.text>\n    );\n  }\n\n  return (\n    <g style={{ transform: `translate(${data.x}px, ${data.y}px)` }}>{label}</g>\n  );\n};\n\nBubbleLabel.defaultProps = {\n  wrap: true,\n  fontSize: 14,\n  fontFamily: 'sans-serif'\n};\n","import React, { FC, Fragment, ReactElement } from 'react';\nimport { motion } from 'framer-motion';\nimport { HierarchyCircularNode } from 'd3-hierarchy';\nimport { ColorSchemeType, getColor } from '../common/color';\nimport { Bubble, BubbleProps } from './Bubble';\nimport { BubbleLabel, BubbleLabelProps } from './BubbleLabel';\nimport { CloneElement } from 'reablocks';\nimport invert from 'invert-color';\nimport chroma from 'chroma-js';\nimport { DEFAULT_TRANSITION } from '../common/Motion';\nimport { identifier } from 'safe-identifier';\n\nexport interface BubbleSeriesProps {\n  /**\n   * Id set by the parent.\n   */\n  id: string;\n\n  /**\n   * The internal data object built by d3\n   */\n  data: HierarchyCircularNode<any>[];\n\n  /**\n   * Whether the chart is animated or not.\n   */\n  animated?: boolean;\n\n  /**\n   * Color scheme for the chart.\n   */\n  colorScheme: ColorSchemeType;\n\n  /**\n   * Bubble element.\n   */\n  bubble?: ReactElement<BubbleProps, typeof Bubble>;\n\n  /**\n   * Bubble element.\n   */\n  format?: (item: any) => ReactElement<BubbleProps, typeof Bubble>;\n\n  /**\n   * Label element.\n   */\n  label?: ReactElement<BubbleLabelProps, typeof BubbleLabel>;\n}\n\nexport const BubbleSeries: FC<Partial<BubbleSeriesProps>> = ({\n  id,\n  data,\n  colorScheme,\n  animated,\n  bubble,\n  format,\n  label\n}) => {\n  const transition = animated ? DEFAULT_TRANSITION : { type: false, delay: 0 };\n\n  const renderBubble = (item, index) => {\n    const fill = getColor({\n      data,\n      colorScheme,\n      point: item.data,\n      index\n    });\n\n    const textFill = fill\n      ? invert(chroma(fill).darken(0.5).hex(), true)\n      : 'white';\n\n    return (\n      <motion.g\n        key={(item.data as any).key}\n        initial={{\n          scale: 0.5,\n          opacity: 0\n        }}\n        animate={{\n          scale: 1,\n          opacity: 1\n        }}\n        transition={transition}\n      >\n        <CloneElement<BubbleProps>\n          element={format ? format(item) : bubble}\n          id={identifier(`${id}-${item.data.key}-bubble`)}\n          animated={animated}\n          data={item}\n          fill={fill}\n        />\n        <CloneElement<BubbleLabelProps>\n          element={label}\n          id={identifier(`${id}-${item.data.key}-label`)}\n          animated={animated}\n          data={item}\n          fill={textFill}\n        />\n      </motion.g>\n    );\n  };\n\n  return <Fragment>{data.map(renderBubble)}</Fragment>;\n};\n\nBubbleSeries.defaultProps = {\n  colorScheme: 'cybertron',\n  animated: true,\n  bubble: <Bubble />,\n  label: <BubbleLabel />\n};\n","import React, { FC, ReactElement, useCallback } from 'react';\nimport { hierarchy, pack } from 'd3-hierarchy';\nimport { CloneElement } from 'reablocks';\nimport {\n  ChartContainer,\n  ChartContainerChildProps,\n  ChartProps,\n  ChartShallowDataShape\n} from '../common';\nimport { BubbleSeries, BubbleSeriesProps } from './BubbleSeries';\n\nexport interface BubbleChartProps extends ChartProps {\n  /**\n   * Data the chart will receive to render.\n   */\n  data: ChartShallowDataShape[];\n\n  /**\n   * The series component that renders the arc components.\n   */\n  series?: ReactElement<BubbleSeriesProps, typeof BubbleSeries>;\n}\n\nexport const BubbleChart: FC<Partial<BubbleChartProps>> = ({\n  data,\n  id,\n  width,\n  height,\n  className,\n  containerClassName,\n  margins,\n  series\n}) => {\n  const getData = useCallback(\n    (cw: number, ch: number) => {\n      const bubble = pack().size([cw, ch]).padding(3);\n\n      const root = hierarchy<any>({ children: data })\n        .sum((d) => d.data)\n        .sort((a, b) => b.data - a.data);\n\n      return bubble(root).leaves();\n    },\n    [data]\n  );\n\n  const renderChart = useCallback(\n    ({ chartWidth, chartHeight, ...rest }: ChartContainerChildProps) => {\n      const circles = getData(chartWidth, chartHeight);\n\n      return (\n        <CloneElement<BubbleSeriesProps>\n          element={series}\n          id={`${rest.id}-series`}\n          data={circles}\n        />\n      );\n    },\n    [series, getData]\n  );\n\n  return (\n    <ChartContainer\n      id={id}\n      width={width}\n      height={height}\n      containerClassName={containerClassName}\n      margins={margins}\n      xAxisVisible={false}\n      yAxisVisible={false}\n      className={className}\n    >\n      {renderChart}\n    </ChartContainer>\n  );\n};\n\nBubbleChart.defaultProps = {\n  data: [],\n  margins: 10,\n  series: <BubbleSeries />\n};\n","import React, { FC } from 'react';\nimport { calculateDimensions, wrapText } from '../common/utils';\nimport { formatValue } from '../common/utils/formatting';\n\nexport interface TreeMapLabelProps {\n  /**\n   * Id set by the parent.\n   */\n  id: string;\n\n  /**\n   * The internal data object built by d3\n   */\n  data: any;\n\n  /**\n   * Font size of the text.\n   */\n  fontSize?: number;\n\n  /**\n   * Font family of the text.\n   */\n  fontFamily?: string;\n\n  /**\n   * Fill of the text.\n   */\n  fill?: string;\n\n  /**\n   * Should wrap text or not.\n   */\n  wrap?: boolean;\n\n  /**\n   * Placement of the text.\n   */\n  placement?: 'start' | 'middle' | 'end';\n}\n\nexport const TreeMapLabel: FC<Partial<TreeMapLabelProps>> = ({\n  id,\n  data,\n  fill,\n  wrap,\n  placement,\n  fontSize,\n  fontFamily\n}) => {\n  const key = data.data.key;\n  const width = data.x1 - data.x0;\n  const text = wrapText({\n    key,\n    fontFamily,\n    fontSize,\n    paddingX: 10,\n    wrap,\n    paddingY: 10,\n    width,\n    height: data.y1 - data.y0\n  });\n  const size = calculateDimensions(\n    typeof text === 'string' ? text : key,\n    fontFamily,\n    fontSize\n  );\n\n  const offsetX =\n    placement === 'start'\n      ? 10\n      : placement === 'middle'\n        ? (width - size.width) / 2\n        : width - size.width - 10;\n\n  return (\n    <g style={{ transform: `translate(${offsetX}px, 15px)` }}>\n      <text\n        id={`${id}-text`}\n        style={{ pointerEvents: 'none', fontFamily, fontSize }}\n        fill={fill}\n      >\n        {text}\n      </text>\n    </g>\n  );\n};\n\nTreeMapLabel.defaultProps = {\n  fill: '#FFF',\n  wrap: true,\n  fontSize: 14,\n  fontFamily: 'sans-serif',\n  placement: 'start'\n};\n","import React, {\n  FC,\n  ReactElement,\n  useRef,\n  useState,\n  Fragment,\n  useMemo\n} from 'react';\nimport { motion } from 'framer-motion';\nimport chroma from 'chroma-js';\nimport { ChartTooltip, ChartTooltipProps } from '../common/Tooltip';\nimport { CloneElement } from 'reablocks';\nimport { DEFAULT_TRANSITION } from '../common/Motion';\nimport { useHoverIntent } from '../common/utils/useHoverIntent';\nimport { getAriaLabel } from '../common';\n\nexport interface TreeMapRectProps {\n  /**\n   * The internal data object built by d3\n   */\n  data: any;\n\n  /**\n   * Id set by the parent.\n   */\n  id: string;\n\n  /**\n   * Fill for the rect.\n   */\n  fill: string;\n\n  /**\n   * Whether the chart is animated or not.\n   */\n  animated?: boolean;\n\n  /**\n   * Cursor for the element.\n   */\n  cursor?: string;\n\n  /**\n   * Tooltip element.\n   */\n  tooltip?: ReactElement<ChartTooltipProps, typeof ChartTooltip> | null;\n\n  /**\n   * Event for when the arc is clicked.\n   */\n  onClick?: (event, data) => void;\n\n  /**\n   * Event for when the arc has mouse enter.\n   */\n  onMouseEnter?: (event, data) => void;\n\n  /**\n   * Event for when the arc has mouse leave.\n   */\n  onMouseLeave?: (event, data) => void;\n}\n\nexport const TreeMapRect: FC<Partial<TreeMapRectProps>> = ({\n  data,\n  fill,\n  animated,\n  cursor,\n  tooltip,\n  onMouseEnter,\n  onMouseLeave,\n  onClick\n}) => {\n  const [internalActive, setInternalActive] = useState<boolean>(false);\n  const rectRef = useRef<any | null>(null);\n  const transition = animated ? DEFAULT_TRANSITION : { type: false, delay: 0 };\n  const currentFill = internalActive ? chroma(fill).darken(0.8).hex() : fill;\n\n  const { pointerOut, pointerOver } = useHoverIntent({\n    onPointerOver: (event) => {\n      setInternalActive(true);\n      onMouseEnter?.(event, data);\n    },\n    onPointerOut: (event) => {\n      setInternalActive(false);\n      onMouseLeave?.(event, data);\n    }\n  });\n\n  const tooltipLabel = useMemo(() => {\n    const getKey = (node): string[] => {\n      if (!node.parent) {\n        return [];\n      }\n      return [...getKey(node.parent), node.data.key];\n    };\n    return getKey(data).join('  ');\n  }, [data]);\n\n  const tooltipData = useMemo(\n    () => ({ y: data.value, x: tooltipLabel }),\n    [data, tooltipLabel]\n  );\n  const ariaLabelData = useMemo(() => getAriaLabel(tooltipData), [tooltipData]);\n\n  return (\n    <Fragment>\n      <motion.rect\n        ref={rectRef}\n        initial={{\n          fill: currentFill,\n          width: data.x1 - data.x0,\n          height: data.y1 - data.y0\n        }}\n        animate={{\n          fill: currentFill,\n          width: data.x1 - data.x0,\n          height: data.y1 - data.y0\n        }}\n        style={{ cursor }}\n        transition={transition}\n        onClick={(event) => {\n          onClick?.(event, data);\n        }}\n        onPointerOver={pointerOver}\n        onPointerOut={pointerOut}\n        tabIndex={0}\n        aria-label={ariaLabelData}\n        role=\"graphics-document\"\n      />\n      {tooltip && !tooltip.props.disabled && (\n        <CloneElement<ChartTooltipProps>\n          element={tooltip}\n          visible={!!internalActive}\n          reference={rectRef}\n          value={tooltipData}\n        />\n      )}\n    </Fragment>\n  );\n};\n\nTreeMapRect.defaultProps = {\n  cursor: 'pointer',\n  tooltip: <ChartTooltip />\n};\n","import React, { FC, Fragment, ReactElement } from 'react';\nimport { motion } from 'framer-motion';\nimport { CloneElement } from 'reablocks';\nimport { ColorSchemeType, getColor } from '../common/color';\nimport { TreeMapLabel, TreeMapLabelProps } from './TreeMapLabel';\nimport { TreeMapRect, TreeMapRectProps } from './TreeMapRect';\nimport invert from 'invert-color';\nimport chroma from 'chroma-js';\nimport { DEFAULT_TRANSITION } from '../common/Motion';\n\nexport interface TreeMapSeriesProps {\n  /**\n   * Id set by the parent.\n   */\n  id: string;\n\n  /**\n   * The internal data object built by d3\n   */\n  data: any[];\n\n  /**\n   * Whether the chart is animated or not.\n   */\n  animated?: boolean;\n\n  /**\n   * Color scheme for the chart.\n   */\n  colorScheme: ColorSchemeType;\n\n  /**\n   * Rect element to be rendered.\n   */\n  rect?: ReactElement<TreeMapRectProps, typeof TreeMapRect>;\n\n  /**\n   * Label element to be rendered.\n   */\n  label?: ReactElement<TreeMapLabelProps, typeof TreeMapLabel>;\n}\n\nexport const TreeMapSeries: FC<Partial<TreeMapSeriesProps>> = ({\n  id,\n  data,\n  colorScheme,\n  animated,\n  rect,\n  label\n}) => {\n  const transition = animated ? DEFAULT_TRANSITION : { type: false, delay: 0 };\n\n  const renderItem = (item: any, index: number) => {\n    const fill = getColor({\n      data,\n      colorScheme,\n      point: item.data,\n      index\n    });\n\n    const textFill = fill\n      ? invert(chroma(fill).darken(0.5).hex(), true)\n      : 'white';\n\n    return (\n      <motion.g\n        key={item.data.key}\n        initial={{\n          scale: 0.5,\n          opacity: 0,\n          x: item.x0,\n          y: item.y0\n        }}\n        animate={{\n          scale: 1,\n          opacity: 1,\n          x: item.x0,\n          y: item.y0\n        }}\n        transition={transition}\n      >\n        <CloneElement<TreeMapRectProps>\n          element={rect}\n          id={`${id}-${item.data.key}-rect`}\n          animated={animated}\n          data={item}\n          fill={fill}\n        />\n        <CloneElement<TreeMapLabelProps>\n          element={label}\n          id={`${id}-${item.data.key}-label`}\n          data={item}\n          fill={textFill}\n        />\n      </motion.g>\n    );\n  };\n\n  return <Fragment>{data.map((d, index) => renderItem(d, index))}</Fragment>;\n};\n\nTreeMapSeries.defaultProps = {\n  colorScheme: 'cybertron',\n  animated: true,\n  rect: <TreeMapRect />,\n  label: <TreeMapLabel />\n};\n","import React, { FC, ReactElement, useCallback } from 'react';\nimport {\n  ChartContainer,\n  ChartContainerChildProps,\n  ChartProps\n} from '../common/containers/ChartContainer';\nimport { ChartNestedDataShape, ChartShallowDataShape } from '../common/data';\nimport { hierarchy, treemap, treemapSquarify } from 'd3-hierarchy';\nimport { TreeMapSeries, TreeMapSeriesProps } from './TreeMapSeries';\nimport { CloneElement } from 'reablocks';\n\nexport interface TreeMapProps extends ChartProps {\n  /**\n   * Data the chart will receive to render.\n   */\n  data: ChartShallowDataShape[] | ChartNestedDataShape[];\n\n  /**\n   * The series component that renders the components.\n   */\n  series?: ReactElement<TreeMapSeriesProps, typeof TreeMapSeries>;\n\n  /**\n   * Inner padding for the treemap. Defaults to 5.\n   */\n  paddingInner?: number;\n\n  /**\n   * Outer padding for the treemap. Defaults to 5.\n   */\n  paddingOuter?: number;\n\n  /**\n   * Padding top for the treemap. This is used for the title\n   * spacing in nested situations. Defaults to 30.\n   */\n  paddingTop?: number;\n}\n\nexport const TreeMap: FC<Partial<TreeMapProps>> = ({\n  data,\n  id,\n  containerClassName,\n  paddingInner,\n  paddingTop,\n  paddingOuter,\n  width,\n  height,\n  className,\n  margins,\n  series\n}) => {\n  const getData = useCallback(\n    (cw: number, ch: number) => {\n      const root = hierarchy<any>({ data: data }, (d) => d.data)\n        .sum((d) => d.data)\n        .sort((a, b) => b.data - a.data);\n\n      const t = treemap()\n        .size([cw, ch])\n        .tile(treemapSquarify)\n        .round(true)\n        .paddingInner(paddingInner)\n        .paddingOuter(paddingOuter)\n        .paddingTop(paddingTop);\n\n      const tree = t(root);\n      const nodes = [];\n\n      const getAllNodes = (node) => {\n        if (node?.parent) {\n          // Don't add root node\n          nodes.push(node);\n        }\n        for (let child of node?.children || []) {\n          getAllNodes(child);\n        }\n      };\n\n      getAllNodes(tree);\n      return nodes;\n    },\n    [data, paddingInner, paddingOuter, paddingTop]\n  );\n\n  const renderChart = useCallback(\n    ({ chartWidth, chartHeight, ...rest }: ChartContainerChildProps) => {\n      const datas = getData(chartWidth, chartHeight);\n      return (\n        <CloneElement<TreeMapSeriesProps>\n          element={series}\n          {...rest}\n          id={`${id || rest.id}-series`}\n          data={datas}\n        />\n      );\n    },\n    [series, getData, id]\n  );\n\n  return (\n    <ChartContainer\n      id={id}\n      width={width}\n      height={height}\n      containerClassName={containerClassName}\n      margins={margins}\n      xAxisVisible={false}\n      yAxisVisible={false}\n      className={className}\n    >\n      {renderChart}\n    </ChartContainer>\n  );\n};\n\nTreeMap.defaultProps = {\n  margins: 0,\n  paddingInner: 5,\n  paddingOuter: 5,\n  paddingTop: 30,\n  series: <TreeMapSeries />,\n  data: []\n};\n","import React, { FC, useCallback } from 'react';\nimport {\n  ChartInternalDataTypes,\n  ChartShallowDataShape,\n  ColorSchemeType,\n  DEFAULT_TRANSITION,\n  formatValue,\n  getAriaLabel,\n  getColor\n} from '../common';\nimport { motion } from 'framer-motion';\nimport classNames from 'classnames';\nimport css from './BarListSeries.module.css';\n\nexport type BarListLabelPosition = 'none' | 'top' | 'start' | 'end' | 'bottom';\n\nexport interface BarListSeriesProps {\n  /**\n   * Data for the chart.\n   */\n  data?: ChartShallowDataShape[];\n\n  /**\n   * Color scheme for the chart.\n   */\n  colorScheme?: ColorSchemeType;\n\n  /**\n   * The label position.\n   */\n  labelPosition?: BarListLabelPosition;\n\n  /**\n   * The value position.\n   */\n  valuePosition?: BarListLabelPosition;\n\n  /**\n   * The bar item class name.\n   */\n  itemClassName?: string;\n\n  /**\n   * Label css class name.\n   */\n  labelClassName?: string;\n\n  /**\n   * Label value class name.\n   */\n  valueClassName?: string;\n\n  /**\n   * Bar component class name.\n   */\n  barClassName?: string;\n\n  /**\n   * Bar container class name.\n   */\n  outerBarClassName?: string;\n\n  /**\n   * Custom label format.\n   */\n  labelFormat?: (data: ChartInternalDataTypes, index: number) => any;\n\n  /**\n   * Custom value format\n   */\n  valueFormat?: (data: ChartInternalDataTypes, index: number) => any;\n\n  /**\n   * Item was clicked.\n   */\n  onItemClick?: (data: ChartShallowDataShape) => void;\n\n  /**\n   * Item had mouse enter.\n   */\n  onItemMouseEnter?: (data: ChartShallowDataShape) => void;\n\n  /**\n   * Item had mouse leave.\n   */\n  onItemMouseLeave?: (data: ChartShallowDataShape) => void;\n}\n\nexport const BarListSeries: FC<Partial<BarListSeriesProps>> = ({\n  data,\n  colorScheme,\n  itemClassName,\n  labelClassName,\n  outerBarClassName,\n  valueClassName,\n  labelFormat,\n  barClassName,\n  labelPosition,\n  valuePosition,\n  valueFormat,\n  onItemClick,\n  onItemMouseEnter,\n  onItemMouseLeave\n}) => {\n  const renderBar = useCallback(\n    (item, index) => {\n      const fill = getColor({\n        data,\n        colorScheme,\n        point: item.data,\n        index\n      });\n\n      return (\n        <div className={classNames(css.outerBar, outerBarClassName)}>\n          <motion.div\n            transition={DEFAULT_TRANSITION}\n            className={classNames(css.bar, barClassName)}\n            initial={{ width: '0%' }}\n            animate={{ width: `${item.data}%` }}\n            style={{ background: fill }}\n            tabIndex={0}\n            aria-label={getAriaLabel(item)}\n            role=\"graphics-document\"\n          />\n        </div>\n      );\n    },\n    [barClassName, outerBarClassName, colorScheme, data]\n  );\n\n  return (\n    <>\n      {data.map((d, i) => {\n        const label = labelFormat ? labelFormat(d.key as any, i) : d.key;\n\n        const valueLabel = valueFormat\n          ? valueFormat(d.metadata.value, i)\n          : formatValue(d.metadata.value);\n\n        return (\n          <div\n            key={d.key as string}\n            role=\"listitem\"\n            className={classNames(css.item, itemClassName, {\n              [css.clickable]: onItemClick,\n              [css.valueBottom]: valuePosition === 'bottom',\n              [css.valueStart]: valuePosition === 'start',\n              [css.valueEnd]: valuePosition === 'end',\n              [css.valueNone]: valuePosition === 'none',\n              [css.labelBottom]: labelPosition === 'bottom',\n              [css.labelTop]: labelPosition === 'top',\n              [css.labelStart]: labelPosition === 'start',\n              [css.labelEnd]: labelPosition === 'end',\n              [css.labelNone]: labelPosition === 'none'\n            })}\n            onMouseEnter={() => onItemMouseEnter?.(d)}\n            onMouseLeave={() => onItemMouseLeave?.(d)}\n            onClick={() => onItemClick?.(d)}\n          >\n            <label title={label} className={classNames(css.label, labelClassName)}>\n              {label}\n            </label>\n            {renderBar(d, i)}\n            <label\n              title={valueLabel}\n              className={classNames(css.valueLabel, valueClassName)}\n            >\n              <small>{valueLabel}</small>\n            </label>\n          </div>\n        );\n      })}\n    </>\n  );\n};\n\nBarListSeries.defaultProps = {\n  colorScheme: 'cybertron',\n  labelPosition: 'top',\n  valuePosition: 'none'\n};\n","import { max } from 'd3-array';\nimport { scaleLinear } from 'd3-scale';\nimport { motion } from 'framer-motion';\nimport { CloneElement, useId } from 'reablocks';\nimport React, { FC, ReactElement, useMemo } from 'react';\nimport { ChartShallowDataShape } from '../common';\nimport { BarListSeries, BarListSeriesProps } from './BarListSeries';\n\nexport interface BarListProps {\n  /**\n   * ID for the chart.\n   */\n  id?: string;\n\n  /**\n   * CSS Classname for the element.\n   */\n  className?: string;\n\n  /**\n   * Style for the element.\n   */\n  style?: React.CSSProperties;\n\n  /**\n   * Data for the chart.\n   */\n  data: ChartShallowDataShape[];\n\n  /**\n   * Sort direction of the data.\n   */\n  sortDirection?: 'asc' | 'desc' | 'none';\n\n  /**\n   * Series to render.\n   */\n  series?: ReactElement<BarListSeriesProps, typeof BarList>;\n\n  /**\n   * Whether the values are percentages or absolute values.\n   * In the latter case, the chart would be relative\n   */\n  type?: 'percent' | 'count';\n}\n\nexport const BarList: FC<BarListProps> = ({\n  data,\n  id,\n  className,\n  sortDirection,\n  style,\n  series,\n  type\n}) => {\n  const curId = useId(id);\n\n  const mashedData = useMemo(() => {\n    const maxVal = type === 'count' ? max(data, (d) => d.data) : 100;\n    const domainVal = maxVal == 0 ? [0] : [0, maxVal];\n    const groupScale = scaleLinear().domain(domainVal).rangeRound([0, 100]);\n\n    const mashed = data.map((d) => ({\n      ...d,\n      data: groupScale(d.data as number),\n      metadata: {\n        value: d.data,\n        percent: (data.length * (d.data as number)) / 100\n      }\n    }));\n\n    if (sortDirection === 'asc') {\n      mashed.sort((a, b) => a.data - b.data);\n    } else if (sortDirection === 'desc') {\n      mashed.sort((a, b) => b.data - a.data);\n    }\n\n    return mashed;\n  }, [data, sortDirection]);\n\n  return (\n    <motion.section\n      role=\"list\"\n      variants={{\n        initial: {\n          transition: {\n            staggerChildren: 0.05,\n            staggerDirection: -1 as any\n          }\n        },\n        animate: {\n          transition: {\n            staggerChildren: 0.07,\n            delayChildren: 0.2\n          }\n        }\n      }}\n      id={curId}\n      className={className}\n      style={style}\n    >\n      <CloneElement<BarListSeriesProps> element={series} data={mashedData} />\n    </motion.section>\n  );\n};\n\nBarList.defaultProps = {\n  data: [],\n  sortDirection: 'desc',\n  series: <BarListSeries />,\n  type: 'count'\n};\n","import React, { FC } from 'react';\nimport { motion } from 'framer-motion';\nimport { DEFAULT_TRANSITION, schemes } from '../common';\n\nexport interface MeterColumnProps {\n  /**\n   * The value of the meter.\n   */\n  value: number;\n\n  /**\n   * The height of the column.\n   */\n  height?: number;\n\n  /**\n   * The index of the column.\n   */\n  index: number;\n\n  /**\n   * The scale to use.\n   */\n  scale: any;\n\n  /**\n   * The active fill color.\n   */\n  activeFill: string;\n\n  /**\n   * The inactive fill color.\n   */\n  inActiveFill: string;\n\n  /**\n   * Additional class names to apply.\n   */\n  className?: string;\n\n  /**\n   * The total number of columns. Set internally.\n   */\n  count?: number;\n\n  /**\n   * Whether to animate the column.\n   */\n  animated?: boolean;\n}\n\nexport const MeterColumn: FC<Partial<MeterColumnProps>> = ({\n  index,\n  scale,\n  value,\n  count,\n  height,\n  className,\n  animated,\n  activeFill,\n  inActiveFill\n}) => {\n  const isActive = scale(index) <= scale(value);\n  const fill = isActive ? activeFill : inActiveFill;\n  const transition = animated\n    ? {\n      ...DEFAULT_TRANSITION,\n      delay: (index / count) * 0.5\n    }\n    : {\n      type: false,\n      delay: 0\n    };\n\n  return (\n    <motion.div\n      key={index}\n      initial={{\n        background: inActiveFill,\n        height\n      }}\n      animate={{\n        background: fill,\n        height\n      }}\n      tranisition={transition}\n      className={className}\n    />\n  );\n};\n\nMeterColumn.defaultProps = {\n  activeFill: schemes.cybertron[0],\n  inActiveFill: '#414242',\n  height: 32,\n  animated: true\n};\n","import React, { FC, ReactElement } from 'react';\nimport { scaleLinear } from 'd3-scale';\nimport classNames from 'classnames';\nimport { MeterColumn, MeterColumnProps } from './MeterColumn';\nimport { CloneElement } from 'reablocks';\nimport css from './Meter.module.css';\n\nexport interface MeterProps {\n  /**\n   * The value of the meter.\n   */\n  value: number;\n\n  /**\n   * The minimum value of the meter.\n   */\n  min?: number;\n\n  /**\n   * The maximum value of the meter.\n   */\n  max?: number;\n\n  /**\n   * The number of columns to display.\n   */\n  columns?: number;\n\n  /**\n   * Additional class names to apply.\n   */\n  className?: string;\n\n  /**\n   * The gap between columns.\n   */\n  gap?: number;\n\n  /**\n   * Additional styles to apply.\n   */\n  style?: React.CSSProperties;\n\n  /**\n   * The column to render.\n   */\n  column: ReactElement<MeterColumnProps, typeof MeterColumn> | null;\n}\n\nexport const Meter: FC<Partial<MeterProps>> = ({\n  min,\n  max,\n  className,\n  column,\n  gap,\n  style,\n  value,\n  columns\n}) => {\n  const scale = scaleLinear().domain([min, max]).range([0, 100]);\n  const cols = scale.ticks(columns);\n\n  return (\n    <div\n      className={classNames(css.container, className)}\n      style={{ gap: `${gap}px`, ...style }}\n    >\n      {cols.map((index) => (\n        <CloneElement<MeterColumnProps>\n          element={column}\n          key={index}\n          count={cols.length}\n          index={index}\n          scale={scale}\n          value={value}\n        />\n      ))}\n    </div>\n  );\n};\n\nMeter.defaultProps = {\n  min: 0,\n  max: 100,\n  columns: 10,\n  gap: 15,\n  style: {},\n  column: <MeterColumn />\n};\n","import React, { FC } from 'react';\nimport { ChartNestedDataShape } from '../common/data';\nimport {\n  RadialAreaChart,\n  RadialAreaChartProps,\n  RadialAreaSeries,\n  RadialAreaSeriesProps,\n  RadialPointSeries\n} from '../RadialAreaChart';\nimport {\n  RadialAxis,\n  RadialAxisArcLine,\n  RadialAxisArcSeries\n} from '../common/Axis/RadialAxis';\n\nexport interface RadarChartSeriesProps extends RadialAreaSeriesProps {}\n\nexport const RadarChartSeries: FC<Partial<RadarChartSeriesProps>> = (props) => (\n  <RadialAreaSeries {...props} />\n);\n\nRadarChartSeries.defaultProps = {\n  area: null,\n  type: 'grouped',\n  symbols: <RadialPointSeries show />\n};\n","import React, { FC } from 'react';\nimport { ChartNestedDataShape } from '../common/data';\nimport { RadialAreaChart, RadialAreaChartProps } from '../RadialAreaChart';\nimport {\n  RadialAxis,\n  RadialAxisArcLine,\n  RadialAxisArcSeries\n} from '../common/Axis/RadialAxis';\nimport { RadarChartSeries } from './RadarChartSeries';\n\nexport interface RadarChartProps extends RadialAreaChartProps {\n  data: ChartNestedDataShape[];\n}\n\nexport const RadarChart: FC<Partial<RadarChartProps>> = (props) => (\n  <RadialAreaChart {...props} />\n);\n\nRadarChart.defaultProps = {\n  series: <RadarChartSeries />,\n  axis: (\n    <RadialAxis\n      type=\"category\"\n      arcs={\n        <RadialAxisArcSeries\n          count={5}\n          arc={null}\n          line={<RadialAxisArcLine />}\n        />\n      }\n    />\n  )\n};\n","import React, { FC, ReactElement, useMemo } from 'react';\nimport { ChartShallowDataShape } from '../../common/data';\nimport { area } from 'd3-shape';\nimport {\n  InterpolationTypes,\n  getAriaLabel,\n  interpolate\n} from '../../common/utils';\nimport { ColorSchemeType, getColor, schemes } from '../../common/color';\nimport { Gradient, GradientProps, GradientStop } from '../../common/Gradient';\nimport { CloneElement } from 'reablocks';\nimport { motion } from 'framer-motion';\nimport {\n  ChartTooltip,\n  TooltipArea,\n  TooltipAreaProps,\n  TooltipTemplate\n} from '../../common/Tooltip';\nimport { Glow } from '../../common';\nimport { generateGlowStyles } from '../../common/Glow/utils';\n\nexport interface FunnelArcProps {\n  /**\n   * Unique identifier for the arc. Set internally by `FunnelChart`.\n   */\n  id: string;\n\n  /**\n   * Data to render the funnel. Set internally by `FunnelChart`.\n   */\n  data: ChartShallowDataShape[];\n\n  /**\n   * Opacity of the funnel arc.\n   */\n  opacity?: number;\n\n  /**\n   * Index of the funnel arc. Set internally by `FunnelChart`.\n   */\n  index?: number;\n\n  /**\n   * The chart funnel style to use.\n   */\n  variant?: 'default' | 'layered';\n\n  /**\n   * xScale for the funnel. Set internally by `FunnelChart`.\n   */\n  xScale: any;\n\n  /**\n   * yScale for the funnel. Set internally by `FunnelChart`.\n   */\n  yScale: any;\n\n  /**\n   * Interpolation for the area. Set internally by `AreaSeries`.\n   */\n  interpolation: InterpolationTypes;\n\n  /**\n   * Color scheme for the chart.\n   */\n  colorScheme: ColorSchemeType;\n\n  /**\n   * Gradient to apply to the area.\n   */\n  gradient: ReactElement<GradientProps, typeof Gradient> | null;\n\n  /**\n   * Glow styling for the arc.\n   */\n  glow?: Glow;\n\n  /**\n   * Tooltip for the chart area.\n   */\n  tooltip: ReactElement<TooltipAreaProps, typeof TooltipArea>;\n}\n\nexport const FunnelArc: FC<Partial<FunnelArcProps>> = ({\n  data,\n  id,\n  xScale,\n  opacity,\n  index,\n  variant,\n  yScale,\n  interpolation,\n  colorScheme,\n  gradient,\n  glow,\n  tooltip\n}) => {\n  // Note: Need to append the last section\n  const internalData = [...data, data[data.length - 1]];\n\n  const areaGenerator = area()\n    .curve(interpolate(interpolation))\n    .x((_d, i) => xScale(i))\n    .y0(yScale(0))\n    .y1(({ data }: any) => yScale(data));\n\n  const areaMirrorGenerator = area()\n    .curve(interpolate(interpolation))\n    .x((_d, i) => xScale(i))\n    .y0(yScale(0))\n    .y1(({ data }: any) => yScale(-data));\n\n  const fillColor = getColor({\n    data,\n    domain: [0, 1, 2, 3],\n    colorScheme,\n    key: index\n  });\n\n  const fillTop = gradient ? `url(#gradient-${id}-top)` : fillColor;\n  const fillBottom = gradient ? `url(#gradient-${id}-bottom)` : fillColor;\n\n  const [height] = yScale.range();\n  const [_, width] = xScale.range();\n\n  const ariaLabelData = useMemo(() => getAriaLabel(data), [data]);\n\n  return (\n    <CloneElement<TooltipAreaProps>\n      element={tooltip}\n      xScale={xScale}\n      yScale={yScale}\n      data={data as any}\n      height={height}\n      width={width}\n      tooltip={\n        <ChartTooltip\n          followCursor\n          content={(data, color) => {\n            const value = {\n              x: data.key,\n              y: data.data,\n              value: data.data\n            };\n\n            return <TooltipTemplate value={value} color={color} />;\n          }}\n        />\n      }\n    >\n      <g\n        pointerEvents={tooltip ? 'none' : 'auto'}\n        style={generateGlowStyles({ glow })}\n        aria-label={ariaLabelData}\n        role=\"graphics-document\"\n      >\n        <motion.path\n          d={areaGenerator(internalData as any[])}\n          fill={fillTop}\n          stroke=\"none\"\n          initial={{\n            opacity: 0\n          }}\n          animate={{\n            opacity\n          }}\n        />\n        <motion.path\n          d={areaMirrorGenerator(internalData as any[])}\n          fill={fillBottom}\n          stroke=\"none\"\n          initial={{\n            opacity: 0\n          }}\n          animate={{\n            opacity\n          }}\n        />\n        {gradient && (\n          <>\n            <CloneElement<GradientProps>\n              element={gradient}\n              id={`gradient-${id}-top`}\n              color={fillColor}\n            />\n            <CloneElement<GradientProps>\n              element={gradient}\n              id={`gradient-${id}-bottom`}\n              color={fillColor}\n            />\n          </>\n        )}\n      </g>\n    </CloneElement>\n  );\n};\n\nFunnelArc.defaultProps = {\n  gradient: (\n    <Gradient\n      direction=\"horizontal\"\n      stops={[\n        <GradientStop offset=\"0%\" stopOpacity={1} key=\"stop\" />,\n        <GradientStop offset=\"80%\" stopOpacity={0.5} key=\"start\" />\n      ]}\n    />\n  ),\n  interpolation: 'smooth',\n  colorScheme: schemes.cybertron[0],\n  animated: true,\n  variant: 'default',\n  opacity: 1,\n  tooltip: null\n};\n","import React, { FC, useCallback } from 'react';\nimport { ChartShallowDataShape } from '../../../common/data';\nimport {\n  calculateDimensions,\n  formatValue,\n  wrapText\n} from '../../../common/utils';\nimport { motion } from 'framer-motion';\n\nexport interface FunnelAxisLabelProps {\n  /**\n   * Data object for the label. Set internally by `FunnelAxis`.\n   */\n  data: ChartShallowDataShape;\n\n  /**\n   * Index of the label. Set internally by `FunnelAxis`.\n   */\n  index: number;\n\n  /**\n   * Color of the text.\n   */\n  fill: string;\n\n  /**\n   * Font size of the text.\n   */\n  fontSize: number;\n\n  /**\n   * Font family of the text.\n   */\n  fontFamily: string;\n\n  /**\n   * Padding of the label.\n   */\n  padding?: number;\n\n  /**\n   * Class name to apply to the text.\n   */\n  className?: string;\n\n  /**\n   * xScale for the funnel. Set internally by `FunnelAxis`.\n   */\n  xScale: any;\n\n  /**\n   * yScale for the funnel. Set internally by `FunnelAxis`.\n   */\n  yScale: any;\n\n  /**\n   * Positioning of the label.\n   */\n  position?: 'top' | 'middle' | 'bottom';\n\n  /**\n   * Whether to show the value of the data.\n   * Defaults to `true`.\n   */\n  showValue?: boolean;\n\n  /**\n   * Visibility of the label.\n   */\n  labelVisibility?: 'auto' | 'always';\n}\n\nexport const FunnelAxisLabel: FC<Partial<FunnelAxisLabelProps>> = ({\n  data,\n  index,\n  xScale,\n  yScale,\n  fontFamily,\n  padding,\n  fontSize,\n  fill,\n  className,\n  position,\n  showValue,\n  labelVisibility\n}) => {\n  const x = xScale(index) + padding;\n  const [height] = yScale.range();\n  const y = height / 2 + padding;\n  const label = data.key as string;\n  const nextOffset = xScale(index + 1);\n  const width = (nextOffset ? nextOffset - xScale(index) : 0) - padding;\n  const size = calculateDimensions(label, fontFamily, fontSize);\n  const text = wrapText({\n    key: label,\n    size,\n    paddingY: padding,\n    paddingX: padding,\n    width,\n    height,\n    fontFamily,\n    fontSize,\n    visibility: labelVisibility\n  });\n\n  const getTransformString = useCallback(() => {\n    let transform: string;\n\n    switch (position) {\n    case 'top':\n      transform = `translate(${x}, ${fontSize * 3})`; // fontSize * 3 is to account for the total height of the label\n      break;\n    case 'middle':\n      transform = `translate(${x}, ${y})`;\n      break;\n    case 'bottom':\n      {\n        // If the text is wrapping, we need to account for the height of all the lines\n        const textWrapHeight = Array.isArray(text)\n          ? text.slice(1).reduce((acc, curr) => acc + curr.props.dy, 0) // Don't include first line's dy in order to align properly\n          : 0;\n        transform = `translate(${x}, ${height - padding - textWrapHeight})`;\n      }\n      break;\n    }\n\n    return transform;\n  }, [position, x, fontSize, y, text, height, padding]);\n\n  // If the labels don't fit, just hide them\n  if (labelVisibility !== 'always' && size.width > width) {\n    return null;\n  }\n\n  return (\n    <motion.g\n      transform={getTransformString()}\n      initial={{ opacity: 0 }}\n      animate={{ opacity: 1 }}\n    >\n      {showValue && (\n        <text\n          pointerEvents=\"none\"\n          fill={fill}\n          y={-(fontSize + padding)}\n          className={className}\n          dominantBaseline=\"middle\"\n          fontFamily={fontFamily}\n          fontSize={fontSize * 2}\n        >\n          {formatValue(data.data as any)}\n        </text>\n      )}\n      <text\n        pointerEvents=\"none\"\n        fill={fill}\n        className={className}\n        dominantBaseline=\"middle\"\n        fontFamily={fontFamily}\n        fontSize={fontSize}\n      >\n        {text}\n      </text>\n    </motion.g>\n  );\n};\n\nFunnelAxisLabel.defaultProps = {\n  fontSize: 13,\n  padding: 10,\n  fontFamily: 'sans-serif',\n  fill: '#fff',\n  position: 'middle',\n  showValue: true,\n  labelVisibility: 'auto'\n};\n","import React, { FC } from 'react';\n\nexport interface FunnelAxisLineProps {\n  /**\n   * Color of the axis lines.\n   */\n  strokeColor: string;\n\n  /**\n   * Width of the axis lines.\n   */\n  strokeWidth: number;\n\n  /**\n   * xScale for the funnel. Set internally by `FunnelChart`.\n   */\n  xScale: any;\n\n  /**\n   * yScale for the funnel. Set internally by `FunnelChart`.\n   */\n  yScale: any;\n\n  /**\n   * Index of the line. Set internally by `FunnelAxis`.\n   */\n  index: number;\n}\n\nexport const FunnelAxisLine: FC<Partial<FunnelAxisLineProps>> = ({\n  strokeColor,\n  strokeWidth,\n  yScale,\n  xScale,\n  index\n}) => {\n  const [height] = yScale.range();\n\n  return (\n    <line\n      x1={xScale(index)}\n      y1={0}\n      x2={xScale(index)}\n      y2={height}\n      stroke={strokeColor}\n      strokeWidth={strokeWidth}\n      pointerEvents=\"none\"\n    />\n  );\n};\n\nFunnelAxisLine.defaultProps = {\n  strokeColor: '#333',\n  strokeWidth: 2\n};\n","import React, { FC, Fragment, ReactElement } from 'react';\nimport { ChartShallowDataShape } from '../../../common/data';\nimport { range } from 'd3-array';\nimport { FunnelAxisLabel, FunnelAxisLabelProps } from './FunnelAxisLabel';\nimport { CloneElement } from 'reablocks';\nimport { FunnelAxisLine, FunnelAxisLineProps } from './FunnelAxisLine';\n\nexport interface FunnelAxisProps {\n  /**\n   * Data to render the funnel. Set internally by `FunnelChart`.\n   */\n  data: ChartShallowDataShape[];\n\n  /**\n   * xScale for the funnel. Set internally by `FunnelChart`.\n   */\n  xScale: any;\n\n  /**\n   * yScale for the funnel. Set internally by `FunnelChart`.\n   */\n  yScale: any;\n\n  /**\n   * The funnel axis line.\n   */\n  line?: ReactElement<FunnelAxisLineProps, typeof FunnelAxisLine> | null;\n\n  /**\n   * Label component for the axis.\n   */\n  label?: ReactElement<FunnelAxisLabelProps, typeof FunnelAxisLabel> | null;\n}\n\nexport const FunnelAxis: FC<Partial<FunnelAxisProps>> = ({\n  data,\n  xScale,\n  yScale,\n  line,\n  label\n}) => {\n  const lines = range(0, data.length);\n\n  return (\n    <>\n      {lines.map((index) => (\n        <Fragment key={index}>\n          {line && index !== 0 && (\n            <CloneElement<FunnelAxisLineProps>\n              element={line}\n              index={index}\n              xScale={xScale}\n              yScale={yScale}\n            />\n          )}\n          {label && (\n            <CloneElement<FunnelAxisLabelProps>\n              element={label}\n              index={index}\n              data={data[index]}\n              xScale={xScale}\n              yScale={yScale}\n            />\n          )}\n        </Fragment>\n      ))}\n    </>\n  );\n};\n\nFunnelAxis.defaultProps = {\n  label: <FunnelAxisLabel />,\n  line: <FunnelAxisLine />\n};\n","import React, { MouseEvent, useCallback, useMemo } from 'react';\nimport { FunnelArc } from './FunnelArc';\nimport { CloneElement } from 'reablocks';\nimport { FunnelArcProps } from './FunnelArc';\nimport { FunnelAxis, FunnelAxisProps } from './FunnelAxis';\nimport {\n  ChartShallowDataShape,\n  getClosestContinousScalePoint,\n  getPositionForTarget\n} from '../../common';\nimport { ClickEvent } from '../../common/types';\nimport { scaleLinear } from 'd3-scale';\nimport { max } from 'd3-array';\n\nexport interface FunnelSeriesProps {\n  /**\n   * Parsed data shape. Set internally by `FunnelChart`.\n   */\n  data: ChartShallowDataShape[];\n\n  /**\n   * Id of the funnel chart. Set internally by `FunnelChart`.\n   */\n  id: string;\n\n  /**\n   * The arc component that renders the funnel shape.\n   */\n  arc: React.ReactElement<FunnelArcProps, typeof FunnelArc>;\n\n  /**\n   * The axis component that renders the funnel axis.\n   */\n  axis: React.ReactElement<FunnelAxisProps, typeof FunnelAxis>;\n\n  /**\n   * Height of the chart. Set internally by `FunnelChart`.\n   */\n  height: number;\n\n  /**\n   * Width of the chart. Set internally by `FunnelChart`.\n   */\n  width: number;\n\n  /**\n   * Event for when a segment is clicked.\n   */\n  onSegmentClick?: (e: ClickEvent) => void;\n}\n\nexport const FunnelSeries: React.FC<Partial<FunnelSeriesProps>> = ({\n  data,\n  id,\n  arc,\n  axis,\n  height,\n  width,\n  onSegmentClick\n}) => {\n  // Calculate the funnel data on mount and when data changes\n  const getScales = useCallback(\n    (height: number, width: number) => {\n      const yScale = scaleLinear()\n        .domain([-max(data, ({ data }) => data), max(data, ({ data }) => data)])\n        .nice()\n        .range([height, 0]);\n\n      const xScale = scaleLinear().domain([0, data.length]).range([0, width]);\n\n      const transformedData = data.map((d, i) => ({\n        ...d,\n        key: d.key,\n        x: xScale(i),\n        i\n      }));\n\n      return {\n        data: transformedData,\n        yScale,\n        xScale\n      };\n    },\n    [data]\n  );\n\n  const { datas, halfOffset } = useMemo(() => {\n    // The 'layered' variant is actually just a series of funnel charts\n    // laid on top of each other to create the effect of a layered funnel.\n    if (arc.props.variant === 'layered') {\n      const offset = height / 4;\n      const halfOffset = offset / 2;\n\n      return {\n        halfOffset,\n        datas: [\n          { data, ...getScales(height, width) },\n          { data, ...getScales(height - offset, width) },\n          { data, ...getScales(height - offset * 2, width) }\n        ]\n      };\n    } else {\n      return {\n        halfOffset: 0,\n        datas: [{ data, ...getScales(height, width) }]\n      };\n    }\n  }, [data, arc, height, width, getScales]);\n\n  const handleSegmentClick = useCallback(\n    (e: MouseEvent) => {\n      if (onSegmentClick) {\n        const { xScale, data } = datas[0];\n        const { clientX, clientY, target } = e;\n        const position = getPositionForTarget({ target, clientX, clientY });\n        const value = getClosestContinousScalePoint({\n          pos: position.x,\n          scale: xScale,\n          data,\n          attr: 'i'\n        });\n\n        onSegmentClick({\n          value: { key: value.key, data: value.data },\n          nativeEvent: e\n        });\n      }\n    },\n    [datas, onSegmentClick]\n  );\n\n  return (\n    <>\n      {datas.map((d, i) => (\n        <g\n          key={i}\n          style={{ transform: `translate(0, ${i * halfOffset}px)` }}\n          onClick={handleSegmentClick}\n        >\n          <CloneElement<FunnelArcProps>\n            element={arc}\n            {...d}\n            id={`${id}-arc-${i}`}\n            index={i}\n          />\n        </g>\n      ))}\n      <CloneElement<FunnelAxisProps>\n        element={axis}\n        data={data}\n        xScale={datas[0].xScale}\n        yScale={datas[0].yScale}\n      />\n    </>\n  );\n};\n\nFunnelSeries.defaultProps = {\n  arc: <FunnelArc />,\n  axis: <FunnelAxis />\n};\n","import React, { FC, ReactElement, useCallback } from 'react';\nimport { CloneElement, useId } from 'reablocks';\nimport {\n  ChartContainer,\n  ChartContainerChildProps,\n  ChartProps\n} from '../common/containers';\nimport { ChartShallowDataShape } from '../common/data';\nimport { FunnelSeries, FunnelSeriesProps } from './FunnelSeries/FunnelSeries';\n\nexport interface FunnelChartProps extends ChartProps {\n  /**\n   * Chart shape used to render the funnel.\n   */\n  data: ChartShallowDataShape[];\n\n  /**\n   * The series component that renders the funnel components.\n   */\n  series: ReactElement<FunnelSeriesProps, typeof FunnelSeries>;\n}\n\nexport const FunnelChart: FC<Partial<FunnelChartProps>> = ({\n  data,\n  width,\n  margins,\n  height,\n  className,\n  containerClassName,\n  series,\n  ...rest\n}) => {\n  const id = useId(rest.id);\n\n  const renderChart = useCallback(\n    ({ id, chartWidth, chartHeight, chartSized }: ChartContainerChildProps) => {\n      if (!chartSized) {\n        return null;\n      }\n\n      return (\n        <CloneElement<FunnelSeriesProps>\n          element={series}\n          id={`funnel-series-${id}`}\n          data={data}\n          height={chartHeight}\n          width={chartWidth}\n        />\n      );\n    },\n    [data, series]\n  );\n\n  return (\n    <ChartContainer\n      id={id}\n      width={width}\n      height={height}\n      margins={margins}\n      containerClassName={containerClassName}\n      className={className}\n    >\n      {renderChart}\n    </ChartContainer>\n  );\n};\n\nFunnelChart.defaultProps = {\n  margins: 0,\n  series: <FunnelSeries />\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}