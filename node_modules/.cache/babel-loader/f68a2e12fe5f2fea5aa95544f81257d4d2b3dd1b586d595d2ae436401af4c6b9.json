{"ast":null,"code":"import { nelderMead, bisect, norm2, zeros, conjugateGradient, scale, zerosM } from 'fmin';\nconst SMALL$1 = 1e-10;\n\n/**\n * Returns the intersection area of a bunch of circles (where each circle\n * is an object having an x,y and radius property)\n * @param {ReadonlyArray<{x: number, y: number, radius: number}>} circles\n * @param {undefined | { area?: number, arcArea?: number, polygonArea?: number, arcs?: ReadonlyArray<{ circle: {x: number, y: number, radius: number}, width: number, p1: {x: number, y: number}, p2: {x: number, y: number} }>, innerPoints: ReadonlyArray<{\n    x: number;\n    y: number;\n    parentIndex: [number, number];\n}>, intersectionPoints: ReadonlyArray<{\n  x: number;\n  y: number;\n  parentIndex: [number, number];\n}> }} stats\n * @returns {number}\n */\nfunction intersectionArea(circles, stats) {\n  // get all the intersection points of the circles\n  const intersectionPoints = getIntersectionPoints(circles);\n\n  // filter out points that aren't included in all the circles\n  const innerPoints = intersectionPoints.filter(p => containedInCircles(p, circles));\n  let arcArea = 0;\n  let polygonArea = 0;\n  /** @type {{ circle: {x: number, y: number, radius: number}, width: number, p1: {x: number, y: number}, p2: {x: number, y: number} }[]} */\n  const arcs = [];\n\n  // if we have intersection points that are within all the circles,\n  // then figure out the area contained by them\n  if (innerPoints.length > 1) {\n    // sort the points by angle from the center of the polygon, which lets\n    // us just iterate over points to get the edges\n    const center = getCenter(innerPoints);\n    for (let i = 0; i < innerPoints.length; ++i) {\n      const p = innerPoints[i];\n      p.angle = Math.atan2(p.x - center.x, p.y - center.y);\n    }\n    innerPoints.sort((a, b) => b.angle - a.angle);\n\n    // iterate over all points, get arc between the points\n    // and update the areas\n    let p2 = innerPoints[innerPoints.length - 1];\n    for (let i = 0; i < innerPoints.length; ++i) {\n      const p1 = innerPoints[i];\n\n      // polygon area updates easily ...\n      polygonArea += (p2.x + p1.x) * (p1.y - p2.y);\n\n      // updating the arc area is a little more involved\n      const midPoint = {\n        x: (p1.x + p2.x) / 2,\n        y: (p1.y + p2.y) / 2\n      };\n      /** @types null | { circle: {x: number, y: number, radius: number}, width: number, p1: {x: number, y: number}, p2: {x: number, y: number} } */\n      let arc = null;\n      for (let j = 0; j < p1.parentIndex.length; ++j) {\n        if (p2.parentIndex.includes(p1.parentIndex[j])) {\n          // figure out the angle halfway between the two points\n          // on the current circle\n          const circle = circles[p1.parentIndex[j]];\n          const a1 = Math.atan2(p1.x - circle.x, p1.y - circle.y);\n          const a2 = Math.atan2(p2.x - circle.x, p2.y - circle.y);\n          let angleDiff = a2 - a1;\n          if (angleDiff < 0) {\n            angleDiff += 2 * Math.PI;\n          }\n\n          // and use that angle to figure out the width of the\n          // arc\n          const a = a2 - angleDiff / 2;\n          let width = distance(midPoint, {\n            x: circle.x + circle.radius * Math.sin(a),\n            y: circle.y + circle.radius * Math.cos(a)\n          });\n\n          // clamp the width to the largest is can actually be\n          // (sometimes slightly overflows because of FP errors)\n          if (width > circle.radius * 2) {\n            width = circle.radius * 2;\n          }\n\n          // pick the circle whose arc has the smallest width\n          if (arc == null || arc.width > width) {\n            arc = {\n              circle,\n              width,\n              p1,\n              p2,\n              large: width > circle.radius,\n              sweep: true\n            };\n          }\n        }\n      }\n      if (arc != null) {\n        arcs.push(arc);\n        arcArea += circleArea(arc.circle.radius, arc.width);\n        p2 = p1;\n      }\n    }\n  } else {\n    // no intersection points, is either disjoint - or is completely\n    // overlapped. figure out which by examining the smallest circle\n    let smallest = circles[0];\n    for (let i = 1; i < circles.length; ++i) {\n      if (circles[i].radius < smallest.radius) {\n        smallest = circles[i];\n      }\n    }\n\n    // make sure the smallest circle is completely contained in all\n    // the other circles\n    let disjoint = false;\n    for (let i = 0; i < circles.length; ++i) {\n      if (distance(circles[i], smallest) > Math.abs(smallest.radius - circles[i].radius)) {\n        disjoint = true;\n        break;\n      }\n    }\n    if (disjoint) {\n      arcArea = polygonArea = 0;\n    } else {\n      arcArea = smallest.radius * smallest.radius * Math.PI;\n      arcs.push({\n        circle: smallest,\n        p1: {\n          x: smallest.x,\n          y: smallest.y + smallest.radius\n        },\n        p2: {\n          x: smallest.x - SMALL$1,\n          y: smallest.y + smallest.radius\n        },\n        width: smallest.radius * 2,\n        large: true,\n        sweep: true\n      });\n    }\n  }\n  polygonArea /= 2;\n  if (stats) {\n    stats.area = arcArea + polygonArea;\n    stats.arcArea = arcArea;\n    stats.polygonArea = polygonArea;\n    stats.arcs = arcs;\n    stats.innerPoints = innerPoints;\n    stats.intersectionPoints = intersectionPoints;\n  }\n  return arcArea + polygonArea;\n}\n\n/**\n * returns whether a point is contained by all of a list of circles\n * @param {{x: number, y: number}} point\n * @param {ReadonlyArray<{x: number, y: number, radius: number}>} circles\n * @returns {boolean}\n */\nfunction containedInCircles(point, circles) {\n  return circles.every(circle => distance(point, circle) < circle.radius + SMALL$1);\n}\n\n/**\n * Gets all intersection points between a bunch of circles\n * @param {ReadonlyArray<{x: number, y: number, radius: number}>} circles\n * @returns {ReadonlyArray<{x: number, y: number, parentIndex: [number, number]}>}\n */\nfunction getIntersectionPoints(circles) {\n  /** @type {{x: number, y: number, parentIndex: [number, number]}[]} */\n  const ret = [];\n  for (let i = 0; i < circles.length; ++i) {\n    for (let j = i + 1; j < circles.length; ++j) {\n      const intersect = circleCircleIntersection(circles[i], circles[j]);\n      for (const p of intersect) {\n        p.parentIndex = [i, j];\n        ret.push(p);\n      }\n    }\n  }\n  return ret;\n}\n\n/**\n * Circular segment area calculation. See http://mathworld.wolfram.com/CircularSegment.html\n * @param {number} r\n * @param {number} width\n * @returns {number}\n **/\nfunction circleArea(r, width) {\n  return r * r * Math.acos(1 - width / r) - (r - width) * Math.sqrt(width * (2 * r - width));\n}\n\n/**\n * euclidean distance between two points\n * @param {{x: number, y: number}} p1\n * @param {{x: number, y: number}} p2\n * @returns {number}\n **/\nfunction distance(p1, p2) {\n  return Math.sqrt((p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y) * (p1.y - p2.y));\n}\n\n/**\n * Returns the overlap area of two circles of radius r1 and r2 - that\n * have their centers separated by distance d. Simpler faster\n * circle intersection for only two circles\n * @param {number} r1\n * @param {number} r2\n * @param {number} d\n * @returns {number}\n */\nfunction circleOverlap(r1, r2, d) {\n  // no overlap\n  if (d >= r1 + r2) {\n    return 0;\n  }\n\n  // completely overlapped\n  if (d <= Math.abs(r1 - r2)) {\n    return Math.PI * Math.min(r1, r2) * Math.min(r1, r2);\n  }\n  const w1 = r1 - (d * d - r2 * r2 + r1 * r1) / (2 * d);\n  const w2 = r2 - (d * d - r1 * r1 + r2 * r2) / (2 * d);\n  return circleArea(r1, w1) + circleArea(r2, w2);\n}\n\n/**\n * Given two circles (containing a x/y/radius attributes),\n * returns the intersecting points if possible\n * note: doesn't handle cases where there are infinitely many\n * intersection points (circles are equivalent):, or only one intersection point\n * @param {{x: number, y: number, radius: number}} p1\n * @param {{x: number, y: number, radius: number}} p2\n * @returns {ReadonlyArray<{x: number, y: number}>}\n **/\nfunction circleCircleIntersection(p1, p2) {\n  const d = distance(p1, p2);\n  const r1 = p1.radius;\n  const r2 = p2.radius;\n\n  // if to far away, or self contained - can't be done\n  if (d >= r1 + r2 || d <= Math.abs(r1 - r2)) {\n    return [];\n  }\n  const a = (r1 * r1 - r2 * r2 + d * d) / (2 * d);\n  const h = Math.sqrt(r1 * r1 - a * a);\n  const x0 = p1.x + a * (p2.x - p1.x) / d;\n  const y0 = p1.y + a * (p2.y - p1.y) / d;\n  const rx = -(p2.y - p1.y) * (h / d);\n  const ry = -(p2.x - p1.x) * (h / d);\n  return [{\n    x: x0 + rx,\n    y: y0 - ry\n  }, {\n    x: x0 - rx,\n    y: y0 + ry\n  }];\n}\n\n/**\n * Returns the center of a bunch of points\n * @param {ReadonlyArray<{x: number, y: number}>} points\n * @returns {{x: number, y: number}}\n */\nfunction getCenter(points) {\n  const center = {\n    x: 0,\n    y: 0\n  };\n  for (const point of points) {\n    center.x += point.x;\n    center.y += point.y;\n  }\n  center.x /= points.length;\n  center.y /= points.length;\n  return center;\n}\n\n/**\n * given a list of set objects, and their corresponding overlaps\n * updates the (x, y, radius) attribute on each set such that their positions\n * roughly correspond to the desired overlaps\n * @param {readonly {sets: readonly string[]; size: number; weight?: number}[]} sets\n * @returns {{[setid: string]: {x: number, y: number, radius: number}}}\n */\nfunction venn(sets) {\n  let parameters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  parameters.maxIterations = parameters.maxIterations || 500;\n  const initialLayout = parameters.initialLayout || bestInitialLayout;\n  const loss = parameters.lossFunction || lossFunction;\n\n  // add in missing pairwise areas as having 0 size\n  const areas = addMissingAreas(sets, parameters);\n\n  // initial layout is done greedily\n  const circles = initialLayout(areas, parameters);\n\n  // transform x/y coordinates to a vector to optimize\n  const setids = Object.keys(circles);\n  /** @type {number[]} */\n  const initial = [];\n  for (const setid of setids) {\n    initial.push(circles[setid].x);\n    initial.push(circles[setid].y);\n  }\n\n  // optimize initial layout from our loss function\n  const solution = nelderMead(values => {\n    const current = {};\n    for (let i = 0; i < setids.length; ++i) {\n      const setid = setids[i];\n      current[setid] = {\n        x: values[2 * i],\n        y: values[2 * i + 1],\n        radius: circles[setid].radius\n        // size : circles[setid].size\n      };\n    }\n    return loss(current, areas);\n  }, initial, parameters);\n\n  // transform solution vector back to x/y points\n  const positions = solution.x;\n  for (let i = 0; i < setids.length; ++i) {\n    const setid = setids[i];\n    circles[setid].x = positions[2 * i];\n    circles[setid].y = positions[2 * i + 1];\n  }\n  return circles;\n}\nconst SMALL = 1e-10;\n\n/**\n * Returns the distance necessary for two circles of radius r1 + r2 to\n * have the overlap area 'overlap'\n * @param {number} r1\n * @param {number} r2\n * @param {number} overlap\n * @returns {number}\n */\nfunction distanceFromIntersectArea(r1, r2, overlap) {\n  // handle complete overlapped circles\n  if (Math.min(r1, r2) * Math.min(r1, r2) * Math.PI <= overlap + SMALL) {\n    return Math.abs(r1 - r2);\n  }\n  return bisect(distance => circleOverlap(r1, r2, distance) - overlap, 0, r1 + r2);\n}\n\n/**\n * Missing pair-wise intersection area data can cause problems:\n * treating as an unknown means that sets will be laid out overlapping,\n * which isn't what people expect. To reflect that we want disjoint sets\n * here, set the overlap to 0 for all missing pairwise set intersections\n * @param {ReadonlyArray<{sets: ReadonlyArray<string>, size: number}>} areas\n * @returns {ReadonlyArray<{sets: ReadonlyArray<string>, size: number}>}\n */\nfunction addMissingAreas(areas) {\n  let parameters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const distinct = parameters.distinct;\n  const r = areas.map(s => Object.assign({}, s));\n  function toKey(arr) {\n    return arr.join(';');\n  }\n  if (distinct) {\n    // recreate the full ones by adding things up but just to level two since the rest doesn't matter\n    /** @types Map<string, number> */\n    const count = new Map();\n    for (const area of r) {\n      for (let i = 0; i < area.sets.length; i++) {\n        const si = String(area.sets[i]);\n        count.set(si, area.size + (count.get(si) || 0));\n        for (let j = i + 1; j < area.sets.length; j++) {\n          const sj = String(area.sets[j]);\n          const k1 = \"\".concat(si, \";\").concat(sj);\n          const k2 = \"\".concat(sj, \";\").concat(si);\n          count.set(k1, area.size + (count.get(k1) || 0));\n          count.set(k2, area.size + (count.get(k2) || 0));\n        }\n      }\n    }\n    for (const area of r) {\n      if (area.sets.length < 3) {\n        area.size = count.get(toKey(area.sets));\n      }\n    }\n  }\n\n  // two circle intersections that aren't defined\n  const ids = [];\n\n  /** @type {Set<string>} */\n  const pairs = new Set();\n  for (const area of r) {\n    if (area.sets.length === 1) {\n      ids.push(area.sets[0]);\n    } else if (area.sets.length === 2) {\n      const a = area.sets[0];\n      const b = area.sets[1];\n      pairs.add(toKey(area.sets));\n      pairs.add(toKey([b, a]));\n    }\n  }\n  ids.sort((a, b) => a === b ? 0 : a < b ? -1 : +1);\n  for (let i = 0; i < ids.length; ++i) {\n    const a = ids[i];\n    for (let j = i + 1; j < ids.length; ++j) {\n      const b = ids[j];\n      if (!pairs.has(toKey([a, b]))) {\n        r.push({\n          sets: [a, b],\n          size: 0\n        });\n      }\n    }\n  }\n  return r;\n}\n\n/**\n * Returns two matrices, one of the euclidean distances between the sets\n * and the other indicating if there are subset or disjoint set relationships\n * @param {ReadonlyArray<{sets: ReadonlyArray<number>}>} areas\n * @param {ReadonlyArray<{size: number}>} sets\n * @param {ReadonlyArray<number>} setids\n */\nfunction getDistanceMatrices(areas, sets, setids) {\n  // initialize an empty distance matrix between all the points\n  /**\n   * @type {number[][]}\n   */\n  const distances = zerosM(sets.length, sets.length);\n  /**\n   * @type {number[][]}\n   */\n  const constraints = zerosM(sets.length, sets.length);\n\n  // compute required distances between all the sets such that\n  // the areas match\n  areas.filter(x => x.sets.length === 2).forEach(current => {\n    const left = setids[current.sets[0]];\n    const right = setids[current.sets[1]];\n    const r1 = Math.sqrt(sets[left].size / Math.PI);\n    const r2 = Math.sqrt(sets[right].size / Math.PI);\n    const distance = distanceFromIntersectArea(r1, r2, current.size);\n    distances[left][right] = distances[right][left] = distance;\n\n    // also update constraints to indicate if its a subset or disjoint\n    // relationship\n    let c = 0;\n    if (current.size + 1e-10 >= Math.min(sets[left].size, sets[right].size)) {\n      c = 1;\n    } else if (current.size <= 1e-10) {\n      c = -1;\n    }\n    constraints[left][right] = constraints[right][left] = c;\n  });\n  return {\n    distances,\n    constraints\n  };\n}\n\n/// computes the gradient and loss simultaneously for our constrained MDS optimizer\nfunction constrainedMDSGradient(x, fxprime, distances, constraints) {\n  for (let i = 0; i < fxprime.length; ++i) {\n    fxprime[i] = 0;\n  }\n  let loss = 0;\n  for (let i = 0; i < distances.length; ++i) {\n    const xi = x[2 * i];\n    const yi = x[2 * i + 1];\n    for (let j = i + 1; j < distances.length; ++j) {\n      const xj = x[2 * j];\n      const yj = x[2 * j + 1];\n      const dij = distances[i][j];\n      const constraint = constraints[i][j];\n      const squaredDistance = (xj - xi) * (xj - xi) + (yj - yi) * (yj - yi);\n      const distance = Math.sqrt(squaredDistance);\n      const delta = squaredDistance - dij * dij;\n      if (constraint > 0 && distance <= dij || constraint < 0 && distance >= dij) {\n        continue;\n      }\n      loss += 2 * delta * delta;\n      fxprime[2 * i] += 4 * delta * (xi - xj);\n      fxprime[2 * i + 1] += 4 * delta * (yi - yj);\n      fxprime[2 * j] += 4 * delta * (xj - xi);\n      fxprime[2 * j + 1] += 4 * delta * (yj - yi);\n    }\n  }\n  return loss;\n}\n\n/**\n * takes the best working variant of either constrained MDS or greedy\n * @param {ReadonlyArray<{sets: ReadonlyArray<string>, size: number}>} areas\n */\nfunction bestInitialLayout(areas) {\n  let params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  let initial = greedyLayout(areas, params);\n  const loss = params.lossFunction || lossFunction;\n\n  // greedylayout is sufficient for all 2/3 circle cases. try out\n  // constrained MDS for higher order problems, take its output\n  // if it outperforms. (greedy is aesthetically better on 2/3 circles\n  // since it axis aligns)\n  if (areas.length >= 8) {\n    const constrained = constrainedMDSLayout(areas, params);\n    const constrainedLoss = loss(constrained, areas);\n    const greedyLoss = loss(initial, areas);\n    if (constrainedLoss + 1e-8 < greedyLoss) {\n      initial = constrained;\n    }\n  }\n  return initial;\n}\n\n/**\n * use the constrained MDS variant to generate an initial layout\n * @param {ReadonlyArray<{sets: ReadonlyArray<string>, size: number}>} areas\n * @returns {{[key: string]: {x: number, y: number, radius: number}}}\n */\nfunction constrainedMDSLayout(areas) {\n  let params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const restarts = params.restarts || 10;\n\n  // bidirectionally map sets to a rowid  (so we can create a matrix)\n  const sets = [];\n  const setids = {};\n  for (const area of areas) {\n    if (area.sets.length === 1) {\n      setids[area.sets[0]] = sets.length;\n      sets.push(area);\n    }\n  }\n  let {\n    distances,\n    constraints\n  } = getDistanceMatrices(areas, sets, setids);\n\n  // keep distances bounded, things get messed up otherwise.\n  // TODO: proper preconditioner?\n  const norm = norm2(distances.map(norm2)) / distances.length;\n  distances = distances.map(row => row.map(value => value / norm));\n  const obj = (x, fxprime) => constrainedMDSGradient(x, fxprime, distances, constraints);\n  let best = null;\n  for (let i = 0; i < restarts; ++i) {\n    const initial = zeros(distances.length * 2).map(Math.random);\n    const current = conjugateGradient(obj, initial, params);\n    if (!best || current.fx < best.fx) {\n      best = current;\n    }\n  }\n  const positions = best.x;\n\n  // translate rows back to (x,y,radius) coordinates\n  /** @type {{[key: string]: {x: number, y: number, radius: number}}} */\n  const circles = {};\n  for (let i = 0; i < sets.length; ++i) {\n    const set = sets[i];\n    circles[set.sets[0]] = {\n      x: positions[2 * i] * norm,\n      y: positions[2 * i + 1] * norm,\n      radius: Math.sqrt(set.size / Math.PI)\n    };\n  }\n  if (params.history) {\n    for (const h of params.history) {\n      scale(h.x, norm);\n    }\n  }\n  return circles;\n}\n\n/**\n * Lays out a Venn diagram greedily, going from most overlapped sets to\n * least overlapped, attempting to position each new set such that the\n * overlapping areas to already positioned sets are basically right\n * @param {ReadonlyArray<{size: number, sets: ReadonlyArray<string>}>} areas\n * @return {{[key: string]: {x: number, y: number, radius: number}}}\n */\nfunction greedyLayout(areas, params) {\n  const loss = params && params.lossFunction ? params.lossFunction : lossFunction;\n\n  // define a circle for each set\n  /** @type {{[key: string]: {x: number, y: number, radius: number}}} */\n  const circles = {};\n  /** @type {{[key: string]: {set: string, size: number, weight: number}[]}} */\n  const setOverlaps = {};\n  for (const area of areas) {\n    if (area.sets.length === 1) {\n      const set = area.sets[0];\n      circles[set] = {\n        x: 1e10,\n        y: 1e10,\n        rowid: circles.length,\n        size: area.size,\n        radius: Math.sqrt(area.size / Math.PI)\n      };\n      setOverlaps[set] = [];\n    }\n  }\n  areas = areas.filter(a => a.sets.length === 2);\n\n  // map each set to a list of all the other sets that overlap it\n  for (const current of areas) {\n    let weight = current.weight != null ? current.weight : 1.0;\n    const left = current.sets[0];\n    const right = current.sets[1];\n\n    // completely overlapped circles shouldn't be positioned early here\n    if (current.size + SMALL >= Math.min(circles[left].size, circles[right].size)) {\n      weight = 0;\n    }\n    setOverlaps[left].push({\n      set: right,\n      size: current.size,\n      weight\n    });\n    setOverlaps[right].push({\n      set: left,\n      size: current.size,\n      weight\n    });\n  }\n\n  // get list of most overlapped sets\n  const mostOverlapped = [];\n  Object.keys(setOverlaps).forEach(set => {\n    let size = 0;\n    for (let i = 0; i < setOverlaps[set].length; ++i) {\n      size += setOverlaps[set][i].size * setOverlaps[set][i].weight;\n    }\n    mostOverlapped.push({\n      set,\n      size\n    });\n  });\n\n  // sort by size desc\n  function sortOrder(a, b) {\n    return b.size - a.size;\n  }\n  mostOverlapped.sort(sortOrder);\n\n  // keep track of what sets have been laid out\n  const positioned = {};\n  function isPositioned(element) {\n    return element.set in positioned;\n  }\n\n  /**\n   * adds a point to the output\n   * @param {{x: number, y: number}} point\n   * @param {number} index\n   */\n  function positionSet(point, index) {\n    circles[index].x = point.x;\n    circles[index].y = point.y;\n    positioned[index] = true;\n  }\n\n  // add most overlapped set at (0,0)\n  positionSet({\n    x: 0,\n    y: 0\n  }, mostOverlapped[0].set);\n\n  // get distances between all points. TODO, necessary?\n  // answer: probably not\n  // var distances = venn.getDistanceMatrices(circles, areas).distances;\n  for (let i = 1; i < mostOverlapped.length; ++i) {\n    const setIndex = mostOverlapped[i].set;\n    const overlap = setOverlaps[setIndex].filter(isPositioned);\n    const set = circles[setIndex];\n    overlap.sort(sortOrder);\n    if (overlap.length === 0) {\n      // this shouldn't happen anymore with addMissingAreas\n      throw 'ERROR: missing pairwise overlap information';\n    }\n\n    /** @type {{x: number, y: number}[]} */\n    const points = [];\n    for (var j = 0; j < overlap.length; ++j) {\n      // get appropriate distance from most overlapped already added set\n      const p1 = circles[overlap[j].set];\n      const d1 = distanceFromIntersectArea(set.radius, p1.radius, overlap[j].size);\n\n      // sample positions at 90 degrees for maximum aesthetics\n      points.push({\n        x: p1.x + d1,\n        y: p1.y\n      });\n      points.push({\n        x: p1.x - d1,\n        y: p1.y\n      });\n      points.push({\n        y: p1.y + d1,\n        x: p1.x\n      });\n      points.push({\n        y: p1.y - d1,\n        x: p1.x\n      });\n\n      // if we have at least 2 overlaps, then figure out where the\n      // set should be positioned analytically and try those too\n      for (let k = j + 1; k < overlap.length; ++k) {\n        const p2 = circles[overlap[k].set];\n        const d2 = distanceFromIntersectArea(set.radius, p2.radius, overlap[k].size);\n        const extraPoints = circleCircleIntersection({\n          x: p1.x,\n          y: p1.y,\n          radius: d1\n        }, {\n          x: p2.x,\n          y: p2.y,\n          radius: d2\n        });\n        points.push(...extraPoints);\n      }\n    }\n\n    // we have some candidate positions for the set, examine loss\n    // at each position to figure out where to put it at\n    let bestLoss = 1e50;\n    let bestPoint = points[0];\n    for (const point of points) {\n      circles[setIndex].x = point.x;\n      circles[setIndex].y = point.y;\n      const localLoss = loss(circles, areas);\n      if (localLoss < bestLoss) {\n        bestLoss = localLoss;\n        bestPoint = point;\n      }\n    }\n    positionSet(bestPoint, setIndex);\n  }\n  return circles;\n}\n\n/**\n * Given a bunch of sets, and the desired overlaps between these sets - computes\n * the distance from the actual overlaps to the desired overlaps. Note that\n * this method ignores overlaps of more than 2 circles\n * @param {{[key: string]: <{x: number, y: number, radius: number}>}} circles\n * @param {ReadonlyArray<{size: number, sets: ReadonlyArray<string>, weight?: number}>} overlaps\n * @returns {number}\n */\nfunction lossFunction(circles, overlaps) {\n  let output = 0;\n  for (const area of overlaps) {\n    if (area.sets.length === 1) {\n      continue;\n    }\n    /** @type {number} */\n    let overlap;\n    if (area.sets.length === 2) {\n      const left = circles[area.sets[0]];\n      const right = circles[area.sets[1]];\n      overlap = circleOverlap(left.radius, right.radius, distance(left, right));\n    } else {\n      overlap = intersectionArea(area.sets.map(d => circles[d]));\n    }\n    const weight = area.weight != null ? area.weight : 1.0;\n    output += weight * (overlap - area.size) * (overlap - area.size);\n  }\n  return output;\n}\nfunction logRatioLossFunction(circles, overlaps) {\n  let output = 0;\n  for (const area of overlaps) {\n    if (area.sets.length === 1) {\n      continue;\n    }\n    /** @type {number} */\n    let overlap;\n    if (area.sets.length === 2) {\n      const left = circles[area.sets[0]];\n      const right = circles[area.sets[1]];\n      overlap = circleOverlap(left.radius, right.radius, distance(left, right));\n    } else {\n      overlap = intersectionArea(area.sets.map(d => circles[d]));\n    }\n    const weight = area.weight != null ? area.weight : 1.0;\n    const differenceFromIdeal = Math.log((overlap + 1) / (area.size + 1));\n    output += weight * differenceFromIdeal * differenceFromIdeal;\n  }\n  return output;\n}\n\n/**\n * orientates a bunch of circles to point in orientation\n * @param {{x :number, y: number, radius: number}[]} circles\n * @param {number | undefined} orientation\n * @param {((a: {x :number, y: number, radius: number}, b: {x :number, y: number, radius: number}) => number) | undefined} orientationOrder\n */\nfunction orientateCircles(circles, orientation, orientationOrder) {\n  if (orientationOrder == null) {\n    circles.sort((a, b) => b.radius - a.radius);\n  } else {\n    circles.sort(orientationOrder);\n  }\n\n  // shift circles so largest circle is at (0, 0)\n  if (circles.length > 0) {\n    const largestX = circles[0].x;\n    const largestY = circles[0].y;\n    for (const circle of circles) {\n      circle.x -= largestX;\n      circle.y -= largestY;\n    }\n  }\n  if (circles.length === 2) {\n    // if the second circle is a subset of the first, arrange so that\n    // it is off to one side. hack for https://github.com/benfred/venn.js/issues/120\n    const dist = distance(circles[0], circles[1]);\n    if (dist < Math.abs(circles[1].radius - circles[0].radius)) {\n      circles[1].x = circles[0].x + circles[0].radius - circles[1].radius - 1e-10;\n      circles[1].y = circles[0].y;\n    }\n  }\n\n  // rotate circles so that second largest is at an angle of 'orientation'\n  // from largest\n  if (circles.length > 1) {\n    const rotation = Math.atan2(circles[1].x, circles[1].y) - orientation;\n    const c = Math.cos(rotation);\n    const s = Math.sin(rotation);\n    for (const circle of circles) {\n      const x = circle.x;\n      const y = circle.y;\n      circle.x = c * x - s * y;\n      circle.y = s * x + c * y;\n    }\n  }\n\n  // mirror solution if third solution is above plane specified by\n  // first two circles\n  if (circles.length > 2) {\n    let angle = Math.atan2(circles[2].x, circles[2].y) - orientation;\n    while (angle < 0) {\n      angle += 2 * Math.PI;\n    }\n    while (angle > 2 * Math.PI) {\n      angle -= 2 * Math.PI;\n    }\n    if (angle > Math.PI) {\n      const slope = circles[1].y / (1e-10 + circles[1].x);\n      for (const circle of circles) {\n        var d = (circle.x + slope * circle.y) / (1 + slope * slope);\n        circle.x = 2 * d - circle.x;\n        circle.y = 2 * d * slope - circle.y;\n      }\n    }\n  }\n}\n\n/**\n *\n * @param {ReadonlyArray<{x: number, y: number, radius: number}>} circles\n * @returns {{x: number, y: number, radius: number}[][]}\n */\nfunction disjointCluster(circles) {\n  // union-find clustering to get disjoint sets\n  circles.forEach(circle => {\n    circle.parent = circle;\n  });\n\n  // path compression step in union find\n  function find(circle) {\n    if (circle.parent !== circle) {\n      circle.parent = find(circle.parent);\n    }\n    return circle.parent;\n  }\n  function union(x, y) {\n    const xRoot = find(x);\n    const yRoot = find(y);\n    xRoot.parent = yRoot;\n  }\n\n  // get the union of all overlapping sets\n  for (let i = 0; i < circles.length; ++i) {\n    for (let j = i + 1; j < circles.length; ++j) {\n      const maxDistance = circles[i].radius + circles[j].radius;\n      if (distance(circles[i], circles[j]) + 1e-10 < maxDistance) {\n        union(circles[j], circles[i]);\n      }\n    }\n  }\n\n  // find all the disjoint clusters and group them together\n  /** @type {Map<string, {x: number, y: number, radius: number}[]>} */\n  const disjointClusters = new Map();\n  for (let i = 0; i < circles.length; ++i) {\n    const setid = find(circles[i]).parent.setid;\n    if (!disjointClusters.has(setid)) {\n      disjointClusters.set(setid, []);\n    }\n    disjointClusters.get(setid).push(circles[i]);\n  }\n\n  // cleanup bookkeeping\n  circles.forEach(circle => {\n    delete circle.parent;\n  });\n\n  // return in more usable form\n  return Array.from(disjointClusters.values());\n}\n\n/**\n * @param {ReadonlyArray<{x :number, y: number, radius: number}>} circles\n * @returns {{xRange: [number, number], yRange: [number, number]}}\n */\nfunction getBoundingBox(circles) {\n  const minMax = d => {\n    const hi = circles.reduce((acc, c) => Math.max(acc, c[d] + c.radius), Number.NEGATIVE_INFINITY);\n    const lo = circles.reduce((acc, c) => Math.min(acc, c[d] - c.radius), Number.POSITIVE_INFINITY);\n    return {\n      max: hi,\n      min: lo\n    };\n  };\n  return {\n    xRange: minMax('x'),\n    yRange: minMax('y')\n  };\n}\n\n/**\n *\n * @param {{[setid: string]: {x: number, y: number, radius: number}}} solution\n * @param {undefined | number} orientation\n * @param {((a: {x :number, y: number, radius: number}, b: {x :number, y: number, radius: number}) => number) | undefined} orientationOrder\n * @returns {{[setid: string]: {x: number, y: number, radius: number}}}\n */\nfunction normalizeSolution(solution, orientation, orientationOrder) {\n  if (orientation == null) {\n    orientation = Math.PI / 2;\n  }\n\n  // work with a list instead of a dictionary, and take a copy so we\n  // don't mutate input\n  let circles = fromObjectNotation(solution).map(d => Object.assign({}, d));\n\n  // get all the disjoint clusters\n  const clusters = disjointCluster(circles);\n\n  // orientate all disjoint sets, get sizes\n  for (const cluster of clusters) {\n    orientateCircles(cluster, orientation, orientationOrder);\n    const bounds = getBoundingBox(cluster);\n    cluster.size = (bounds.xRange.max - bounds.xRange.min) * (bounds.yRange.max - bounds.yRange.min);\n    cluster.bounds = bounds;\n  }\n  clusters.sort((a, b) => b.size - a.size);\n\n  // orientate the largest at 0,0, and get the bounds\n  circles = clusters[0];\n  let returnBounds = circles.bounds;\n  const spacing = (returnBounds.xRange.max - returnBounds.xRange.min) / 50;\n\n  /**\n   * @param {ReadonlyArray<{x: number, y: number, radius: number, setid: string}>} cluster\n   * @param {boolean} right\n   * @param {boolean} bottom\n   */\n  function addCluster(cluster, right, bottom) {\n    if (!cluster) {\n      return;\n    }\n    const bounds = cluster.bounds;\n    /** @type {number} */\n    let xOffset;\n    /** @type {number} */\n    let yOffset;\n    if (right) {\n      xOffset = returnBounds.xRange.max - bounds.xRange.min + spacing;\n    } else {\n      xOffset = returnBounds.xRange.max - bounds.xRange.max;\n      const centreing = (bounds.xRange.max - bounds.xRange.min) / 2 - (returnBounds.xRange.max - returnBounds.xRange.min) / 2;\n      if (centreing < 0) {\n        xOffset += centreing;\n      }\n    }\n    if (bottom) {\n      yOffset = returnBounds.yRange.max - bounds.yRange.min + spacing;\n    } else {\n      yOffset = returnBounds.yRange.max - bounds.yRange.max;\n      const centreing = (bounds.yRange.max - bounds.yRange.min) / 2 - (returnBounds.yRange.max - returnBounds.yRange.min) / 2;\n      if (centreing < 0) {\n        yOffset += centreing;\n      }\n    }\n    for (const c of cluster) {\n      c.x += xOffset;\n      c.y += yOffset;\n      circles.push(c);\n    }\n  }\n  let index = 1;\n  while (index < clusters.length) {\n    addCluster(clusters[index], true, false);\n    addCluster(clusters[index + 1], false, true);\n    addCluster(clusters[index + 2], true, true);\n    index += 3;\n\n    // have one cluster (in top left). lay out next three relative\n    // to it in a grid\n    returnBounds = getBoundingBox(circles);\n  }\n\n  // convert back to solution form\n  return toObjectNotation(circles);\n}\n\n/**\n * Scales a solution from venn.venn or venn.greedyLayout such that it fits in\n * a rectangle of width/height - with padding around the borders. also\n * centers the diagram in the available space at the same time.\n * If the scale parameter is not null, this automatic scaling is ignored in favor of this custom one\n * @param {{[setid: string]: {x: number, y: number, radius: number}}} solution\n * @param {number} width\n * @param {number} height\n * @param {number} padding\n * @param {boolean} scaleToFit\n * @returns {{[setid: string]: {x: number, y: number, radius: number}}}\n */\nfunction scaleSolution(solution, width, height, padding, scaleToFit) {\n  const circles = fromObjectNotation(solution);\n  width -= 2 * padding;\n  height -= 2 * padding;\n  const {\n    xRange,\n    yRange\n  } = getBoundingBox(circles);\n  if (xRange.max === xRange.min || yRange.max === yRange.min) {\n    console.log('not scaling solution: zero size detected');\n    return solution;\n  }\n\n  /** @type {number} */\n  let xScaling;\n  /** @type {number} */\n  let yScaling;\n  if (scaleToFit) {\n    const toScaleDiameter = Math.sqrt(scaleToFit / Math.PI) * 2;\n    xScaling = width / toScaleDiameter;\n    yScaling = height / toScaleDiameter;\n  } else {\n    xScaling = width / (xRange.max - xRange.min);\n    yScaling = height / (yRange.max - yRange.min);\n  }\n  const scaling = Math.min(yScaling, xScaling);\n  // while we're at it, center the diagram too\n  const xOffset = (width - (xRange.max - xRange.min) * scaling) / 2;\n  const yOffset = (height - (yRange.max - yRange.min) * scaling) / 2;\n  return toObjectNotation(circles.map(circle => ({\n    radius: scaling * circle.radius,\n    x: padding + xOffset + (circle.x - xRange.min) * scaling,\n    y: padding + yOffset + (circle.y - yRange.min) * scaling,\n    setid: circle.setid\n  })));\n}\n\n/**\n * @param {readonly {x: number, y: number, radius: number, setid: string}[]} circles\n * @returns {{[setid: string]: {x: number, y: number, radius: number, setid: string}}}\n */\nfunction toObjectNotation(circles) {\n  /** @type {{[setid: string]: {x: number, y: number, radius: number, setid: string}}} */\n  const r = {};\n  for (const circle of circles) {\n    r[circle.setid] = circle;\n  }\n  return r;\n}\n/**\n * @param {{[setid: string]: {x: number, y: number, radius: number}}} solution\n * @returns {{x: number, y: number, radius: number, setid: string}[]}}\n */\nfunction fromObjectNotation(solution) {\n  const setids = Object.keys(solution);\n  return setids.map(id => Object.assign(solution[id], {\n    setid: id\n  }));\n}\n\n/*global console:true*/\n\n/**\n * VennDiagram includes an optional `options` parameter containing the following option(s):\n *\n * `colourScheme: Array<String>`\n * A list of color values to be applied when coloring diagram circles.\n *\n * `symmetricalTextCentre: Boolean`\n * Whether to symmetrically center each circle's text horizontally and vertically.\n * Defaults to `false`.\n *\n * `textFill: String`\n * The color to be applied to the text within each circle.\n *\n * @param {object} options\n */\nfunction VennDiagram() {\n  let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  let useViewBox = false,\n    width = 600,\n    height = 350,\n    padding = 15,\n    duration = 1000,\n    orientation = Math.PI / 2,\n    normalize = true,\n    scaleToFit = null,\n    wrap = true,\n    styled = true,\n    fontSize = null,\n    orientationOrder = null,\n    distinct = false,\n    round = null,\n    symmetricalTextCentre = options && options.symmetricalTextCentre ? options.symmetricalTextCentre : false,\n    // mimic the behaviour of d3.scale.category10 from the previous\n    // version of d3\n    colourMap = {},\n    // so this is the same as d3.schemeCategory10, which is only defined in d3 4.0\n    // since we can support older versions of d3 as long as we don't force this,\n    // I'm hackily redefining below. TODO: remove this and change to d3.schemeCategory10\n    colourScheme = options && options.colourScheme ? options.colourScheme : options && options.colorScheme ? options.colorScheme : ['#1f77b4', '#ff7f0e', '#2ca02c', '#d62728', '#9467bd', '#8c564b', '#e377c2', '#7f7f7f', '#bcbd22', '#17becf'],\n    colourIndex = 0,\n    colours = function (key) {\n      if (key in colourMap) {\n        return colourMap[key];\n      }\n      var ret = colourMap[key] = colourScheme[colourIndex];\n      colourIndex += 1;\n      if (colourIndex >= colourScheme.length) {\n        colourIndex = 0;\n      }\n      return ret;\n    },\n    layoutFunction = venn,\n    loss = lossFunction;\n  function chart(selection) {\n    let data = selection.datum();\n\n    // handle 0-sized sets by removing from input\n    const toRemove = new Set();\n    data.forEach(datum => {\n      if (datum.size == 0 && datum.sets.length == 1) {\n        toRemove.add(datum.sets[0]);\n      }\n    });\n    data = data.filter(datum => !datum.sets.some(set => toRemove.has(set)));\n    let circles = {};\n    let textCentres = {};\n    if (data.length > 0) {\n      let solution = layoutFunction(data, {\n        lossFunction: loss,\n        distinct\n      });\n      if (normalize) {\n        solution = normalizeSolution(solution, orientation, orientationOrder);\n      }\n      circles = scaleSolution(solution, width, height, padding, scaleToFit);\n      textCentres = computeTextCentres(circles, data, symmetricalTextCentre);\n    }\n\n    // Figure out the current label for each set. These can change\n    // and D3 won't necessarily update (fixes https://github.com/benfred/venn.js/issues/103)\n    const labels = {};\n    data.forEach(datum => {\n      if (datum.label) {\n        labels[datum.sets] = datum.label;\n      }\n    });\n    function label(d) {\n      if (d.sets in labels) {\n        return labels[d.sets];\n      }\n      if (d.sets.length == 1) {\n        return '' + d.sets[0];\n      }\n    }\n\n    // create svg if not already existing\n    selection.selectAll('svg').data([circles]).enter().append('svg');\n    const svg = selection.select('svg');\n    if (useViewBox) {\n      svg.attr('viewBox', \"0 0 \".concat(width, \" \").concat(height));\n    } else {\n      svg.attr('width', width).attr('height', height);\n    }\n\n    // to properly transition intersection areas, we need the\n    // previous circles locations. load from elements\n    const previous = {};\n    let hasPrevious = false;\n    svg.selectAll('.venn-area path').each(function (d) {\n      const path = this.getAttribute('d');\n      if (d.sets.length == 1 && path && !distinct) {\n        hasPrevious = true;\n        previous[d.sets[0]] = circleFromPath(path);\n      }\n    });\n    // interpolate intersection area paths between previous and\n    // current paths\n    function pathTween(d) {\n      return t => {\n        const c = d.sets.map(set => {\n          let start = previous[set];\n          let end = circles[set];\n          if (!start) {\n            start = {\n              x: width / 2,\n              y: height / 2,\n              radius: 1\n            };\n          }\n          if (!end) {\n            end = {\n              x: width / 2,\n              y: height / 2,\n              radius: 1\n            };\n          }\n          return {\n            x: start.x * (1 - t) + end.x * t,\n            y: start.y * (1 - t) + end.y * t,\n            radius: start.radius * (1 - t) + end.radius * t\n          };\n        });\n        return intersectionAreaPath(c, round);\n      };\n    }\n\n    // update data, joining on the set ids\n    const nodes = svg.selectAll('.venn-area').data(data, d => d.sets);\n\n    // create new nodes\n    const enter = nodes.enter().append('g').attr('class', d => \"venn-area venn-\".concat(d.sets.length == 1 ? 'circle' : 'intersection').concat(d.colour || d.color ? ' venn-coloured' : '')).attr('data-venn-sets', d => d.sets.join('_'));\n    const enterPath = enter.append('path');\n    const enterText = enter.append('text').attr('class', 'label').text(d => label(d)).attr('text-anchor', 'middle').attr('dy', '.35em').attr('x', width / 2).attr('y', height / 2);\n\n    // apply minimal style if wanted\n    if (styled) {\n      enterPath.style('fill-opacity', '0').filter(d => d.sets.length == 1).style('fill', d => d.colour ? d.colour : d.color ? d.color : colours(d.sets)).style('fill-opacity', '.25');\n      enterText.style('fill', d => {\n        if (d.colour || d.color) {\n          return '#FFF';\n        }\n        if (options.textFill) {\n          return options.textFill;\n        }\n        return d.sets.length == 1 ? colours(d.sets) : '#444';\n      });\n    }\n    function asTransition(s) {\n      if (typeof s.transition === 'function') {\n        return s.transition('venn').duration(duration);\n      }\n      return s;\n    }\n\n    // update existing, using pathTween if necessary\n    let update = selection;\n    if (hasPrevious && typeof update.transition === 'function') {\n      update = asTransition(selection);\n      update.selectAll('path').attrTween('d', pathTween);\n    } else {\n      update.selectAll('path').attr('d', d => intersectionAreaPath(d.sets.map(set => circles[set])), round);\n    }\n    const updateText = update.selectAll('text').filter(d => d.sets in textCentres).text(d => label(d)).attr('x', d => Math.floor(textCentres[d.sets].x)).attr('y', d => Math.floor(textCentres[d.sets].y));\n    if (wrap) {\n      if (hasPrevious) {\n        // d3 4.0 uses 'on' for events on transitions,\n        // but d3 3.0 used 'each' instead. switch appropriately\n        if ('on' in updateText) {\n          updateText.on('end', wrapText(circles, label));\n        } else {\n          updateText.each('end', wrapText(circles, label));\n        }\n      } else {\n        updateText.each(wrapText(circles, label));\n      }\n    }\n\n    // remove old\n    const exit = asTransition(nodes.exit()).remove();\n    if (typeof nodes.transition === 'function') {\n      exit.selectAll('path').attrTween('d', pathTween);\n    }\n    const exitText = exit.selectAll('text').attr('x', width / 2).attr('y', height / 2);\n\n    // if we've been passed a fontSize explicitly, use it to\n    // transition\n    if (fontSize !== null) {\n      enterText.style('font-size', '0px');\n      updateText.style('font-size', fontSize);\n      exitText.style('font-size', '0px');\n    }\n    return {\n      circles,\n      textCentres,\n      nodes,\n      enter,\n      update,\n      exit\n    };\n  }\n  chart.wrap = function (_) {\n    if (!arguments.length) return wrap;\n    wrap = _;\n    return chart;\n  };\n  chart.useViewBox = function () {\n    useViewBox = true;\n    return chart;\n  };\n  chart.width = function (_) {\n    if (!arguments.length) return width;\n    width = _;\n    return chart;\n  };\n  chart.height = function (_) {\n    if (!arguments.length) return height;\n    height = _;\n    return chart;\n  };\n  chart.padding = function (_) {\n    if (!arguments.length) return padding;\n    padding = _;\n    return chart;\n  };\n  chart.distinct = function (_) {\n    if (!arguments.length) return distinct;\n    distinct = _;\n    return chart;\n  };\n  chart.colours = function (_) {\n    if (!arguments.length) return colours;\n    colours = _;\n    return chart;\n  };\n  chart.colors = function (_) {\n    if (!arguments.length) return colors;\n    colours = _;\n    return chart;\n  };\n  chart.fontSize = function (_) {\n    if (!arguments.length) return fontSize;\n    fontSize = _;\n    return chart;\n  };\n  chart.round = function (_) {\n    if (!arguments.length) return round;\n    round = _;\n    return chart;\n  };\n  chart.duration = function (_) {\n    if (!arguments.length) return duration;\n    duration = _;\n    return chart;\n  };\n  chart.layoutFunction = function (_) {\n    if (!arguments.length) return layoutFunction;\n    layoutFunction = _;\n    return chart;\n  };\n  chart.normalize = function (_) {\n    if (!arguments.length) return normalize;\n    normalize = _;\n    return chart;\n  };\n  chart.scaleToFit = function (_) {\n    if (!arguments.length) return scaleToFit;\n    scaleToFit = _;\n    return chart;\n  };\n  chart.styled = function (_) {\n    if (!arguments.length) return styled;\n    styled = _;\n    return chart;\n  };\n  chart.orientation = function (_) {\n    if (!arguments.length) return orientation;\n    orientation = _;\n    return chart;\n  };\n  chart.orientationOrder = function (_) {\n    if (!arguments.length) return orientationOrder;\n    orientationOrder = _;\n    return chart;\n  };\n  chart.lossFunction = function (_) {\n    if (!arguments.length) return loss;\n    loss = _ === 'default' ? lossFunction : _ === 'logRatio' ? logRatioLossFunction : _;\n    return chart;\n  };\n  return chart;\n}\n\n// sometimes text doesn't fit inside the circle, if thats the case lets wrap\n// the text here such that it fits\n// todo: looks like this might be merged into d3 (\n// https://github.com/mbostock/d3/issues/1642),\n// also worth checking out is\n// http://engineering.findthebest.com/wrapping-axis-labels-in-d3-js/\n// this seems to be one of those things that should be easy but isn't\nfunction wrapText(circles, labeller) {\n  return function (data) {\n    const text = this;\n    const width = circles[data.sets[0]].radius || 50;\n    const label = labeller(data) || '';\n    const words = label.split(/\\s+/).reverse();\n    const maxLines = 3;\n    const minChars = (label.length + words.length) / maxLines;\n    let word = words.pop();\n    let line = [word];\n    let lineNumber = 0;\n    const lineHeight = 1.1; // ems\n    text.textContent = null; // clear\n    const tspans = [];\n    function append(word) {\n      const tspan = text.ownerDocument.createElementNS(text.namespaceURI, 'tspan');\n      tspan.textContent = word;\n      tspans.push(tspan);\n      text.append(tspan);\n      return tspan;\n    }\n    let tspan = append(word);\n    while (true) {\n      word = words.pop();\n      if (!word) {\n        break;\n      }\n      line.push(word);\n      const joined = line.join(' ');\n      tspan.textContent = joined;\n      if (joined.length > minChars && tspan.getComputedTextLength() > width) {\n        line.pop();\n        tspan.textContent = line.join(' ');\n        line = [word];\n        tspan = append(word);\n        lineNumber++;\n      }\n    }\n    const initial = 0.35 - lineNumber * lineHeight / 2;\n    const x = text.getAttribute('x');\n    const y = text.getAttribute('y');\n    tspans.forEach((t, i) => {\n      t.setAttribute('x', x);\n      t.setAttribute('y', y);\n      t.setAttribute('dy', \"\".concat(initial + i * lineHeight, \"em\"));\n    });\n  };\n}\n\n/**\n *\n * @param {{x: number, y: number}} current\n * @param {ReadonlyArray<{x: number, y: number}>} interior\n * @param {ReadonlyArray<{x: number, y: number}>} exterior\n * @returns {number}\n */\nfunction circleMargin(current, interior, exterior) {\n  let margin = interior[0].radius - distance(interior[0], current);\n  for (let i = 1; i < interior.length; ++i) {\n    const m = interior[i].radius - distance(interior[i], current);\n    if (m <= margin) {\n      margin = m;\n    }\n  }\n  for (let i = 0; i < exterior.length; ++i) {\n    const m = distance(exterior[i], current) - exterior[i].radius;\n    if (m <= margin) {\n      margin = m;\n    }\n  }\n  return margin;\n}\n\n/**\n * compute the center of some circles by maximizing the margin of\n * the center point relative to the circles (interior) after subtracting\n * nearby circles (exterior)\n * @param {readonly {x: number, y: number, radius: number}[]} interior\n * @param {readonly {x: number, y: number, radius: number}[]} exterior\n * @param {boolean} symmetricalTextCentre\n * @returns {{x:number, y: number}}\n */\nfunction computeTextCentre(interior, exterior, symmetricalTextCentre) {\n  // get an initial estimate by sampling around the interior circles\n  // and taking the point with the biggest margin\n  /** @type {{x: number, y: number}[]} */\n  const points = [];\n  for (const c of interior) {\n    points.push({\n      x: c.x,\n      y: c.y\n    });\n    points.push({\n      x: c.x + c.radius / 2,\n      y: c.y\n    });\n    points.push({\n      x: c.x - c.radius / 2,\n      y: c.y\n    });\n    points.push({\n      x: c.x,\n      y: c.y + c.radius / 2\n    });\n    points.push({\n      x: c.x,\n      y: c.y - c.radius / 2\n    });\n  }\n  let initial = points[0];\n  let margin = circleMargin(points[0], interior, exterior);\n  for (let i = 1; i < points.length; ++i) {\n    const m = circleMargin(points[i], interior, exterior);\n    if (m >= margin) {\n      initial = points[i];\n      margin = m;\n    }\n  }\n\n  // maximize the margin numerically\n  const solution = nelderMead(p => -1 * circleMargin({\n    x: p[0],\n    y: p[1]\n  }, interior, exterior), [initial.x, initial.y], {\n    maxIterations: 500,\n    minErrorDelta: 1e-10\n  }).x;\n  const ret = {\n    x: symmetricalTextCentre ? 0 : solution[0],\n    y: solution[1]\n  };\n\n  // check solution, fallback as needed (happens if fully overlapped\n  // etc)\n  let valid = true;\n  for (const i of interior) {\n    if (distance(ret, i) > i.radius) {\n      valid = false;\n      break;\n    }\n  }\n  for (const e of exterior) {\n    if (distance(ret, e) < e.radius) {\n      valid = false;\n      break;\n    }\n  }\n  if (valid) {\n    return ret;\n  }\n  if (interior.length == 1) {\n    return {\n      x: interior[0].x,\n      y: interior[0].y\n    };\n  }\n  const areaStats = {};\n  intersectionArea(interior, areaStats);\n  if (areaStats.arcs.length === 0) {\n    return {\n      x: 0,\n      y: -1000,\n      disjoint: true\n    };\n  }\n  if (areaStats.arcs.length == 1) {\n    return {\n      x: areaStats.arcs[0].circle.x,\n      y: areaStats.arcs[0].circle.y\n    };\n  }\n  if (exterior.length) {\n    // try again without other circles\n    return computeTextCentre(interior, []);\n  }\n  // take average of all the points in the intersection\n  // polygon. this should basically never happen\n  // and has some issues:\n  // https://github.com/benfred/venn.js/issues/48#issuecomment-146069777\n  return getCenter(areaStats.arcs.map(a => a.p1));\n}\n\n// given a dictionary of {setid : circle}, returns\n// a dictionary of setid to list of circles that completely overlap it\nfunction getOverlappingCircles(circles) {\n  const ret = {};\n  const circleids = Object.keys(circles);\n  for (const circleid of circleids) {\n    ret[circleid] = [];\n  }\n  for (let i = 0; i < circleids.length; i++) {\n    const ci = circleids[i];\n    const a = circles[ci];\n    for (let j = i + 1; j < circleids.length; ++j) {\n      const cj = circleids[j];\n      const b = circles[cj];\n      const d = distance(a, b);\n      if (d + b.radius <= a.radius + 1e-10) {\n        ret[cj].push(ci);\n      } else if (d + a.radius <= b.radius + 1e-10) {\n        ret[ci].push(cj);\n      }\n    }\n  }\n  return ret;\n}\nfunction computeTextCentres(circles, areas, symmetricalTextCentre) {\n  const ret = {};\n  const overlapped = getOverlappingCircles(circles);\n  for (let i = 0; i < areas.length; ++i) {\n    const area = areas[i].sets;\n    const areaids = {};\n    const exclude = {};\n    for (let j = 0; j < area.length; ++j) {\n      areaids[area[j]] = true;\n      const overlaps = overlapped[area[j]];\n      // keep track of any circles that overlap this area,\n      // and don't consider for purposes of computing the text\n      // centre\n      for (let k = 0; k < overlaps.length; ++k) {\n        exclude[overlaps[k]] = true;\n      }\n    }\n    const interior = [];\n    const exterior = [];\n    for (let setid in circles) {\n      if (setid in areaids) {\n        interior.push(circles[setid]);\n      } else if (!(setid in exclude)) {\n        exterior.push(circles[setid]);\n      }\n    }\n    const centre = computeTextCentre(interior, exterior, symmetricalTextCentre);\n    ret[area] = centre;\n    if (centre.disjoint && areas[i].size > 0) {\n      console.log('WARNING: area ' + area + ' not represented on screen');\n    }\n  }\n  return ret;\n}\n\n// sorts all areas in the venn diagram, so that\n// a particular area is on top (relativeTo) - and\n// all other areas are so that the smallest areas are on top\nfunction sortAreas(div, relativeTo) {\n  // figure out sets that are completely overlapped by relativeTo\n  const overlaps = getOverlappingCircles(div.selectAll('svg').datum());\n  const exclude = new Set();\n  for (const check of relativeTo.sets) {\n    for (let setid in overlaps) {\n      const overlap = overlaps[setid];\n      for (let j = 0; j < overlap.length; ++j) {\n        if (overlap[j] == check) {\n          exclude.add(setid);\n          break;\n        }\n      }\n    }\n  }\n\n  // checks that all sets are in exclude;\n  function shouldExclude(sets) {\n    return sets.every(set => !exclude.has(set));\n  }\n\n  // need to sort div's so that Z order is correct\n  div.selectAll('g').sort((a, b) => {\n    // highest order set intersections first\n    if (a.sets.length != b.sets.length) {\n      return a.sets.length - b.sets.length;\n    }\n    if (a == relativeTo) {\n      return shouldExclude(b.sets) ? -1 : 1;\n    }\n    if (b == relativeTo) {\n      return shouldExclude(a.sets) ? 1 : -1;\n    }\n\n    // finally by size\n    return b.size - a.size;\n  });\n}\n\n/**\n * @param {number} x\n * @param {number} y\n * @param {number} r\n * @returns {string}\n */\nfunction circlePath(x, y, r) {\n  const ret = [];\n  ret.push('\\nM', x, y);\n  ret.push('\\nm', -r, 0);\n  ret.push('\\na', r, r, 0, 1, 0, r * 2, 0);\n  ret.push('\\na', r, r, 0, 1, 0, -r * 2, 0);\n  return ret.join(' ');\n}\n\n/**\n * inverse of the circlePath function, returns a circle object from an svg path\n * @param {string} path\n * @returns {{x: number, y: number, radius: number}}\n */\nfunction circleFromPath(path) {\n  const tokens = path.split(' ');\n  return {\n    x: Number.parseFloat(tokens[1]),\n    y: Number.parseFloat(tokens[2]),\n    radius: -Number.parseFloat(tokens[4])\n  };\n}\nfunction intersectionAreaArcs(circles) {\n  if (circles.length === 0) {\n    return [];\n  }\n  const stats = {};\n  intersectionArea(circles, stats);\n  return stats.arcs;\n}\nfunction arcsToPath(arcs, round) {\n  if (arcs.length === 0) {\n    return 'M 0 0';\n  }\n  const rFactor = Math.pow(10, round || 0);\n  const r = round != null ? v => Math.round(v * rFactor) / rFactor : v => v;\n  if (arcs.length == 1) {\n    const circle = arcs[0].circle;\n    return circlePath(r(circle.x), r(circle.y), r(circle.radius));\n  }\n  // draw path around arcs\n  const ret = ['\\nM', r(arcs[0].p2.x), r(arcs[0].p2.y)];\n  for (const arc of arcs) {\n    const radius = r(arc.circle.radius);\n    ret.push('\\nA', radius, radius, 0, arc.large ? 1 : 0, arc.sweep ? 1 : 0, r(arc.p1.x), r(arc.p1.y));\n  }\n  return ret.join(' ');\n}\n\n/**\n * returns a svg path of the intersection area of a bunch of circles\n * @param {ReadonlyArray<{x: number, y: number, radius: number}>} circles\n * @returns {string}\n */\nfunction intersectionAreaPath(circles, round) {\n  return arcsToPath(intersectionAreaArcs(circles), round);\n}\nfunction layout(data) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const {\n    lossFunction: loss,\n    layoutFunction: layout = venn,\n    normalize = true,\n    orientation = Math.PI / 2,\n    orientationOrder,\n    width = 600,\n    height = 350,\n    padding = 15,\n    scaleToFit = false,\n    symmetricalTextCentre = false,\n    distinct,\n    round = 2\n  } = options;\n  let solution = layout(data, {\n    lossFunction: loss === 'default' || !loss ? lossFunction : loss === 'logRatio' ? logRatioLossFunction : loss,\n    distinct\n  });\n  if (normalize) {\n    solution = normalizeSolution(solution, orientation, orientationOrder);\n  }\n  const circles = scaleSolution(solution, width, height, padding, scaleToFit);\n  const textCentres = computeTextCentres(circles, data, symmetricalTextCentre);\n  const circleLookup = new Map(Object.keys(circles).map(set => [set, {\n    set,\n    x: circles[set].x,\n    y: circles[set].y,\n    radius: circles[set].radius\n  }]));\n  const helpers = data.map(area => {\n    const circles = area.sets.map(s => circleLookup.get(s));\n    const arcs = intersectionAreaArcs(circles);\n    const path = arcsToPath(arcs, round);\n    return {\n      circles,\n      arcs,\n      path,\n      area,\n      has: new Set(area.sets)\n    };\n  });\n  function genDistinctPath(sets) {\n    let r = '';\n    for (const e of helpers) {\n      if (e.has.size > sets.length && sets.every(s => e.has.has(s))) {\n        r += ' ' + e.path;\n      }\n    }\n    return r;\n  }\n  return helpers.map(_ref => {\n    let {\n      circles,\n      arcs,\n      path,\n      area\n    } = _ref;\n    return {\n      data: area,\n      text: textCentres[area.sets],\n      circles,\n      arcs,\n      path,\n      distinctPath: path + genDistinctPath(area.sets)\n    };\n  });\n}\nexport { VennDiagram, bestInitialLayout, circleArea, circleCircleIntersection, circleFromPath, circleOverlap, circlePath, computeTextCentre, computeTextCentres, disjointCluster, distance, distanceFromIntersectArea, greedyLayout, intersectionArea, intersectionAreaPath, layout, logRatioLossFunction, lossFunction, normalizeSolution, scaleSolution, sortAreas, venn, wrapText };","map":{"version":3,"names":["nelderMead","bisect","norm2","zeros","conjugateGradient","scale","zerosM","SMALL$1","intersectionArea","circles","stats","intersectionPoints","getIntersectionPoints","innerPoints","filter","p","containedInCircles","arcArea","polygonArea","arcs","length","center","getCenter","i","angle","Math","atan2","x","y","sort","a","b","p2","p1","midPoint","arc","j","parentIndex","includes","circle","a1","a2","angleDiff","PI","width","distance","radius","sin","cos","large","sweep","push","circleArea","smallest","disjoint","abs","area","point","every","ret","intersect","circleCircleIntersection","r","acos","sqrt","circleOverlap","r1","r2","d","min","w1","w2","h","x0","y0","rx","ry","points","venn","sets","parameters","arguments","undefined","maxIterations","initialLayout","bestInitialLayout","loss","lossFunction","areas","addMissingAreas","setids","Object","keys","initial","setid","solution","values","current","positions","SMALL","distanceFromIntersectArea","overlap","distinct","map","s","assign","toKey","arr","join","count","Map","si","String","set","size","get","sj","k1","concat","k2","ids","pairs","Set","add","has","getDistanceMatrices","distances","constraints","forEach","left","right","c","constrainedMDSGradient","fxprime","xi","yi","xj","yj","dij","constraint","squaredDistance","delta","params","greedyLayout","constrained","constrainedMDSLayout","constrainedLoss","greedyLoss","restarts","norm","row","value","obj","best","random","fx","history","setOverlaps","rowid","weight","mostOverlapped","sortOrder","positioned","isPositioned","element","positionSet","index","setIndex","d1","k","d2","extraPoints","bestLoss","bestPoint","localLoss","overlaps","output","logRatioLossFunction","differenceFromIdeal","log","orientateCircles","orientation","orientationOrder","largestX","largestY","dist","rotation","slope","disjointCluster","parent","find","union","xRoot","yRoot","maxDistance","disjointClusters","Array","from","getBoundingBox","minMax","hi","reduce","acc","max","Number","NEGATIVE_INFINITY","lo","POSITIVE_INFINITY","xRange","yRange","normalizeSolution","fromObjectNotation","clusters","cluster","bounds","returnBounds","spacing","addCluster","bottom","xOffset","yOffset","centreing","toObjectNotation","scaleSolution","height","padding","scaleToFit","console","xScaling","yScaling","toScaleDiameter","scaling","id","VennDiagram","options","useViewBox","duration","normalize","wrap","styled","fontSize","round","symmetricalTextCentre","colourMap","colourScheme","colorScheme","colourIndex","colours","key","layoutFunction","chart","selection","data","datum","toRemove","some","textCentres","computeTextCentres","labels","label","selectAll","enter","append","svg","select","attr","previous","hasPrevious","each","path","getAttribute","circleFromPath","pathTween","t","start","end","intersectionAreaPath","nodes","colour","color","enterPath","enterText","text","style","textFill","asTransition","transition","update","attrTween","updateText","floor","on","wrapText","exit","remove","exitText","_","colors","labeller","words","split","reverse","maxLines","minChars","word","pop","line","lineNumber","lineHeight","textContent","tspans","tspan","ownerDocument","createElementNS","namespaceURI","joined","getComputedTextLength","setAttribute","circleMargin","interior","exterior","margin","m","computeTextCentre","minErrorDelta","valid","e","areaStats","getOverlappingCircles","circleids","circleid","ci","cj","overlapped","areaids","exclude","centre","sortAreas","div","relativeTo","check","shouldExclude","circlePath","tokens","parseFloat","intersectionAreaArcs","arcsToPath","rFactor","pow","v","layout","circleLookup","helpers","genDistinctPath","_ref","distinctPath"],"sources":["/Users/jenn/Desktop/info340/project-jsorror/node_modules/@upsetjs/venn.js/build/venn.esm.js"],"sourcesContent":["import { nelderMead, bisect, norm2, zeros, conjugateGradient, scale, zerosM } from 'fmin';\n\nconst SMALL$1 = 1e-10;\n\n/**\n * Returns the intersection area of a bunch of circles (where each circle\n * is an object having an x,y and radius property)\n * @param {ReadonlyArray<{x: number, y: number, radius: number}>} circles\n * @param {undefined | { area?: number, arcArea?: number, polygonArea?: number, arcs?: ReadonlyArray<{ circle: {x: number, y: number, radius: number}, width: number, p1: {x: number, y: number}, p2: {x: number, y: number} }>, innerPoints: ReadonlyArray<{\n    x: number;\n    y: number;\n    parentIndex: [number, number];\n}>, intersectionPoints: ReadonlyArray<{\n  x: number;\n  y: number;\n  parentIndex: [number, number];\n}> }} stats\n * @returns {number}\n */\nfunction intersectionArea(circles, stats) {\n  // get all the intersection points of the circles\n  const intersectionPoints = getIntersectionPoints(circles);\n\n  // filter out points that aren't included in all the circles\n  const innerPoints = intersectionPoints.filter((p) => containedInCircles(p, circles));\n\n  let arcArea = 0;\n  let polygonArea = 0;\n  /** @type {{ circle: {x: number, y: number, radius: number}, width: number, p1: {x: number, y: number}, p2: {x: number, y: number} }[]} */\n  const arcs = [];\n\n  // if we have intersection points that are within all the circles,\n  // then figure out the area contained by them\n  if (innerPoints.length > 1) {\n    // sort the points by angle from the center of the polygon, which lets\n    // us just iterate over points to get the edges\n    const center = getCenter(innerPoints);\n    for (let i = 0; i < innerPoints.length; ++i) {\n      const p = innerPoints[i];\n      p.angle = Math.atan2(p.x - center.x, p.y - center.y);\n    }\n    innerPoints.sort((a, b) => b.angle - a.angle);\n\n    // iterate over all points, get arc between the points\n    // and update the areas\n    let p2 = innerPoints[innerPoints.length - 1];\n    for (let i = 0; i < innerPoints.length; ++i) {\n      const p1 = innerPoints[i];\n\n      // polygon area updates easily ...\n      polygonArea += (p2.x + p1.x) * (p1.y - p2.y);\n\n      // updating the arc area is a little more involved\n      const midPoint = { x: (p1.x + p2.x) / 2, y: (p1.y + p2.y) / 2 };\n      /** @types null | { circle: {x: number, y: number, radius: number}, width: number, p1: {x: number, y: number}, p2: {x: number, y: number} } */\n      let arc = null;\n\n      for (let j = 0; j < p1.parentIndex.length; ++j) {\n        if (p2.parentIndex.includes(p1.parentIndex[j])) {\n          // figure out the angle halfway between the two points\n          // on the current circle\n          const circle = circles[p1.parentIndex[j]];\n          const a1 = Math.atan2(p1.x - circle.x, p1.y - circle.y);\n          const a2 = Math.atan2(p2.x - circle.x, p2.y - circle.y);\n\n          let angleDiff = a2 - a1;\n          if (angleDiff < 0) {\n            angleDiff += 2 * Math.PI;\n          }\n\n          // and use that angle to figure out the width of the\n          // arc\n          const a = a2 - angleDiff / 2;\n          let width = distance(midPoint, {\n            x: circle.x + circle.radius * Math.sin(a),\n            y: circle.y + circle.radius * Math.cos(a),\n          });\n\n          // clamp the width to the largest is can actually be\n          // (sometimes slightly overflows because of FP errors)\n          if (width > circle.radius * 2) {\n            width = circle.radius * 2;\n          }\n\n          // pick the circle whose arc has the smallest width\n          if (arc == null || arc.width > width) {\n            arc = { circle, width, p1, p2, large: width > circle.radius, sweep: true };\n          }\n        }\n      }\n\n      if (arc != null) {\n        arcs.push(arc);\n        arcArea += circleArea(arc.circle.radius, arc.width);\n        p2 = p1;\n      }\n    }\n  } else {\n    // no intersection points, is either disjoint - or is completely\n    // overlapped. figure out which by examining the smallest circle\n    let smallest = circles[0];\n    for (let i = 1; i < circles.length; ++i) {\n      if (circles[i].radius < smallest.radius) {\n        smallest = circles[i];\n      }\n    }\n\n    // make sure the smallest circle is completely contained in all\n    // the other circles\n    let disjoint = false;\n    for (let i = 0; i < circles.length; ++i) {\n      if (distance(circles[i], smallest) > Math.abs(smallest.radius - circles[i].radius)) {\n        disjoint = true;\n        break;\n      }\n    }\n\n    if (disjoint) {\n      arcArea = polygonArea = 0;\n    } else {\n      arcArea = smallest.radius * smallest.radius * Math.PI;\n      arcs.push({\n        circle: smallest,\n        p1: { x: smallest.x, y: smallest.y + smallest.radius },\n        p2: { x: smallest.x - SMALL$1, y: smallest.y + smallest.radius },\n        width: smallest.radius * 2,\n        large: true,\n        sweep: true,\n      });\n    }\n  }\n\n  polygonArea /= 2;\n\n  if (stats) {\n    stats.area = arcArea + polygonArea;\n    stats.arcArea = arcArea;\n    stats.polygonArea = polygonArea;\n    stats.arcs = arcs;\n    stats.innerPoints = innerPoints;\n    stats.intersectionPoints = intersectionPoints;\n  }\n\n  return arcArea + polygonArea;\n}\n\n/**\n * returns whether a point is contained by all of a list of circles\n * @param {{x: number, y: number}} point\n * @param {ReadonlyArray<{x: number, y: number, radius: number}>} circles\n * @returns {boolean}\n */\nfunction containedInCircles(point, circles) {\n  return circles.every((circle) => distance(point, circle) < circle.radius + SMALL$1);\n}\n\n/**\n * Gets all intersection points between a bunch of circles\n * @param {ReadonlyArray<{x: number, y: number, radius: number}>} circles\n * @returns {ReadonlyArray<{x: number, y: number, parentIndex: [number, number]}>}\n */\nfunction getIntersectionPoints(circles) {\n  /** @type {{x: number, y: number, parentIndex: [number, number]}[]} */\n  const ret = [];\n  for (let i = 0; i < circles.length; ++i) {\n    for (let j = i + 1; j < circles.length; ++j) {\n      const intersect = circleCircleIntersection(circles[i], circles[j]);\n      for (const p of intersect) {\n        p.parentIndex = [i, j];\n        ret.push(p);\n      }\n    }\n  }\n  return ret;\n}\n\n/**\n * Circular segment area calculation. See http://mathworld.wolfram.com/CircularSegment.html\n * @param {number} r\n * @param {number} width\n * @returns {number}\n **/\nfunction circleArea(r, width) {\n  return r * r * Math.acos(1 - width / r) - (r - width) * Math.sqrt(width * (2 * r - width));\n}\n\n/**\n * euclidean distance between two points\n * @param {{x: number, y: number}} p1\n * @param {{x: number, y: number}} p2\n * @returns {number}\n **/\nfunction distance(p1, p2) {\n  return Math.sqrt((p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y) * (p1.y - p2.y));\n}\n\n/**\n * Returns the overlap area of two circles of radius r1 and r2 - that\n * have their centers separated by distance d. Simpler faster\n * circle intersection for only two circles\n * @param {number} r1\n * @param {number} r2\n * @param {number} d\n * @returns {number}\n */\nfunction circleOverlap(r1, r2, d) {\n  // no overlap\n  if (d >= r1 + r2) {\n    return 0;\n  }\n\n  // completely overlapped\n  if (d <= Math.abs(r1 - r2)) {\n    return Math.PI * Math.min(r1, r2) * Math.min(r1, r2);\n  }\n\n  const w1 = r1 - (d * d - r2 * r2 + r1 * r1) / (2 * d);\n  const w2 = r2 - (d * d - r1 * r1 + r2 * r2) / (2 * d);\n  return circleArea(r1, w1) + circleArea(r2, w2);\n}\n\n/**\n * Given two circles (containing a x/y/radius attributes),\n * returns the intersecting points if possible\n * note: doesn't handle cases where there are infinitely many\n * intersection points (circles are equivalent):, or only one intersection point\n * @param {{x: number, y: number, radius: number}} p1\n * @param {{x: number, y: number, radius: number}} p2\n * @returns {ReadonlyArray<{x: number, y: number}>}\n **/\nfunction circleCircleIntersection(p1, p2) {\n  const d = distance(p1, p2);\n  const r1 = p1.radius;\n  const r2 = p2.radius;\n\n  // if to far away, or self contained - can't be done\n  if (d >= r1 + r2 || d <= Math.abs(r1 - r2)) {\n    return [];\n  }\n\n  const a = (r1 * r1 - r2 * r2 + d * d) / (2 * d);\n  const h = Math.sqrt(r1 * r1 - a * a);\n  const x0 = p1.x + (a * (p2.x - p1.x)) / d;\n  const y0 = p1.y + (a * (p2.y - p1.y)) / d;\n  const rx = -(p2.y - p1.y) * (h / d);\n  const ry = -(p2.x - p1.x) * (h / d);\n\n  return [\n    { x: x0 + rx, y: y0 - ry },\n    { x: x0 - rx, y: y0 + ry },\n  ];\n}\n\n/**\n * Returns the center of a bunch of points\n * @param {ReadonlyArray<{x: number, y: number}>} points\n * @returns {{x: number, y: number}}\n */\nfunction getCenter(points) {\n  const center = { x: 0, y: 0 };\n  for (const point of points) {\n    center.x += point.x;\n    center.y += point.y;\n  }\n  center.x /= points.length;\n  center.y /= points.length;\n  return center;\n}\n\n/**\n * given a list of set objects, and their corresponding overlaps\n * updates the (x, y, radius) attribute on each set such that their positions\n * roughly correspond to the desired overlaps\n * @param {readonly {sets: readonly string[]; size: number; weight?: number}[]} sets\n * @returns {{[setid: string]: {x: number, y: number, radius: number}}}\n */\nfunction venn(sets, parameters = {}) {\n  parameters.maxIterations = parameters.maxIterations || 500;\n\n  const initialLayout = parameters.initialLayout || bestInitialLayout;\n  const loss = parameters.lossFunction || lossFunction;\n\n  // add in missing pairwise areas as having 0 size\n  const areas = addMissingAreas(sets, parameters);\n\n  // initial layout is done greedily\n  const circles = initialLayout(areas, parameters);\n\n  // transform x/y coordinates to a vector to optimize\n  const setids = Object.keys(circles);\n  /** @type {number[]} */\n  const initial = [];\n  for (const setid of setids) {\n    initial.push(circles[setid].x);\n    initial.push(circles[setid].y);\n  }\n\n  // optimize initial layout from our loss function\n  const solution = nelderMead(\n    (values) => {\n      const current = {};\n      for (let i = 0; i < setids.length; ++i) {\n        const setid = setids[i];\n        current[setid] = {\n          x: values[2 * i],\n          y: values[2 * i + 1],\n          radius: circles[setid].radius,\n          // size : circles[setid].size\n        };\n      }\n      return loss(current, areas);\n    },\n    initial,\n    parameters\n  );\n\n  // transform solution vector back to x/y points\n  const positions = solution.x;\n  for (let i = 0; i < setids.length; ++i) {\n    const setid = setids[i];\n    circles[setid].x = positions[2 * i];\n    circles[setid].y = positions[2 * i + 1];\n  }\n\n  return circles;\n}\n\nconst SMALL = 1e-10;\n\n/**\n * Returns the distance necessary for two circles of radius r1 + r2 to\n * have the overlap area 'overlap'\n * @param {number} r1\n * @param {number} r2\n * @param {number} overlap\n * @returns {number}\n */\nfunction distanceFromIntersectArea(r1, r2, overlap) {\n  // handle complete overlapped circles\n  if (Math.min(r1, r2) * Math.min(r1, r2) * Math.PI <= overlap + SMALL) {\n    return Math.abs(r1 - r2);\n  }\n\n  return bisect((distance) => circleOverlap(r1, r2, distance) - overlap, 0, r1 + r2);\n}\n\n/**\n * Missing pair-wise intersection area data can cause problems:\n * treating as an unknown means that sets will be laid out overlapping,\n * which isn't what people expect. To reflect that we want disjoint sets\n * here, set the overlap to 0 for all missing pairwise set intersections\n * @param {ReadonlyArray<{sets: ReadonlyArray<string>, size: number}>} areas\n * @returns {ReadonlyArray<{sets: ReadonlyArray<string>, size: number}>}\n */\nfunction addMissingAreas(areas, parameters = {}) {\n  const distinct = parameters.distinct;\n  const r = areas.map((s) => Object.assign({}, s));\n\n  function toKey(arr) {\n    return arr.join(';');\n  }\n\n  if (distinct) {\n    // recreate the full ones by adding things up but just to level two since the rest doesn't matter\n    /** @types Map<string, number> */\n    const count = new Map();\n    for (const area of r) {\n      for (let i = 0; i < area.sets.length; i++) {\n        const si = String(area.sets[i]);\n        count.set(si, area.size + (count.get(si) || 0));\n        for (let j = i + 1; j < area.sets.length; j++) {\n          const sj = String(area.sets[j]);\n          const k1 = `${si};${sj}`;\n          const k2 = `${sj};${si}`;\n          count.set(k1, area.size + (count.get(k1) || 0));\n          count.set(k2, area.size + (count.get(k2) || 0));\n        }\n      }\n    }\n    for (const area of r) {\n      if (area.sets.length < 3) {\n        area.size = count.get(toKey(area.sets));\n      }\n    }\n  }\n\n  // two circle intersections that aren't defined\n  const ids = [];\n\n  /** @type {Set<string>} */\n  const pairs = new Set();\n  for (const area of r) {\n    if (area.sets.length === 1) {\n      ids.push(area.sets[0]);\n    } else if (area.sets.length === 2) {\n      const a = area.sets[0];\n      const b = area.sets[1];\n      pairs.add(toKey(area.sets));\n      pairs.add(toKey([b, a]));\n    }\n  }\n\n  ids.sort((a, b) => (a === b ? 0 : a < b ? -1 : +1));\n\n  for (let i = 0; i < ids.length; ++i) {\n    const a = ids[i];\n    for (let j = i + 1; j < ids.length; ++j) {\n      const b = ids[j];\n      if (!pairs.has(toKey([a, b]))) {\n        r.push({ sets: [a, b], size: 0 });\n      }\n    }\n  }\n  return r;\n}\n\n/**\n * Returns two matrices, one of the euclidean distances between the sets\n * and the other indicating if there are subset or disjoint set relationships\n * @param {ReadonlyArray<{sets: ReadonlyArray<number>}>} areas\n * @param {ReadonlyArray<{size: number}>} sets\n * @param {ReadonlyArray<number>} setids\n */\nfunction getDistanceMatrices(areas, sets, setids) {\n  // initialize an empty distance matrix between all the points\n  /**\n   * @type {number[][]}\n   */\n  const distances = zerosM(sets.length, sets.length);\n  /**\n   * @type {number[][]}\n   */\n  const constraints = zerosM(sets.length, sets.length);\n\n  // compute required distances between all the sets such that\n  // the areas match\n  areas\n    .filter((x) => x.sets.length === 2)\n    .forEach((current) => {\n      const left = setids[current.sets[0]];\n      const right = setids[current.sets[1]];\n      const r1 = Math.sqrt(sets[left].size / Math.PI);\n      const r2 = Math.sqrt(sets[right].size / Math.PI);\n      const distance = distanceFromIntersectArea(r1, r2, current.size);\n\n      distances[left][right] = distances[right][left] = distance;\n\n      // also update constraints to indicate if its a subset or disjoint\n      // relationship\n      let c = 0;\n      if (current.size + 1e-10 >= Math.min(sets[left].size, sets[right].size)) {\n        c = 1;\n      } else if (current.size <= 1e-10) {\n        c = -1;\n      }\n      constraints[left][right] = constraints[right][left] = c;\n    });\n\n  return { distances, constraints };\n}\n\n/// computes the gradient and loss simultaneously for our constrained MDS optimizer\nfunction constrainedMDSGradient(x, fxprime, distances, constraints) {\n  for (let i = 0; i < fxprime.length; ++i) {\n    fxprime[i] = 0;\n  }\n\n  let loss = 0;\n  for (let i = 0; i < distances.length; ++i) {\n    const xi = x[2 * i];\n    const yi = x[2 * i + 1];\n    for (let j = i + 1; j < distances.length; ++j) {\n      const xj = x[2 * j];\n      const yj = x[2 * j + 1];\n      const dij = distances[i][j];\n      const constraint = constraints[i][j];\n\n      const squaredDistance = (xj - xi) * (xj - xi) + (yj - yi) * (yj - yi);\n      const distance = Math.sqrt(squaredDistance);\n      const delta = squaredDistance - dij * dij;\n\n      if ((constraint > 0 && distance <= dij) || (constraint < 0 && distance >= dij)) {\n        continue;\n      }\n\n      loss += 2 * delta * delta;\n\n      fxprime[2 * i] += 4 * delta * (xi - xj);\n      fxprime[2 * i + 1] += 4 * delta * (yi - yj);\n\n      fxprime[2 * j] += 4 * delta * (xj - xi);\n      fxprime[2 * j + 1] += 4 * delta * (yj - yi);\n    }\n  }\n  return loss;\n}\n\n/**\n * takes the best working variant of either constrained MDS or greedy\n * @param {ReadonlyArray<{sets: ReadonlyArray<string>, size: number}>} areas\n */\nfunction bestInitialLayout(areas, params = {}) {\n  let initial = greedyLayout(areas, params);\n  const loss = params.lossFunction || lossFunction;\n\n  // greedylayout is sufficient for all 2/3 circle cases. try out\n  // constrained MDS for higher order problems, take its output\n  // if it outperforms. (greedy is aesthetically better on 2/3 circles\n  // since it axis aligns)\n  if (areas.length >= 8) {\n    const constrained = constrainedMDSLayout(areas, params);\n    const constrainedLoss = loss(constrained, areas);\n    const greedyLoss = loss(initial, areas);\n\n    if (constrainedLoss + 1e-8 < greedyLoss) {\n      initial = constrained;\n    }\n  }\n  return initial;\n}\n\n/**\n * use the constrained MDS variant to generate an initial layout\n * @param {ReadonlyArray<{sets: ReadonlyArray<string>, size: number}>} areas\n * @returns {{[key: string]: {x: number, y: number, radius: number}}}\n */\nfunction constrainedMDSLayout(areas, params = {}) {\n  const restarts = params.restarts || 10;\n\n  // bidirectionally map sets to a rowid  (so we can create a matrix)\n  const sets = [];\n  const setids = {};\n  for (const area of areas) {\n    if (area.sets.length === 1) {\n      setids[area.sets[0]] = sets.length;\n      sets.push(area);\n    }\n  }\n\n  let { distances, constraints } = getDistanceMatrices(areas, sets, setids);\n\n  // keep distances bounded, things get messed up otherwise.\n  // TODO: proper preconditioner?\n  const norm = norm2(distances.map(norm2)) / distances.length;\n  distances = distances.map((row) => row.map((value) => value / norm));\n\n  const obj = (x, fxprime) => constrainedMDSGradient(x, fxprime, distances, constraints);\n\n  let best = null;\n  for (let i = 0; i < restarts; ++i) {\n    const initial = zeros(distances.length * 2).map(Math.random);\n\n    const current = conjugateGradient(obj, initial, params);\n    if (!best || current.fx < best.fx) {\n      best = current;\n    }\n  }\n\n  const positions = best.x;\n\n  // translate rows back to (x,y,radius) coordinates\n  /** @type {{[key: string]: {x: number, y: number, radius: number}}} */\n  const circles = {};\n  for (let i = 0; i < sets.length; ++i) {\n    const set = sets[i];\n    circles[set.sets[0]] = {\n      x: positions[2 * i] * norm,\n      y: positions[2 * i + 1] * norm,\n      radius: Math.sqrt(set.size / Math.PI),\n    };\n  }\n\n  if (params.history) {\n    for (const h of params.history) {\n      scale(h.x, norm);\n    }\n  }\n  return circles;\n}\n\n/**\n * Lays out a Venn diagram greedily, going from most overlapped sets to\n * least overlapped, attempting to position each new set such that the\n * overlapping areas to already positioned sets are basically right\n * @param {ReadonlyArray<{size: number, sets: ReadonlyArray<string>}>} areas\n * @return {{[key: string]: {x: number, y: number, radius: number}}}\n */\nfunction greedyLayout(areas, params) {\n  const loss = params && params.lossFunction ? params.lossFunction : lossFunction;\n\n  // define a circle for each set\n  /** @type {{[key: string]: {x: number, y: number, radius: number}}} */\n  const circles = {};\n  /** @type {{[key: string]: {set: string, size: number, weight: number}[]}} */\n  const setOverlaps = {};\n  for (const area of areas) {\n    if (area.sets.length === 1) {\n      const set = area.sets[0];\n      circles[set] = {\n        x: 1e10,\n        y: 1e10,\n        rowid: circles.length,\n        size: area.size,\n        radius: Math.sqrt(area.size / Math.PI),\n      };\n      setOverlaps[set] = [];\n    }\n  }\n\n  areas = areas.filter((a) => a.sets.length === 2);\n\n  // map each set to a list of all the other sets that overlap it\n  for (const current of areas) {\n    let weight = current.weight != null ? current.weight : 1.0;\n    const left = current.sets[0];\n    const right = current.sets[1];\n\n    // completely overlapped circles shouldn't be positioned early here\n    if (current.size + SMALL >= Math.min(circles[left].size, circles[right].size)) {\n      weight = 0;\n    }\n\n    setOverlaps[left].push({ set: right, size: current.size, weight });\n    setOverlaps[right].push({ set: left, size: current.size, weight });\n  }\n\n  // get list of most overlapped sets\n  const mostOverlapped = [];\n  Object.keys(setOverlaps).forEach((set) => {\n    let size = 0;\n    for (let i = 0; i < setOverlaps[set].length; ++i) {\n      size += setOverlaps[set][i].size * setOverlaps[set][i].weight;\n    }\n\n    mostOverlapped.push({ set, size });\n  });\n\n  // sort by size desc\n  function sortOrder(a, b) {\n    return b.size - a.size;\n  }\n  mostOverlapped.sort(sortOrder);\n\n  // keep track of what sets have been laid out\n  const positioned = {};\n  function isPositioned(element) {\n    return element.set in positioned;\n  }\n\n  /**\n   * adds a point to the output\n   * @param {{x: number, y: number}} point\n   * @param {number} index\n   */\n  function positionSet(point, index) {\n    circles[index].x = point.x;\n    circles[index].y = point.y;\n    positioned[index] = true;\n  }\n\n  // add most overlapped set at (0,0)\n  positionSet({ x: 0, y: 0 }, mostOverlapped[0].set);\n\n  // get distances between all points. TODO, necessary?\n  // answer: probably not\n  // var distances = venn.getDistanceMatrices(circles, areas).distances;\n  for (let i = 1; i < mostOverlapped.length; ++i) {\n    const setIndex = mostOverlapped[i].set;\n    const overlap = setOverlaps[setIndex].filter(isPositioned);\n    const set = circles[setIndex];\n    overlap.sort(sortOrder);\n\n    if (overlap.length === 0) {\n      // this shouldn't happen anymore with addMissingAreas\n      throw 'ERROR: missing pairwise overlap information';\n    }\n\n    /** @type {{x: number, y: number}[]} */\n    const points = [];\n    for (var j = 0; j < overlap.length; ++j) {\n      // get appropriate distance from most overlapped already added set\n      const p1 = circles[overlap[j].set];\n      const d1 = distanceFromIntersectArea(set.radius, p1.radius, overlap[j].size);\n\n      // sample positions at 90 degrees for maximum aesthetics\n      points.push({ x: p1.x + d1, y: p1.y });\n      points.push({ x: p1.x - d1, y: p1.y });\n      points.push({ y: p1.y + d1, x: p1.x });\n      points.push({ y: p1.y - d1, x: p1.x });\n\n      // if we have at least 2 overlaps, then figure out where the\n      // set should be positioned analytically and try those too\n      for (let k = j + 1; k < overlap.length; ++k) {\n        const p2 = circles[overlap[k].set];\n        const d2 = distanceFromIntersectArea(set.radius, p2.radius, overlap[k].size);\n\n        const extraPoints = circleCircleIntersection(\n          { x: p1.x, y: p1.y, radius: d1 },\n          { x: p2.x, y: p2.y, radius: d2 }\n        );\n        points.push(...extraPoints);\n      }\n    }\n\n    // we have some candidate positions for the set, examine loss\n    // at each position to figure out where to put it at\n    let bestLoss = 1e50;\n    let bestPoint = points[0];\n    for (const point of points) {\n      circles[setIndex].x = point.x;\n      circles[setIndex].y = point.y;\n      const localLoss = loss(circles, areas);\n      if (localLoss < bestLoss) {\n        bestLoss = localLoss;\n        bestPoint = point;\n      }\n    }\n\n    positionSet(bestPoint, setIndex);\n  }\n\n  return circles;\n}\n\n/**\n * Given a bunch of sets, and the desired overlaps between these sets - computes\n * the distance from the actual overlaps to the desired overlaps. Note that\n * this method ignores overlaps of more than 2 circles\n * @param {{[key: string]: <{x: number, y: number, radius: number}>}} circles\n * @param {ReadonlyArray<{size: number, sets: ReadonlyArray<string>, weight?: number}>} overlaps\n * @returns {number}\n */\nfunction lossFunction(circles, overlaps) {\n  let output = 0;\n\n  for (const area of overlaps) {\n    if (area.sets.length === 1) {\n      continue;\n    }\n    /** @type {number} */\n    let overlap;\n    if (area.sets.length === 2) {\n      const left = circles[area.sets[0]];\n      const right = circles[area.sets[1]];\n      overlap = circleOverlap(left.radius, right.radius, distance(left, right));\n    } else {\n      overlap = intersectionArea(area.sets.map((d) => circles[d]));\n    }\n\n    const weight = area.weight != null ? area.weight : 1.0;\n    output += weight * (overlap - area.size) * (overlap - area.size);\n  }\n\n  return output;\n}\n\nfunction logRatioLossFunction(circles, overlaps) {\n  let output = 0;\n\n  for (const area of overlaps) {\n    if (area.sets.length === 1) {\n      continue;\n    }\n    /** @type {number} */\n    let overlap;\n    if (area.sets.length === 2) {\n      const left = circles[area.sets[0]];\n      const right = circles[area.sets[1]];\n      overlap = circleOverlap(left.radius, right.radius, distance(left, right));\n    } else {\n      overlap = intersectionArea(area.sets.map((d) => circles[d]));\n    }\n\n    const weight = area.weight != null ? area.weight : 1.0;\n    const differenceFromIdeal = Math.log((overlap + 1) / (area.size + 1));\n    output += weight * differenceFromIdeal * differenceFromIdeal;\n  }\n\n  return output;\n}\n\n/**\n * orientates a bunch of circles to point in orientation\n * @param {{x :number, y: number, radius: number}[]} circles\n * @param {number | undefined} orientation\n * @param {((a: {x :number, y: number, radius: number}, b: {x :number, y: number, radius: number}) => number) | undefined} orientationOrder\n */\nfunction orientateCircles(circles, orientation, orientationOrder) {\n  if (orientationOrder == null) {\n    circles.sort((a, b) => b.radius - a.radius);\n  } else {\n    circles.sort(orientationOrder);\n  }\n\n  // shift circles so largest circle is at (0, 0)\n  if (circles.length > 0) {\n    const largestX = circles[0].x;\n    const largestY = circles[0].y;\n\n    for (const circle of circles) {\n      circle.x -= largestX;\n      circle.y -= largestY;\n    }\n  }\n\n  if (circles.length === 2) {\n    // if the second circle is a subset of the first, arrange so that\n    // it is off to one side. hack for https://github.com/benfred/venn.js/issues/120\n    const dist = distance(circles[0], circles[1]);\n    if (dist < Math.abs(circles[1].radius - circles[0].radius)) {\n      circles[1].x = circles[0].x + circles[0].radius - circles[1].radius - 1e-10;\n      circles[1].y = circles[0].y;\n    }\n  }\n\n  // rotate circles so that second largest is at an angle of 'orientation'\n  // from largest\n  if (circles.length > 1) {\n    const rotation = Math.atan2(circles[1].x, circles[1].y) - orientation;\n    const c = Math.cos(rotation);\n    const s = Math.sin(rotation);\n\n    for (const circle of circles) {\n      const x = circle.x;\n      const y = circle.y;\n      circle.x = c * x - s * y;\n      circle.y = s * x + c * y;\n    }\n  }\n\n  // mirror solution if third solution is above plane specified by\n  // first two circles\n  if (circles.length > 2) {\n    let angle = Math.atan2(circles[2].x, circles[2].y) - orientation;\n    while (angle < 0) {\n      angle += 2 * Math.PI;\n    }\n    while (angle > 2 * Math.PI) {\n      angle -= 2 * Math.PI;\n    }\n    if (angle > Math.PI) {\n      const slope = circles[1].y / (1e-10 + circles[1].x);\n      for (const circle of circles) {\n        var d = (circle.x + slope * circle.y) / (1 + slope * slope);\n        circle.x = 2 * d - circle.x;\n        circle.y = 2 * d * slope - circle.y;\n      }\n    }\n  }\n}\n\n/**\n *\n * @param {ReadonlyArray<{x: number, y: number, radius: number}>} circles\n * @returns {{x: number, y: number, radius: number}[][]}\n */\nfunction disjointCluster(circles) {\n  // union-find clustering to get disjoint sets\n  circles.forEach((circle) => {\n    circle.parent = circle;\n  });\n\n  // path compression step in union find\n  function find(circle) {\n    if (circle.parent !== circle) {\n      circle.parent = find(circle.parent);\n    }\n    return circle.parent;\n  }\n\n  function union(x, y) {\n    const xRoot = find(x);\n    const yRoot = find(y);\n    xRoot.parent = yRoot;\n  }\n\n  // get the union of all overlapping sets\n  for (let i = 0; i < circles.length; ++i) {\n    for (let j = i + 1; j < circles.length; ++j) {\n      const maxDistance = circles[i].radius + circles[j].radius;\n      if (distance(circles[i], circles[j]) + 1e-10 < maxDistance) {\n        union(circles[j], circles[i]);\n      }\n    }\n  }\n\n  // find all the disjoint clusters and group them together\n  /** @type {Map<string, {x: number, y: number, radius: number}[]>} */\n  const disjointClusters = new Map();\n  for (let i = 0; i < circles.length; ++i) {\n    const setid = find(circles[i]).parent.setid;\n    if (!disjointClusters.has(setid)) {\n      disjointClusters.set(setid, []);\n    }\n    disjointClusters.get(setid).push(circles[i]);\n  }\n\n  // cleanup bookkeeping\n  circles.forEach((circle) => {\n    delete circle.parent;\n  });\n\n  // return in more usable form\n  return Array.from(disjointClusters.values());\n}\n\n/**\n * @param {ReadonlyArray<{x :number, y: number, radius: number}>} circles\n * @returns {{xRange: [number, number], yRange: [number, number]}}\n */\nfunction getBoundingBox(circles) {\n  const minMax = (d) => {\n    const hi = circles.reduce((acc, c) => Math.max(acc, c[d] + c.radius), Number.NEGATIVE_INFINITY);\n    const lo = circles.reduce((acc, c) => Math.min(acc, c[d] - c.radius), Number.POSITIVE_INFINITY);\n    return { max: hi, min: lo };\n  };\n  return { xRange: minMax('x'), yRange: minMax('y') };\n}\n\n/**\n *\n * @param {{[setid: string]: {x: number, y: number, radius: number}}} solution\n * @param {undefined | number} orientation\n * @param {((a: {x :number, y: number, radius: number}, b: {x :number, y: number, radius: number}) => number) | undefined} orientationOrder\n * @returns {{[setid: string]: {x: number, y: number, radius: number}}}\n */\nfunction normalizeSolution(solution, orientation, orientationOrder) {\n  if (orientation == null) {\n    orientation = Math.PI / 2;\n  }\n\n  // work with a list instead of a dictionary, and take a copy so we\n  // don't mutate input\n  let circles = fromObjectNotation(solution).map((d) => Object.assign({}, d));\n\n  // get all the disjoint clusters\n  const clusters = disjointCluster(circles);\n\n  // orientate all disjoint sets, get sizes\n  for (const cluster of clusters) {\n    orientateCircles(cluster, orientation, orientationOrder);\n    const bounds = getBoundingBox(cluster);\n    cluster.size = (bounds.xRange.max - bounds.xRange.min) * (bounds.yRange.max - bounds.yRange.min);\n    cluster.bounds = bounds;\n  }\n  clusters.sort((a, b) => b.size - a.size);\n\n  // orientate the largest at 0,0, and get the bounds\n  circles = clusters[0];\n  let returnBounds = circles.bounds;\n  const spacing = (returnBounds.xRange.max - returnBounds.xRange.min) / 50;\n\n  /**\n   * @param {ReadonlyArray<{x: number, y: number, radius: number, setid: string}>} cluster\n   * @param {boolean} right\n   * @param {boolean} bottom\n   */\n  function addCluster(cluster, right, bottom) {\n    if (!cluster) {\n      return;\n    }\n\n    const bounds = cluster.bounds;\n    /** @type {number} */\n    let xOffset;\n    /** @type {number} */\n    let yOffset;\n\n    if (right) {\n      xOffset = returnBounds.xRange.max - bounds.xRange.min + spacing;\n    } else {\n      xOffset = returnBounds.xRange.max - bounds.xRange.max;\n      const centreing =\n        (bounds.xRange.max - bounds.xRange.min) / 2 - (returnBounds.xRange.max - returnBounds.xRange.min) / 2;\n      if (centreing < 0) {\n        xOffset += centreing;\n      }\n    }\n\n    if (bottom) {\n      yOffset = returnBounds.yRange.max - bounds.yRange.min + spacing;\n    } else {\n      yOffset = returnBounds.yRange.max - bounds.yRange.max;\n      const centreing =\n        (bounds.yRange.max - bounds.yRange.min) / 2 - (returnBounds.yRange.max - returnBounds.yRange.min) / 2;\n      if (centreing < 0) {\n        yOffset += centreing;\n      }\n    }\n\n    for (const c of cluster) {\n      c.x += xOffset;\n      c.y += yOffset;\n      circles.push(c);\n    }\n  }\n\n  let index = 1;\n  while (index < clusters.length) {\n    addCluster(clusters[index], true, false);\n    addCluster(clusters[index + 1], false, true);\n    addCluster(clusters[index + 2], true, true);\n    index += 3;\n\n    // have one cluster (in top left). lay out next three relative\n    // to it in a grid\n    returnBounds = getBoundingBox(circles);\n  }\n\n  // convert back to solution form\n  return toObjectNotation(circles);\n}\n\n/**\n * Scales a solution from venn.venn or venn.greedyLayout such that it fits in\n * a rectangle of width/height - with padding around the borders. also\n * centers the diagram in the available space at the same time.\n * If the scale parameter is not null, this automatic scaling is ignored in favor of this custom one\n * @param {{[setid: string]: {x: number, y: number, radius: number}}} solution\n * @param {number} width\n * @param {number} height\n * @param {number} padding\n * @param {boolean} scaleToFit\n * @returns {{[setid: string]: {x: number, y: number, radius: number}}}\n */\nfunction scaleSolution(solution, width, height, padding, scaleToFit) {\n  const circles = fromObjectNotation(solution);\n\n  width -= 2 * padding;\n  height -= 2 * padding;\n\n  const { xRange, yRange } = getBoundingBox(circles);\n\n  if (xRange.max === xRange.min || yRange.max === yRange.min) {\n    console.log('not scaling solution: zero size detected');\n    return solution;\n  }\n\n  /** @type {number} */\n  let xScaling;\n  /** @type {number} */\n  let yScaling;\n  if (scaleToFit) {\n    const toScaleDiameter = Math.sqrt(scaleToFit / Math.PI) * 2;\n    xScaling = width / toScaleDiameter;\n    yScaling = height / toScaleDiameter;\n  } else {\n    xScaling = width / (xRange.max - xRange.min);\n    yScaling = height / (yRange.max - yRange.min);\n  }\n\n  const scaling = Math.min(yScaling, xScaling);\n  // while we're at it, center the diagram too\n  const xOffset = (width - (xRange.max - xRange.min) * scaling) / 2;\n  const yOffset = (height - (yRange.max - yRange.min) * scaling) / 2;\n\n  return toObjectNotation(\n    circles.map((circle) => ({\n      radius: scaling * circle.radius,\n      x: padding + xOffset + (circle.x - xRange.min) * scaling,\n      y: padding + yOffset + (circle.y - yRange.min) * scaling,\n      setid: circle.setid,\n    }))\n  );\n}\n\n/**\n * @param {readonly {x: number, y: number, radius: number, setid: string}[]} circles\n * @returns {{[setid: string]: {x: number, y: number, radius: number, setid: string}}}\n */\nfunction toObjectNotation(circles) {\n  /** @type {{[setid: string]: {x: number, y: number, radius: number, setid: string}}} */\n  const r = {};\n  for (const circle of circles) {\n    r[circle.setid] = circle;\n  }\n  return r;\n}\n/**\n * @param {{[setid: string]: {x: number, y: number, radius: number}}} solution\n * @returns {{x: number, y: number, radius: number, setid: string}[]}}\n */\nfunction fromObjectNotation(solution) {\n  const setids = Object.keys(solution);\n  return setids.map((id) => Object.assign(solution[id], { setid: id }));\n}\n\n/*global console:true*/\n\n/**\n * VennDiagram includes an optional `options` parameter containing the following option(s):\n *\n * `colourScheme: Array<String>`\n * A list of color values to be applied when coloring diagram circles.\n *\n * `symmetricalTextCentre: Boolean`\n * Whether to symmetrically center each circle's text horizontally and vertically.\n * Defaults to `false`.\n *\n * `textFill: String`\n * The color to be applied to the text within each circle.\n *\n * @param {object} options\n */\nfunction VennDiagram(options = {}) {\n  let useViewBox = false,\n    width = 600,\n    height = 350,\n    padding = 15,\n    duration = 1000,\n    orientation = Math.PI / 2,\n    normalize = true,\n    scaleToFit = null,\n    wrap = true,\n    styled = true,\n    fontSize = null,\n    orientationOrder = null,\n    distinct = false,\n    round = null,\n    symmetricalTextCentre = options && options.symmetricalTextCentre ? options.symmetricalTextCentre : false,\n    // mimic the behaviour of d3.scale.category10 from the previous\n    // version of d3\n    colourMap = {},\n    // so this is the same as d3.schemeCategory10, which is only defined in d3 4.0\n    // since we can support older versions of d3 as long as we don't force this,\n    // I'm hackily redefining below. TODO: remove this and change to d3.schemeCategory10\n    colourScheme =\n      options && options.colourScheme\n        ? options.colourScheme\n        : options && options.colorScheme\n        ? options.colorScheme\n        : [\n            '#1f77b4',\n            '#ff7f0e',\n            '#2ca02c',\n            '#d62728',\n            '#9467bd',\n            '#8c564b',\n            '#e377c2',\n            '#7f7f7f',\n            '#bcbd22',\n            '#17becf',\n          ],\n    colourIndex = 0,\n    colours = function (key) {\n      if (key in colourMap) {\n        return colourMap[key];\n      }\n      var ret = (colourMap[key] = colourScheme[colourIndex]);\n      colourIndex += 1;\n      if (colourIndex >= colourScheme.length) {\n        colourIndex = 0;\n      }\n      return ret;\n    },\n    layoutFunction = venn,\n    loss = lossFunction;\n\n  function chart(selection) {\n    let data = selection.datum();\n\n    // handle 0-sized sets by removing from input\n    const toRemove = new Set();\n    data.forEach((datum) => {\n      if (datum.size == 0 && datum.sets.length == 1) {\n        toRemove.add(datum.sets[0]);\n      }\n    });\n    data = data.filter((datum) => !datum.sets.some((set) => toRemove.has(set)));\n\n    let circles = {};\n    let textCentres = {};\n\n    if (data.length > 0) {\n      let solution = layoutFunction(data, { lossFunction: loss, distinct });\n\n      if (normalize) {\n        solution = normalizeSolution(solution, orientation, orientationOrder);\n      }\n\n      circles = scaleSolution(solution, width, height, padding, scaleToFit);\n      textCentres = computeTextCentres(circles, data, symmetricalTextCentre);\n    }\n\n    // Figure out the current label for each set. These can change\n    // and D3 won't necessarily update (fixes https://github.com/benfred/venn.js/issues/103)\n    const labels = {};\n    data.forEach((datum) => {\n      if (datum.label) {\n        labels[datum.sets] = datum.label;\n      }\n    });\n\n    function label(d) {\n      if (d.sets in labels) {\n        return labels[d.sets];\n      }\n      if (d.sets.length == 1) {\n        return '' + d.sets[0];\n      }\n    }\n\n    // create svg if not already existing\n    selection.selectAll('svg').data([circles]).enter().append('svg');\n\n    const svg = selection.select('svg');\n\n    if (useViewBox) {\n      svg.attr('viewBox', `0 0 ${width} ${height}`);\n    } else {\n      svg.attr('width', width).attr('height', height);\n    }\n\n    // to properly transition intersection areas, we need the\n    // previous circles locations. load from elements\n    const previous = {};\n    let hasPrevious = false;\n    svg.selectAll('.venn-area path').each(function (d) {\n      const path = this.getAttribute('d');\n      if (d.sets.length == 1 && path && !distinct) {\n        hasPrevious = true;\n        previous[d.sets[0]] = circleFromPath(path);\n      }\n    });\n    // interpolate intersection area paths between previous and\n    // current paths\n    function pathTween(d) {\n      return (t) => {\n        const c = d.sets.map((set) => {\n          let start = previous[set];\n          let end = circles[set];\n          if (!start) {\n            start = { x: width / 2, y: height / 2, radius: 1 };\n          }\n          if (!end) {\n            end = { x: width / 2, y: height / 2, radius: 1 };\n          }\n          return {\n            x: start.x * (1 - t) + end.x * t,\n            y: start.y * (1 - t) + end.y * t,\n            radius: start.radius * (1 - t) + end.radius * t,\n          };\n        });\n        return intersectionAreaPath(c, round);\n      };\n    }\n\n    // update data, joining on the set ids\n    const nodes = svg.selectAll('.venn-area').data(data, (d) => d.sets);\n\n    // create new nodes\n    const enter = nodes\n      .enter()\n      .append('g')\n      .attr(\n        'class',\n        (d) =>\n          `venn-area venn-${d.sets.length == 1 ? 'circle' : 'intersection'}${\n            d.colour || d.color ? ' venn-coloured' : ''\n          }`\n      )\n      .attr('data-venn-sets', (d) => d.sets.join('_'));\n\n    const enterPath = enter.append('path');\n    const enterText = enter\n      .append('text')\n      .attr('class', 'label')\n      .text((d) => label(d))\n      .attr('text-anchor', 'middle')\n      .attr('dy', '.35em')\n      .attr('x', width / 2)\n      .attr('y', height / 2);\n\n    // apply minimal style if wanted\n    if (styled) {\n      enterPath\n        .style('fill-opacity', '0')\n        .filter((d) => d.sets.length == 1)\n        .style('fill', (d) => (d.colour ? d.colour : d.color ? d.color : colours(d.sets)))\n        .style('fill-opacity', '.25');\n\n      enterText.style('fill', (d) => {\n        if (d.colour || d.color) {\n          return '#FFF';\n        }\n        if (options.textFill) {\n          return options.textFill;\n        }\n        return d.sets.length == 1 ? colours(d.sets) : '#444';\n      });\n    }\n\n    function asTransition(s) {\n      if (typeof s.transition === 'function') {\n        return s.transition('venn').duration(duration);\n      }\n      return s;\n    }\n\n    // update existing, using pathTween if necessary\n    let update = selection;\n    if (hasPrevious && typeof update.transition === 'function') {\n      update = asTransition(selection);\n      update.selectAll('path').attrTween('d', pathTween);\n    } else {\n      update.selectAll('path').attr('d', (d) => intersectionAreaPath(d.sets.map((set) => circles[set])), round);\n    }\n\n    const updateText = update\n      .selectAll('text')\n      .filter((d) => d.sets in textCentres)\n      .text((d) => label(d))\n      .attr('x', (d) => Math.floor(textCentres[d.sets].x))\n      .attr('y', (d) => Math.floor(textCentres[d.sets].y));\n\n    if (wrap) {\n      if (hasPrevious) {\n        // d3 4.0 uses 'on' for events on transitions,\n        // but d3 3.0 used 'each' instead. switch appropriately\n        if ('on' in updateText) {\n          updateText.on('end', wrapText(circles, label));\n        } else {\n          updateText.each('end', wrapText(circles, label));\n        }\n      } else {\n        updateText.each(wrapText(circles, label));\n      }\n    }\n\n    // remove old\n    const exit = asTransition(nodes.exit()).remove();\n    if (typeof nodes.transition === 'function') {\n      exit.selectAll('path').attrTween('d', pathTween);\n    }\n\n    const exitText = exit\n      .selectAll('text')\n      .attr('x', width / 2)\n      .attr('y', height / 2);\n\n    // if we've been passed a fontSize explicitly, use it to\n    // transition\n    if (fontSize !== null) {\n      enterText.style('font-size', '0px');\n      updateText.style('font-size', fontSize);\n      exitText.style('font-size', '0px');\n    }\n\n    return { circles, textCentres, nodes, enter, update, exit };\n  }\n\n  chart.wrap = function (_) {\n    if (!arguments.length) return wrap;\n    wrap = _;\n    return chart;\n  };\n\n  chart.useViewBox = function () {\n    useViewBox = true;\n    return chart;\n  };\n\n  chart.width = function (_) {\n    if (!arguments.length) return width;\n    width = _;\n    return chart;\n  };\n\n  chart.height = function (_) {\n    if (!arguments.length) return height;\n    height = _;\n    return chart;\n  };\n\n  chart.padding = function (_) {\n    if (!arguments.length) return padding;\n    padding = _;\n    return chart;\n  };\n\n  chart.distinct = function (_) {\n    if (!arguments.length) return distinct;\n    distinct = _;\n    return chart;\n  };\n\n  chart.colours = function (_) {\n    if (!arguments.length) return colours;\n    colours = _;\n    return chart;\n  };\n\n  chart.colors = function (_) {\n    if (!arguments.length) return colors;\n    colours = _;\n    return chart;\n  };\n\n  chart.fontSize = function (_) {\n    if (!arguments.length) return fontSize;\n    fontSize = _;\n    return chart;\n  };\n\n  chart.round = function (_) {\n    if (!arguments.length) return round;\n    round = _;\n    return chart;\n  };\n\n  chart.duration = function (_) {\n    if (!arguments.length) return duration;\n    duration = _;\n    return chart;\n  };\n\n  chart.layoutFunction = function (_) {\n    if (!arguments.length) return layoutFunction;\n    layoutFunction = _;\n    return chart;\n  };\n\n  chart.normalize = function (_) {\n    if (!arguments.length) return normalize;\n    normalize = _;\n    return chart;\n  };\n\n  chart.scaleToFit = function (_) {\n    if (!arguments.length) return scaleToFit;\n    scaleToFit = _;\n    return chart;\n  };\n\n  chart.styled = function (_) {\n    if (!arguments.length) return styled;\n    styled = _;\n    return chart;\n  };\n\n  chart.orientation = function (_) {\n    if (!arguments.length) return orientation;\n    orientation = _;\n    return chart;\n  };\n\n  chart.orientationOrder = function (_) {\n    if (!arguments.length) return orientationOrder;\n    orientationOrder = _;\n    return chart;\n  };\n\n  chart.lossFunction = function (_) {\n    if (!arguments.length) return loss;\n    loss = _ === 'default' ? lossFunction : _ === 'logRatio' ? logRatioLossFunction : _;\n    return chart;\n  };\n\n  return chart;\n}\n\n// sometimes text doesn't fit inside the circle, if thats the case lets wrap\n// the text here such that it fits\n// todo: looks like this might be merged into d3 (\n// https://github.com/mbostock/d3/issues/1642),\n// also worth checking out is\n// http://engineering.findthebest.com/wrapping-axis-labels-in-d3-js/\n// this seems to be one of those things that should be easy but isn't\nfunction wrapText(circles, labeller) {\n  return function (data) {\n    const text = this;\n    const width = circles[data.sets[0]].radius || 50;\n    const label = labeller(data) || '';\n\n    const words = label.split(/\\s+/).reverse();\n    const maxLines = 3;\n    const minChars = (label.length + words.length) / maxLines;\n\n    let word = words.pop();\n    let line = [word];\n    let lineNumber = 0;\n    const lineHeight = 1.1; // ems\n    text.textContent = null; // clear\n    const tspans = [];\n\n    function append(word) {\n      const tspan = text.ownerDocument.createElementNS(text.namespaceURI, 'tspan');\n      tspan.textContent = word;\n      tspans.push(tspan);\n      text.append(tspan);\n      return tspan;\n    }\n    let tspan = append(word);\n\n    while (true) {\n      word = words.pop();\n      if (!word) {\n        break;\n      }\n      line.push(word);\n      const joined = line.join(' ');\n      tspan.textContent = joined;\n      if (joined.length > minChars && tspan.getComputedTextLength() > width) {\n        line.pop();\n        tspan.textContent = line.join(' ');\n        line = [word];\n        tspan = append(word);\n        lineNumber++;\n      }\n    }\n\n    const initial = 0.35 - (lineNumber * lineHeight) / 2;\n    const x = text.getAttribute('x');\n    const y = text.getAttribute('y');\n    tspans.forEach((t, i) => {\n      t.setAttribute('x', x);\n      t.setAttribute('y', y);\n      t.setAttribute('dy', `${initial + i * lineHeight}em`);\n    });\n  };\n}\n\n/**\n *\n * @param {{x: number, y: number}} current\n * @param {ReadonlyArray<{x: number, y: number}>} interior\n * @param {ReadonlyArray<{x: number, y: number}>} exterior\n * @returns {number}\n */\nfunction circleMargin(current, interior, exterior) {\n  let margin = interior[0].radius - distance(interior[0], current);\n\n  for (let i = 1; i < interior.length; ++i) {\n    const m = interior[i].radius - distance(interior[i], current);\n    if (m <= margin) {\n      margin = m;\n    }\n  }\n\n  for (let i = 0; i < exterior.length; ++i) {\n    const m = distance(exterior[i], current) - exterior[i].radius;\n    if (m <= margin) {\n      margin = m;\n    }\n  }\n  return margin;\n}\n\n/**\n * compute the center of some circles by maximizing the margin of\n * the center point relative to the circles (interior) after subtracting\n * nearby circles (exterior)\n * @param {readonly {x: number, y: number, radius: number}[]} interior\n * @param {readonly {x: number, y: number, radius: number}[]} exterior\n * @param {boolean} symmetricalTextCentre\n * @returns {{x:number, y: number}}\n */\nfunction computeTextCentre(interior, exterior, symmetricalTextCentre) {\n  // get an initial estimate by sampling around the interior circles\n  // and taking the point with the biggest margin\n  /** @type {{x: number, y: number}[]} */\n  const points = [];\n  for (const c of interior) {\n    points.push({ x: c.x, y: c.y });\n    points.push({ x: c.x + c.radius / 2, y: c.y });\n    points.push({ x: c.x - c.radius / 2, y: c.y });\n    points.push({ x: c.x, y: c.y + c.radius / 2 });\n    points.push({ x: c.x, y: c.y - c.radius / 2 });\n  }\n\n  let initial = points[0];\n  let margin = circleMargin(points[0], interior, exterior);\n\n  for (let i = 1; i < points.length; ++i) {\n    const m = circleMargin(points[i], interior, exterior);\n    if (m >= margin) {\n      initial = points[i];\n      margin = m;\n    }\n  }\n\n  // maximize the margin numerically\n  const solution = nelderMead(\n    (p) => -1 * circleMargin({ x: p[0], y: p[1] }, interior, exterior),\n    [initial.x, initial.y],\n    { maxIterations: 500, minErrorDelta: 1e-10 }\n  ).x;\n\n  const ret = { x: symmetricalTextCentre ? 0 : solution[0], y: solution[1] };\n\n  // check solution, fallback as needed (happens if fully overlapped\n  // etc)\n  let valid = true;\n  for (const i of interior) {\n    if (distance(ret, i) > i.radius) {\n      valid = false;\n      break;\n    }\n  }\n\n  for (const e of exterior) {\n    if (distance(ret, e) < e.radius) {\n      valid = false;\n      break;\n    }\n  }\n  if (valid) {\n    return ret;\n  }\n\n  if (interior.length == 1) {\n    return { x: interior[0].x, y: interior[0].y };\n  }\n  const areaStats = {};\n  intersectionArea(interior, areaStats);\n\n  if (areaStats.arcs.length === 0) {\n    return { x: 0, y: -1000, disjoint: true };\n  }\n  if (areaStats.arcs.length == 1) {\n    return { x: areaStats.arcs[0].circle.x, y: areaStats.arcs[0].circle.y };\n  }\n  if (exterior.length) {\n    // try again without other circles\n    return computeTextCentre(interior, []);\n  }\n  // take average of all the points in the intersection\n  // polygon. this should basically never happen\n  // and has some issues:\n  // https://github.com/benfred/venn.js/issues/48#issuecomment-146069777\n  return getCenter(areaStats.arcs.map((a) => a.p1));\n}\n\n// given a dictionary of {setid : circle}, returns\n// a dictionary of setid to list of circles that completely overlap it\nfunction getOverlappingCircles(circles) {\n  const ret = {};\n  const circleids = Object.keys(circles);\n  for (const circleid of circleids) {\n    ret[circleid] = [];\n  }\n  for (let i = 0; i < circleids.length; i++) {\n    const ci = circleids[i];\n    const a = circles[ci];\n    for (let j = i + 1; j < circleids.length; ++j) {\n      const cj = circleids[j];\n      const b = circles[cj];\n      const d = distance(a, b);\n\n      if (d + b.radius <= a.radius + 1e-10) {\n        ret[cj].push(ci);\n      } else if (d + a.radius <= b.radius + 1e-10) {\n        ret[ci].push(cj);\n      }\n    }\n  }\n  return ret;\n}\n\nfunction computeTextCentres(circles, areas, symmetricalTextCentre) {\n  const ret = {};\n  const overlapped = getOverlappingCircles(circles);\n  for (let i = 0; i < areas.length; ++i) {\n    const area = areas[i].sets;\n    const areaids = {};\n    const exclude = {};\n\n    for (let j = 0; j < area.length; ++j) {\n      areaids[area[j]] = true;\n      const overlaps = overlapped[area[j]];\n      // keep track of any circles that overlap this area,\n      // and don't consider for purposes of computing the text\n      // centre\n      for (let k = 0; k < overlaps.length; ++k) {\n        exclude[overlaps[k]] = true;\n      }\n    }\n\n    const interior = [];\n    const exterior = [];\n    for (let setid in circles) {\n      if (setid in areaids) {\n        interior.push(circles[setid]);\n      } else if (!(setid in exclude)) {\n        exterior.push(circles[setid]);\n      }\n    }\n    const centre = computeTextCentre(interior, exterior, symmetricalTextCentre);\n    ret[area] = centre;\n    if (centre.disjoint && areas[i].size > 0) {\n      console.log('WARNING: area ' + area + ' not represented on screen');\n    }\n  }\n  return ret;\n}\n\n// sorts all areas in the venn diagram, so that\n// a particular area is on top (relativeTo) - and\n// all other areas are so that the smallest areas are on top\nfunction sortAreas(div, relativeTo) {\n  // figure out sets that are completely overlapped by relativeTo\n  const overlaps = getOverlappingCircles(div.selectAll('svg').datum());\n  const exclude = new Set();\n  for (const check of relativeTo.sets) {\n    for (let setid in overlaps) {\n      const overlap = overlaps[setid];\n      for (let j = 0; j < overlap.length; ++j) {\n        if (overlap[j] == check) {\n          exclude.add(setid);\n          break;\n        }\n      }\n    }\n  }\n\n  // checks that all sets are in exclude;\n  function shouldExclude(sets) {\n    return sets.every((set) => !exclude.has(set));\n  }\n\n  // need to sort div's so that Z order is correct\n  div.selectAll('g').sort((a, b) => {\n    // highest order set intersections first\n    if (a.sets.length != b.sets.length) {\n      return a.sets.length - b.sets.length;\n    }\n\n    if (a == relativeTo) {\n      return shouldExclude(b.sets) ? -1 : 1;\n    }\n    if (b == relativeTo) {\n      return shouldExclude(a.sets) ? 1 : -1;\n    }\n\n    // finally by size\n    return b.size - a.size;\n  });\n}\n\n/**\n * @param {number} x\n * @param {number} y\n * @param {number} r\n * @returns {string}\n */\nfunction circlePath(x, y, r) {\n  const ret = [];\n  ret.push('\\nM', x, y);\n  ret.push('\\nm', -r, 0);\n  ret.push('\\na', r, r, 0, 1, 0, r * 2, 0);\n  ret.push('\\na', r, r, 0, 1, 0, -r * 2, 0);\n  return ret.join(' ');\n}\n\n/**\n * inverse of the circlePath function, returns a circle object from an svg path\n * @param {string} path\n * @returns {{x: number, y: number, radius: number}}\n */\nfunction circleFromPath(path) {\n  const tokens = path.split(' ');\n  return { x: Number.parseFloat(tokens[1]), y: Number.parseFloat(tokens[2]), radius: -Number.parseFloat(tokens[4]) };\n}\n\nfunction intersectionAreaArcs(circles) {\n  if (circles.length === 0) {\n    return [];\n  }\n  const stats = {};\n  intersectionArea(circles, stats);\n  return stats.arcs;\n}\n\nfunction arcsToPath(arcs, round) {\n  if (arcs.length === 0) {\n    return 'M 0 0';\n  }\n  const rFactor = Math.pow(10, round || 0);\n  const r = round != null ? (v) => Math.round(v * rFactor) / rFactor : (v) => v;\n  if (arcs.length == 1) {\n    const circle = arcs[0].circle;\n    return circlePath(r(circle.x), r(circle.y), r(circle.radius));\n  }\n  // draw path around arcs\n  const ret = ['\\nM', r(arcs[0].p2.x), r(arcs[0].p2.y)];\n  for (const arc of arcs) {\n    const radius = r(arc.circle.radius);\n    ret.push('\\nA', radius, radius, 0, arc.large ? 1 : 0, arc.sweep ? 1 : 0, r(arc.p1.x), r(arc.p1.y));\n  }\n  return ret.join(' ');\n}\n\n/**\n * returns a svg path of the intersection area of a bunch of circles\n * @param {ReadonlyArray<{x: number, y: number, radius: number}>} circles\n * @returns {string}\n */\nfunction intersectionAreaPath(circles, round) {\n  return arcsToPath(intersectionAreaArcs(circles), round);\n}\n\nfunction layout(data, options = {}) {\n  const {\n    lossFunction: loss,\n    layoutFunction: layout = venn,\n    normalize = true,\n    orientation = Math.PI / 2,\n    orientationOrder,\n    width = 600,\n    height = 350,\n    padding = 15,\n    scaleToFit = false,\n    symmetricalTextCentre = false,\n    distinct,\n    round = 2,\n  } = options;\n\n  let solution = layout(data, {\n    lossFunction: loss === 'default' || !loss ? lossFunction : loss === 'logRatio' ? logRatioLossFunction : loss,\n    distinct,\n  });\n\n  if (normalize) {\n    solution = normalizeSolution(solution, orientation, orientationOrder);\n  }\n\n  const circles = scaleSolution(solution, width, height, padding, scaleToFit);\n  const textCentres = computeTextCentres(circles, data, symmetricalTextCentre);\n\n  const circleLookup = new Map(\n    Object.keys(circles).map((set) => [\n      set,\n      {\n        set,\n        x: circles[set].x,\n        y: circles[set].y,\n        radius: circles[set].radius,\n      },\n    ])\n  );\n  const helpers = data.map((area) => {\n    const circles = area.sets.map((s) => circleLookup.get(s));\n    const arcs = intersectionAreaArcs(circles);\n    const path = arcsToPath(arcs, round);\n    return { circles, arcs, path, area, has: new Set(area.sets) };\n  });\n\n  function genDistinctPath(sets) {\n    let r = '';\n    for (const e of helpers) {\n      if (e.has.size > sets.length && sets.every((s) => e.has.has(s))) {\n        r += ' ' + e.path;\n      }\n    }\n    return r;\n  }\n\n  return helpers.map(({ circles, arcs, path, area }) => {\n    return {\n      data: area,\n      text: textCentres[area.sets],\n      circles,\n      arcs,\n      path,\n      distinctPath: path + genDistinctPath(area.sets),\n    };\n  });\n}\n\nexport { VennDiagram, bestInitialLayout, circleArea, circleCircleIntersection, circleFromPath, circleOverlap, circlePath, computeTextCentre, computeTextCentres, disjointCluster, distance, distanceFromIntersectArea, greedyLayout, intersectionArea, intersectionAreaPath, layout, logRatioLossFunction, lossFunction, normalizeSolution, scaleSolution, sortAreas, venn, wrapText };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}