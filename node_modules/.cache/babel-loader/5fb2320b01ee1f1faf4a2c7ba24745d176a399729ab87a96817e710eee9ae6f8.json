{"ast":null,"code":"import { scale } from './scale';\nimport { compose } from './transform';\n/**\n * Decompose a matrix into translation, scaling and rotation components, optionally\n * take horizontal and vertical flip in to consideration.\n * Note this function decomposes a matrix in rotation -> scaling -> translation order. I.e. for\n * certain translation T {tx, ty}, rotation R and scaling S { sx, sy }, it's only true for:\n *  decomposeTSR(compose(T, S, R)) === { translate: T, rotation: R, scale: S }\n * composing in a different order may yield a different decomposition result.\n * @param matrix {Matrix} Affine Matrix\n * @param  flipX {boolean} Whether the matrix contains vertical flip, i.e. mirrors on x-axis\n * @param  flipY {boolean} Whether the matrix contains horizontal flip, i.e. mirrors on y-axis\n * @returns {Transform} A transform object consisted by its translation, scaling\n * and rotation components.\n */\nexport function decomposeTSR(matrix) {\n  let flipX = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  let flipY = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  // Remove flip from the matrix first - flip could be incorrectly interpreted as\n  // rotations (e.g. flipX + flipY = rotate by 180 degrees).\n  // Note flipX is a vertical flip, and flipY is a horizontal flip.\n  if (flipX) {\n    if (flipY) {\n      matrix = compose(matrix, scale(-1, -1));\n    } else {\n      matrix = compose(matrix, scale(1, -1));\n    }\n  } else if (flipY) {\n    matrix = compose(matrix, scale(-1, 1));\n  }\n  const a = matrix.a;\n  const b = matrix.b;\n  const c = matrix.c;\n  const d = matrix.d;\n  let scaleX, scaleY, rotation;\n  if (a !== 0 || c !== 0) {\n    const hypotAc = Math.hypot(a, c);\n    scaleX = hypotAc;\n    scaleY = (a * d - b * c) / hypotAc;\n    const acos = Math.acos(a / hypotAc);\n    rotation = c > 0 ? -acos : acos;\n  } else if (b !== 0 || d !== 0) {\n    const hypotBd = Math.hypot(b, d);\n    scaleX = (a * d - b * c) / hypotBd;\n    scaleY = hypotBd;\n    const acos = Math.acos(b / hypotBd);\n    rotation = Math.PI / 2 + (d > 0 ? -acos : acos);\n  } else {\n    scaleX = 0;\n    scaleY = 0;\n    rotation = 0;\n  }\n\n  // put the flip factors back\n  if (flipY) {\n    scaleX = -scaleX;\n  }\n  if (flipX) {\n    scaleY = -scaleY;\n  }\n  return {\n    translate: {\n      tx: matrix.e,\n      ty: matrix.f\n    },\n    scale: {\n      sx: scaleX,\n      sy: scaleY\n    },\n    rotation: {\n      angle: rotation\n    }\n  };\n}","map":{"version":3,"names":["scale","compose","decomposeTSR","matrix","flipX","arguments","length","undefined","flipY","a","b","c","d","scaleX","scaleY","rotation","hypotAc","Math","hypot","acos","hypotBd","PI","translate","tx","e","ty","f","sx","sy","angle"],"sources":["/Users/jenn/Desktop/info340/project-jsorror/node_modules/transformation-matrix/src/decompose.js"],"sourcesContent":["import { scale } from './scale'\nimport { compose } from './transform'\n/**\n * Decompose a matrix into translation, scaling and rotation components, optionally\n * take horizontal and vertical flip in to consideration.\n * Note this function decomposes a matrix in rotation -> scaling -> translation order. I.e. for\n * certain translation T {tx, ty}, rotation R and scaling S { sx, sy }, it's only true for:\n *  decomposeTSR(compose(T, S, R)) === { translate: T, rotation: R, scale: S }\n * composing in a different order may yield a different decomposition result.\n * @param matrix {Matrix} Affine Matrix\n * @param  flipX {boolean} Whether the matrix contains vertical flip, i.e. mirrors on x-axis\n * @param  flipY {boolean} Whether the matrix contains horizontal flip, i.e. mirrors on y-axis\n * @returns {Transform} A transform object consisted by its translation, scaling\n * and rotation components.\n */\nexport function decomposeTSR (matrix, flipX = false, flipY = false) {\n  // Remove flip from the matrix first - flip could be incorrectly interpreted as\n  // rotations (e.g. flipX + flipY = rotate by 180 degrees).\n  // Note flipX is a vertical flip, and flipY is a horizontal flip.\n  if (flipX) {\n    if (flipY) {\n      matrix = compose(matrix, scale(-1, -1))\n    } else {\n      matrix = compose(matrix, scale(1, -1))\n    }\n  } else if (flipY) {\n    matrix = compose(matrix, scale(-1, 1))\n  }\n\n  const a = matrix.a; const b = matrix.b\n  const c = matrix.c; const d = matrix.d\n  let scaleX, scaleY, rotation\n\n  if (a !== 0 || c !== 0) {\n    const hypotAc = Math.hypot(a, c)\n    scaleX = hypotAc\n    scaleY = (a * d - b * c) / hypotAc\n    const acos = Math.acos(a / hypotAc)\n    rotation = c > 0 ? -acos : acos\n  } else if (b !== 0 || d !== 0) {\n    const hypotBd = Math.hypot(b, d)\n    scaleX = (a * d - b * c) / hypotBd\n    scaleY = hypotBd\n    const acos = Math.acos(b / hypotBd)\n    rotation = Math.PI / 2 + (d > 0 ? -acos : acos)\n  } else {\n    scaleX = 0\n    scaleY = 0\n    rotation = 0\n  }\n\n  // put the flip factors back\n  if (flipY) {\n    scaleX = -scaleX\n  }\n\n  if (flipX) {\n    scaleY = -scaleY\n  }\n\n  return {\n    translate: { tx: matrix.e, ty: matrix.f },\n    scale: { sx: scaleX, sy: scaleY },\n    rotation: { angle: rotation }\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}